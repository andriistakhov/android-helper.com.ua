
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Android helper</title>
  <meta name="author" content="Andrii Stakhov">

  
  <meta name="description" content="Добрый день друзья.
В одном из проэктов я столкнулся с задачей обрабатывать нажатия на сенсорный экран.
Долго искал материалы, и мои поиски &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://android-helper.com.ua//blog/page/21">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/github/atom.xml" rel="alternate" title="Android helper" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Android helper</a></h1>
  
    <h2>Освоим android вместе?.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/github/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:android-helper.com.ua/" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/events/">Взаимодействие с сенсорным экраном</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-09-04T07:20:58+03:00" pubdate data-updated="true">Sep 4<span>th</span>, 2012</time>
        
           | <a href="/events/#disqus_thread"
             data-disqus-identifier="http://android-helper.com.ua//events/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Добрый день друзья.<br/>
В одном из проэктов я столкнулся с задачей обрабатывать нажатия на сенсорный экран.<br/>
Долго искал материалы, и мои поиски увенчались успехом.<br/>
Ниже я приведу статью, которая описывает как с этим работать.<br/>
Прошу к прочтению.</p>

<p>Занимаясь программированием под Android необходимо знать, как взаимодействовать с сенсорным экраном — главным устройством ввода на большинстве Android устройств. В этой статье будет рассмотрено:</p>

<ul>
<li><p>Низкоуровневое взаимодействие с тачскрином, нужное прежде всего для разработки игр.</p>

<ul>
<li><p>Класс MotionEvent</p></li>
<li><p>Обработка MotionEvent&#8217;ов</p></li>
</ul>
</li>
<li><p>Работа с MultiTouch.</p></li>
<li><p>Некоторые высокоуровневые методы обработки прикосновений.</p></li>
</ul>


<p>Также будут приведены различные примеры…</p>

<h4>Отступление по поводу Лога</h4>

<p>Так как в дальнейшем в этой статье мы будем активно использовать Log, я кратко расскажу про него(те, кто уже знаком с логом Андроида, могут благополучно пропустить этот раздел статьи).<br/>
В Android имеется собственный лог, куда могут писать все желающие приложения от Dvalvik VM до вашего приложения. Все сообщения в логе разделяются по приоритету (право выбирать приоритет сообщения, посылаемого в лог остается за вами) <br/>
Для записи в лог достаточно вызвать один из статических методов класса Log, различающихся только приоритетом отсылаемых ими сообщений.<br/>
Эти методы приведены ниже, по возрастанию приоритета:</p>

<ul>
<li><p>Log.v(String tag, String msg) — VERBOSE</p></li>
<li><p>Log.d(String tag, String msg) — DEBUG</p></li>
<li><p>Log.i(String tag, String msg) — INFO</p></li>
<li><p>Log.w(String tag, String msg) — WARNING</p></li>
<li><p>Log.e(String tag, String msg) — ERROR</p></li>
<li><p>Log.wtf(String tag, String msg) — What a Terrible Failure</p></li>
</ul>


<p>Также есть возможность отправлять в лог исключения. В этом случае добавляется еще один аргумент — Throwable tr. Например:</p>

<ul>
<li>Log.v(String tag, String msg, Throwable tr)</li>
</ul>


<p>Вывести окно Log&#8217;а в Eclipse можно так:<br/>
<strong>Window &ndash;> Show View &ndash;> Other &ndash;> Android &ndash;> LogCat</strong></p>

<h4>Понятие о MotionEvent</h4>

<p>Класс MotionEvent служит хранилищем данных о прикосновении (touch event). Каждый раз, когда пользователь проводит пальцем по экрану, или даже просто тапает, создается целая последовательность экземпляров класса <strong>MotionEvent</strong>: последовательность начинается, когда пользователь дотрагивается до экрана, продолжается, пока пользователь двигает палец по экрану, и кончается, когда пользователь поднимает палец. Таким образом получается три основных типа действия, которые описывает MotionEvent: опускание пальца, его передвижение и поднятие. Каждый MotionEvent хранит в себе информацию о типе действия, которое он описывает. Для этого в классе MotionEvent предусмотрены константы:</p>

<ul>
<li><p>int MotionEvent.ACTION_DOWN — пользователь опускает палец на экран.</p></li>
<li><p>int MotionEvent.ACTION_MOVE — пользователь передвигает пальцем по экрану.</p></li>
<li><p>int MotionEvent.ACTION_UP — пользователь поднимает палец с экрана.</p></li>
</ul>


<p>Узнать какое действие описывает данный MotionEvent можно с помощью метода <strong>getAction()</strong>.<br/>
Стоит отметить, что существует еще один тип действия — MotionEvent.ACTION_CANCEL, который по сути является обозначением того, что последовательность завершена некорректно, то есть без MotionEvent.ACTION_UP. Все это будет объяснено подробнее на примере, но чуть позже.</p>

<h4>Получение и обработка MotionEvent&#8217;ов</h4>

<p>Теперь, когда мы получили общее представление о MotionEvent&#8217;ах, необходимо разобраться с тем, откуда нам их «брать». Существует 2 способа, разберем их по отдельности.</p>

<ul>
<li><p>Первый способ является оптимальным, когда вы используете один из стандартных View. У класса View существует метод SetOnTouchListener(View.OnTouchListener l), аргументом которого является класс, реализующий интерфейс OnTouchListener. Этот метод позволяет назначить «слушателя» MotionEvent&#8217;ов. Интерфейс OnTouchListener обязует класс реализовывать метод public boolean OnTouch(View v,MotionEvent event), вторым аргументом которого и является нужный нам MotionEvent. Теперь каждый раз, когда пользователь будет прикасаться к экрану, Android будет вызывать наш метод OnTouch, давая ему в аргумент описание произошедшего действия, то есть MotionEvent. Рассмотрим подробнее на примере:<br/>
Вот наш файл res/layout/main.xml:</p>

<pre><code>  &lt;?xml version="1.0" encoding="utf-8"?&gt; 

  &lt;LinearLayout xmlns:android="schemas.android.com/apk/res/android" 
  android:orientation="vertical" 
  android:layout_width="fill_parent" 
  android:layout_height="fill_parent" 
  android:id="@+id/ll" 
  /&gt; 
</code></pre></li>
</ul>


<p>А вот наш Activity класс:</p>

<pre><code>import android.app.Activity;
import android.os.Bundle;
import android.util.Log;
import android.view.MotionEvent;
import android.view.View;
import android.view.View.OnTouchListener;
import android.widget.LinearLayout; 

  public class main extends Activity implements OnTouchListener{// Заставляем наш Activity класс воплощать интерфейс OnTouchListener

  /** Called when the activity is first created. */

  @Override

  public void onCreate(Bundle savedInstanceState) {

      super.onCreate(savedInstanceState);

      setContentView(R.layout.main);

      LinearLayout ll =(LinearLayout)this.findViewById(R.id.ll);//Достаем нужный View

      ll.setOnTouchListener(this);// Устанавливаем данный класс в качестве слушателя MotionEvent'ов для нашего LinearLayout

  } 

  @Override

  public boolean onTouch(View v, MotionEvent event)// Вот, собственно, метод, который и будет обрабатывать MotionEvent'ы.

  {

      int Action=event.getAction();

      // С помощью метода getAction() получаем тип действия(ACTION_DOWN,ACTION_MOVE или ACTION_UP)

      StringBuilder str=new StringBuilder();

      str.append("\nActrion type: ");

      //Дальше для лучшего восприятия(т.к. константы ACTION_DOWN,ACTION_MOVE и ACTION_UP числовые)

      //проводим switch по переменной Action и добавляем в наш StringBuilder название константы

      switch(Action)

     {

          case MotionEvent.ACTION_DOWN: str.append("ACTION_DOWN\n");break;

          case MotionEvent.ACTION_MOVE: str.append("ACTION_MOVE\n");break;

          case MotionEvent.ACTION_UP: str.append("ACTION_UP\n");break;

     }

      //С помощью методов getX() и getY() получаем координаты по оси x и y соответственно

      //Следует отметить, что точка 0 располагается в левом верхнем углу экрана.

      //Ось x направлена вправо

      //Ось y направлена вниз(чем ниже, тем больше координата).

      str.append("Location: ").append(event.getX()).append(" x ").append(event.getY()).append("\n");//Узнаем координаты

      str.append("Edge flags: ").append(event.getEdgeFlags()).append("\n");// Метод getEdgeFlags возвращает информацию о пересечении краев экрана

      str.append("Pressure: ").append(event.getPressure()).append("\n");// Узнаем давление

      str.append("Size: ").append(event.getSize()).append("\n"); // Узнаем размер указателя(места соприкосновения пальца с экраном)

      str.append("Down time: ").append(event.getDownTime()).append("ms\n");// Узнаем время, когда палец был опущен на экран в миллисекундах

      str.append("Event time: ").append(event.getEventTime()).append("ms");//узнаем текущее время(соответствующее обрабатываемому MotionEvent'у) в миллисекундах

      str.append(" Elapsed: ").append(event.getEventTime()-event.getDownTime());//Узнаем сколько времени прошло с момента опускания пальца, до текущего MotionEvent'а

      Log.v("Mytag", str.toString());//Для того, чтобы можно было отслеживать эти действия, записываем всю информацию о них в лог.

      return true;// Почему мы возвращаем true будет рассмотрено потом

  }

}
</code></pre>

<p>Понятно, что один класс может быть слушателем у нескольких View. Чтобы это учитывать метод onTouch принимает в аргумент View.</p>

<ul>
<li><p>Второй способ является оптимальным, когда вы пишете свой View класс, который должен реагировать на прикосновения. У View есть метод onTouchEvent(MotionEvent event), который, собственно, и позволяет обрабатывать MotionEvent&#8217;ы. Рассмотрим на примере:<br/>
Напишем свой класс SomeView:</p>

<pre><code>  package com.example.MotionEventExample1;

  import android.content.Context;
  import android.util.AttributeSet;
  import android.view.View;

  public class SomeView extends View {

  // Сначала необходимо реализовать конструктор.

  // Тут все просто - просто вызываем конструктор суперкласса

  public SomeView(Context context, AttributeSet attrs) {

  super(context, attrs);

  }
  }
</code></pre>

<p>  // Теперь приступаем непосредственно к обработке MotionEvent&#8217;ов.</p>

<p>  // Для этого нужно переписать метод onTouchEvent</p>

<pre><code>  @Override

  public boolean onTouchEvent(MotionEvent event) {

      Float X = (Float) event.getX();

      Float Y = (Float) event.getY();

      int Action = event.getAction();

      String ActionString = "";

      switch (Action) {

      case MotionEvent.ACTION_DOWN:

          ActionString = "ACTION_DOWN";

          break;

      case MotionEvent.ACTION_MOVE:

          ActionString = "ACTION_MOVE";

          break;

      case MotionEvent.ACTION_UP:

          ActionString = "ACTION_UP";

          break;

      }

      Log.v("MyTag", "View OnTouchListener:\n" + "Coords: " + X.toString() + " x " + Y.toString() + "\nAction type: " +  ActionString);

      return true;

      }

  }
</code></pre></li>
</ul>


<p>И наш /res/layout/main.xml:</p>

<pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;

&lt;LinearLayout xmlns:android="schemas.android.com/apk/res/android"

   android:orientation="vertical"

   android:layout_width="fill_parent"

   android:layout_height="fill_parent"

   &gt;

&lt;com.example.MotionEventExample1.SomeView

   android:layout_width="fill_parent"

   android:layout_height="fill_parent"

  android:id="@+id/sv"

/&gt;

&lt;/LinearLayout&gt;
</code></pre>

<p>Activity класс:<br/>
 </p>

<pre><code>package com.example.MotionEventExample1;

import android.app.Activity;
import android.os.Bundle;

public class main extends Activity {

/** Called when the activity is first created. */

@Override

public void onCreate(Bundle savedInstanceState) {

    super.onCreate(savedInstanceState);

    setContentView(R.layout.main);

}

}
</code></pre>

<p>  </p>

<h4>О том, что возвращают обработчики MotionEvent&#8217;ов</h4>

<p>Как вы могли заметить, обработчики MotionEvent&#8217;ов должны возвращать boolean&#8217;овское значение. В примерах до этого мы просто всегда возвращали true. Так для чего же этим методам вообще нужно возвращать значение? Дело в том, что у одного View может быть несколько слушателей (например onTouchEvent в самом View и OnTouch у внешнего слушателя) и они имеют некоторый приоритет: OnTouch вызывается первым (если он вообще имеется), а уже после него может вызываться onTouchEvent. Вызов следующего по приоритету обработчика как раз зависит от возвращаемого текущим обработчиком значения (true — ничто не вызывается, false — вызывается следующий по приоритету, если таковой имеется). Таким образом Android позволяет нам разделять обязанности по обработке touch event&#8217;ов на несколько слушателей.</p>

<h5>Drag and Drop</h5>

<p>Вот мы и разобрались с основами обработки MotionEvento&#8217;ов. Для закрепления навыков напишем приложение, реализующее простенький Drag and Drop.</p>

<p>Вот наш /res/layout/main.xml:</p>

<pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;

&lt;LinearLayout xmlns:android="schemas.android.com/apk/res/android"

   android:orientation="vertical"

   android:layout_width="fill_parent"

   android:layout_height="fill_parent"

   &gt;

&lt;com.example.dragdrop.SomeView

   android:layout_width="fill_parent"

   android:layout_height="fill_parent"

  android:id="@+id/sv"

/&gt;

&lt;/LinearLayout&gt;
</code></pre>

<p> </p>

<p>Вот наш Activity класс:</p>

<pre><code>package com.example.dragdrop;

import android.app.Activity;
import android.os.Bundle;

public class main extends Activity {

/** Called when the activity is first created. */

@Override

public void onCreate(Bundle savedInstanceState) {

    super.onCreate(savedInstanceState);

    setContentView(R.layout.main);

}

}
</code></pre>

<p>А вот наш основной класс SomeView:</p>

<pre><code>package com.example.dragdrop;

import android.content.Context;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.Paint;
import android.graphics.Paint.Style;
import android.util.AttributeSet;
import android.view.MotionEvent;
import android.view.View;

public class SomeView extends View {

Paint paint;

int X;

int Y;

final static int Radius = 20;



public SomeView(Context context, AttributeSet attrs) {

    super(context, attrs);

    paint = new Paint();

    paint.setColor(Color.YELLOW);

    paint.setStyle(Style.FILL);

    X = 30;

    Y = 30;

}



@Override

public boolean onTouchEvent(MotionEvent event) {

    X = (int) event.getX();

    Y = (int) event.getY();

    return true;

}



@Override

protected void onDraw(Canvas canvas)// метод OnDraw вызвается Андроидом

                                    // тогда, когда нужно отрисовать данный

                                    // View

{

    canvas.drawCircle(X, Y, Radius, paint);

    invalidate();// invalidate() нужен для того, чтобы оповестить Android,

                    // что нужно выполнить метод OnDraw снова, без него View

                    // не будет перериcовываться.

}

}
</code></pre>

<p><strong>Multitouch</strong></p>

<p> </p>

<p>В Android, сколько-бы вы пальцев ни использовали, информация о всех них хранится в одном MotionEvent&#8217;е. Первый метод, который нужно узнать, если вы собираетесь использовать мультитач — getPointerCount(), который возвращает количество пальцев, зафиксированных на экране(Не всегда совпадает с реальным количеством из-за ограничений в железе). Каждому пальцу, находящемуся на экране, присваивается индекс и id. Индексы всегда начинаются с 0, id — не обязательно. Для понятности рассмотрим на примере.<br/>
Первый палец опускается — ему присваивается index=0 и id=0<br/>
Второй палец опускается — ему присваивается index=1 и id=1<br/>
Первый палец поднимается — Второму пальцу присваивается index=0 (Индексы всегда начинаются с нуля), а id остается тем же<br/>
Второй палец поднимается — MotionEvent&#8217;ов больше нет, вплоть до следушего прикосновения.<br/>
Id всегда сохраняется за указателем(пальцем), так что мы всегда можем отследить какой угодно указатель.<br/>
Когда мы разобрались с id и индексами, рассмотрим как получать свойства (координаты, величину и т. п. ) у конкретного указателя, когда их много. Для этого в классе MotionEvent существуют методы:getX(int Index)getY(int Index)getSize(int Index)и т. д., мы уже их рассматривали<br/>
В аргумент эти методы принимают <strong>индекс</strong> указателя.<br/>
Но так как индексы указателя могут меняться, а часто требуется отследить конкретный палец, то существует очень важный метод  getPointerId(int index), который позволяет по указанному индексу узнать id указателя.</p>

<p> </p>

<p>Рассмотрим пример: перепишем наше приложение (Drag and Drop) так, чтобы оно воспринимало мультитач.<br/>
(Важно: На эмуляторе мультитач не проверить, это можно сделать только на настоящем девайсе)<br/>
Вот наш res/layout/main.xml<br/>
 </p>

<pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;

&lt;LinearLayout xmlns:android="schemas.android.com/apk/res/android"

   android:orientation="vertical"

   android:layout_width="fill_parent"

   android:layout_height="fill_parent"

   &gt;

&lt;com.example.multitouch.SomeView

   android:layout_width="fill_parent"

   android:layout_height="wrap_content"

  android:id="@+id/view"

  /&gt;

&lt;/LinearLayout&gt; 
</code></pre>

<p>  <br/>
Наш Activity класс:</p>

<pre><code>package com.example.multitouch;

import android.app.Activity;
import android.os.Bundle;

public class main extends Activity {

/** Called when the activity is first created. */

@Override

public void onCreate(Bundle savedInstanceState) {

    super.onCreate(savedInstanceState);

    setContentView(R.layout.main);

}

}
</code></pre>

<p>А вот основной класс — SomeView:</p>

<pre><code>package com.example.multitouch;

import android.content.Context;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.Paint;
import android.graphics.Paint.Style;
import android.util.AttributeSet;
import android.util.Log;
import android.view.MotionEvent;
import android.view.View;

//Будем рисовать желтые круги под пальцами

public class SomeView extends View {

Paint paint;// нужен чтобы установить цвет.

int[] X;

int[] Y;

final static int Radius = 20;

int PointerCount;



public SomeView(Context context, AttributeSet attrs) {

    super(context, attrs);

    paint = new Paint();

    paint.setColor(Color.YELLOW);

    paint.setStyle(Style.FILL);

    PointerCount = 0;

    X = new int[10];// Это будут массивы координат(будем воспринимать до 10

                    // пальцев)

    Y = new int[10];

}



@Override

public boolean onTouchEvent(MotionEvent event) {

    StringBuilder result = new StringBuilder(300);

    PointerCount = event.getPointerCount();

    for (int i = 0; i &lt; PointerCount; i++) {

        int ptrId = event.getPointerId(i);

        X[i] = (int) event.getX(i);// Запоминаем координаты

        Y[i] = (int) event.getY(i);

        result.append("Pointer Index: ").append(i);

        result.append(", Pointer Id: ").append(ptrId).append("\n");

        result.append("Location: ").append(event.getX(i));

        result.append(" x ").append(event.getX(i)).append("\n");

        result.append("Pressure: ").append(event.getPressure(i));

        result.append("Size: ").append(event.getSize(i)).append("\n");

    }

    Log.v("Mytag", result.toString());// Выводим всю информацию в лог

    return true;

}



@Override

protected void onDraw(Canvas canvas) {

    for (int i = 0; i &lt; PointerCount; i++)// Смотрим сколько пальцев было на

                                            // экране и отрисовываем View

    {

        canvas.drawCircle(X[i], Y[i], Radius, paint);

    }

    invalidate();// invalidate() нужен для того, чтобы оповестить Android,

                    // что нужно выполнить метод OnDraw снова, без него View

                    // не будет перериовываться. }

}

}
</code></pre>

<p><strong>Другие способы взаимодействия с тачскрином</strong></p>

<p> </p>

<p>Взаимодействие с экраном через MotionEvent&#8217;ы является довольно низкоуровневым, нужно это прежде всего для разработки игр. Для более узких, повседневных ситуаций в Android предусмотрен ряд интерфейсов, которые позволяют распознавать наиболее «популярные» touch event&#8217;ы:</p>

<ul>
<li><strong>OnClickListener</strong> — onClick(View v)</li>
<li><strong>OnFocusChangeListener</strong> — onFocusChange(View v, boolean hasFocus)</li>
<li><strong>OnKeyListener</strong> — onKey(View v, int keyCode, KeyEvent event)</li>
<li><strong>OnLongClickListener</strong> — onLongClick(View v)</li>
<li>и т. д.</li>
</ul>


<p> </p>

<p>Обрабатываются они аналогично, так что в пояснении не нуждаются.<br/>
Больше информации о таких методах можно узнать здесь:<br/>
<a href="http://developer.android.com/reference/android/view/View.html">developer.android.com/reference/android/view/View.html </a></p>

<h4>Для написания статьи использовались:</h4>

<ul>
<li><p><a href="http://developer.android.com/">developer.android.com</a></p></li>
<li><p>Pro Android 2 — глава TouchScreens.</p></li>
</ul>


<p>Спасибо за внимание.</p>

<p>Если вам понравилась статья. Прошу вас оставить комментарии и подписаться на рассылку.<br/>
Всегда ваш, Андрей</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/static/">Сбор статистики в приложении на Android</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-08-22T07:50:57+03:00" pubdate data-updated="true">Aug 22<span>nd</span>, 2012</time>
        
           | <a href="/static/#disqus_thread"
             data-disqus-identifier="http://android-helper.com.ua//static/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Сегодня нашел очень интересную статью.</p>

<p>Вот ее содержание:</p>

<p>Всегда интересно знать, как пользователи работают с вашим приложением: какие функции наиболее востребованы, какие кнопки нажимаются, какие настройки меняются, какие ошибки совершаются. Неплохо так же представлять себе, что это за пользователи &ndash; какая версия прошивки у их девайсов, где они географически расположены и т.д. </p>

<p>Такая информация неоценима для разработчика, ведь с ее помощью можно оптимизировать юзабилити, определиться с приоритеностью функционала, найти пути повышения продаж. Вопрос только как такую статистику собирать.</p>

<p>Самый простой путь &ndash; воспользоваться готовой системой сбора аналитической информации. Таких систем сейчас более чем достаточно (<a href="http://www.foundersspace.com/tech/whats-the-best-analytics-service-for-apps/">1</a>, <a href="http://www.quora.com/What-is-the-best-Mobile-Analytics-service-for-iOS-apps-and-why">2</a>). Например:У каждой системы есть свои изюминки: real-time обновление статистики (Localitics), суперточность с отслеживанием уникальных ID каждого пользователя (Bango), наличие средств для проведения опроса пользователей (Apsalar), наличие средств для регулярной отправки уведомлений пользователям (BuzzBox) и т.д. Естественно, есть и море отличий: в интерфейсе, в средствах анализа, в наличии дополнительных API, в стоимости, в наборе поддерживаемых платформ и т.п. </p>

<p>Принцип работы у всех систем примерно одинаков. Регистрируемся на сайте системы, получаем SDK и уникальный ключ. В приложение подключаем стороннюю библиотеку (единственный jar-файл из SDK). Добавляем код вызова функций, регистрирующих события в приложении. Релизим приложение. Ждем некоторое время, пока пользователи поработают в программе. Заходим на сайт системы и смотрим разнообразные аналитические отчеты. </p>

<p>Вот, например, как ведется сбор данных в Apsalar:</p>

<pre><code>import com.apsalar.sdk.Apsalar;



public void onCreate(Bundle savedInstanceState) {

...

    Apsalar.startSession(this, "myapikey", "mypassword");

..

}



/** уровень level пройден за countSeconds */

public void onLevelPassed(int level, int countSeconds) {

...

Apsalar.event("passed", "level", level, "duration", countSeconds);

...

}
</code></pre>

<p>API, как видите, тривиальное, так что технически добавить код для фиксации событий в приложении совсем не сложно. Количество событий и количество атрибутов у каждого события не ограничено, поэтому детализация собираемой информации может быть весьма высокой. </p>

<p>Конечно, подобные системы сбора информации &ndash; это, прежде всего, инструмент аналитика, желающего увеличить доход от продажи приложения. И накапливаемая статистика событий в приложении &ndash; всего лишь первичный материал для анализа. Тот же Apsalar позволяет, например, проводить <a href="http://apsalar.com/apscience/features/">Funnel Analysis, Engagment Analysis, Trending Analysis, Path Analysis, Event Analysis, Operational Analysis </a>.</p>

<p>Взять к примеру Funnel Analysis (воронку продаж). Если в вашем приложении пользователь должен сделать несколько шагов к совершению покупки (последовательно открыть несколько страниц, нажать несколько кнопок), то Funnel Analysis позволит увидеть, сколько пользователей (и каких именно) отсеивается на каждом шаге. Любопытно, что существуют системы монетизации, активно <a href="http://moneynews.ru/AuthorsArticle/14844/">использующие </a>подобную информацию.</p>

<p>Резюме. Готовых систем сбора аналитической информации для Android приложений сейчас множество, выбор широк. Многие из них бесплатные и, одновременно, обладают достойным функционалом. Подключаются подобные системы тривиально, весят &ldquo;копейки&rdquo; (10-30 kb), а пользу разработчику могут принести немалую. Единственное но: не у всех пользователей неограниченный трафик. Так что пользователи должны иметь возможность сбор статистики отключать.</p>

<p><strong>Update</strong>: Полезная статья на хабре <a href="http://habrahabr.ru/blogs/android_development/122510/">Flurry Analytics. Как держать руку на пульсе приложения </a></p>

<p><a href="http://apsalar.com/blog/">Блог</a>компании Apsalar. <br/>
Еще пара сервисов: <a href="http://www.appoxee.com/">Appoxee </a>, <a href="http://www.appfigures.com/">AppFiguers </a>. По поводу Appoxee см. так же <a href="http://appsmarketing.mobi/deliver-post-app-download-engagement-appoxee-mobile/">how to create post app download engagement.</a></p>

<p>Спасибо <a href="http://derevyanko.blogspot.com/2011/07/android.html">DV</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/send_get_sms/">Отправка и получение SMS</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-08-17T15:37:17+03:00" pubdate data-updated="true">Aug 17<span>th</span>, 2012</time>
        
           | <a href="/send_get_sms/#disqus_thread"
             data-disqus-identifier="http://android-helper.com.ua//send_get_sms/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Добрый день друзья.</p>

<p>В предыдущих записях я писал как можно отправлять сообщения с помощью встроенной системы.</p>

<p>Сегодня же я решил поделится опытом отправки и приема сообщений без участия стандартных программ.</p>

<p>Приступим.</p>

<h3>Отправка сообщений</h3>

<h2>1. Дадим права отправки сообщений</h2>

<pre><code>&lt;uses-permission android:name="android.permission.SEND_SMS"&gt;&lt;/uses-permission&gt;
</code></pre>

<h2>2. Базовая функция отправки сообщений</h2>

<pre><code>SmsManager sms = SmsManager.getDefault();

sms.sendTextMessage("1-212-555-1212", null, "Привет, Android-helper.com.ua", null, null);
</code></pre>

<h2>3. Опишем Activity для отправки.</h2>

<p>Хочу отметить, что для получения статуса сообщение мы создадим BroadcastReceiver и зарегистрируем его.</p>

<pre><code>import android.app.Activity;

import android.app.PendingIntent;

import android.content.BroadcastReceiver;

import android.content.Context;

import android.content.Intent;

import android.content.IntentFilter;

import android.os.Bundle;

import android.telephony.SmsManager;

import android.util.Log;

import android.view.View;

import android.view.View.OnClickListener;

import android.widget.Button;

import android.widget.Toast;

public class SMSFun extends Activity {

// Button to trigger sending the SMS

Button aButton;

// PendingIntent to tell the SMS app to notify us

PendingIntent sentPI;

// The intent action we are using

String SENT = "SMS_SENT";

// The BroadcastReceiver that we use to listen for the notification back

BroadcastReceiver br;

@Override

public void onCreate(Bundle savedInstanceState) {

    super.onCreate(savedInstanceState);

    setContentView(R.layout.main);

    // Create the Pending Intent

sentPI = PendingIntent.getBroadcast(this, 0,

            new Intent(SENT), 0);

aButton = (Button) this.findViewById(R.id.Button01);

    aButton.setOnClickListener(new OnClickListener() {

public void onClick(View v) {

SmsManager sms = SmsManager.getDefault();

// send the message, passing in the pending intent, sentPI

    sms.sendTextMessage("1-212-555-1212", null, "Привет android-helper.com.ua", sentPI, null);  

    registerReceiver(br, new IntentFilter(SENT));       

}});  



    // In order to receive the results via the pending intent we need

// to register a new BroadcastReceiver and pay attention to the various

// values we could get back

br = new BroadcastReceiver(){

            @Override

public void onReceive(Context ctx, Intent intent) {

                switch (getResultCode())

                {

                    case Activity.RESULT_OK:

                        Toast.makeText(getBaseContext(), "SMS sent", 

                                Toast.LENGTH_SHORT).show();

                        break;

                    case SmsManager.RESULT_ERROR_GENERIC_FAILURE:

                        Toast.makeText(getBaseContext(), "SMS: Generic failure", 

                                Toast.LENGTH_SHORT).show();

                        break;

                    case SmsManager.RESULT_ERROR_NO_SERVICE:

                        Toast.makeText(getBaseContext(), "SMS: No service", 

                                Toast.LENGTH_SHORT).show();

                        break;

                    case SmsManager.RESULT_ERROR_NULL_PDU:

                        Toast.makeText(getBaseContext(), "SMS: Null PDU", 

                                Toast.LENGTH_SHORT).show();

                        break;

                    case SmsManager.RESULT_ERROR_RADIO_OFF:

                        Toast.makeText(getBaseContext(), "SMS: Radio off", 

                                Toast.LENGTH_SHORT).show();

                        break;

                }

                unregisterReceiver(br);

            }

        };    }

}
</code></pre>

<h3>Получение сообщений</h3>

<h2>1. Права доступа</h2>

<pre><code>&lt;uses-permission android:name="android.permission.RECEIVE_SMS"&gt;&lt;/uses-permission&gt;
</code></pre>

<h2>2. Для того что бы получать сообщения, нужно создать BroadcastReceiver</h2>

<pre><code>&lt;receiver android:name=".SMSFunReceive"&gt;

 &lt;intent-filter&gt;

            &lt;action android:name=

               "android.provider.Telephony.SMS_RECEIVED" /&gt;

 &lt;/intent-filter&gt;

&lt;/receiver&gt;
</code></pre>

<p><strong>Java</strong></p>

<pre><code>import android.content.BroadcastReceiver;

import android.content.Context;

import android.content.Intent;

import android.os.Bundle;

import android.telephony.SmsMessage;

import android.util.Log;

// This will run when an SMS message comes in.

// We can see if we want to do something based upon the message

// Perhaps launch an activity

public class SMSFunReceive extends BroadcastReceiver 

{

@Override

public void onReceive(Context ctx, Intent intent) 

{

Bundle bundle = intent.getExtras();        

Object[] pdus = (Object[]) bundle.get("pdus");

SmsMessage[] messages = new SmsMessage[pdus.length];



for (int i = 0; i &lt; messages.length; i++)
{

messages[i] = SmsMessage.createFromPdu((byte[])pdus[i]);



Log.v("SMSFun","Body: " + messages[i].getDisplayMessageBody());

Log.v("SMSFun","Address: " + messages[i].getDisplayOriginatingAddress());

//If say we wanted to do something based on who sent it

if (messages[i].getDisplayOriginatingAddress().contains("2125551212"))

     {

// we could launch an activity and pass the data

Intent newintent = new Intent(ctx, SecretMessage.class);
newintent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);         // Pass in data

newintent.putExtra("address", messages[i].getDisplayOriginatingAddress());

newintent.putExtra("message", messages[i].getDisplayMessageBody());

ctx.startActivity(newintent);         

}

}

}

}
</code></pre>

<h2>5. Финальный аккорд. Создадим Activity для отображения сообщения.</h2>

<pre><code>import android.app.Activity;

import android.os.Bundle;

import android.widget.TextView;

public class SecretMessage extends Activity {

public void onCreate(Bundle savedInstanceState) {

    super.onCreate(savedInstanceState);

    setContentView(R.layout.secret);

    // Get the extra data

    Bundle extras = getIntent().getExtras(); 

    String address = extras.getString("address");

    String message = extras.getString("message");



    TextView addresstv = (TextView) findViewById(R.id.addresstv);

    TextView messagetv = (TextView) findViewById(R.id.messagetv);



    messagetv.setText(message);

    addresstv.setText(address);

}

}
</code></pre>

<p><strong>xml</strong></p>

<pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;

&lt;LinearLayout 
    xmlns:android="http://schemas.android.com/apk/res/android" 
    android:layout_width="wrap_content" 
    android:layout_height="wrap_content"&gt;

    &lt;TextView 
        android:layout_height="wrap_content" 
        android:id="@+id/addresstv" 
        android:text="address" 
        android:layout_width="fill_parent"
        android:layout_gravity="fill_horizontal" /&gt;

    &lt;TextView 
        android:layout_height="wrap_content" 
        android:id="@+id/messagetv" 
        android:text="message" 
        android:layout_width="fill_parent" 
        android:layout_gravity="fill_horizontal" /&gt;

&lt;/LinearLayout&gt;
</code></pre>

<p>Если понравилась статья, нажми рассказать друзьям.</p>

<p>Полный код программы <a href="http://android-helper.com.ua/forms">тут</a>.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/design/">Проектирование интерфейсов</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-08-15T12:00:12+03:00" pubdate data-updated="true">Aug 15<span>th</span>, 2012</time>
        
           | <a href="/design/#disqus_thread"
             data-disqus-identifier="http://android-helper.com.ua//design/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Добрый день друзья.</p>

<p>Многие разработчики сталкиваются с проблемой проектирования пользовательского интерфейса.</p>

<p>Все ищут идеи у других программ, которые скачивают с <a href="https://play.google.com/store">Google Play</a></p>

<p>Я же в своей статье хочу дать несколько полезных ссылок на сайты где вы сможете черпнуть идей для своего приложения.</p>

<h4><a href="http://justnotes.ru/proektiruya-dlya-konchikov-palcev.html">Проектируя для кончиков пальцев.</a></h4>

<p>Использование пальцев перевернуло устоявшиеся представления о настольных приложениях. Дизайнер интерактивной среды Джош Кларк объясняет, о чём важно помнить при проектировании интерфейсов для мобильных сенсорных экранов, и сравнивает удобные для пальцев тач-интерфейсы iPhone, iPad и Android.</p>

<h4><a href="http://justnotes.ru/dizayn-polzovatelskogo-interfeysa-prilozheniya-dlya-iphone.html">Дизайн пользовательского интерфейса приложения для iPhone</a></h4>

<p>Необходимые знания: ничего кроме внимания к деталям и основ Photoshop<br/>
Инструменты: ручка, бумага, Photoshop (или другой графический редактор, позволяющий экспортировать png-файлы)<br/>
Продолжительность работы: 2-5 часов.</p>

<p>Проектирование для устройств на платформе iOS4 сильно отличается от разработки сайтов. Сара Парментер объясняет, как создать качественный пользовательский интерфейс приложения.</p>

<h3><a href="http://pttrns.com/">Очень много различных примеров</a></h3>

<p>Если у вас есть еще какие то статьи или сайты пишите, я с радость буду их добавлять.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/send_message/">Отправка сообщения с приложения</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-08-10T11:01:42+03:00" pubdate data-updated="true">Aug 10<span>th</span>, 2012</time>
        
           | <a href="/send_message/#disqus_thread"
             data-disqus-identifier="http://android-helper.com.ua//send_message/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Добрый день всем.</p>

<p>В предыдущем посте я писал о возможности отправки писем с вашего приложения.</p>

<p>Сегодня я бы хотел написать, как же можно отправлять SMS с вашего приложения.</p>

<p>Вот код:</p>

<pre><code>Intent smsIntent = new Intent(Intent.ACTION_VIEW);

smsIntent.setType("vnd.android-dir/mms-sms");

smsIntent.putExtra("address", "12125551212,121212121212"); // C версии 2.2 можно отправлять множеству получателей

smsIntent.putExtra("sms_body","Body of Message");

startActivity(smsIntent);
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/send_mail/">Отправка почты вашим приложением.</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-08-07T11:22:43+03:00" pubdate data-updated="true">Aug 7<span>th</span>, 2012</time>
        
           | <a href="/send_mail/#disqus_thread"
             data-disqus-identifier="http://android-helper.com.ua//send_mail/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Несколько дней наз столкнулся с задачей отправки почты с приложения.</p>

<p>И как оказалось и тут google позаботился о нас.</p>

<p>Пример кода:</p>

<pre><code>Intent it = new Intent(Intent.ACTION_SEND);   

it.putExtra(Intent.EXTRA_EMAIL, "me@abc.com");   

it.putExtra(Intent.EXTRA_TEXT, "The email body text");   

it.setType("text/plain");   

context.startActivity(Intent.createChooser(it, "Choose Email Client")); 
</code></pre>

<p>После этого будет вызван диалог выбора почтового клиента.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/static_code/">Статические анализаторы кода для Android-приложения.</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-08-02T11:02:27+03:00" pubdate data-updated="true">Aug 2<span>nd</span>, 2012</time>
        
           | <a href="/static_code/#disqus_thread"
             data-disqus-identifier="http://android-helper.com.ua//static_code/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Добрый день друзья.</p>

<p>Сегодня нашел очень увлекательную <a href="http://derevyanko.blogspot.com/2012/01/android.html">статью</a> которая помогает проанализировать коды вашей программы.</p>

<p>Надеюсь, что вам понравится!</p>

<p>А вот и описание:</p>

<p>Одним из путей улучшения качества кода приложения является <a href="http://habrahabr.ru/blogs/code_review/135234/#habracut">регулярное</a>применение статических анализаторов кода. Статический анализ кода позволяет находить ошибки в коде, отслеживать несоблюдение стандарта кодирования, находить &ldquo;плохой&rdquo; код, который может привести к проблемам в будущем, а так же неэффективный код, негативно сказывающийся на производительности в настоящем, строить метрики кода, находить полностью или частично одинаковые фрагменты кода и так далее. </p>

<p>Для разработчиков, ведущих кодирование в одиночку, статические анализаторы вещь вообще неоценимая. Ведь им некому показать код своего приложения. Так что &ldquo;электронный помощник&rdquo;, способный грамотно выполнить &ldquo;code review&rdquo;, может им здорово пригодится.</p>

<p>Вопрос &ndash; какие статические анализаторы кода доступны разработчику Android приложений? Для Java статических анализаторов существует множество (см. список <a href="http://en.wikipedia.org/wiki/Lint_(software">lint </a>)приложений для Java в википедии), но не все они умеют работать с Android-приложениями и, тем более, учитывать их специфику.</p>

<p>Мне удалось отыскать следующие статические анализаторы кода, которые умеют работать с Android-приложениями:</p>

<ul>
<li><p><a href="http://tools.android.com/tips/lint">Lint </a>. &ldquo;Родной&rdquo; анализатор кода для Android, входит в состав Android SDK начиная с r16.</p></li>
<li><p><a href="http://findbugs.sourceforge.net/">FindBugs </a>(бесплатный).</p></li>
<li><p><a href="http://checkstyle.sourceforge.net/">Checkstyle </a>(бесплатный).</p></li>
<li><p><a href="http://code.google.com/intl/ru-RU/javadevtools/codepro/doc/index.html">CodePro Analytix </a>(бесплатный).</p></li>
<li><p><a href="http://pmd.sourceforge.net/">PMD </a>(бесплатный)</p></li>
<li><p>Motodev App Validator (бесплатный). Входит в состав среды разработки<a href="http://developer.motorola.com/docstools/motodevstudio/">MOTODEV Studio for Android </a>. Есть <a href="http://developer.motorola.com/testing/app-validator/">online </a>вариант.</p></li>
<li><p><a href="http://www.klocwork.com/products/solo/">Klocwork Solo </a>(платный). Доступна триальная версия</p></li>
<li><p><a href="http://www.parasoft.com/jsp/products/jtest.jsp">JTest </a>от Parasoft (платный).</p></li>
<li><p><a href="http://juliasoft.com/">Julia </a>(платный). Доступен бесплатный <a href="http://julia.scienze.univr.it/">online </a>вариант.</p></li>
</ul>


<p>Далее представлены результаты сравнения всех этих анализаторов &ndash; какой анализатор что умеет, для чего предназначен, насколько удобно пользоваться, какие ошибки находит, насколько он полезен на практике. </p>

<p>Чтобы было интереснее сравнивать, я &ldquo;натравил&rdquo; каждый из этих анализаторов на одно и то же тестовое приложение. В качестве такового я взял код одной из ранних версий моего приложения <a href="https://market.android.com/details?id=com.mobilityflow.awidget&amp;hl=ru">Animated Widget Contact Launcher </a>. Версию я выбрал годичной давности, багов и проблем в ней было вагон (с FindBugs на тот момент я был не знаком). Так что &ldquo;что поискать&rdquo; в ней точно было.</p>

<h3>Lint</h3>

<p><a href="http://tools.android.com/tips/lint">Lint </a>&ndash; анализатор кода, который поставляется вместе с Android SDK. Он появился совсем недавно, в версии r16. </p>

<p>Lint нацелен на поиск проблем, связанных с ресурсами. Неиспользуемые ресурсы, ненужные или наоборот, отсутствующие, аттрибуты, неоптимальные конструкции в layout и т.д. Список проблем, которые ищет Lint, приведен <a href="http://tools.android.com/tips/lint-checks">здесь </a>. </p>

<p>Работать с Lint очень удобно. Вызывать и настраивать его можно прямо из Eclipse. Для найденных ошибок показывается объяснение &ndash; в чем состоит ошибка и как ее исправить. Ошибки делятся на 3 уровня (error, warning, information). </p>

<p>При проверке тестового приложения был выдан 101 warning. Все по существу &ndash; ложных срабатываний не было, за исключением пары сообщений об неиспользуемости ресурсов (и это при отсутствии библиотек; если же библиотеки используются, то разработчики прямо предупреждают о возможности ложных сообщений, так что будьте осторожны при чистке кода).</p>

<p><img src="http://3.bp.blogspot.com/-UJ2JPXSVb9s/TwVtraTmfMI/AAAAAAAAAFQ/R32F2qPO1uk/s320/lint2.png" alt="" /></p>

<h3> </h3>

<h3>FindBugs</h3>

<p>FindBugs я пользуюсь уже почти год и очень доволен. Находит реальные ошибки в коде. Вот полный <a href="http://findbugs.sourceforge.net/bugDescriptions.html">список проблем </a>, которые он умеет находить.</p>

<p>В декабре 2011, после длительного перерыва, FindBugs обновился с версии 1.3.9 до 2.0. Субъективно новая версия стала точнее, удобнее и быстрее предыдущей. Настраивается она теперь прямо из Eclipse (важно: в свойствах проекта, а не в свойствах workspace). Плагин для eclipse устанавливается с помощью location URL: <code>http://findbugs.cs.umd.edu/eclipse/</code> (в Eclipse выбрать <code>Help\Install new software</code>, ввести location URL в поле Work with).</p>

<p><img src="http://2.bp.blogspot.com/-dKUxauuPo5s/TwV0S48r2zI/AAAAAAAAAFc/0cjP_W2wTuM/s320/findbugs_settings.jpg" alt="" /></p>

<p>FindBugs нашел в тестовом приложении 12 ошибок при дефолтном уровне чувствительности. При максимальной чувствительности ошибок нашлось 137. При этом ложных срабатываний было всего 10 (анализатору не понравился способ именования классов в автоматические генерируемом файле ресурсов; этот файл нужно просто исключить из обработки в настройках FindBugs). Подавляющее большинство остальных ошибок я исправил в более поздних версиях.</p>

<p><img src="http://4.bp.blogspot.com/-hybSpfAErHs/TwV0q3gJQhI/AAAAAAAAAFo/Q_9jti2d1oI/s320/findbugs_sample.jpg" alt="" /></p>

<p>Приведу примеры ошибок, которые нашел FindBugs:</p>

<ul>
<li><p><code>Should be a static inner class</code> (вложенный класс не сделан статичным, хотя доступ к внешнему классу ему не нужен).</p></li>
<li><p><code>Should this field be static?</code> (константа не объявлена как static)</p></li>
<li><p><code>Switch statement found where one case falls through to the next case</code>(пропущен break)</p></li>
<li><p><code>Comparison of String parameter using == or != in</code> (строки в Java небходимо сравнивать через equal)</p></li>
</ul>


<p>Специфичных для Android правил в FindBugs пока нет. Но, возможно, со временем они появятся &ndash; разработчики <a href="http://groups.google.com/group/openintents/browse_thread/thread/b3a520a90254ce7f?pli=1">готовы идти навстречу пожеланиям пользователей.</a></p>

<h3> </h3>

<h3>Checkstyle</h3>

<p><a href="http://checkstyle.sourceforge.net/">Checkstyle </a>нацелен на проверку соблюдения стандарта кодирования. Проверка соблюдения правил именования, правил расстановки скобочек, правил оформления кода и т.д. &ndash; вот цель этого анализатора. Полный список правил можно посмотреть в <a href="http://checkstyle.sourceforge.net/config_coding.html">документации </a>. Плагин для eclipse устанавливается с помощью location URL: <code>http://eclipse-cs.sf.net/update/</code></p>

<p>После анализа тестового приложения Checkstyle выдал 8741(!) ворнинг. Я внимательно просмотрел все типы ворнингов.. и не нашел для себя ничего полезного. На мой взгляд &ndash; это совершенно не тот инструмент, который необходим индивидуальным разработчикам и небольшим командам. С другой стороны, его активно используют и <a href="http://sevntu-checkstyle.github.com/sevntu.checkstyle/">дорабатывают </a>, так что видимо область применения у него все же есть.</p>

<p><img src="http://3.bp.blogspot.com/-2S9FFxInHYo/TwV4wSDKRhI/AAAAAAAAAF0/xlOO_lzrCSc/s320/checkstyle_settings.png" alt="" /></p>

<h3> </h3>

<h3>CodePro Analytix</h3>

<p><a href="http://code.google.com/intl/ru-RU/javadevtools/codepro/doc/index.html">CodePro Analytix </a>&ndash; разработка компании Instantiations. Google купил эту компанию и <a href="http://googlewebtoolkit.blogspot.com/2010/09/google-relaunches-instantiations.html">сделал эти продукт бесплатным </a>, за что ему большое спасибо.</p>

<p>Заявленные <a href="http://code.google.com/intl/ru-RU/javadevtools/codepro/doc/index.html">возможности CodePro Analytix </a>впечатляют. <a href="http://code.google.com/intl/ru-RU/javadevtools/codepro/doc/features/audit/audit.html">Аудит кода </a>на основе нескольких различных наборов правил (&ldquo;The Elements of Java Style&rdquo;, &ldquo;Effective Java&rdquo;, &ldquo;Potential Errors and Refactoring&rdquo;, &ldquo;Security&rdquo; и т.д.). Измерение кода с помощью различных метрик. Поиск &ldquo;дублей&rdquo; в коде &ndash; результатов копипаста. И т.д.</p>

<p>Провел аудит кода тестового приложения используя все возможные наборы правил. Получил: 152 предупреждения с уровнем серьезности High, 1246 &ndash; medium, 1062 &ndash; low. Для сравнения &ndash; анализ с помощью единственного набора правил &ldquo;Code Pro Core&rdquo; выдал 64 medium и 4 low предупреждения.</p>

<p><img src="http://4.bp.blogspot.com/-RD18joLpJgo/TwWG7-5R8EI/AAAAAAAAAGM/l3WFRuLTkG8/s320/codepro_audit.png" alt="" /></p>

<p>Что-же нашел Code Pro? Частично, результаты поиска пересеклись с результатами FindBugs и Lint. Но только частично. Большую часть ошибок составили минорные проблемы в коде, которые не были обнаружены другими анализаторами. Например:</p>

<ul>
<li><p><code>String literal can be replaced by a character literal</code>. В StringBuilder вместо append(&ldquo;\n&rdquo;) использовать append(&lsquo;\n&rsquo;).</p></li>
<li><p><code>Badly located array declarators</code>. Массив объявлен как &ldquo;String abc[]&rdquo; вместо &ldquo;String[] abc&rdquo;.</p></li>
<li><p><code>Constant on right side of comparison</code>. Код &ldquo;if (a == 5) { .. }&rdquo; следует переписать так &ldquo;if (5 == a&rdquo;) { .. }&#8221;</p></li>
<li><p><code>Switch statements should include all possible enumeration constants</code>. В перечислимом типе 3 возможных значения, а в switch задействовано только 2 из них.</p></li>
<li><p><code>Do not divide by powers of 2: use "&gt;&gt; 1" rather than "/ 2"</code></p></li>
<li><p><code>Invalid string literal: "Yes"</code>. Строки следует хранить в ресурсах, а не кодировать их жестко в код.</p></li>
<li><p><code>Use charAt() rather than startsWith() when the constant is a single character string</code>. Код skinName.startsWith(&ldquo;/&rdquo;) можно переписать skinName.charAt(0) == &lsquo;/&rsquo;</p></li>
<li><p><code>Define the initial capacity of StringBuilder instances</code></p></li>
</ul>


<p>Если не полениться и настроить Code Pro под себя, то инструмент оказывается весьма полезным. Возможно, некоторые рекомендации похожи на &ldquo;ловлю блох&rdquo;.. но почему бы не привыкнуть писать более оптимальный код, если это возможно?</p>

<p>Кстати, юзабилити у Code Pro на высоте. Находясь в списке ошибок можно:</p>

<ul>
<li><p>автоматически исправить ошибку (естестенно, автоматический рефакторинг кода поддерживается не для всех типов правил);</p></li>
<li><p>проигнорировать ошибку &ndash; она перестанет появляться в списке ошибок;</p></li>
<li><p>отключить правило, по которому была найдена ошибка;</p></li>
<li><p>настроить (!) параметры правила,</p></li>
</ul>


<p>и так далее.</p>

<p>Кроме аудита, очень понравилось, как Code Pro ищет дубли. Незаменимая функция.</p>

<p><img src="http://4.bp.blogspot.com/-yKmH44qnn_o/TwWG1iYOocI/AAAAAAAAAGA/6Feo9xpPQ9Y/s320/codepro_compare.png" alt="" /></p>

<h3>PMD</h3>

<p><a href="http://pmd.sourceforge.net/">PMD </a>&ndash; еще один анализатор кода, типа Code Pro. Основное назначение &ndash; поиск неоптимального кода, проблем с производительностью, нарушений стиля кодирования, дублей в коде и т.д. Плагин PMD устанавливается с помощью location URL: <code>http://pmd.sourceforge.net/rules/android.html</code></p>

<p>Примечательно, что в PMD реализовано <a href="http://pmd.sourceforge.net/rules/android.html">несколько правил, специфичных для Android </a></p>

<p>Для тестового приложения PMD выдал около 2000 предупреждений. Примеры:</p>

<ul>
<li><p><code>Substitute calls to size() == 0 (or size() != 0) with calls to isEmpty()</code></p></li>
<li><p><code>Private field ''{0}'' could be made final; it is only initialized in the declaration or constructor.</code></p></li>
<li><p><code>UnnecessaryCaseChange: Using equalsIgnoreCase() is cleaner than using toUpperCase/toLowerCase().equals()</code></p></li>
<li><p><code>UnusedFormalParameter: Avoid unused {0} parameters such as ''{1}''. Avoid passing parameters to methods or constructors and then not using those parameters.</code></p></li>
<li><p><code>InefficientEmptyStringCheck: String.trim().length()==0 is an inefficient way to validate an empty String.</code></p></li>
<li><p><code>UseIndexOfChar: String.indexOf(char) is faster than String.indexOf(String).</code></p></li>
<li><p><code>BooleanInversion: Use bitwise inversion to invert boolean values</code></p></li>
</ul>


<p>Несмотря на то, что PMD генерирует множество лишних предупреждений, следует отметить, что и полезных подсказок он выдает множество. Так же как и Code Pro, PMD следует тщательно настраивать.</p>

<p>В PMD, так же как в Code Pro, реализована функция поиска повторяющихся участков кода. Визуализация найденных фрагментов, правда, похуже. Зато результаты поиска &ndash; другие, так что программы дополняют друг друга.</p>

<p><img src="http://1.bp.blogspot.com/-07qFCT9CevQ/TwWOUNRVzfI/AAAAAAAAAGY/EBMZ6YGA2-U/s320/pmd.jpg" alt="" /></p>

<h3> </h3>

<h3>Motodev App Validator</h3>

<p>Motodev App Validator входит в состав среды разработки <a href="http://developer.motorola.com/docstools/motodevstudio/">MOTODEV Studio for Android </a>. Прочитать про него можно в презентации <a href="http://assets.en.oreilly.com/1/event/68/Static%20Analysis%20For%20Improved%20Application%20Performance%20And%20Quality%20Presentation.pdf">Static Analysis For Improved Application Performance And Quality Presentation (PDF) </a></p>

<p>Те, кто не использует MOTODEV Studio, могут попробовать <a href="http://developer.motorola.com/testing/app-validator/">online вариант Motodev App Validator </a>(требуется зарегистрироваться на сайте). </p>

<p>Online вариант Motodev App Validator принимает на вход apk-файл приложения. К сожалению, 400 килобайтную apk-шку тестового приложения online вариант не заглотил &ndash; выдал ошибку. Мелкие приложение в 30-40 кб анализирует, а с &ldquo;крупным&rdquo; не работает. Пришлось <a href="http://developer.motorola.com/docstools/motodevstudio/download/">качать Motodev Studio </a></p>

<p>Скачал, запустил. Для тестового приложения Application Validator выдал 101 предупреждение. Из них:</p>

<ul>
<li><p>75 - <code>"Drawable "XXX.png" does not exist in the "drawable-ldpi" folder. Add the appropriate "XXX.png" drawable to the "drawable-ldpi" folder."</code> - ничего нового.</p></li>
<li><p>13 - <code>"Default layout file YYY.xml does not have an xlarge-specific version. This app may not have the look and feel expected on devices with extra large screens. Define an xlarge layout for YYY.xml or add &lt;supports-screens android:xlargeScreens="false"&gt; to the manifest file."</code> - так же ничего нового.</p></li>
<li><p>4 - <code>"The import android.util.DisplayMetrics is never used ZZZ.java"</code> - ошибка, на которую умеет указывать сам Eclipse.</p></li>
<li><p>1 - <code>"The value of the local variable AAA is not used"</code> - эту ошибку умеют находить многие анализаторы.</p></li>
<li><p>3 - <code>"The static field A.B should be accessed in a static way ClassA.B"</code> - и эту тоже.</p></li>
</ul>


<p>Интересным оказалось лишь одно сообщение - <code>"The application declares the permission android.permission.CALL_PHONE which implies the unsupported feature android.hardware.telephony..."</code>. Честно говоря, результаты работы не впечатлили.</p>

<p><img src="http://1.bp.blogspot.com/-NHo6NN7u7ZY/TwZeDM5UqkI/AAAAAAAAAGw/EfpMA2g-Ong/s320/motodev_settings.png" alt="" /></p>

<p>Впрочем, судя по списку правил, Application Validator умеет находить и более интересные вещи: незакрытые курсоры, недочеты Android Manifest, отсутствие перевода строки в локализованных ресурсах, ненужные или наоборот, пропущенные permissions и т.д.</p>

<h3> </h3>

<h3>Klocwork Solo for Java</h3>

<p><a href="http://www.klocwork.com/products/solo/">Klocwork Solo </a>&ndash; платный статический анализатор кода. По заверениям разработчиков, способен находить более 200 типов проблем, связанных с уязвимостью и надежностью кода. Анализатор умеет находить проблемы, специфичные для Android-приложений. Интегрируется с EClipse. Триальная 30-дневная версия доступна после регистрации на сайте. У триальной версии ограничение &ndash; не более 300 файлов в проекте.</p>

<p>Полный список правил, которые проверяет Kockwork Solo, можно посмотреть в<a href="http://download.klocwork.com/docs/issuehelp/index.html">документации </a>. На настоящий момент правил, специфичных для Android, всего девять.</p>

<p><img src="http://2.bp.blogspot.com/-EX-wZ8D7340/TwWqBFoC-LI/AAAAAAAAAGk/aaRqJPj4WPM/s320/klocwork_settings.png" alt="" /></p>

<p>Для тестового приложения Kockwork Solo выдал 240 предупреждений. Неожиданно, очень интересных. Примеры:</p>

<ul>
<li><p><code>NPE.RET : Null pointer dereference of 'xy' where null is returned from a method</code>. В приложении имеется такой код: <code>Point xy = m_SA.getShortcutPosition(); Rect r = new Rect(0, 0, xy.x, xy.y);</code>. Функция getShortcutPosition() в отдельных случаях может возвращать null. Но в вызывающей функции проверки на null нет. Это типичная ошибка.</p></li>
<li><p><code>NPE.COND : Null pointer dereference of 'xxx' where null comes from condition</code>. Объект xxx используется без проверки на null, а между тем, он запросто может быть равен null.</p></li>
<li><p><code>RTC.CALL : Type cast from 'android.view.View' to 'android.widget.ImageButton' is redundant because method 'setTag' is defined in 'android.view.View'</code>. В приложении код такой:<code>((ImageButton)findViewById(R.id.hs_image)).setTag(combination)</code>. Т.е. анализатор обнаружил ненужное приведение типа.</p></li>
<li><p><code>REDUN.FINAL : Redundant 'final' modifier</code> - приватный метод объявлен как final. Приватные методы всегда final, так что объявление излишне.</p></li>
<li><p><code>JD.SYNC.IN : Field 'VarName' synchronized inconsistently.</code> - доступ к переменной VarName синхронизирован частично. Это ошибка &ndash; доступ должен либо всегда синхронизироваться, либо никогда.</p></li>
<li><p><code>ANDROID.NPE : Null pointer dereference of 'window' in an Android application</code>. Код в приложении следующий: <code>Window window = activity.getWindow(); window.getDecorView().getWindowVisibleDisplayFrame(rect)</code> Т.е. не выполняется проверка window на null</p></li>
</ul>


<p>Так что Kockwork Solo находит реальные ошибки, причем иные, чем FindBugs (списки дефектов, которые они обнаруживают, пересекаются незначительно). Лично меня очень заинтересовали ошибки типа NPE.RET и Android.NPE. Такие ошибки, судя по всему, не находит ни один другой анализатор.</p>

<p>Юзабилити у продукта не понравилось. В списке ошибок есть фильтрация, есть возможность указать статус ошибки. Но если указать статус &ldquo;Ignored&rdquo;, то ошибка пропадает и не ясно, как ее вернуть. Если отфильтровать список, то часть ошибок из списка пропадает и опять же не ясно, как сбросить фильтр. Не интуитивно все как-то. В CodePro сделано удобнее.</p>

<p><img src="http://1.bp.blogspot.com/-Lmwoy5r95EE/TwZ1c_3J7AI/AAAAAAAAAG8/YJ0REyWSlCQ/s320/klocwok_screen.jpg" alt="" /></p>

<h3> </h3>

<h3>JTest от Parasoft</h3>

<p>Триальную версию <a href="http://www.parasoft.com/jsp/products/jtest.jsp">Jtest </a>просто так скачать не дают. Так что этот анализатор я в работе проверить не смог. Судя по описанию &ndash; функциональность очень интересная. Например, JTest, так же как и Code Pro, умеет самостоятельно рефакторить код.</p>

<h3> </h3>

<h3>Julia</h3>

<p>Julia &ndash; коммерческий анализатор кода Java / Android приложений. &ldquo;Семантический инструмент, основанный на <a href="http://www.juliasoft.com/public/Biblioteca/cade11.pdf">математической теории </a>&rdquo;. </p>

<p>Как указано на сайте разработчика, протестировать работу анализатора можно<a href="http://julia.scienze.univr.it/">online </a>, загрузив в него jar-файл. У android приложения нет jar файла, есть apk (бинарный формат &ndash; другой). APK-файл анализатор принял.. но ни один из доступных способов анализа (Nullness, Termination, Check) ничего не выдал. Пишет &ndash; &ldquo;there are no warnings&rdquo;. </p>

<p>Загрузил первый попавшийся JAR &ndash; работает. Судя по всему, там неплохой анализ на &ldquo;отсутствие проверки на null&rdquo;. Жаль, что apk-шки не грузятся.</p>

<p><strong>Update</strong>: Написал разработчикам. Они мне подсказали, что можно экспортировать Android приложение в JAR-файл прямо из Eclipse. Экспортировал, загрузил в Julia.</p>

<p>Nullness analysis и Termination analysis результатов не выдали. Дело в том, что в демонстрационной online-версии для данных типов анализа существует ограничение: общее количество методов не должно превышать 10000 и 8500 соответственно. В тестовом приложении количество методов оказалось большим, так что процедура анализа принудительно останавливалась до завершения работы.</p>

<p>Третий тип анализа &ndash; &ldquo;Checks&rdquo;, &ndash; выдал 286 предупреждений. По большей части, вот таких:</p>

<ul>
<li><p><code>[Classcast] A you sure that this cast from classA into classB is always legal?</code></p></li>
<li><p><code>[BadNames] Method XXX has a bad name</code></p></li>
<li><p><code>[Deadcode] Methos XXX is not reachable</code></p></li>
<li><p><code>[BadEq] Inefficient comparison with the empty string. Use isEmpty() instead</code></p></li>
<li><p><code>[Approximation] Unsafe comparison beween non-integral numbers.</code></p></li>
<li><p><code>[StaticFieldAccess] Modification of static field from a non-static context</code>(это что-то новенькое; другие анализаторы на такие ошибки не ругались).</p></li>
<li><p><code>[Unused class] Class YYY is not used.</code></p></li>
<li><p><code>[Field access] Field XXX is never reach in reachable code.</code></p></li>
<li><p><code>[Useless call] Useless call toString()</code></p></li>
<li><p><code>[BadEq] Suspicious use of == rather then equals() to compare two java.lang.String</code></p></li>
</ul>


<p>В принципе, кое что интересно есть. Но: пользоваться очень неудобно (результаты выдаются в виде странички на флеш), поскольку сервис online, приходится &ldquo;отдавать&rdquo; исходники приложения в виде jar, что не всегда приемлемо.</p>

<p><strong>Update2</strong>. Попросил разработчиков Julia провести анализ тестового приложения и прислать мне результаты. Они любезно согласились.</p>

<p>Termination analysis &ndash; это анализ кода на наличие бесконечных циклов и рекурсий в коде. Он выдал одно предупреждение. Анализатору не понравился код </p>

<pre><code>private void expungeStaleEntries() {  
Reference sv;  
while ((sv = queue.poll()) != null) {  
hash.remove(reverseLookup.remove(sv));  
}  
}  
</code></pre>

<p>из реализации SoftHashMap, взятой <a href="http://www.javaspecialists.eu/archive/Issue098.html">отсюда </a>. Опасения анализатора понятны. Тем не менее, код правильный.</p>

<p>Nullness analysis проверяет в коде отсутствие необходимых и наличие излишних проверок на null. Таких предупреждений было выдано 187. Примеры ошибок:</p>

<ul>
<li><p><code>X1.java:57: is the return value of getY1 non-null?</code></p></li>
<li><p><code>X2.java:57: is the 0th actual parameter of parseInt non-null?</code></p></li>
<li><p><code>X3.java:69,70,72,78,105,109,178: is the return value of getY2 non-null?</code></p></li>
<li><p><code>X4.java:227,261,309: is the value of field mX1 non-null?</code></p></li>
<li><p><code>X5.java:84: is this nullness check useless?</code></p></li>
<li><p><code>X6.java:318,361: is the receiver of the call to iterator non-null?</code></p></li>
<li><p><code>X7.java:34: is the formal parameter srcRect non-null?</code></p></li>
</ul>


<p>Отмечу, что Kockwork Solo выдал всего 43 предупреждения, связанных с проверкой на null. Подробнее результаты, полученные Julia и Kockwork Solo, сравниваются ниже.</p>

<h3> </h3>

<h3>Напоследок. Сравнительные тесты</h3>

<p>Ну как же без тестов&hellip; Многие анализаторы обнаруживают одни и те же типы проблемы в коде. Сравним, кто что находит.</p>

<h4>Неверное сравнение строк</h4>

<p>В Java строки надо сравнивать через equal. Между тем, по старой сишной привычке, можно сравнить строки через != и == и получить ошибку. Этот баг настолько распространен, что его ищут чуть ли не все анализаторы.</p>

<p>В тестовом приложении оказалось семь таких багов. Вот они:</p>

<pre><code>1. widget_name == ""  
2. title != adapter.getItem(i).Title  
3. srcStr == "S"  
4. m_K != ""  
5. contact_name != m_B.getB().GetR(this)  
6. contact_name == ""  
7. name == "" ? "" : name + ": "  
</code></pre>

<h4>Проблемы со switch</h4>

<p>Для switch характерны следующие проблемы:</p>

<ul>
<li><ol>
<li>Отсутствие default</li>
</ol>
</li>
<li><ol>
<li>Пропущен break</li>
</ol>
</li>
<li><ol>
<li>Switch выполняется по значению перечислимого типа. В &ldquo;case&rdquo; используются не все значения, входящие в перечислимый тип.</li>
</ol>
</li>
<li><ol>
<li>Switch слишком маленький &ndash; например, в нем одно или два значения. Можно обойтись if/else.</li>
</ol>
</li>
<li><ol>
<li>В двух case используется одинаковый код.</li>
</ol>
</li>
</ul>


<p>Далеко не всегда эти проблемы являются реальными ошибками. Тем не менее, анализаторы кода как правило считают своим долгом о них сообщить.</p>

<p>Разные анализаторы работают с разными типами проблем. Итак, вот как отработали анализаторы на тестовом приложении.</p>

<h4>NP-анализ</h4>

<p>Отсутствие проверки на null и, как результат, &ldquo;NUll pointer exception&rdquo; &ndash; одна из наиболее частых ошибок при разработке под Android. Другая сторона медали &ndash; излишние проверки. </p>

<p>К слову сказать, FindBugs успешно отлавливает такую ошибку: вначале у объекта вызывается функция, а затем объект проверяется на null. </p>

<p>Klocwork и Julia &ldquo;заточены&rdquo; под Android. И эта &ldquo;заточенность&rdquo; проявляется, прежде всего, в возможности NP-анализа. Как я писал вышел, Klocwork для тестового приложения выдал 43 NP-предупреждения, Julia &ndash; 187. Сравним, кто что нашел.</p>

<h5>NP анализ. Файл 1</h5>

<p>Проблема 1.1. <code>String action = intent.getAction(); if (action.equals("abc")) {..};</code> Переменная action может быть null. Проблему обнаружили обе программы.<br/>
Проблема 1.2. <code>intent.getExtras().getInt(...);</code> Результат getExtras() не проверяется на null. Проблему обнаружили обе программы. <br/>
Проблема 1.3. <code>Uri uri = intent.getData(); Integer.parseInt(uri.getQueryParameter("widget_id"))</code>. Оба анализатора сообщили об использовании uri без проверки uri на null. Julia дополнительно сообщила о том, что результаты работы uri.getQueryParameter на null не проверяются и в parseInt может быть передан null.<br/>
Проблема 1.4. <code>WidgetContent wc = WidgetFabric.getWidgetContent(); wc.getFlagValue();</code>. Оба анализатора сообщили, что wc может быть null. В реализации getWidgetContent() действительно есть ветка кода, которая возвращает null.<br/>
Проблема 1.5. <code>((Singleton)context.getApplicationContext()).getABC().Register();</code>Об этой проблеме сообщила только Julia. Функция getABC() может вернуть null и вызывать Register() нельзя. На самом деле, объект ABC создается в <a href="http://derevyanko.blogspot.com/2010/12/android_26.html">синглетоне, реализованном поверх класса Application. </a>Инициализируется он в момент запуска приложения и null быть не может. Однако, инициализация ABC проводится не в конструкторе синглетона, а в функции onCreate. Анализатор не знает про тонкости создания синглетона и предупреждает об ошибке, которая вряд ли возможна.</p>

<h5>NP анализ. Файл 2</h5>

<p>Проблема 2.1. <code>CheckBoxPreference pref = (CheckBoxPreference)getPreferenceScreen().findPreference("pref_name");</code>. findPreference может возвращать null.<br/>
Проблема 2.2. <code>List list_skins = ((Singleton)this.getApplicationContext()).getSkinManager().getListSkins("skin_name");</code>Проблема аналогична 1.5. Функция getSkinManager может возвращать null, но только теоретически.<br/>
Проблема 2.3. <code>int len_skins = list_skins.size();</code> Переменная list_skins действительно может быть null.<br/>
Проблема 2.4. <code>for (int j = 0; j &lt; len_skins; ++j) { array_skins[j] = list_skins.get(j).SkinTag; }</code> Результаты get не проверяются на null. Такая проверка необходима, если list_skins может содержать null. В приложении такого быть не может, так что проверка не нужна.<br/>
Проблема 2.5. <code>String skin_name = (String) p.getEntries()[p.findIndexOfValue(skin_tag)];</code> Результат работы getEntries() не проверяется на null.<br/>
Проблема 2.6. <code>CharSequence[] titles = res.getTextArray(idTitles); if (values[0].equals(svalue)) {...};</code> Значение values[0] не проверяется на null.<br/>
Julia сообщила обо всех этих проблемах. Klocwork &ndash; только о 2.3.</p>

<h5>NP анализ. Файл 3</h5>

<p>Проблема 3.1. <code>m_AsyncTask = new AppInfoReceiverTask(mUtils.getList());</code> Эту ошибка нашла только Julia &ndash; переменная mUtils может быть null. На самом деле, mUtils инициализируется в onCreate (речь идет о наследнике Activity) и null быть не может.<br/>
Проблема 3.2. <code>protected void onActivityResult(int requestCode, int resultCode, Intent data) { data.getExtras().getString(...);</code> Эту проблему нашли оба анализатора: data.getExtra может вернуть null.<br/>
Проблема 3.3. <code>(LauncherContent)WidgetFabric.getWidgetContent()</code> Эту проблему нашел Klocwork. Julia ее пропустила.<br/>
Проблема 3.4. <code>SpinnerItem selected_item = (SpinnerItem)spinner.getSelectedItem(); String s = selected_item.Title;</code>Функция getSelectedItem может вернуть null согласно документации. Проблему нашла только Julia<br/>
Проблема 3.5. <code>ListView list_view = (ListView) dialog.findViewById(R.id.listview); list_view.setAdapter(new SelectImageAdapter(list_images) );</code> Теоретически, findViewById может вернуть null. На проблему указала только Julia.<br/>
Проблема 3.6. <code>private final void remove_shortcut(AppInfo appInfo) { m_List.remove(appInfo); }</code> В функцию может быть передан null, appInfo на null не проверяется. Проблему нашла только Julia.<br/>
Проблема 3.7. <code>for (SkinManager.SkinInfo skin : skins) { ... }</code> Переменная skins может содержать null. Проблему нашли оба анализатора.</p>

<p>Резюме. Julia находит почти все NP-ошибки, которые обнаруживает Klocwork, плюс еще ряд дополнительных. Одновременно, она генерирует довольно много ложных сообщений, которые на практике придется просто игнорировать. Самая большая проблема на мой взгляд &ndash; она не учитывает, что в Activity переменные инициализируются в onCreate, а не в конструкторе.</p>

<h3>Итоги</h3>

<p>В итоге получается следующая картина. В настоящее время существует восемь доступных статических анализаторов кода для Android приложений: Lint, FindBugs, Checkstyle, CodePro, PMD, Motodev App Validator, Klocwork Solo, Julia. Основная специализация у них следующая:</p>

<ul>
<li><p>Lint и Motodev App Validator &ndash; поиск проблем в ресурсах Android приложения;</p></li>
<li><p>FindBugs, Klocwork Solo и Julia &ndash; поиск ошибок в коде приложения;</p></li>
<li><p>Checkstyle &ndash; проверка соблюдения правил оформления кода и стандарта кодирования;</p></li>
<li><p>CodePro и PMD &ndash; поиск неоптимального кода, проблемного кода, поиск дублей.</p></li>
</ul>


<p>FindBugs и Lint прекрасно работают &ldquo;с нуля&rdquo; &ndash; настраивать их практически не требуется. CodePro и PMD требуют тонкой настройки. Но если отключить в них ненужные проверки, они приносят реальную пользу. Motodev App Validator и Checkstyle мне показались не слишком полезными &ndash; на любителя. Klocwork Solo &ndash; находит ряд ошибок, которые не находят другие анализаторы. Он платный, но и триальную версию можно вполне успешно использовать для небольших приложений. Julia находит ряд NP-ошибок, которые не находит Klocwork, но при этом генерирует еще и множество ложных предупреждений (ошибка возможна, но только теоретически). К сожалению, воспользоваться бесплатной версией практически не возможно.</p>

<p> </p>

<p> </p>

<p> </p>

<p> </p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/patch_lenovo_a750/">Исправление русского ввода на Lenovo A750</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-07-23T08:41:12+03:00" pubdate data-updated="true">Jul 23<span>rd</span>, 2012</time>
        
           | <a href="/patch_lenovo_a750/#disqus_thread"
             data-disqus-identifier="http://android-helper.com.ua//patch_lenovo_a750/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Добрый день друзья.</p>

<p>Пару дней назад купил себе телефон <a href="http://utc.vn.ua/product/lenovo-a750">Lenovo A750</a></p>

<p>Телефон был уже перепрошит на Android 4.0.3, но была одна маленькая проблема.</p>

<p>В наборе номера не было русских букв.</p>

<p>Долго не думая, я решил найти как побороть эту проблему. И решение нашлось.</p>

<h4>1. <a href="http://android-helper.com.ua/images/uploads/2012/07/Search_T9_ICS_rus.zip">Скачиваем патч</a>.</h4>

<ol>
<li>Копируем его на флеш карту телефона. (Можно подключить телефон к компьютеру и скопировать туда).</li>
<li>Заходим в recovery.</li>
</ol>


<p><img src="http://android-helper.com.ua/images/uploads/2012/07/device-2012-07-23-080632.png" alt="" /></p>

<p><img src="http://android-helper.com.ua/images/uploads/2012/07/device-2012-07-23-080658.png" alt="" /></p>

<p> </p>

<h4>4. Выбираем обновление.</h4>

<p><img src="http://android-helper.com.ua/images/uploads/2012/07/2012-07-23-08.jpg" alt="" /></p>

<p><img src="http://android-helper.com.ua/images/uploads/2012/07/2012-07-23-08.09.33.jpg" alt="" /></p>

<p><img src="http://android-helper.com.ua/images/uploads/2012/07/2012-07-23-08.09.20.jpg" alt="" /></p>

<h4>5. Обновляем.</h4>

<p><img src="http://android-helper.com.ua/images/uploads/2012/07/2012-07-23-08.09.jpg" alt="" /></p>

<h4>6. Выключаем телефон.</h4>

<p><img src="http://android-helper.com.ua/images/uploads/2012/07/2012-07-23-08.10.jpg" alt="" /></p>

<h4>7. Включаем и наслаждаемся.</h4>

<p><img src="http://android-helper.com.ua/images/uploads/2012/07/device-2012-07-23-081251.png" alt="" /></p>

<p>Если не работает поиск по русскому тексту. Тогда смените язык системы на Английский, а затем на Русский.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/pull-to-refresh/">Pull to Refresh - обновление ListView как у Twitter</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-07-19T16:33:10+03:00" pubdate data-updated="true">Jul 19<span>th</span>, 2012</time>
        
           | <a href="/pull-to-refresh/#disqus_thread"
             data-disqus-identifier="http://android-helper.com.ua//pull-to-refresh/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Добрый день друзья.</p>

<p>Сегодня я бы хотел поделится с вами одной интересной темой.</p>

<p>Если вы когда нибудь использовали приложение Twitter у себя на устройстве, то видели, что если потянуть список вниз то появится что то типа этого:</p>

<p><a href="http://android-helper.com.ua/images/uploads/2012/07/device-2012-07-19-155609.jpg"><img src="http://android-helper.com.ua/images/uploads/2012/07/device-2012-07-19-155609.jpg" alt="" /></a></p>

<p><a href="http://android-helper.com.ua/images/uploads/2012/07/device-2012-07-19-155634.jpg"><img src="http://android-helper.com.ua/images/uploads/2012/07/device-2012-07-19-155634.jpg" alt="" /></a></p>

<p><a href="http://android-helper.com.ua/images/uploads/2012/07/device-2012-07-19-155646.jpg"><img src="http://android-helper.com.ua/images/uploads/2012/07/device-2012-07-19-155646.jpg" alt="" /></a></p>

<p>Попробуем это написать сами.</p>

<p>Должно получится что то вроде этого:</p>

<p><a href="http://android-helper.com.ua/images/uploads/2012/07/device-2012-07-19-162848.png"><img src="http://android-helper.com.ua/images/uploads/2012/07/device-2012-07-19-162848.png" alt="" /></a></p>

<p><a href="http://android-helper.com.ua/images/uploads/2012/07/device-2012-07-19-162904.png"><img src="http://android-helper.com.ua/images/uploads/2012/07/device-2012-07-19-162904.png" alt="" /></a></p>

<p><a href="http://android-helper.com.ua/images/uploads/2012/07/device-2012-07-19-162911.png"><img src="http://android-helper.com.ua/images/uploads/2012/07/device-2012-07-19-162911.png" alt="" /></a></p>

<p><a href="http://android-helper.com.ua/images/uploads/2012/07/device-2012-07-19-162918.png"><img src="http://android-helper.com.ua/images/uploads/2012/07/device-2012-07-19-162918.png" alt="" /></a></p>

<p>Создадим разметку нашего загрузчика:</p>

<p>[xml]</p>

<p>&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;utf-8&rdquo;?></p>

<p>&lt;RelativeLayout xmlns:android=&ldquo;<a href="http://schemas.android.com/apk/res/android">http://schemas.android.com/apk/res/android</a>&rdquo;</p>

<pre><code>android:id="@+id/pull_to_refresh_header"

android:layout_width="fill_parent"

android:layout_height="fill_parent"

android:gravity="center"

android:paddingBottom="15dip"

android:paddingTop="10dip" &gt;



&lt;ProgressBar

    android:id="@+id/pull_to_refresh_progress"

    style="?android:attr/progressBarStyleSmall"

    android:layout_width="wrap_content"

    android:layout_height="wrap_content"

    android:layout_centerVertical="true"

    android:layout_marginLeft="30dip"

    android:layout_marginRight="20dip"

    android:layout_marginTop="10dip"

    android:indeterminate="true"

    android:visibility="gone" /&gt;



&lt;ImageView

    android:id="@+id/pull_to_refresh_image"

    android:layout_width="wrap_content"

    android:layout_height="wrap_content"

    android:layout_gravity="center"

    android:layout_marginLeft="30dip"

    android:layout_marginRight="20dip"

    android:gravity="center"

    android:src="@drawable/ic_pulltorefresh_arrow"

    android:visibility="gone" /&gt;



&lt;TextView

    android:id="@+id/pull_to_refresh_text"

    android:layout_width="fill_parent"

    android:layout_height="wrap_content"

    android:layout_gravity="center"

    android:gravity="center"

    android:paddingTop="5dip"

    android:text="@string/pull_to_refresh_tap_label"

    android:textAppearance="?android:attr/textAppearanceMedium"

    android:textStyle="bold" /&gt;



&lt;TextView

    android:id="@+id/pull_to_refresh_updated_at"

    android:layout_width="fill_parent"

    android:layout_height="wrap_content"

    android:layout_below="@+id/pull_to_refresh_text"

    android:layout_gravity="center"

    android:gravity="center"

    android:textAppearance="?android:attr/textAppearanceSmall"

    android:visibility="gone" /&gt;
</code></pre>

<p></RelativeLayout></p>

<p>[/xml]</p>

<p>Реализуем ListView (полный код):</p>

<p>[java]</p>

<p>package com.ua.androidhelper.widget;</p>

<p>import android.content.Context;</p>

<p>import android.util.AttributeSet;</p>

<p>import android.util.Log;</p>

<p>import android.view.LayoutInflater;</p>

<p>import android.view.MotionEvent;</p>

<p>import android.view.View;</p>

<p>import android.view.ViewGroup;</p>

<p>import android.view.animation.LinearInterpolator;</p>

<p>import android.view.animation.RotateAnimation;</p>

<p>import android.widget.AbsListView;</p>

<p>import android.widget.AbsListView.OnScrollListener;</p>

<p>import android.widget.ImageView;</p>

<p>import android.widget.ListAdapter;</p>

<p>import android.widget.ListView;</p>

<p>import android.widget.ProgressBar;</p>

<p>import android.widget.RelativeLayout;</p>

<p>import android.widget.TextView;</p>

<p>public class PullToRefreshListView extends ListView implements OnScrollListener {</p>

<pre><code>private static final int TAP_TO_REFRESH = 1;

private static final int PULL_TO_REFRESH = 2;

private static final int RELEASE_TO_REFRESH = 3;

private static final int REFRESHING = 4;



private static final String TAG = "PullToRefreshListView";



private OnRefreshListener mOnRefreshListener;



/**

 * Listener that will receive notifications every time the list scrolls.

 */

private OnScrollListener mOnScrollListener;

private LayoutInflater mInflater;



private RelativeLayout mRefreshView;

private TextView mRefreshViewText;

private ImageView mRefreshViewImage;

private ProgressBar mRefreshViewProgress;

private TextView mRefreshViewLastUpdated;



private int mCurrentScrollState;

private int mRefreshState;



private RotateAnimation mFlipAnimation;

private RotateAnimation mReverseFlipAnimation;



private int mRefreshViewHeight;

private int mRefreshOriginalTopPadding;

private int mLastMotionY;



private boolean mBounceHack;



public PullToRefreshListView(Context context) {

    super(context);

    init(context);

}



public PullToRefreshListView(Context context, AttributeSet attrs) {

    super(context, attrs);

    init(context);

}



public PullToRefreshListView(Context context, AttributeSet attrs, int defStyle) {

    super(context, attrs, defStyle);

    init(context);

}



private void init(Context context) {

    // Load all of the animations we need in code rather than through XML

    mFlipAnimation = new RotateAnimation(0, -180, RotateAnimation.RELATIVE_TO_SELF, 0.5f,

            RotateAnimation.RELATIVE_TO_SELF, 0.5f);

    mFlipAnimation.setInterpolator(new LinearInterpolator());

    mFlipAnimation.setDuration(250);

    mFlipAnimation.setFillAfter(true);

    mReverseFlipAnimation = new RotateAnimation(-180, 0, RotateAnimation.RELATIVE_TO_SELF, 0.5f,

            RotateAnimation.RELATIVE_TO_SELF, 0.5f);

    mReverseFlipAnimation.setInterpolator(new LinearInterpolator());

    mReverseFlipAnimation.setDuration(250);

    mReverseFlipAnimation.setFillAfter(true);



    mInflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);



    mRefreshView = (RelativeLayout) mInflater.inflate(R.layout.pull_to_refresh_header, this, false);

    mRefreshViewText = (TextView) mRefreshView.findViewById(R.id.pull_to_refresh_text);

    mRefreshViewImage = (ImageView) mRefreshView.findViewById(R.id.pull_to_refresh_image);

    mRefreshViewProgress = (ProgressBar) mRefreshView.findViewById(R.id.pull_to_refresh_progress);

    mRefreshViewLastUpdated = (TextView) mRefreshView.findViewById(R.id.pull_to_refresh_updated_at);



    mRefreshViewImage.setMinimumHeight(50);

    mRefreshView.setOnClickListener(new OnClickRefreshListener());

    mRefreshOriginalTopPadding = mRefreshView.getPaddingTop();



    mRefreshState = TAP_TO_REFRESH;



    addHeaderView(mRefreshView);



    super.setOnScrollListener(this);



    measureView(mRefreshView);

    mRefreshViewHeight = mRefreshView.getMeasuredHeight();

}



@Override

protected void onAttachedToWindow() {

    setSelection(1);

}



@Override

public void setAdapter(ListAdapter adapter) {

    super.setAdapter(adapter);



    setSelection(1);

}



/**

 * Set the listener that will receive notifications every time the list scrolls.

 * 

 * @param l

 *            The scroll listener.

 */

@Override

public void setOnScrollListener(AbsListView.OnScrollListener l) {

    mOnScrollListener = l;

}



/**

 * Register a callback to be invoked when this list should be refreshed.

 * 

 * @param onRefreshListener

 *            The callback to run.

 */

public void setOnRefreshListener(OnRefreshListener onRefreshListener) {

    mOnRefreshListener = onRefreshListener;

}



/**

 * Set a text to represent when the list was last updated.

 * 

 * @param lastUpdated

 *            Last updated at.

 */

public void setLastUpdated(CharSequence lastUpdated) {

    if (lastUpdated != null) {

        mRefreshViewLastUpdated.setVisibility(View.VISIBLE);

        mRefreshViewLastUpdated.setText(lastUpdated);

    } else {

        mRefreshViewLastUpdated.setVisibility(View.GONE);

    }

}



@Override

public boolean onTouchEvent(MotionEvent event) {

    final int y = (int) event.getY();

    mBounceHack = false;



    switch (event.getAction()) {

        case MotionEvent.ACTION_UP:

            if (!isVerticalScrollBarEnabled()) {

                setVerticalScrollBarEnabled(true);

            }

            if (getFirstVisiblePosition() == 0 &amp;&amp; mRefreshState != REFRESHING) {

                if ((mRefreshView.getBottom() &gt;= mRefreshViewHeight || mRefreshView.getTop() &gt;= 0)

                        &amp;&amp; mRefreshState == RELEASE_TO_REFRESH) {

                    // Initiate the refresh

                    mRefreshState = REFRESHING;

                    prepareForRefresh();

                    onRefresh();

                } else if (mRefreshView.getBottom() &lt; mRefreshViewHeight || mRefreshView.getTop() &lt;= 0) {

                    // Abort refresh and scroll down below the refresh view

                    resetHeader();

                    setSelection(1);

                }

            }

            break;

        case MotionEvent.ACTION_DOWN:

            mLastMotionY = y;

            break;

        case MotionEvent.ACTION_MOVE:

            applyHeaderPadding(event);

            break;

    }

    return super.onTouchEvent(event);

}



private void applyHeaderPadding(MotionEvent ev) {

    // getHistorySize has been available since API 1

    int pointerCount = ev.getHistorySize();



    for (int p = 0; p &lt; pointerCount; p++) {

        if (mRefreshState == RELEASE_TO_REFRESH) {

            if (isVerticalFadingEdgeEnabled()) {

                setVerticalScrollBarEnabled(false);

            }



            int historicalY = (int) ev.getHistoricalY(p);



            // Calculate the padding to apply, we divide by 1.7 to

            // simulate a more resistant effect during pull.

            int topPadding = (int) (((historicalY - mLastMotionY) - mRefreshViewHeight) / 1.7);



            mRefreshView.setPadding(mRefreshView.getPaddingLeft(), topPadding, mRefreshView.getPaddingRight(),

                    mRefreshView.getPaddingBottom());

        }

    }

}



/**

 * Sets the header padding back to original size.

 */

private void resetHeaderPadding() {

    mRefreshView.setPadding(mRefreshView.getPaddingLeft(), mRefreshOriginalTopPadding,

            mRefreshView.getPaddingRight(), mRefreshView.getPaddingBottom());

}



/**

 * Resets the header to the original state.

 */

private void resetHeader() {

    if (mRefreshState != TAP_TO_REFRESH) {

        mRefreshState = TAP_TO_REFRESH;



        resetHeaderPadding();



        // Set refresh view text to the pull label

        mRefreshViewText.setText(R.string.pull_to_refresh_tap_label);

        // Replace refresh drawable with arrow drawable

        mRefreshViewImage.setImageResource(R.drawable.ic_pulltorefresh_arrow);

        // Clear the full rotation animation

        mRefreshViewImage.clearAnimation();

        // Hide progress bar and arrow.

        mRefreshViewImage.setVisibility(View.GONE);

        mRefreshViewProgress.setVisibility(View.GONE);

    }

}



private void measureView(View child) {

    ViewGroup.LayoutParams p = child.getLayoutParams();

    if (p == null) {

        p = new ViewGroup.LayoutParams(ViewGroup.LayoutParams.FILL_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT);

    }



    int childWidthSpec = ViewGroup.getChildMeasureSpec(0, 0 + 0, p.width);

    int lpHeight = p.height;

    int childHeightSpec;

    if (lpHeight &gt; 0) {

        childHeightSpec = MeasureSpec.makeMeasureSpec(lpHeight, MeasureSpec.EXACTLY);

    } else {

        childHeightSpec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED);

    }

    child.measure(childWidthSpec, childHeightSpec);

}



@Override

public void onScroll(AbsListView view, int firstVisibleItem, int visibleItemCount, int totalItemCount) {

    // When the refresh view is completely visible, change the text to say

    // "Release to refresh..." and flip the arrow drawable.

    if (mCurrentScrollState == SCROLL_STATE_TOUCH_SCROLL &amp;&amp; mRefreshState != REFRESHING) {

        if (firstVisibleItem == 0) {

            mRefreshViewImage.setVisibility(View.VISIBLE);

            if ((mRefreshView.getBottom() &gt;= mRefreshViewHeight + 20 || mRefreshView.getTop() &gt;= 0)

                    &amp;&amp; mRefreshState != RELEASE_TO_REFRESH) {

                mRefreshViewText.setText(R.string.pull_to_refresh_release_label);

                mRefreshViewImage.clearAnimation();

                mRefreshViewImage.startAnimation(mFlipAnimation);

                mRefreshState = RELEASE_TO_REFRESH;

            } else if (mRefreshView.getBottom() &lt; mRefreshViewHeight + 20 &amp;&amp; mRefreshState != PULL_TO_REFRESH) {

                mRefreshViewText.setText(R.string.pull_to_refresh_pull_label);

                if (mRefreshState != TAP_TO_REFRESH) {

                    mRefreshViewImage.clearAnimation();

                    mRefreshViewImage.startAnimation(mReverseFlipAnimation);

                }

                mRefreshState = PULL_TO_REFRESH;

            }

        } else {

            mRefreshViewImage.setVisibility(View.GONE);

            resetHeader();

        }

    } else if (mCurrentScrollState == SCROLL_STATE_FLING &amp;&amp; firstVisibleItem == 0 &amp;&amp; mRefreshState != REFRESHING) {

        setSelection(1);

        mBounceHack = true;

    } else if (mBounceHack &amp;&amp; mCurrentScrollState == SCROLL_STATE_FLING) {

        setSelection(1);

    }



    if (mOnScrollListener != null) {

        mOnScrollListener.onScroll(view, firstVisibleItem, visibleItemCount, totalItemCount);

    }

}



@Override

public void onScrollStateChanged(AbsListView view, int scrollState) {

    mCurrentScrollState = scrollState;



    if (mCurrentScrollState == SCROLL_STATE_IDLE) {

        mBounceHack = false;

    }



    if (mOnScrollListener != null) {

        mOnScrollListener.onScrollStateChanged(view, scrollState);

    }

}



public void prepareForRefresh() {

    resetHeaderPadding();



    mRefreshViewImage.setVisibility(View.GONE);

    // We need this hack, otherwise it will keep the previous drawable.

    mRefreshViewImage.setImageDrawable(null);

    mRefreshViewProgress.setVisibility(View.VISIBLE);



    // Set refresh view text to the refreshing label

    mRefreshViewText.setText(R.string.pull_to_refresh_refreshing_label);



    mRefreshState = REFRESHING;

}



public void onRefresh() {

    Log.d(TAG, "onRefresh");



    if (mOnRefreshListener != null) {

        mOnRefreshListener.onRefresh();

    }

}



/**

 * Resets the list to a normal state after a refresh.

 * 

 * @param lastUpdated

 *            Last updated at.

 */

public void onRefreshComplete(CharSequence lastUpdated) {

    setLastUpdated(lastUpdated);

    onRefreshComplete();

}



/**

 * Resets the list to a normal state after a refresh.

 */

public void onRefreshComplete() {

    Log.d(TAG, "onRefreshComplete");



    resetHeader();



    // If refresh view is visible when loading completes, scroll down to

    // the next item.

    if (mRefreshView.getBottom() &gt; 0) {

        invalidateViews();

        setSelection(1);

    }

}



/**

 * Invoked when the refresh view is clicked on. This is mainly used when there's only a few items in the list and

 * it's not possible to drag the list.

 */

private class OnClickRefreshListener implements OnClickListener {



    @Override

    public void onClick(View v) {

        if (mRefreshState != REFRESHING) {

            prepareForRefresh();

            onRefresh();

        } else {

            onRefreshComplete();

        }

    }



}



/**

 * Interface definition for a callback to be invoked when list should be refreshed.

 */

public interface OnRefreshListener {

    /**

     * Called when the list should be refreshed.

     * &lt;p&gt;

     * A call to {@link PullToRefreshListView #onRefreshComplete()} is expected to indicate that the refresh has

     * completed.

     */

    public void onRefresh();

}
</code></pre>

<p>}</p>

<p>[/java]</p>

<p>Добавим ListView на наш Activity:</p>

<p>[java]</p>

<p>public class MainActivity extends Activity {</p>

<pre><code>private final String[] values = { "Test 1", "Test 2", "Test 3", "Test 4", "Test 5", "Test 6", "Test 7", "Test 8",

        "Test 1", "Test 2", "Test 3", "Test 4", "Test 5", "Test 6", "Test 7", "Test 8", "Test 1", "Test 2",

        "Test 3", "Test 4", "Test 5", "Test 6", "Test 7", "Test 8", "Test 1", "Test 2", "Test 3", "Test 4",

        "Test 5", "Test 6", "Test 7", "Test 8" };



@Override

public void onCreate(Bundle savedInstanceState) {

    super.onCreate(savedInstanceState);

    // setContentView(R.layout.activity_main);



    ListAdapter adapter = new ArrayAdapter&lt;String&gt;(this, R.layout.list_item, values);

    PullToRefreshListView listView = new PullToRefreshListView(this);

    listView.setAdapter(adapter);

    setContentView(listView, new LayoutParams(LayoutParams.FILL_PARENT, LayoutParams.FILL_PARENT));

}
</code></pre>

<p>}</p>

<p>[/java]</p>

<p>Все готово.</p>

<p>Коды как всегда <a href="http://android-helper.com.ua/forms">тут</a>.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/fragments/">Fragments - описание</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-07-18T16:58:04+03:00" pubdate data-updated="true">Jul 18<span>th</span>, 2012</time>
        
           | <a href="/fragments/#disqus_thread"
             data-disqus-identifier="http://android-helper.com.ua//fragments/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Добрый день друзья.</p>

<p>Как и обещал выкладываю информацию о Fragments.</p>

<p>Пошарил немного по Интернету и нашел увлекательную статью на <a href="http://habrahabr.ru/post/113196/">Habrahabr.ru</a></p>

<p>Поэтому было решено вставить ее сюда полностью + со своей доработкой</p>

<p><em>В Android 3.0 введена новая концепция фрагментов, которая служит для упрощения работы с интерфейсом под разные размеры экранов. Данный топик является переводом статьи с android-developers.blogspot.com. В ней рассмотрены преимущества фрагментов, а также приведен простой, но законченный пример приложения, работающего по этому принципу.</em></p>

<p>Важная цель Android 3.0 — упростить написание программ, которые должны масштабироваться в зависимости от размеров экрана. Для этого в платформе Android уже доступны следующие средства:</p>

<ul>
<li><p>С самого начала, UI-фреймворк был спроектирован для использования layout managers, которые позволяют описывать интерфейс так, чтобы он «подгонялся» к размерам. Примером этого является ListView, высота которого изменяется в зависимости от размера экрана, который варьируется между соотношениями QVGA, HVGA, and WVGA.</p></li>
<li><p>В Android 1.6 была введена новая концепция плотности экрана, позволяющая приложениям легче масштабировать размеры между разными разрешениями, в то время как экраны имеют почти один и тот же физический размер. Разработчики незамедлительно начали использовать эту особенность, когда были введены телефоны с высоким разрешением, такие как Droid.</p></li>
<li><p>Также в Android 1.6 разработчикам стали доступны размеры экрана, при помощи их классификации: «small» для соотношения QVGA, «normal» для HVGA и WVGA, и «large» для более больших экранов. Разработчики могут использовать систему ресурсов для выбора между различными layout&#8217;ами, в зависимости от размера экрана</p></li>
</ul>


<p>Комбинация layout managers и выбора различных ресурсов представляет долгий путь для создания масштабируемого интерфейса. В итоге многие приложения для хэндсетов не используют специальный интерфейс для планшетов, работающих под Honeycomb.</p>

<h4>Введение во фрагменты</h4>

<p>В Android 3.0 введена поддержка новых классов, которые помогают приложениям масштабировать их интерфейс, называемых фрагментами (Fragment). Фрагмент — это независимый компонент со своим интерфейсом и жизненным циклом; он может быть неоднократно использован в разных частях пользовательского интерфейса, в зависимости от нужного UI потока для определенного устройства или экрана.</p>

<p>В некотором смысле можно рассматривать фрагмент как мини-Activity, хотя он не может запускаться независимо и должен размещаться внутри Activity. На самом деле введение Fragment API дало нам возможность решать многие проблемы, с которыми сталкивались разработчики, при работе с Activity, так как полезность фрагмента простирается далеко за пределы обычных настроек для разных разрешений экрана:</p>

<ul>
<li><p>Activity, вложенные через ActivityGroup были хорошей идеей, однако с ними было не так просто работать, так как Activity изначально разработан как независимый компонент. Fragment API — намного лучшее решение для этого, его стоит рассматривать как замену для вложенных Activity.</p></li>
<li><p>Сохранение данных для экземпляров Activity может быть выполнено через Activity.onRetainNonConfigurationInstance(), но это неуклюже само по себе и не очевидно. Фрагменты заменяют этот механизм, позволяя сохранять целый экземпляр фрагмента простой установкой флага.</p></li>
<li><p>Одна из конкретизаций фрагмента — DialogFragment, она упрощает отображение диалога, который управляется как часть жизненного цикла Activity. Он заменяет API Activity, используемые для управления диалогами.</p></li>
<li><p>Еще одна конкретизация фрагмента — ListFragment, она упрощает отображение списка данных. ListFragment похож на ListActivity (с несколькими дополнительными особенностями), его использование упростит отображение данных в списке.</p></li>
<li><p>Информация по всем фрагментам, прикрепленным к Activity, сохраняется фреймворком в сохраненное состояние той же Activity и восстанавливается при рестарте. Таким образом уменьшается количество сохраняемых состояний.</p></li>
<li><p>У фреймворка есть встроенная поддержка для управления стеком фрагментов, она упрощает поддержку поведения кнопки BACK внутри Activity, причем это поведение интегрируется с существующим стеком Activities.</p></li>
</ul>


<h4>Приступая к работе</h4>

<p>Вот простой, но полный пример реализации множественных потоков UI, с помощью фрагментов. Начнем с проектирования ландшафтного layout&#8217;a, содержащего список элементов слева и данные по ним справа. Так выглядит нужный нам layout:</p>

<p><img src="http://android-helper.com.ua/images/uploads/2012/07/device-fragment-land_new.png" alt="" /></p>

<p>Код для Activity не особенно интересен, он просто вызывает setContentView() со следующим макетом:</p>

<pre><code>&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"

android:layout_width="match_parent"

android:layout_height="match_parent"

android:orientation="horizontal" &gt;



&lt;fragment

    android:id="@+id/titles"

    android:layout_width="0px"

    android:layout_height="match_parent"

    android:layout_weight="1"

    class="com.example.androidhelper.fragments.TitlesFragment" /&gt;



&lt;FrameLayout

    android:id="@+id/details"

    android:layout_width="0px"

    android:layout_height="match_parent"

    android:layout_weight="1" /&gt;



&lt;/LinearLayout&gt;
</code></pre>

<p>Вы можете заметить первую особенность: тег</p>

<pre><code>&lt;fragment&gt;
</code></pre>

<p>позволяет устанавливать фрагмент в вашу иерархию интерфейса. Вышеописанный фрагмент наследует свойства ListFragment, который отображает данные по элементу в текущем месте, или в отдельном Activity, в зависимости от layout&#8217;a. Обратите внимание на то, как сохраняются изменения в состоянии фрагмента.</p>

<pre><code>public class TitlesFragment extends ListFragment {

boolean mDualPane;

int mCurCheckPosition = 0;



@Override

public void onActivityCreated(Bundle savedState) {

    super.onActivityCreated(savedState);



    // Populate list with our static array of titles.

    setListAdapter(new ArrayAdapter&lt;String&gt;(getActivity(), R.layout.list_item, Shakespeare.TITLES));



    // Check to see if we have a frame in which to embed the details

    // fragment directly in the containing UI.

    View detailsFrame = getActivity().findViewById(R.id.details);

    mDualPane = detailsFrame != null &amp;&amp; detailsFrame.getVisibility() == View.VISIBLE;



    if (savedState != null) {

        // Restore last state for checked position.

        mCurCheckPosition = savedState.getInt("curChoice", 0);

    }



    if (mDualPane) {

        // In dual-pane mode, list view highlights selected item.

        getListView().setChoiceMode(ListView.CHOICE_MODE_SINGLE);

        // Make sure our UI is in the correct state.

        showDetails(mCurCheckPosition);

    }

}



@Override

public void onSaveInstanceState(Bundle outState) {

    super.onSaveInstanceState(outState);

    outState.putInt("curChoice", mCurCheckPosition);

}



@Override

public void onListItemClick(ListView l, View v, int pos, long id) {

    showDetails(pos);

}



/**

 * Helper function to show the details of a selected item, either by displaying a fragment in-place in the current

 * UI, or starting a whole new activity in which it is displayed.

 */

void showDetails(int index) {

    mCurCheckPosition = index;



    if (mDualPane) {

        // We can display everything in-place with fragments.

        // Have the list highlight this item and show the data.

        getListView().setItemChecked(index, true);



        // Check what fragment is shown, replace if needed.

        DetailsFragment details = (DetailsFragment) getFragmentManager().findFragmentById(R.id.details);

        if (details == null || details.getShownIndex() != index) {

            // Make new fragment to show this selection.

            details = DetailsFragment.newInstance(index);



            // Execute a transaction, replacing any existing

            // fragment with this one inside the frame.

            FragmentTransaction ft = getFragmentManager().beginTransaction();

            ft.replace(R.id.details, details);

            ft.setTransition(FragmentTransaction.TRANSIT_FRAGMENT_FADE);

            ft.commit();

        }



    } else {

        // Otherwise we need to launch a new activity to display

        // the dialog fragment with selected text.

        Intent intent = new Intent();

        intent.setClass(getActivity(), DetailsActivity.class);

        intent.putExtra("index", index);

        startActivity(intent);

    }

}

}
</code></pre>

<p>Также необходимо реализовать DetailsFragment, который будет отображать данные по элементу в обычном TextView.</p>

<pre><code>public class DetailsFragment extends Fragment {

/**

 * Create a new instance of DetailsFragment, initialized to show the text at 'index'.

 */

public static DetailsFragment newInstance(int index) {

    DetailsFragment f = new DetailsFragment();



    // Supply index input as an argument.

    Bundle args = new Bundle();

    args.putInt("index", index);

    f.setArguments(args);



    return f;

}



public int getShownIndex() {

    return getArguments().getInt("index", 0);

}



@Override

public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {

    if (container == null) {

        // Currently in a layout without a container, so no

        // reason to create our view.

        return null;

    }



    ScrollView scroller = new ScrollView(getActivity());

    TextView text = new TextView(getActivity());

    int padding = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 4, getActivity().getResources()

            .getDisplayMetrics());

    text.setPadding(padding, padding, padding, padding);

    scroller.addView(text);

    text.setText(Shakespeare.DIALOGUE[getShownIndex()]);

    return scroller;

}

}
</code></pre>

<p>Настало время для добавления еще одного потока UI в наше приложение. Когда экран находится в портретном режиме, то недостаточно места для отображения двух фрагментов бок о бок. То есть мы хотим, чтобы отображался только список:</p>

<p><img src="http://android-helper.com.ua/images/uploads/2012/07/device-fragment-port1_new.png" alt="" /></p>

<p>Напишем новый layout для портретной ориентации:</p>

<pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;

&lt;FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"

android:layout_width="match_parent"

android:layout_height="match_parent" &gt;



&lt;fragment

    android:id="@+id/titles"

    android:layout_width="match_parent"

    android:layout_height="match_parent"

    class="com.example.androidhelper.fragments.TitlesFragment" /&gt;



&lt;/FrameLayout&gt;
</code></pre>

<p>Теперь у нас нет контейнера для отображения данных для TitlesFragment, отображается только список. При нажатии на элемент списка теперь нужно вызывать отдельное Activity, в котором и будут отображаться данные:</p>

<p><img src="http://android-helper.com.ua/images/uploads/2012/07/device-fragment-port2_new.png" alt="" /></p>

<p>Теперь, всё что от нас требуется — использовать уже готовый DetailsFragment:</p>

<pre><code>public class DetailsActivity extends FragmentActivity {



@Override

protected void onCreate(Bundle savedInstanceState) {

    super.onCreate(savedInstanceState);



    if (getResources().getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPE) {

        // If the screen is now in landscape mode, we can show the

        // dialog in-line so we don't need this activity.

        finish();

        return;

    }



    if (savedInstanceState == null) {

        // During initial setup, plug in the details fragment.

        DetailsFragment details = new DetailsFragment();

        details.setArguments(getIntent().getExtras());

        getSupportFragmentManager().beginTransaction().add(android.R.id.content, details).commit();

    }

}



}
</code></pre>

<p>Соединив Activity, мы получаем полностью работающий пример приложения, использующего радикальное изменение UI потока, основанное на том, какая конфигурация используется в данный момент. Также приложение автоматически подгоняется под требования размеров экрана при смене конфигурации.</p>

<p>Этот пример иллюстрирует всего лишь один способ использования фрагментов для подгонки вашего UI. В зависимости от дизайна, вы можете предпочесть другие. Например, вы можете поместить всё ваше приложение в одно Activity, в котором будет изменяться структура фрагментов.</p>

<p>Как обычно, больше информации можно найти в документации по SDK. Также можно найти примеры в ApiDemos.</p>

<h4>Фрагментация для всех</h4>

<p>Fragment API будет полезен для разработчиков, начинающих работать с приложениями, ориентированными на планшеты, которые спроектированы под Android 3.0, во многих случаях, связанных с большим экраном. Также использование фрагментов должно сделать проще настройку UI для приложений под новые устройства на Android, например, телевизоры.</p>

<p>Однако, сейчас Fragment API будет наиболее востребован для улучшения интерфейса существующих приложений для телефонов под планшеты.</p>

<p>Также планируется сделать статическую библиотеку для использования Fragment API (<em>Ура!!!</em>), чтобы использовать вышеописанный метод на ранних версиях Android. На самом деле, весь код в примере использует как раз статическую библиотеку классов, причем выполняется на Android 2.3 (можете сравнить с примерами в Android 3.0 SDK, они почти не отличаются). Наша цель — сделать эти API как можно более похожими, чтобы вы могли начать работать с ними сейчас, независимо от того, когда вы перейдете на Android 3.0.</p>

<p>Пока нет точной даты, когда библиотека будет доступна, но она точно будет скоро. Пока вы можете начать работать с фрагментами на Android 3.0.</p>

<h4>Дополнения</h4>

<p>Это была первая статья которая описывала фрагменты. На данный момент выпущена библиотека с обратной совместимостью (см. мои предыдущие посты) до версии андроид 1.6.</p>

<p>Для подключения фрагментов в приложения с обратной совместимостью вам нужно сделать следующее:</p>

<p>Наследоватся не от Activity, а от FragmentActivity. Это самое главное требование.</p>

<p>Пример как всегда вы сможете скачать <a href="http://android-helper.com.ua/forms/">тут</a>.</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/page/22/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/blog/page/20/">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/happy_new_year/">C Новым годом!</a>
      </li>
    
      <li class="post">
        <a href="/skype-premium/">Skype - годовой преимум аккаунт бесплатно!</a>
      </li>
    
      <li class="post">
        <a href="/custom-font/">Custom Font - свои шрифты в Android</a>
      </li>
    
      <li class="post">
        <a href="/ganymotion-root/">Genymotion Root - Как получить права рут на емуляторе</a>
      </li>
    
      <li class="post">
        <a href="/coaching_report/">Отчет по коучингу</a>
      </li>
    
  </ul>
</section>



<section class="googleplus">
  <h1>
    <a href="https://plus.google.com/Android-helperUa?rel=author">
      <img src="http://www.google.com/images/icons/ui/gprofile_button-32.png" width="32" height="32">
      Google+
    </a>
  </h1>
</section>



  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - Andrii Stakhov -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'androidhelper';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>





  <script type="text/javascript">
    (function() {
      var script = document.createElement('script'); script.type = 'text/javascript'; script.async = true;
      script.src = 'https://apis.google.com/js/plusone.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(script, s);
    })();
  </script>



  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
