---
author: andrew
comments: true
date: 2012-09-04 04:20:58+00:00
layout: post
slug: events
title: Взаимодействие с сенсорным экраном
wordpress_id: 514
categories:
- Android для профессионалов
- Программирование
---





Добрый день друзья.  
В одном из проэктов я столкнулся с задачей обрабатывать нажатия на сенсорный экран.  
Долго искал материалы, и мои поиски увенчались успехом.  
Ниже я приведу статью, которая описывает как с этим работать.  
Прошу к прочтению.





  






Занимаясь программированием под Android необходимо знать, как взаимодействовать с сенсорным экраном — главным устройством ввода на большинстве Android устройств. В этой статье будет рассмотрено:



<!-- more -->




  * Низкоуровневое взаимодействие с тачскрином, нужное прежде всего для разработки игр.




  * Класс MotionEvent



  * Обработка MotionEvent'ов




  * Работа с MultiTouch.



  * Некоторые высокоуровневые методы обработки прикосновений.






Также будут приведены различные примеры…





#### Отступление по поводу Лога





Так как в дальнейшем в этой статье мы будем активно использовать Log, я кратко расскажу про него(те, кто уже знаком с логом Андроида, могут благополучно пропустить этот раздел статьи).  
В Android имеется собственный лог, куда могут писать все желающие приложения от Dvalvik VM до вашего приложения. Все сообщения в логе разделяются по приоритету (право выбирать приоритет сообщения, посылаемого в лог остается за вами)   
Для записи в лог достаточно вызвать один из статических методов класса Log, различающихся только приоритетом отсылаемых ими сообщений.  
Эти методы приведены ниже, по возрастанию приоритета:








  * Log.v(String tag, String msg) — VERBOSE



  * Log.d(String tag, String msg) — DEBUG



  * Log.i(String tag, String msg) — INFO



  * Log.w(String tag, String msg) — WARNING



  * Log.e(String tag, String msg) — ERROR



  * Log.wtf(String tag, String msg) — What a Terrible Failure






Также есть возможность отправлять в лог исключения. В этом случае добавляется еще один аргумент — Throwable tr. Например:








  * Log.v(String tag, String msg, Throwable tr)






Вывести окно Log'а в Eclipse можно так:  
**Window -> Show View -> Other -> Android -> LogCat**





#### Понятие о MotionEvent





Класс MotionEvent служит хранилищем данных о прикосновении (touch event). Каждый раз, когда пользователь проводит пальцем по экрану, или даже просто тапает, создается целая последовательность экземпляров класса **MotionEvent**: последовательность начинается, когда пользователь дотрагивается до экрана, продолжается, пока пользователь двигает палец по экрану, и кончается, когда пользователь поднимает палец. Таким образом получается три основных типа действия, которые описывает MotionEvent: опускание пальца, его передвижение и поднятие. Каждый MotionEvent хранит в себе информацию о типе действия, которое он описывает. Для этого в классе MotionEvent предусмотрены константы:








  * int MotionEvent.ACTION_DOWN — пользователь опускает палец на экран.



  * int MotionEvent.ACTION_MOVE — пользователь передвигает пальцем по экрану.



  * int MotionEvent.ACTION_UP — пользователь поднимает палец с экрана.






Узнать какое действие описывает данный MotionEvent можно с помощью метода **getAction()**.  
Стоит отметить, что существует еще один тип действия — MotionEvent.ACTION_CANCEL, который по сути является обозначением того, что последовательность завершена некорректно, то есть без MotionEvent.ACTION_UP. Все это будет объяснено подробнее на примере, но чуть позже.





#### Получение и обработка MotionEvent'ов





Теперь, когда мы получили общее представление о MotionEvent'ах, необходимо разобраться с тем, откуда нам их «брать». Существует 2 способа, разберем их по отдельности.








  * Первый способ является оптимальным, когда вы используете один из стандартных View. У класса View существует метод SetOnTouchListener(View.OnTouchListener l), аргументом которого является класс, реализующий интерфейс OnTouchListener. Этот метод позволяет назначить «слушателя» MotionEvent'ов. Интерфейс OnTouchListener обязует класс реализовывать метод public boolean OnTouch(View v,MotionEvent event), вторым аргументом которого и является нужный нам MotionEvent. Теперь каждый раз, когда пользователь будет прикасаться к экрану, Android будет вызывать наш метод OnTouch, давая ему в аргумент описание произошедшего действия, то есть MotionEvent. Рассмотрим подробнее на примере:  
Вот наш файл res/layout/main.xml:  
  
		<?xml version="1.0" encoding="utf-8"?> 
	
		<LinearLayout xmlns:android="schemas.android.com/apk/res/android" 
    	android:orientation="vertical" 
    	android:layout_width="fill_parent" 
    	android:layout_height="fill_parent" 
    	android:id="@+id/ll" 
	 	/> 


  
  
  
А вот наш Activity класс:  
	
	import android.app.Activity;
	import android.os.Bundle;
	import android.util.Log;
	import android.view.MotionEvent;
	import android.view.View;
	import android.view.View.OnTouchListener;
	import android.widget.LinearLayout; 
	
	  public class main extends Activity implements OnTouchListener{// Заставляем наш Activity класс воплощать интерфейс OnTouchListener

      /** Called when the activity is first created. */

      @Override

      public void onCreate(Bundle savedInstanceState) {

          super.onCreate(savedInstanceState);

          setContentView(R.layout.main);

          LinearLayout ll =(LinearLayout)this.findViewById(R.id.ll);//Достаем нужный View

          ll.setOnTouchListener(this);// Устанавливаем данный класс в качестве слушателя MotionEvent'ов для нашего LinearLayout

      } 

      @Override

      public boolean onTouch(View v, MotionEvent event)// Вот, собственно, метод, который и будет обрабатывать MotionEvent'ы.

      {

          int Action=event.getAction();

		  // С помощью метода getAction() получаем тип действия(ACTION_DOWN,ACTION_MOVE или ACTION_UP)

          StringBuilder str=new StringBuilder();

          str.append("\nActrion type: ");

		  //Дальше для лучшего восприятия(т.к. константы ACTION_DOWN,ACTION_MOVE и ACTION_UP числовые)

          //проводим switch по переменной Action и добавляем в наш StringBuilder название константы

          switch(Action)

         {

              case MotionEvent.ACTION_DOWN: str.append("ACTION_DOWN\n");break;

              case MotionEvent.ACTION_MOVE: str.append("ACTION_MOVE\n");break;

              case MotionEvent.ACTION_UP: str.append("ACTION_UP\n");break;

         }

          //С помощью методов getX() и getY() получаем координаты по оси x и y соответственно

          //Следует отметить, что точка 0 располагается в левом верхнем углу экрана.

          //Ось x направлена вправо

          //Ось y направлена вниз(чем ниже, тем больше координата).

          str.append("Location: ").append(event.getX()).append(" x ").append(event.getY()).append("\n");//Узнаем координаты

          str.append("Edge flags: ").append(event.getEdgeFlags()).append("\n");// Метод getEdgeFlags возвращает информацию о пересечении краев экрана

          str.append("Pressure: ").append(event.getPressure()).append("\n");// Узнаем давление

          str.append("Size: ").append(event.getSize()).append("\n"); // Узнаем размер указателя(места соприкосновения пальца с экраном)

          str.append("Down time: ").append(event.getDownTime()).append("ms\n");// Узнаем время, когда палец был опущен на экран в миллисекундах

          str.append("Event time: ").append(event.getEventTime()).append("ms");//узнаем текущее время(соответствующее обрабатываемому MotionEvent'у) в миллисекундах

          str.append(" Elapsed: ").append(event.getEventTime()-event.getDownTime());//Узнаем сколько времени прошло с момента опускания пальца, до текущего MotionEvent'а

          Log.v("Mytag", str.toString());//Для того, чтобы можно было отслеживать эти действия, записываем всю информацию о них в лог.

          return true;// Почему мы возвращаем true будет рассмотрено потом

      }

  	}







  
  
  
Понятно, что один класс может быть слушателем у нескольких View. Чтобы это учитывать метод onTouch принимает в аргумент View.



  * Второй способ является оптимальным, когда вы пишете свой View класс, который должен реагировать на прикосновения. У View есть метод onTouchEvent(MotionEvent event), который, собственно, и позволяет обрабатывать MotionEvent'ы. Рассмотрим на примере:  
Напишем свой класс SomeView:  
  

		package com.example.MotionEventExample1;

		import android.content.Context;
		import android.util.AttributeSet;
		import android.view.View;

		public class SomeView extends View {

    	// Сначала необходимо реализовать конструктор.

    	// Тут все просто - просто вызываем конструктор суперкласса

    	public SomeView(Context context, AttributeSet attrs) {

        super(context, attrs);

    	}
		}



	// Теперь приступаем непосредственно к обработке MotionEvent'ов.

	// Для этого нужно переписать метод onTouchEvent

		@Override

		public boolean onTouchEvent(MotionEvent event) {

			Float X = (Float) event.getX();

			Float Y = (Float) event.getY();

			int Action = event.getAction();

			String ActionString = "";

			switch (Action) {

			case MotionEvent.ACTION_DOWN:

				ActionString = "ACTION_DOWN";

				break;

			case MotionEvent.ACTION_MOVE:

				ActionString = "ACTION_MOVE";

				break;

			case MotionEvent.ACTION_UP:

				ActionString = "ACTION_UP";

				break;

			}

			Log.v("MyTag", "View OnTouchListener:\n" + "Coords: " + X.toString() + " x " + Y.toString() + "\nAction type: " +  ActionString);

			return true;

			}

		}
  


  
  
И наш /res/layout/main.xml:  
  


   	<?xml version="1.0" encoding="utf-8"?>

   	<LinearLayout xmlns:android="schemas.android.com/apk/res/android"

       android:orientation="vertical"

       android:layout_width="fill_parent"

       android:layout_height="fill_parent"

       >

   	<com.example.MotionEventExample1.SomeView

       android:layout_width="fill_parent"

       android:layout_height="fill_parent"

      android:id="@+id/sv"

  	/>

  	</LinearLayout>





  
Activity класс:  
   


	package com.example.MotionEventExample1;

	import android.app.Activity;
	import android.os.Bundle;

	public class main extends Activity {

	/** Called when the activity is first created. */

	@Override

	public void onCreate(Bundle savedInstanceState) {

		super.onCreate(savedInstanceState);

		setContentView(R.layout.main);

	}

	}


  






#### О том, что возвращают обработчики MotionEvent'ов





Как вы могли заметить, обработчики MotionEvent'ов должны возвращать boolean'овское значение. В примерах до этого мы просто всегда возвращали true. Так для чего же этим методам вообще нужно возвращать значение? Дело в том, что у одного View может быть несколько слушателей (например onTouchEvent в самом View и OnTouch у внешнего слушателя) и они имеют некоторый приоритет: OnTouch вызывается первым (если он вообще имеется), а уже после него может вызываться onTouchEvent. Вызов следующего по приоритету обработчика как раз зависит от возвращаемого текущим обработчиком значения (true — ничто не вызывается, false — вызывается следующий по приоритету, если таковой имеется). Таким образом Android позволяет нам разделять обязанности по обработке touch event'ов на несколько слушателей.





##### Drag and Drop





Вот мы и разобрались с основами обработки MotionEvento'ов. Для закрепления навыков напишем приложение, реализующее простенький Drag and Drop.  
  
Вот наш /res/layout/main.xml:  
  


   	<?xml version="1.0" encoding="utf-8"?>

  	<LinearLayout xmlns:android="schemas.android.com/apk/res/android"

       android:orientation="vertical"

       android:layout_width="fill_parent"

       android:layout_height="fill_parent"

       >

   	<com.example.dragdrop.SomeView

       android:layout_width="fill_parent"

       android:layout_height="fill_parent"

      android:id="@+id/sv"

  	/>

  	</LinearLayout>







 





Вот наш Activity класс:


	package com.example.dragdrop;
	
	import android.app.Activity;
	import android.os.Bundle;

	public class main extends Activity {

	/** Called when the activity is first created. */

	@Override

	public void onCreate(Bundle savedInstanceState) {

		super.onCreate(savedInstanceState);

		setContentView(R.layout.main);

	}

	}






А вот наш основной класс SomeView:

	package com.example.dragdrop;

	import android.content.Context;
	import android.graphics.Canvas;
	import android.graphics.Color;
	import android.graphics.Paint;
	import android.graphics.Paint.Style;
	import android.util.AttributeSet;
	import android.view.MotionEvent;
	import android.view.View;
	
	public class SomeView extends View {

	Paint paint;

	int X;

	int Y;

	final static int Radius = 20;



	public SomeView(Context context, AttributeSet attrs) {

		super(context, attrs);

		paint = new Paint();

		paint.setColor(Color.YELLOW);

		paint.setStyle(Style.FILL);

		X = 30;

		Y = 30;

	}



	@Override

	public boolean onTouchEvent(MotionEvent event) {

		X = (int) event.getX();

		Y = (int) event.getY();

		return true;

	}



	@Override

	protected void onDraw(Canvas canvas)// метод OnDraw вызвается Андроидом

										// тогда, когда нужно отрисовать данный

										// View

	{

		canvas.drawCircle(X, Y, Radius, paint);

		invalidate();// invalidate() нужен для того, чтобы оповестить Android,

						// что нужно выполнить метод OnDraw снова, без него View

						// не будет перериcовываться.

	}

	}





**Multitouch**





 





В Android, сколько-бы вы пальцев ни использовали, информация о всех них хранится в одном MotionEvent'е. Первый метод, который нужно узнать, если вы собираетесь использовать мультитач — getPointerCount(), который возвращает количество пальцев, зафиксированных на экране(Не всегда совпадает с реальным количеством из-за ограничений в железе). Каждому пальцу, находящемуся на экране, присваивается индекс и id. Индексы всегда начинаются с 0, id — не обязательно. Для понятности рассмотрим на примере.  
Первый палец опускается — ему присваивается index=0 и id=0  
Второй палец опускается — ему присваивается index=1 и id=1  
Первый палец поднимается — Второму пальцу присваивается index=0 (Индексы всегда начинаются с нуля), а id остается тем же  
Второй палец поднимается — MotionEvent'ов больше нет, вплоть до следушего прикосновения.  
Id всегда сохраняется за указателем(пальцем), так что мы всегда можем отследить какой угодно указатель.  
Когда мы разобрались с id и индексами, рассмотрим как получать свойства (координаты, величину и т. п. ) у конкретного указателя, когда их много. Для этого в классе MotionEvent существуют методы:getX(int Index)getY(int Index)getSize(int Index)и т. д., мы уже их рассматривали  
В аргумент эти методы принимают **индекс** указателя.  
Но так как индексы указателя могут меняться, а часто требуется отследить конкретный палец, то существует очень важный метод  getPointerId(int index), который позволяет по указанному индексу узнать id указателя.





 





Рассмотрим пример: перепишем наше приложение (Drag and Drop) так, чтобы оно воспринимало мультитач.  
(Важно: На эмуляторе мультитач не проверить, это можно сделать только на настоящем девайсе)  
Вот наш res/layout/main.xml  
   


   	<?xml version="1.0" encoding="utf-8"?>

   	<LinearLayout xmlns:android="schemas.android.com/apk/res/android"

       android:orientation="vertical"

       android:layout_width="fill_parent"

       android:layout_height="fill_parent"

       >

   	<com.example.multitouch.SomeView

       android:layout_width="fill_parent"

       android:layout_height="wrap_content"

      android:id="@+id/view"

      />

  	</LinearLayout> 

    
Наш Activity класс:


	package com.example.multitouch;

	import android.app.Activity;
	import android.os.Bundle;

	public class main extends Activity {

	/** Called when the activity is first created. */

	@Override

	public void onCreate(Bundle savedInstanceState) {

		super.onCreate(savedInstanceState);

		setContentView(R.layout.main);

	}

	}


А вот основной класс — SomeView:


	package com.example.multitouch;

	import android.content.Context;
	import android.graphics.Canvas;
	import android.graphics.Color;
	import android.graphics.Paint;
	import android.graphics.Paint.Style;
	import android.util.AttributeSet;
	import android.util.Log;
	import android.view.MotionEvent;
	import android.view.View;

	//Будем рисовать желтые круги под пальцами

	public class SomeView extends View {

	Paint paint;// нужен чтобы установить цвет.

	int[] X;

	int[] Y;

	final static int Radius = 20;

	int PointerCount;



	public SomeView(Context context, AttributeSet attrs) {

		super(context, attrs);

		paint = new Paint();

		paint.setColor(Color.YELLOW);

		paint.setStyle(Style.FILL);

		PointerCount = 0;

		X = new int[10];// Это будут массивы координат(будем воспринимать до 10

						// пальцев)

		Y = new int[10];

	}



	@Override

	public boolean onTouchEvent(MotionEvent event) {

		StringBuilder result = new StringBuilder(300);

		PointerCount = event.getPointerCount();

		for (int i = 0; i < PointerCount; i++) {

			int ptrId = event.getPointerId(i);

			X[i] = (int) event.getX(i);// Запоминаем координаты

			Y[i] = (int) event.getY(i);

			result.append("Pointer Index: ").append(i);

			result.append(", Pointer Id: ").append(ptrId).append("\n");

			result.append("Location: ").append(event.getX(i));

			result.append(" x ").append(event.getX(i)).append("\n");

			result.append("Pressure: ").append(event.getPressure(i));

			result.append("Size: ").append(event.getSize(i)).append("\n");

		}

		Log.v("Mytag", result.toString());// Выводим всю информацию в лог

		return true;

	}



	@Override

	protected void onDraw(Canvas canvas) {

		for (int i = 0; i < PointerCount; i++)// Смотрим сколько пальцев было на

												// экране и отрисовываем View

		{

			canvas.drawCircle(X[i], Y[i], Radius, paint);

		}

		invalidate();// invalidate() нужен для того, чтобы оповестить Android,

						// что нужно выполнить метод OnDraw снова, без него View

						// не будет перериовываться. }

	}

	}




**Другие способы взаимодействия с тачскрином**





 





Взаимодействие с экраном через MotionEvent'ы является довольно низкоуровневым, нужно это прежде всего для разработки игр. Для более узких, повседневных ситуаций в Android предусмотрен ряд интерфейсов, которые позволяют распознавать наиболее «популярные» touch event'ы:

- **OnClickListener** — onClick(View v)
- **OnFocusChangeListener** — onFocusChange(View v, boolean hasFocus)
- **OnKeyListener** — onKey(View v, int keyCode, KeyEvent event)
- **OnLongClickListener** — onLongClick(View v)
- и т. д.





 





Обрабатываются они аналогично, так что в пояснении не нуждаются.  
Больше информации о таких методах можно узнать здесь:  
[developer.android.com/reference/android/view/View.html ](http://developer.android.com/reference/android/view/View.html)





#### Для написания статьи использовались:








  * [developer.android.com](http://developer.android.com/)



  * Pro Android 2 — глава TouchScreens.






Спасибо за внимание.









Если вам понравилась статья. Прошу вас оставить комментарии и подписаться на рассылку.  
Всегда ваш, Андрей
