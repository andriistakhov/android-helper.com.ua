
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>My Octopress Blog</title>
  <meta name="author" content="Your Name">

  
  <meta name="description" content="Продолжаю серию игр для android. Владельцы смартфонов и планшетов на платформе Android могут порадоваться — для них и для их детей разрабатывают по- &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://andriistakhov.github.io/android-helper/blog/page/18">
  <link href="/android-helper/favicon.png" rel="icon">
  <link href="/android-helper/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/android-helper/atom.xml" rel="alternate" title="My Octopress Blog" type="application/atom+xml">
  <script src="/android-helper/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/android-helper/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/android-helper/">My Octopress Blog</a></h1>
  
    <h2>A blogging framework for hackers.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/android-helper/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:andriistakhov.github.io/android-helper" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/android-helper/">Blog</a></li>
  <li><a href="/android-helper/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/android-helper/blog/2012/10/11/superstar/">Модельное агентство Superstar - красивая и занимательная игра-одевалка</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-10-11T22:45:56+03:00" pubdate data-updated="true">Oct 11<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Продолжаю серию игр для android.</p>

<p>Владельцы смартфонов и планшетов на платформе Android могут порадоваться — для них и для их детей разрабатывают по-настоящему качественные и красивые приложения, которые до недавнего времени встречались в Google Play достаточно редко. Одно из них — красочная игра-одевалка для девочек «Модельное агентство Superstar».</p>

<p><img src="http://s.4pda.ru/wp-content/uploads/2012/10/device-2012-10-01-0917401-480x300.png" alt="Разработчик: " /></p>

<p><strong>Версия: </strong>1.4.0</p>

<p><strong>Русский интерфейс: </strong>Нет</p>

<p><strong>Технические требования: </strong>Android 2.3.3 и выше, поддерживаемое разрешение 1280 х 800</p>

<p><strong>Поддержка установки на SD:</strong> Нет</p>

<p><strong>Категория: </strong>Дети</p>

<p>Помните игру из детства, когда девочки вырезали из бумаги кукол и наряды для них? Высокие технологии позволяют юным модницам гораздо больше!</p>

<p><img src="http://s.4pda.ru/wp-content/uploads/2012/10/device-2012-10-01-0920311-480x300.png" alt="" /></p>

<p>Вашей дочке наверняка понравится играть с пятью очаровательными моделями: Алисой, Анной, Марией, Сашей и Викторией, гардеробу которых позавидует любая модница. Подбирая моделям наряды и аксессуары, ваша малышка будет не просто играть, она будет учиться правильно сочетать вещи и одеваться со вкусом, а это, согласитесь, для девчонок очень важно.</p>

<p><img src="http://s.4pda.ru/wp-content/uploads/2012/10/device-2012-10-01-0919321-480x300.png" alt="" /></p>

<p>Интерфейс приложения выполнен в стиле модельного подиума, на котором стоят стройняшки-модели. Всем моделям можно изменять цвет волос и губ в соответствии с требованиями юного кутюрье. Все по-настоящему!</p>

<p><img src="http://s.4pda.ru/wp-content/uploads/2012/10/device-2012-10-01-0933591-480x300.png" alt="" /></p>

<p>В приложении маленьких дизайнеров ждет более 30 самых модных нарядов: шорты, юбки, майки, пиджаки, костюмы и, конечно, мечта каждой девочки — великолепное свадебное платье! Можно одеть модель в готовый наряд, подготовленный разработчиками или подобрать совершенно оригинальный комплект — к услугам юного дизайнера более 150 предметов одежды и стильных аксессуаров. Скучно точно не будет! Кроме того, когда идеальный образ найден, можно устроить для супермодели настоящую фотосессию. Самые удачные ансамбли можно сохранить, дополнить своими рисунками и отправить подружкам по почте. У «Модельного агентства Superstar» есть все шансы стать первой ступенькой в карьере вашего маленького модного дизайнера!</p>

<p><strong>Стоимость:</strong> $1,99</p>

<p><strong>Обсуждение на 4pda:</strong> <a href="http://4pda.ru/forum/index.php?showtopic=383793">http://4pda.ru/forum/index.php?showtopic=383793</a></p>

<p><strong>Ссылка на Google Play:</strong> <a href="https://play.google.com/store/apps/details?id=ru.phonematics.superstar">https://play.google.com/store/apps/details?id=ru.phonematics.superstar</a></p>

<p><strong>Сылка на Samsung Apps:</strong> <a href="http://www.samsungapps.com/topApps/topAppsDetail.as?productId=G00005588299">http://www.samsungapps.com/topApps/topAppsDetail.as?productId=G00005588299</a></p>

<p>Статья взята из сайта <a href="http://4pda.ru/2012/10/03/73543/">4pda.ru</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/android-helper/blog/2012/10/11/ghost-adventure/">Ghost Adventure: играй и создавай свои уровни</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-10-11T22:44:24+03:00" pubdate data-updated="true">Oct 11<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Продолжаю серию игр для android.</p>

<p>Вы играете за новоиспеченного призрака, которому предстоит пройти всевозможные лабиринты, для достижения конечной цели. В игре есть возможность создавать свои уровни и делиться ими с друзьями.</p>

<p><img src="http://s.4pda.ru/wp-content/uploads/2012/10/unnamed3-287x480.jpg" alt="" /></p>

<p><strong>Версия: </strong>1.0</p>

<p><strong>Русский интерфейс: </strong>Нет</p>

<p><strong>Технические требования: </strong>Android 1.5+</p>

<p><strong>Поддержка установки на SD:</strong> Нет</p>

<p><strong>Категория:</strong> аркады и экшн</p>

<p><strong>Стоимость:</strong> Бесплатно</p>

<p><strong>Ссылка на Google Play:</strong> <a href="https://play.google.com/store/apps/details?id=ru.GhostAdventure">https://play.google.com/store/apps/details?id=ru.GhostAdventure</a></p>

<p>Статья взята из сайта <a href="http://4pda.ru/2012/10/11/74336/">4pda.ru</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/android-helper/blog/2012/10/11/water-closet/">Water Closet - Don&#8217;t Be a Pig: поход в уборную ещё никогда не был так увлекателен</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-10-11T22:43:11+03:00" pubdate data-updated="true">Oct 11<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Продолжаю серию игр для android.</p>

<p>Каждый человек, посещает туалет. Но поход в уборную ещё никогда не был так увлекателен! Но не думайте, что это будет очень просто. Придется значительно постараться, чтобы не стать свиньей и не описать все вокруг.</p>

<p><img src="http://s.4pda.ru/wp-content/uploads/2012/10/recommend3-480x234.jpg" alt="Разработчик: Мой первый проект под adnroid" /></p>

<p><strong>Версия:</strong> 1.0</p>

<p><strong>Русский интерфейс:</strong> Нет</p>

<p><strong>Технические требования:</strong> android 2.0.1 +</p>

<p><strong>Поддержка установки на SD:</strong> Да</p>

<p><strong>Категория:</strong> Аркады и экшн</p>

<p>Наконец-то закончил свой первый проект под android! В игре необходимо писать в туалет как можно точнее, при этом на уровнях происходят различные мешающие факторы, такие как закрывание крышки, поломка туалета, выключение света. К тому же, камера игрока трясётся с силой, увеличивающейся прямо пропорционально долготе попадания в туалет без промаха. Игру решил сделать в двух версиях: бесплатная демка с рекламой и 1 уровнем и полная версия, включающая в себя 25 уровней и 5 различных локаций, естественно она без рекламы. С внутри-игровыми покупками, пока что не разобрался, так что они отсутствуют. Зато есть &ldquo;накопительный&rdquo; момент &ndash; если убивать золотых мух, летающих на уровнях, то открываются различные вспомогательные бонусы.</p>

<p>Игру не делал на русском языке, так как все знают, что в России не так много людей, готовых платить за игры, хотя и цену установил минимальную в 1$.</p>

<p><strong>Стоимость:</strong> 1$</p>

<p><strong>Ссылка на Google Play:</strong> <a href="https://play.google.com/store/apps/details?id=com.SmileApps.WCfull">https://play.google.com/store/apps/details?id=com.SmileApps.WCfull</a></p>

<p><img src="http://s.4pda.ru/wp-content/uploads/2012/10/unnamed4-287x480.jpg" alt="" />
<img src="http://s.4pda.ru/wp-content/uploads/2012/10/scrin4-288x480.jpg" alt="" /></p>

<p>Статья взята из сайта <a href="http://4pda.ru/2012/10/11/74342/">4pda.ru</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/android-helper/blog/2012/10/11/games_65456/">Классический Сапёр из Windows - ностальгия по прошлому</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-10-11T22:34:18+03:00" pubdate data-updated="true">Oct 11<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Начинаю собирать игры для android.</p>

<p>Если у кого есть и хотите поделится пишите, буду рад добавить на блог.</p>

<p>Игра написана специально для тех, кто скучает по старым-добрым временам и провёл не один час за этой простой, но вместе с тем затягивающей игрой. Игра визуально максимально приближена к оригиналу.</p>

<p>Цель игры состоит в том, чтобы как можно быстрее найти все мины на минном поле, не вскрыв ни одну из них. Игрок открывает ячейки, стараясь не открыть ячейку с миной. Открыв ячейку с миной, он проигрывает. Если под открытой ячейкой мины нет, то в ней появляется число, показывающее, сколько ячеек, соседствующих с только что открытой, «заминировано»; используя эти числа, игрок пытается рассчитать расположение мин, однако иногда даже в середине и в конце игры некоторые ячейки всё же приходится открывать наугад.</p>

<p><img src="http://s.4pda.ru/wp-content/uploads/2012/10/unnamed2.jpg" alt="" /></p>

<p><strong>Версия: </strong>1.4</p>

<p><strong>Русский интерфейс: </strong>Да</p>

<p><strong>Технические требования: </strong>Android 2.0.1+</p>

<p><strong>Поддержка установки на SD:</strong> Да</p>

<p><strong>Категория: </strong>Головоломки</p>

<p>Открыв все «незаминированные» ячейки, игрок выигрывает.</p>

<ul>
<li><p>Игрок имеет возможность открыть любую ячейку простым нажатием на неё. Если ячейка содержит мину, вы проиграли.</p></li>
<li><p>Если мины нет, в ячейке появится цифра, которая указывает, сколько мин находится в восьми смежных с ней ячейках.</p></li>
<li><p>Чтобы пометить ячейку, в которой по вашему мнению находится мина, нажмите на неё длинным нажатием.</p></li>
<li><p>Игровое поле состоит из счетчика мин, секундомера и минного поля.</p></li>
</ul>


<p>Размер игровых ячеек меняется кнопками громкости, либо при помощи специальных пунктов в меню.</p>

<p><strong>__</strong><strong>Стоимость:</strong> Содержит рекламу****</p>

<p><strong>Ссылка на Google Play:</strong> <a href="https://play.google.com/store/apps/details?id=biz.toway.games.minesweeper">https://play.google.com/store/apps/details?id=biz.toway.games.minesweeper</a></p>

<p><img src="http://s.4pda.ru/wp-content/uploads/2012/10/qr-code.gif" alt="" /></p>

<p>Статья взята из сайта <a href="http://4pda.ru/2012/10/10/74177/">4pda.ru</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/android-helper/blog/2012/10/11/activity-lifecycle/">Activity Lifecycle. В каких состояниях может быть Activity</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-10-11T12:41:17+03:00" pubdate data-updated="true">Oct 11<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Многие меня спрашивают.</p>

<p>Что когда нужно вызывать в Activity. И когда вызываются разные методы.</p>

<p>И мне попалась интересная статья.</p>

<p>Лично для себя я читал официальную статью. Аналогов на русской тогда не было.</p>

<p>И так прошу к прочтению.</p>

<h3>Теория</h3>

<p>При работе приложения, мы <strong>создаем</strong> новые <strong>Activity</strong> и <strong>закрываем</strong> старые, <strong>сворачиваем</strong> приложение, снова <strong>открываем</strong> и т.д. Activity умеет обрабатывать все эти движения. Это необходимо, например, для освобождения ресурсов или сохранения данных. В <a href="http://developer.android.com/guide/topics/fundamentals/activities.html#Lifecycle">хелпе</a> достаточно подробно это описано.</p>

<p>Созданное при работе приложения <strong>Activity </strong>может быть в одном из <strong>трех состояний</strong>:</p>

<p><strong>Resumed</strong>&ndash; Activity видно на экране, оно находится в фокусе, пользователь может с ним взаимодействовать. Это состояние также иногда называют Running.<br/>
<strong>Paused</strong>&ndash; Activity не в фокусе, пользователь не может с ним взаимодействовать, но его видно (оно перекрыто другим Activity, которое занимает не весь экран или полупрозрачно).<br/>
<strong>Stopped</strong>&ndash; Activity не видно (полностью перекрывается другим Activity), соответственно оно не в фокусе и пользователь не может с ним взаимодействовать.</p>

<p>Когда Activity переходит из одного <strong>состояния</strong> в другое, система вызывает различные его <strong>методы</strong>, которые мы можем заполнять своим кодом. Схематично это можно изобразить так:</p>

<p><img src="http://android-helper.com.ua/wp-content/uploads/2012/10/20111005_L0023_L_StatesSchema.jpg" alt="" /></p>

<p>Для упрощения понимания я дал краткое описание состояний в скобках под названиями. А крестом обозначил отсутствие Activity.</p>

<p>Итак, мы имеем следующие методы Activity, которые вызывает система:</p>

<p><strong>onCreate</strong>() – вызывается при первом создании Activity<br/>
<strong>onStart</strong>() – вызывается перед тем, как Activity будет видно пользователю<br/>
<strong>onResume</strong>() – вызывается перед тем как будет доступно для активности пользователя (взаимодействие)</p>

<p><strong>onPause</strong>() – вызывается перед тем, как будет показано другое Activity<br/>
<strong>onStop</strong>() – вызывается когда Activity становится не видно пользователю<br/>
<strong>onDestroy</strong>() – вызывается перед тем, как Activity будет уничтожено</p>

<p>Т.е. эти методы <strong>НЕ</strong> вызывают смену состояния. Наоборот, смена состояния Activity является триггером, который вызывает эти методы. Тем самым нас уведомляют о смене, и мы можем реагировать соответственно. Посмотрим на практике, когда и в каком порядке вызываются эти методы.</p>

<h3> </h3>

<h3>Практика</h3>

<p>В этом уроке нам надо будет эмулировать событие смены ориентации экрана. Но эмулятор с Android 2.3 делает это криво, поэтому в проекте будем использовать версию 2.2. Для этого надо <a href="http://startandroid.ru/uroki/vse-uroki-spiskom/12-urok-3-sozdanie-avd-pervoe-prilozhenie-struktura-android-proekta.html">создать</a> новое AVD по версии 2.2 </p>

<p><img src="http://android-helper.com.ua/wp-content/uploads/2012/10/20111005_L0023_L_AVD22.jpg" alt="" /></p>

<p>Создадим проект (обратите внимание, используем Android 2.2.):</p>

<p><strong>Project name</strong>: P0231_OneActivityState<br/>
<strong>Build Target</strong>: Android 2.2<br/>
<strong>Application name</strong>: OneActivityState<br/>
<strong>Package name</strong>: ru.startandroid.develop.p0231oneactivitystate<br/>
<strong>Create Activity</strong>: MainActivity</p>

<p>Layout не меняем, нам он сейчас не важен.</p>

<pre><code>import android.app.Activity;

import android.os.Bundle;

import android.util.Log;



public class MainActivity extends Activity {



final String TAG = "States";



/** Called when the activity is first created. */

@Override

public void onCreate(Bundle savedInstanceState) {

    super.onCreate(savedInstanceState);

    setContentView(R.layout.main);

    Log.d(TAG, "MainActivity: onCreate()");

}



@Override

protected void onStart() {

    super.onStart();

    Log.d(TAG, "MainActivity: onStart()");

}



@Override

protected void onResume() {

    super.onResume();

    Log.d(TAG, "MainActivity: onResume()");

}



@Override

protected void onPause() {

    super.onPause();

    Log.d(TAG, "MainActivity: onPause()");

}



@Override

protected void onStop() {

    super.onStop();

    Log.d(TAG, "MainActivity: onStop()");

}



@Override

protected void onDestroy() {

    super.onDestroy();

    Log.d(TAG, "MainActivity: onDestroy()");

}

}
</code></pre>

<p>Добавим все остальные <strong>методы</strong> из схемы, и в каждый добавим запись в <strong>лог</strong>.</p>

<p>В каментах подсказали важное замечание! При реализации этих методов обязательно вызывайте соответствующие методы супер-класса и обязательно перед вашим кодом. См. код выше. Каждый метод содержит вызов метода супер-класса и свой код расположен после этих вызовов.</p>

<p>Все сохраним и запустим приложение. После того, как запустилось, смотрим лог:</p>

<p><em>MainActivity: onCreate()<br/>
MainActivity: onStart()<br/>
MainActivity: onResume()</em></p>

<p>Activity создалось, прошло два состояния (Stopped, Paused) и теперь находится в третьем состоянии &ndash; Resumed. Т.е. оно создалось (onCreate), отобразилось (onStart) и получило возможность взаимодействовать с пользователем (onResume).</p>

<p>Теперь нажмем кнопку Back на эмуляторе. Activity закрылось. Смотрим лог:</p>

<p><em>MainActivity: onPause()<br/>
MainActivity: onStop()<br/>
MainActivity: onDestroy()</em></p>

<p>Activity проделывает путь, обратный созданию. Сначала теряет фокус (onPaused), затем исчезает с экрана (onStop), затем полностью уничтожается (onDestroy).</p>

<h3> </h3>

<h3>Смена ориентации экрана</h3>

<p>Посмотрим, как ведет себя Activity, когда происходит смена ориентации экрана. Запустите снова приложение (либо найдите его в списке приложений в системе на эмуляторе, либо снова нажмите CTRL+F11 в Eclipse ). В логах снова отобразились три метода, вызванные при создании. Теперь в эмуляторе нажмите CTRL+F12, ориентация сменилась. Кажется, что ничего особенного не произошло, но смотрим логи и видим:</p>

<p><em>MainActivity: onPause()<br/>
MainActivity: onStop()<br/>
MainActivity: onDestroy()<br/>
MainActivity: onCreate()<br/>
MainActivity: onStart()<br/>
MainActivity: onResume()</em></p>

<p>Activity полностью уничтожается и снова создается. При этом обычно выполняются процедуры сохранения и восстановления данных, чтобы не потерялись данные, и приложение сохранило свой вид. Про то, как это делается, мы будем говорить в последующих уроках.</p>

<p>Также есть еще метод <strong>onRestart</strong>. Он вызывается перед методом <strong>onStart</strong>, если Activity не создается с нуля, а восстанавливается из состояния <strong>Stoped</strong>. Его мы рассмотрим в следующем уроке.</p>

<p>Обычно в учебниках эта тема дается по-другому. Но мне это шаблонное объяснение кажется недостаточно понятным, поэтому я написал свое. Как всегда, надеюсь, что у меня получилось раскрыть тему )</p>

<p>Советую вам после этого урока прочитать хелп, ссылку на который я дал в самом начале урока. Там все очень хорошо написано. И знания лучше усвоятся. Пока что, главное – это понять в какой момент, какой метод вызывается. А уже дальше мы будем разбираться, как это можно использовать и что там кодить.</p>

<p>Статья взята из сайта <a href="http://startandroid.ru/">startandroid.ru</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/android-helper/blog/2012/10/11/soap-rest-android/">SOAP и REST Web-сервиса в Android</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-10-11T11:14:09+03:00" pubdate data-updated="true">Oct 11<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Добрый день друзья.</p>

<p>Продолжаю собирать важную информацию по программированию под android.</p>

<p>Сегодня речь пойдет о SOAP и REST запросах.</p>

<p>Одной из задач, часто решаемых разработчиками мобильного софта, является получение данных от удаленного <strong>web сервиса</strong>. Этот процесс включает в себя несколько этапов: отправка запрос web-сервису, получение ответа и парсинг ответа с целью получения данных. В Android нет встроенного SOAP клиента, однако существует несколько довольно неплохих сторонних библиотек. Мы не будем пользоваться чужими поделками, а разработаем собственный клиент на базе Android API.</p>

<p><em><strong>SOAP </strong>(Simple Object Access Protocol) это основанный на XML протокол, предназначенный для обмена данными между распределенными приложениями.  <strong>REST </strong>(Representational State Transfer)&ndash; архитектура позволяющая строить распределенные, масштабируемые приложения. Основная задача сервера в этой архитектуре предоставить клиентам доступ к ресурсам по их идентификаторам (URI). Под доступом подразумевается как получение информации, так и ее изменение. SOAP и REST строятся поверх существующих web протоколов, например HTTP. Я не буду здесь вдаваться в детали, если Вы не знакомы с темой, рекомендую посмотреть вот эту <a href="http://habrahabr.ru/blogs/webdev/131343/">статью</a>.</em></p>

<h3>Формат запроса для SOAP сервису</h3>

<p>Прежде чем переходить к написанию кода, давайте посмотрим на структуру SOAP.</p>

<p><img src="http://android-helper.com.ua/wp-content/uploads/2012/10/soap_structure.png" alt="" /></p>

<p>Обычный<strong> SOAP запрос</strong> выглядит так:</p>

<pre><code>POST /InStock HTTP/1.1

Host: www.example.org

Content-Type: application/soap+xml; charset=utf-8

Content-Length: length

SOAPAction: "http://www.w3schools.com/GetItems"



&lt;?xml version="1.0"?&gt;

&lt;soap:Envelope

xmlns:soap="http://www.w3.org/2001/12/soap-envelope"

soap:encodingStyle="http://www.w3.org/2001/12/soap-encoding"&gt;

&lt;soap:Header&gt;

&lt;m:Trans xmlns:m="http://www.w3schools.com/transaction/"

soap:mustUnderstand="1"&gt;234

  &lt;/m:Trans&gt;

&lt;/soap:Header&gt;

&lt;soap:Body&gt;

&lt;m:GetPrice xmlns:m="http://www.w3schools.com/prices"&gt;

    &lt;m:Item&gt;Apples&lt;/m:Item&gt;

  &lt;/m:GetPrice&gt;

&lt;/soap:Body&gt;&lt;/soap:Envelope&gt;
</code></pre>

<p>То есть SOAP запрос/ответ передается как пакет (SOAP Envelope), состоящий из заголовка (SOAP Header) и тела (SOAP Body).<strong>SOAP Header</strong> - вспомогательный  компонент, содержащий конфиденциальную информацию для приложения, например параметры  аутентификации. <strong>SOAP Body</strong> - это сообщение с полезной информацией. Заголовок может также содержать<strong> SOAP Action</strong>, который определяет функцию, запрашиваемую сервисом.</p>

<h3>Отправка запроса SOAP-сервису</h3>

<p>Чтобы вызвать SOAP-сервис вы должны сделать две вещи:<br/>
<strong>Во-первых</strong>, вручную сконструировать SOAP пакет, например вот так:</p>

<pre><code>String envelope="&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;"+

"&lt;soap:Envelope xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\"xmlns:soap=\"http://schemas.xmlsoap.org/soap/envelope/\"&gt;"+

"&lt;soap:Body&gt;"+

"&lt;GetItems xmlns=\"http://tempuri.org/\"&gt;"+

  "&lt;startDate&gt;%s&lt;/ startDate&gt;"+

  "&lt;getAll&gt;%s&lt;/getAll&gt;"+

"&lt;/Items&gt;"+

"&lt;/soap:Body&gt;"+

"&lt;/soap:Envelope&gt;";
</code></pre>

<p>где %s метка формата. С помощью метода String.format на ее место  будет подставляться конкретное значение.</p>

<pre><code>String requestEnvelope=String.format(envelope, "10-5-2011","true");
</code></pre>

<p><strong>Во-вторых</strong>, вызвать web-сервис, например так:</p>

<pre><code>String CallWebService(String url,

String soapAction,

String envelope)  {

final DefaultHttpClient httpClient=new DefaultHttpClient();

  // параметры запроса

  HttpParams params = httpClient.getParams();

 HttpConnectionParams.setConnectionTimeout(params, 10000);

 HttpConnectionParams.setSoTimeout(params, 15000);

 // устанавливаем параметры

HttpProtocolParams.setUseExpectContinue(httpClient.getParams(), true);



// С помощью метода POST отправляем конверт

HttpPost httppost = new HttpPost(url);

// и заголовки

 httppost.setHeader("soapaction", soapAction);

 httppost.setHeader("Content-Type", "text/xml; charset=utf-8");



 String responseString="";

 try {



  // выполняем запрос

HttpEntity entity = new StringEntity(envelope);

httppost.setEntity(entity);



// Заголоаок запроса

ResponseHandler&lt;string&gt; rh=new ResponseHandler&lt;string&gt;() {

// вызывается, когда клиент пришлет ответ

public String handleResponse(HttpResponse response)

  throws ClientProtocolException, IOException {



 // получаем ответ

 HttpEntity entity = response.getEntity();



 // читаем его в массив

       StringBuffer out = new StringBuffer();

       byte[] b = EntityUtils.toByteArray(entity);



       // write the response byte array to a string buffer

       out.append(new String(b, 0, b.length));

       return out.toString();

}

};



responseString=httpClient.execute(httppost, rh); 



}

 catch (Exception e) {

  Log.v("exception", e.toString());

}



 // закрываем соединение

httpClient.getConnectionManager().shutdown();

return responseString;

    }
</code></pre>

<p>После вызова этой функции Вы получите ответ, который будет выглядеть как-то так:</p>

<pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;

&lt;soap:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/"&gt;

&lt;soap:Body&gt;

    &lt;GetItemsResponse xmlns="http://tempuri.org/"&gt;

     &lt;GetItemsResult&gt;



    &lt;Items&gt;

      &lt;Item&gt;

        &lt;name&gt;string&lt;/name&gt;

        &lt;description&gt;string&lt;/ description &gt;

      &lt;/iPhoneCategory&gt;

      &lt;iPhoneCategory&gt;

        &lt;name&gt;string&lt;/name&gt;

        &lt;description&gt;string&lt;/ description &gt;

      &lt;/ Item &gt;

    &lt;/Items&gt;

    &lt;/GetItemsResult&gt;

    &lt;/ GetItemsResponse &gt;

&lt;/soap:Body&gt;

&lt;/soap:Envelope&gt;
</code></pre>

<p>Этот ответ нужно разобрать XML парсером и извлечь нужные данные.</p>

<h3>Отправка запроса REST-сервису</h3>

<p>Расбота с REST-сервисом намного проще. Вы должны вызвать сервис, передав ему URL с параметрами, например вот так:</p>

<pre><code>http://example.com/resources/getitems  
</code></pre>

<p>Пример вызова REST сервиса:</p>

<pre><code>String callWebErvice(String serviceURL){

    // http get client

        HttpClient client=new DefaultHttpClient();

        HttpGet getRequest=new HttpGet();



        try {

            // создаем a URI объект

            getRequest.setURI(new URI(serviceURL));

        } catch (URISyntaxException e) {

            Log.e("URISyntaxException", e.toString());

        }



        // Создаем BufferedReader дял чтения ответа

        BufferedReader in=null;

        // и HttpResponse для получения ответа

        HttpResponse response=null;

        try {

            // выполняем запрос

            response = client.execute(getRequest);

        } catch (ClientProtocolException e) {

            Log.e("ClientProtocolException", e.toString());

        } catch (IOException e) {

            Log.e("IO exception", e.toString());

        }

        try {

            in=new BufferedReader(new InputStreamReader(response.getEntity().getContent()));

        } catch (IllegalStateException e) {

            Log.e("IllegalStateException", e.toString());

        } catch (IOException e) {

            Log.e("IO exception", e.toString());

        }

        StringBuffer buff=new StringBuffer("");

        String line="";

        try {

            while((line=in.readLine())!=null)

            {

                buff.append(line);

            }

        } catch (IOException e) {

            Log.e("IO exception", e.toString());

            return e.getMessage();

        }



        try {

            in.close();

        } catch (IOException e) {

            Log.e("IO exception", e.toString());

        }

        // возвращаем ответ в виде строки текста

        return buff.toString();

}
</code></pre>

<p>Соединение с web-сервисом по протоколу Secure Sockets Layer (SSL)</p>

<p>HttpClinet не поддерживает SSL соединения, поэтому если Вам необходимо работать с защищенным web-сервисом, то используйте  javax.net.ssl.HttpsURLConnection. Ниже приведен пример, иллюстрирующий работу с SSL SOAP web-сервисом.</p>

<pre><code>String CallWebService(String url,

         String soapAction,

        String envelope) throws IOException  {

    URL address=new URL(url);

    URLConnection connection=address.openConnection();

    HttpsURLConnection post=(HttpsURLConnection)connection;

    post.setDoInput(true);

    post.setDoOutput(true);

    post.setRequestMethod("POST");

    post.setRequestProperty("SOAPAction", soapAction);

    post.setRequestProperty( "Content-type", "text/xml; charset=utf-8" );

    post.setRequestProperty( "Content-Length", String.valueOf(envelope.length()));

    post.setReadTimeout(4000);



    OutputStream outStream=post.getOutputStream();

    Writer out=new OutputStreamWriter(outStream);

    out.write(envelope);

    out.flush();

    out.close();



    InputStream inStream = post.getInputStream();

    BufferedInputStream in = new BufferedInputStream(inStream,4);

    StringBuffer buffer=new StringBuffer();

    // читаем за раз 4 байта

    byte[] buffArray=new byte[4];

    int c=0;

        while((c=in.read(buffArray))!=-1){

            for(int i=0;i&lt;c;i++)

                buffer.append((char)buffArray[i]);

        }



        return buffer.toString();

}
</code></pre>

<p>Итак, мы отправили запрос web-сервису и получили ответ в виде строки. Настало время использовать парсер.</p>

<h3>Использование парсера в Android</h3>

<p>В зависимости от реализации сервиса в ответ на наш запрос может прийти ответ в формате XML, SOAP или JSON.</p>

<h4>Программирование XML парсера в Android</h4>

<p>Рассмотрим конкретный пример. Допустим, нам пришел XML ответ, содержащий имя, фамилию и возраст пользователя:</p>

<pre><code>&lt;?xml version="1.0"?&gt;

&lt;person&gt;

&lt;firstname&gt;Jack&lt;/firstname&gt;

&lt;lastname&gt;smith&lt;/lastname&gt;

&lt;age&gt;28&lt;/age&gt;

&lt;/person&gt;
</code></pre>

<p>С помощью этих параметров нужно создать объект класса Person:</p>

<pre><code>public class Person{

    public String firstName;

    public String lastName;

    public int age;

}
</code></pre>

<h3>Использование DOM Parser</h3>

<p>В библиотека <strong>org.w3c.dom</strong> можно найти классы, с помощью которых можно разобрать xml, создав документ и сравнив каждый узел с шаблоном. Приведенная ниже функция использует DOM парсер:</p>

<pre><code>void parseByDOM(String response) throws     ParserConfigurationException, SAXException, IOException{

    Person person=new Person();

    DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();

    DocumentBuilder db = dbf.newDocumentBuilder();

    Document doc = db.parse(new InputSource(new StringReader(response)));

    // нормализируем документ

    doc.getDocumentElement().normalize();

    // получаем корневой узел

    NodeList nodeList = doc.getElementsByTagName("person");

    Node node=nodeList.item(0);

    // узел имеет три дочерних узла

    for (int i = 0; i &lt; node.getChildNodes().getLength(); i++) {

    Node temp=node.getChildNodes().item(i);

    if(temp.getNodeName().equalsIgnoreCase("firstname")){

        person.firstName=temp.getTextContent();

    }

    else if(temp.getNodeName().equalsIgnoreCase("lastname")){

        person.lastName=temp.getTextContent();

    }

    else if(temp.getNodeName().equalsIgnoreCase("age")){

        person.age=Integer.parseInt(temp.getTextContent());

    }



    }



    Log.e("person", person.firstName+ " "+person.lastName+" "+String.valueOf(person.age));

}
</code></pre>

<p>Показаный метод работает, однако для его использования нужно знать структуру разбираемого xml и порядок перечисления узлов. Более гибок в этом плане SAX парсер.<br/>
 </p>

<h3> Использование SAX Parser</h3>

<p>SAX Parser находится в пакете <strong>org.xml.sax</strong>. В процессе разбора документа SAX генерирует события, для которых программист должен написать обработчики. Создадим класс-потомок основе класса <strong>DefaultHandler </strong>и переопределим следующие методы:<br/>
 </p>

<ul>
<li><p><strong>startDocument()</strong>: Этот метод вызывается при открытии XML документа.</p></li>
<li><p><strong>startElement(String uri, String localName, String qName, Attributes attributes)</strong>: вызывается, когда парсер встречает XML-узел.</p></li>
<li><p><strong>endElement(String uri, String localName, String Name)</strong>: вызывается, когда парсер считал закрывающий тег.</p></li>
<li><p><strong>characters(char[] ch, int start, int length)</strong>: этот метод вызывается, когда парсер считывает данные из узла.</p></li>
</ul>


<p>Напишем класс для парсинга нашего примера</p>

<pre><code>public class PersonParser extends DefaultHandler

{



// arraylist для сохранения объектов persons

ArrayList persons;

// вспомогательный объект

Person tempPerson;

// буфер

StringBuilder builder;



/**

 * Инициализируем arraylist

 * @throws SAXException

 */

@Override

public void startDocument() throws SAXException {

    pesons=new ArrayList();



}



/**

 * Инициализируем вспомогательный объект и буфер 

 * @param uri

 * @param localName

 * @param qName

 * @param attributes

 * @throws SAXException

 */

@Override

public void startElement(String uri, String localName, String qName,

        Attributes attributes) throws SAXException {



    if(localName.equalsIgnoreCase.equals("person")){

        tempPerson=new Person();

        builder=new StringBuilder();

    }



}

/**

 * Завершение чтения тега person и

 * добавление данных в arraylist

 * @param uri

 * @param localName

 * @param qName

 * @throws SAXException

 */

@Override

public void endElement(String uri, String localName, String qName)

        throws SAXException {

    // закончилось чтение person, добавим собранные данные в массив

    if(localName.toLowerCase().equals("person"))

    {

        this.persons.add(tempPerson);

    }

    // закончилось чтение  "firstname", добавим эти данные во вспомогательный объект

    else if(localName.toLowerCase().equals("firstname")){

        tempPerson.firstName=builder.toString();

    }

    // закончилось чтение  "lastname", добавим эти данные во вспомогательный объект

    else if(localName.toLowerCase().equals("lastname")){

        tempPerson.lastName=builder.toString();

    }

    // закончилось чтение  "age", добавим эти данные во вспомогательный объект

    else if(localName.toLowerCase().equals("age")){

        tempPerson.age=Integer.parseInt(builder.toString());

    }

}



/**

 * Считываем данные из каждого тега

 * @param ch

 * @param start

 * @param length

 * @throws SAXException

 */

@Override

public void characters(char[] ch, int start, int length)

        throws SAXException {

    // читаем символы в буфер

    String tempString=new String(ch, start, length);

     builder.append(tempString);

}

}
</code></pre>

<p>Код довольно прост. Парсер проходится по всем узлам, и в зависимости от считанного тега, вы выполняете то или иное действие. Используем этот класс:</p>

<pre><code>public ArrayList getPersons(final String response) throws 

ParserConfigurationException, SAXException, IOException

{

    BufferedReader br=new BufferedReader(new StringReader(response));

    InputSource is=new InputSource(br);

    PersonParser parser=new PersonParser();

    SAXParserFactory factory=SAXParserFactory.newInstance();

       SAXParser sp=factory.newSAXParser();

       XMLReader reader=sp.getXMLReader();

       reader.setContentHandler(parser);

       reader.parse(is);

       ArrayList persons=parser.persons;



    return persons;



}
</code></pre>

<h3>Программирование JSON парсера в Android</h3>

<p>Некоторые сервисы могут вернуть ответ не в виде XML, а как JSON массив:</p>

<pre><code>"persons"

[

{

    "person"{

        "firstName": "John",

    "lastName": "Smith",

    "age": 25

    }

}

{

    "person"{

        "firstName": "Catherine",

    "lastName": "Jones",

    "age": 35

    }

}

]
</code></pre>

<p>Здесь мы видим JSON массив persons, содержащий несколько JSON объектов person. На самом деле, работать с JSON намного проще, чем с XML:</p>

<pre><code>public ArrayList&lt;Person&gt; getMessage(String response){

    JSONObject jsonResponse;

    ArrayList&lt;Person&gt; arrPersons=new ArrayList&lt;Person&gt;;

    try {

        // получаем ответ

        jsonResponse = new JSONObject(response);

        // получаем массив

        JSONArray persons=jsonResponse.optJSONArray("persons");

        // проходимся по массиву и извлекаем персоны

        for(int i=0;i&lt;persons.length();i++){

            // получаем объект person

            JSONObject person=persons.getJSONObject(i);

            // получаем firstname

            String firstname=person.optString("firstname");

            // получаем lastname

            String lastname=person.optString("lastname");

            // получаем age

            int age=person.optInt("age");



            // создаем объект и добавляем его в массив

            Person p=new Person();

            p.firstName=firstname;

            p.lastName=lastname;

            p.age=age;

            arrPersons.add(p);

        }



    } catch (JSONException e) {



        e.printStackTrace();

    }



    return arrPersons;

}    
</code></pre>

<p>Обратите внимание, здесь мы использовали методы optJSONArray, optString, optInt вместо getString, getInt, поскольку opt-методы эти методы возвращают пустую строку или 0, если какой-то элемент не найден, в то время как get-методы генерируют исключения.</p>

<p>Источник статьи <a href="http://www.mobilab.ru/androiddev/androidwebserviceclient.html">mobilab.ru</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/android-helper/blog/2012/10/10/speak-android/">Распознавание и генерация речи в Android</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-10-10T22:52:24+03:00" pubdate data-updated="true">Oct 10<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Столкнулся с необходимостью распознавать речь на android устройстве.</p>

<p>Долго собирал крупицы информации, пока не нашел хорошею и полною статью</p>

<p>Прошу к прочтению.</p>

<p>Последнее время большой интерес у пользователей вызывает возможность распознавания речи в телефонах. Огромная заслуга в популяризации этого направления принадлежит компании Aple, однако Google также располагает подобными технологиями. Собственно этой теме и будет посвящена данная статья. Мы разработаем приложение, которое будет распознавать речь пользователя и воспроизводить результат с помощью голосового движка &ldquo;Text To Speech&rdquo; (TTS). Отметим, что распознавание происходит на серверах Google, поэтому для работы приложению необходимо разрешить использовать коммуникационные возможности. Кроме того, распознавание речи не работает на эмуляторе. Тестировать программу необходимо на реальном устройстве.</p>

<p>На самом деле работать с распознаванием и синтезом речи в Android очень просто. Все сложные вычисления скрыты от нас в довольно элегантную библиотеку с простым API. Вы сможете осилить этот урок, даже если имеете весьма поверхностные знания о программировании для Android.</p>

<p>Давайте создадим новый проект в Eclipse. Для наших нужд понадобится версия SDK не меньше 8. Опишем в общих чертах создаваемую программу. При запуске приложения пользователю будет показана кнопка, после нажатия на которую пользователю будет предложено надиктовать фразу. Затем будет осуществлено распознавание и будет показан список возможных вариантов. Поскольку технологии распознавания речи далеки от совершенства, программа не может ручаться за точность результата, именно поэтому будет предложено несколько вариантов. После того, как пользователь выберет один из них, будет запущен генератор голоса, который воспроизведет выбранную фразу. </p>

<p>Нам понадобится несколько текстовых строк, объявим их в фале &ldquo;res/values/strings.xml&rdquo;</p>

<pre><code>&lt;resources&gt;

&lt;string name="intro"&gt;Press the button to speak!&lt;/string&gt;

&lt;string name="app_name"&gt;SpeechRepeat&lt;/string&gt;

&lt;string name="speech"&gt;Speak now!&lt;/string&gt;

&lt;string name="word_intro"&gt;Suggested words&amp;#8230;&lt;/string&gt;

&lt;/resources&gt;
</code></pre>

<p>Откроем файл &ldquo;res/layout/main.xml&rdquo; и зададим шаблон дизайна приложения. Для этого переключимся из графического в XML редактор и изменим содержимое файла</p>

<pre><code>&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"

android:layout_width="fill_parent"

android:layout_height="fill_parent"

android:orientation="vertical"

android:background="#ff330066"

android:paddingBottom="5dp" &gt;



&lt;/LinearLayout&gt;
</code></pre>

<p>Добавим в Linear Layout элемент Text View</p>

<pre><code>&lt;TextView android:layout_width="fill_parent"

android:layout_height="wrap_content"

android:text="@string/intro"

android:padding="5dp"

android:textStyle="bold"

android:textSize="16dp"

android:gravity="center"

android:textColor="#ffffff33" /&gt;
</code></pre>

<p>обратите внимание, TextView ссылается на строку intro, которую мы задали в файле strings.xml. </p>

<p>После Text View добавим кнопку</p>

<pre><code>&lt;Button android:id="@+id/speech_btn"

android:layout_width="match_parent"

android:layout_height="wrap_content"

android:text="@string/speech" /&gt;
</code></pre>

<p>Пользователь будет нажимать эту кнопку, чтобы начать говорить. Кнопка имеет параметр id, через который ее можно вызвать из Java кода. После нажатия на кнопку пользователю показывается сообщение. Нам также понадобится TextView для вывода слов с предложениями</p>

<pre><code>&lt;TextView android:layout_width="fill_parent"

android:layout_height="wrap_content"

android:padding="5dp"

android:text="@string/word_intro"

android:textStyle="italic" /&gt;
</code></pre>

<p>TextView будет использовать строковый ресурс. Нам также понадобится список для вариантов слов</p>

<pre><code>&lt;ListView android:id="@+id/word_list"

android:layout_width="fill_parent"

android:layout_height="0dip"

android:layout_weight="1"

android:paddingLeft="10dp"

android:paddingTop="3dp"

android:paddingRight="10dp"

android:paddingBottom="3dp"

android:layout_marginLeft="20dp"

android:layout_marginRight="20dp"

android:layout_marginTop="5dp"

android:layout_marginBottom="5dp"

android:background="@drawable/words_bg" /&gt;
</code></pre>

<p>ListView будет заполняться данными в процессе работы программы, поэтому для доступа к этому компоненту также требуется ID. Обратите также внимание на наличие ресурса drawable. Вы должны сохранить файл words_bg.xml в папке res</p>

<pre><code>&lt;shape xmlns:android="http://schemas.android.com/apk/res/android"

android:dither="true"&gt;

&lt;gradient

android:startColor="#ff000000"

android:endColor="#ff000000"

android:centerColor="#00000000"

android:angle="180" /&gt;

&lt;corners android:radius="10dp" /&gt;

&lt;stroke

android:width="2dp"

android:color="#66ffffff" /&gt;

&lt;/shape&gt; 
</code></pre>

<p>Ничего особенного. Вы можете настроить дизайн ListView по своему усмотрению. Нам осталось задать еще один элемент пользовательского интерфейса &ndash; шаблон для элемента ListView. Создайте новый файл res/layout/word.xml со следующим содержанием</p>

<pre><code>&lt;TextView xmlns:android="http://schemas.android.com/apk/res/android"

android:layout_width="fill_parent"

android:layout_height="fill_parent"

android:gravity="center"

android:padding="5dp"

android:textColor="#ffffffff"

android:textSize="16dp" &gt;

&lt;/TextView&gt;
</code></pre>

<p>Таким образом, каждый элемент списка представляет собой просто Text View.</p>

<p>Если Вы все сделали правильно, то при запуске должно получиться следующее</p>

<p><img src="http://android-helper.com.ua/wp-content/uploads/2012/10/speechsample1.jpg" alt="" /></p>

<h3>Программируем распознавание речи в Android</h3>

<p>После того, как шаблон будущего приложения создан, можно перейти к кодированию. Откройте java файл главной Activity и добавьте в начало файла</p>

<pre><code>import java.util.ArrayList;

import java.util.List;

import java.util.Locale;



import android.app.Activity;

import android.content.Intent;

import android.content.pm.PackageManager;

import android.content.pm.ResolveInfo;

import android.os.Bundle;

import android.speech.RecognizerIntent;

import android.speech.tts.TextToSpeech.OnInitListener;

import android.speech.tts.TextToSpeech;

import android.util.Log;

import android.view.View;

import android.view.View.OnClickListener;

import android.widget.AdapterView;

import android.widget.AdapterView.OnItemClickListener;

import android.widget.ArrayAdapter;

import android.widget.Button;

import android.widget.ListView;

import android.widget.Toast;

import android.widget.TextView;
</code></pre>

<p>Изменим немного декларацию главного класса</p>

<pre><code>public class SpeechRepeatActivity extends Activity implements OnClickListener, OnInitListener {
</code></pre>

<p>OnInitListener необходим для работы TTS движка. Внутри класса добавим объявления переменных перед методом onCreate</p>

<pre><code>//переменная для проверки возможности

//распознавания голоса в телефоне

private static final int VR_REQUEST = 999;



//ListView для отображения распознанных слов

private ListView wordList;



//Log для вывода вспомогательной информации

private final String LOG_TAG = "SpeechRepeatActivity";

//***здесь можно использовать собственный тег***



//переменные для работы TTS 



//переменная для проверки данных для TTS 

private int MY_DATA_CHECK_CODE = 0;



//Text To Speech интерфейс

private TextToSpeech repeatTTS;
</code></pre>

<p>Внутри метода onCreate автоматически сгенерирован код, вызывающий метод родительского класса и устанавливающий главный контекст вывода.</p>

<pre><code>//вызов суперкласса

super.onCreate(savedInstanceState);

//установка контекста вывода

setContentView(R.layout.main);
</code></pre>

<p>Cоздадим переменные для работы с кнопкой и списком распознанных слов</p>

<pre><code>Button speechBtn = (Button) findViewById(R.id.speech_btn);

wordList = (ListView) findViewById(R.id.word_list);
</code></pre>

<p>Далее необходимо проверить поддерживается ли возможность распознавания голоса телефоном</p>

<pre><code>//проверяем, поддерживается ли распознование речи

PackageManager packManager = getPackageManager();

List&lt;ResolveInfo&gt; intActivities = packManager.queryIntentActivities(new 

    Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH), 0);

if (intActivities.size() != 0) {

// распознавание поддерживается, будем отслеживать событие щелчка по кнопке

speechBtn.setOnClickListener(this);

}

else

{

// распознавание не работает. Заблокируем 

// кнопку и выведем соответствующее 

// предупреждение.

speechBtn.setEnabled(false);

Toast.makeText(this, "Oops - Speech recognition not supported!", Toast.LENGTH_LONG).show();

}
</code></pre>

<p>Мы запрашиваем среду, поддерживается ли Recognizer Intent. Если поддерживается, мы говорим приложению, что нужно отслеживать щелчок пользователя по кнопке. Если интент не поддерживается, мы блокируем кнопку и выводим соответствующее сообщение пользователю.</p>

<p>Напишем код, обрабатывающий нажатие на кнопку. Внутри класса после метода OnCreate добавим метод OnClick.</p>

<pre><code>public void onClick(View v) {

if (v.getId() == R.id.speech_btn) {

    // отслеживаем результат

    listenToSpeech();

}

}
</code></pre>

<p>Как видите, при нажатии на кнопку мы вызываем метод listenToSpeech().</p>

<pre><code>private void listenToSpeech() {



//запускаем интент, распознающий речь и передаем ему требуемые данные

Intent listenIntent = new Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH);

//указываем пакет

listenIntent.putExtra(RecognizerIntent.EXTRA_CALLING_PACKAGE, 

       getClass().getPackage().getName());

//В процессе распознования выводим сообщение

listenIntent.putExtra(RecognizerIntent.EXTRA_PROMPT, "Say a word!");

//устанавливаем модель речи

    listenIntent.putExtra(RecognizerIntent.EXTRA_LANGUAGE_MODEL, 

        RecognizerIntent.LANGUAGE_MODEL_FREE_FORM);

//указываем число результатов, которые могут быть получены

listenIntent.putExtra(RecognizerIntent.EXTRA_MAX_RESULTS, 10);



//начинаем прослушивание

startActivityForResult(listenIntent, VR_REQUEST);

}
</code></pre>

<p>Большая часть приведенного кода стандартна для программ, использующих распознавание голоса. Обратите внимание на параметр EXTRA_PROMPT. Он задает строку-приглашение для пользователя. Параметр EXTRA_MAX_RESULTS определяет максимальное число вариантов распознавания. В конце концов, мы вызываем startActivityForResult. Результат его работы будет передан в метод onActivityResult.</p>

<p>На следующем скриншоте показан экран в момент распознавания речи.</p>

<p><img src="http://android-helper.com.ua/wp-content/uploads/2012/10/speechsample2.jpg" alt="" /></p>

<p>Определим метод onActivityResult</p>

<pre><code>@Override

protected void onActivityResult(int requestCode, int resultCode, Intent data) {

//проверяем результат распознавания речи

if (requestCode == VR_REQUEST &amp;&amp; resultCode == RESULT_OK)

{

    //Добавляем распознанные слова в список результатов

    ArrayList&lt;String&gt; suggestedWords = 

             data.getStringArrayListExtra(RecognizerIntent.EXTRA_RESULTS);

    //Передаем список возможных слов через ArrayAdapter компоненту ListView  

    wordList.setAdapter(new ArrayAdapter&lt;String&gt; (this, R.layout.word, suggestedWords));

}



//tss код здесь



//вызываем метод родительского класса

super.onActivityResult(requestCode, resultCode, data);

}
</code></pre>

<p>Обратите внимание, при проверке результата мы сравниваем переменную requestCode с константой VR_REQUEST, которую использовали ранее при вызове метода startActivityForResult. Таким образом, мы рассматриваем только результаты от нашего запроса. В метод возвращается 10 вариантов распознанных слов, которые мы записываем в список ArrayList. Этот список мы используем в ArrayAdapter компонента List View. </p>

<p>Если приложение справилось с задачей и смогло что-то распознать, вы увидите похожий н показанный на левом скриншоте результат. Если приложению не удалось распознать фразу, будет показано сообщение, как на правом скриншоте</p>

<p><img src="http://android-helper.com.ua/wp-content/uploads/2012/10/speechsample3.jpg" alt="" />
<img src="http://android-helper.com.ua/wp-content/uploads/2012/10/speechsample4.jpg" alt="" /></p>

<p>Вот, собственно и все. Распознавание голоса в Android &ndash; довольно простая задача. Мы вызываем интент RecognizerIntent с требуемыми нами параметрами. Результат  возвращается в onActivityResult.</p>

<h3>Генерация речи в Android</h3>

<p>Перейдем ко второй части нашего приложения, связанного с генерацией речи. Мы хотим, чтобы телефон проговаривал фразу из списка результатов. Мы должны определить строку, на которую щелкнул пользователь. Вернемся к методу onCreate и добавим в конец этого метода код</p>

<pre><code>//засекаем щелчок пользователя по слову из списка

wordList.setOnItemClickListener(new OnItemClickListener() {



//метод вызывается в ответ на щелчок по слову

public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id)

{

    //записываем в переменную TextView строки

    TextView wordView = (TextView)view;

    //получаем строку с текстом

    String wordChosen = (String) wordView.getText();

    //выводим ее в лог для отладки

    Log.v(LOG_TAG, "chosen: "+wordChosen);

    //выводим Toast сообщение

    Toast.makeText(SpeechRepeatActivity.this, "You said: "+wordChosen, 

            Toast.LENGTH_SHORT).show();

}

});
</code></pre>

<p>Мы используем метод setOnItemClickListener чтобы установить отслеживание щелчков для каждой строки. Внутри нового объекта OnItemClickListener мы описали метод onItemClick, который вызывается в ответ на щелчок по строке списка. Выбранная строка передается, как View в этот метод. Поскольку при проектировании шаблона приложения мы указали, что наш список состоит из TextView, мы преобразуем полученное значение в объект TextView и достаем из него строковое значение. Мы записываем это слово в лог и показываем пользователю Toast сообщение.</p>

<p>Если Вас не интересует процесс генерации речи, Вы можете остановиться и протестировать приложение. </p>

<p>Для генерации речи необходимо настроить движок TTS. Добавим код в конец метода onCreate</p>

<pre><code>//подготовка движка TTS для проговаривания слов

Intent checkTTSIntent = new Intent(); 

//проверка наличия TTS 

checkTTSIntent.setAction(TextToSpeech.Engine.ACTION_CHECK_TTS_DATA); 

//запуск checkTTSIntent интента

startActivityForResult(checkTTSIntent, MY_DATA_CHECK_CODE); 
</code></pre>

<p>Как и в случае распознавания, результат интента возвращается в метод onActivityResult. В этом методе перед строкой super.onActivityResult(requestCode, resultCode, data); добавьте</p>

<pre><code>//returned from TTS data check

if (requestCode == MY_DATA_CHECK_CODE)

{ 

//все необходимые приложения установлены, создаем TTS 

if (resultCode == TextToSpeech.Engine.CHECK_VOICE_DATA_PASS) 

    repeatTTS = new TextToSpeech(this, this); 

//движок не установлен, предположим пользователю установить его

else

{ 

    //интент, перебрасывающий пользователя на страницу TSS в Google Play

    Intent installTTSIntent = new Intent(); 

    installTTSIntent.setAction(TextToSpeech.Engine.ACTION_INSTALL_TTS_DATA); 

    startActivity(installTTSIntent); 

} 

}
</code></pre>

<p>Таким образом, мы проверяем наличие TTS движка, и если он не установлен &ndash; предлагаем пользователю установить соответствующую программу. </p>

<p>Чтобы завершить настройку TTS, добавим метод onInit, который вызывается при успешной инициализации TTS.</p>

<pre><code>public void onInit(int initStatus) {

if (initStatus == TextToSpeech.SUCCESS)  

    repeatTTS.setLanguage(Locale.UK); //Язык

}
</code></pre>

<p>Здесь мы устанавливаем язык генератора речи.</p>

<p>Для того, чтобы заставить движок проговорить строку, нужно вызвать метод repeatTTS.speak. Вернемся к методу onCreate. Внутри метода onItemClick после строки Toast.makeText(SpeechRepeatActivity.this, &ldquo;You said: &rdquo;+wordChosen, Toast.LENGTH_SHORT).show(); добавьте следующий код</p>

<pre><code>repeatTTS.speak("You said: "+wordChosen, TextToSpeech.QUEUE_FLUSH, null);
</code></pre>

<p>Таким образом, одновременно с Toast сообщением пользователь услышит сгенерированную речь. Отметим еще раз, что эмулятор не поддерживает распознавание речи, поэтому тестировать программу необходимо на телефоне.</p>

<p>Полный проект вы можете скачать на <a href="http://android-helper.com.ua/codes/">странице с кодами</a>.</p>

<p>Статья взята из сайта <a href="http://www.mobilab.ru/androiddev/androidspeechrecognition.html">mobilab.ru</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/android-helper/blog/2012/10/10/sqlite_1/">Работа с базой данных в Android (SQLite)</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-10-10T12:40:24+03:00" pubdate data-updated="true">Oct 10<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Добрый день друзья.</p>

<p>Много уже работал с базами данных.</p>

<p>Но ни как не мог подготовить статью на эту тему.</p>

<p>Сегодня я ее нашел хорошею статью. И покажу ее вам.</p>

<p>По умолчанию в Android используется база данных SQLite &ndash; это довольно популярная, легкая и быстрая реляционная база данных. Если для вас SQL – это пустой звук, то, скорее всего, вы мало что поймете из этой статьи. Предполагается, что читатель знаком с SQL, знает что такое запросы выборки, триггеры и представления. Если это не так &ndash; почитайте какое-нибудь введение в SQL, а потом возвращайтесь сюда.</p>

<p>База данных SQLite  имеет некоторые особенности, о которых нужно помнить:</p>

<ul>
<li><p>Не поддерживается проверка типов данных. Это значит, что Вы случайно сможете записать данные не того типа, например поместить строку в колонку, предназначенную для целых чисел.</p></li>
<li><p>Не поддерживается ссылочная целостность:  нет поддержки FOREIGN KEY и конструкций JOIN.</p></li>
<li><p>Полная поддержка Unicode отключена по умолчанию.</p></li>
</ul>


<p>Давайте создадим простую базу данных, содержащую информацию о работниках. База содержит две таблицы:  Employees &ndash; для хранения данных о сотрудниках и Dept &ndash; о департаментах. И представление ViewEmps, связывающее работников с департаментами.</p>

<p><img src="http://android-helper.com.ua/wp-content/uploads/2012/10/android_db_sql.jpg" alt="" /></p>

<h2>Создание SQLite базы данных в Android проекте</h2>

<p>По умолчанию, Android не содержит удобных СУБД для создания и работы с базами данных (есть sqlite3.exe &ndash; консоль для работы с базой данных), поэтому давайте создадим базу и все необходимые таблицы непосредственно из кода. </p>

<p>Во-первых, мы напишем класс, который будет управлять всеми операциями с базой данных: созданием базы, созданием таблиц, вставкой и удалением записей. Давайте создадим класс потомок от <strong>SQLiteOpenHelper</strong>. Нам нужно переопределить два метода:</p>

<ul>
<li><p>onCreate(SQLiteDatabase db) &ndash; вызывается при создании базы данных. Здесь мы можем создать таблицы, определить в них колонки, создать виды и триггеры.</p></li>
<li><p>onUpgrade(SQLiteDatabse db, int oldVersion, int newVersion) &ndash; вызывается, при внесении изменений в базу, например при создании и удалении таблиц</p></li>
</ul>


<p>Внутри нашего класса определим переменные</p>

<pre><code>public class DatabaseHelper extends SQLiteOpenHelper {



static final String dbName="demoDB";

static final String employeeTable="Employees";

static final String colID="EmployeeID";

static final String colName="EmployeeName";

static final String colAge="Age";

static final String colDept="Dept";



static final String deptTable="Dept";

static final String colDeptID="DeptID";

static final String colDeptName="DeptName";



static final String viewEmps="ViewEmps";



// и создадим конструктор



public DatabaseHelper(Context context) {

super(context, dbName, null,33);

    }

}
</code></pre>

<p>Как видите, здесь мы просто вызываем конструктор суперкласса, который имеет четыре параметра:</p>

<ul>
<li><p><strong>Context </strong>&ndash; контекст, связанный с базой данных.</p></li>
<li><p><strong>dataBaseName </strong>&ndash; имя базы данных.</p></li>
<li><p><strong>CursorFactory</strong> &ndash; можно использовать класс, созданный на основе класса Cursor. Это позволяет проводить некоторые дополнительные проверки и операции с результатами запросов. Если сюда подставить ссылку на наш класс, он будет использоваться вместо стандартного курсора. Мы не будем работать с  <strong>CursorFactory</strong>, поэтому передадим значение null.</p></li>
<li><p><strong>Version</strong>&ndash; версия базы данных. Смысл этого параметра будет раскрыт ниже</p></li>
</ul>


<h2>Создание базы данных</h2>

<p>Давайте переопределим метод <strong>onCreate</strong></p>

<pre><code>public void onCreate(SQLiteDatabase db) {

// TODO Auto-generated method stub



db.execSQL("CREATE TABLE "+deptTable+" ("+

    colDeptID+ " INTEGER PRIMARY KEY , "+

    colDeptName+ " TEXT)");



db.execSQL("CREATE TABLE "+employeeTable+

    " ("+colID+" INTEGER PRIMARY KEY AUTOINCREMENT, "+

    colName+" TEXT, "+colAge+" Integer, "+colDept+

    " INTEGER NOT NULL ,FOREIGN KEY ("+colDept+")

    REFERENCES "+deptTable+" ("+colDeptID+"));");



 db.execSQL("CREATE TRIGGER fk_empdept_deptid " +

" BEFORE INSERT "+

" ON "+employeeTable+



" FOR EACH ROW BEGIN"+

" SELECT CASE WHEN ((SELECT "+colDeptID+" FROM "+

deptTable+" WHERE "+colDeptID+"=new."+colDept+" ) IS NULL)"+

" THEN RAISE (ABORT,'Foreign Key Violation') END;"+

"  END;");



db.execSQL("CREATE VIEW "+viewEmps+

" AS SELECT "+employeeTable+"."+colID+" AS _id,"+

" "+employeeTable+"."+colName+","+

" "+employeeTable+"."+colAge+","+

" "+deptTable+"."+colDeptName+""+

" FROM "+employeeTable+" JOIN "+deptTable+

" ON "+employeeTable+"."+colDept+" ="+deptTable+"."+colDeptID

);

 //Inserts pre-defined departments

InsertDepts(db);

}
</code></pre>

<p>Внутри метода мы с помощью SQL запросов создаем таблицы, триггеры и представления. Запросы вызываются для базы db с помощью метода <strong>execSQL</strong>.<br/>
 <br/>
Метод <strong>onCreate  </strong>вызывается при создании базы данных, как только база создана, мы добавляем туда таблицы с необходимым набором полей. Вызов метода происходит, когда база данных не существует на диске, то есть для данного конкретного устройства этот метод будет вызван всего один раз, сколько бы мы потом не запускали нашу программу.<br/>
 </p>

<h2> Изменение базы данных</h2>

<p> <br/>
Иногда возникает необходимость внести изменения в базу данных: поменять схему, добавить новые таблицы или поменять типы столбцов таблиц. Все это можно сделать внутри метода <strong>onUpdate(SQLiteDatabase db,int old Version,int newVerison)</strong> .</p>

<pre><code>public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {

// TODO Auto-generated method stub



db.execSQL("DROP TABLE IF EXISTS "+employeeTable);

db.execSQL("DROP TABLE IF EXISTS "+deptTable);



db.execSQL("DROP TRIGGER IF EXISTS dept_id_trigger");

db.execSQL("DROP TRIGGER IF EXISTS dept_id_trigger22");

db.execSQL("DROP TRIGGER IF EXISTS fk_empdept_deptid");

db.execSQL("DROP VIEW IF EXISTS "+viewEmps);

onCreate(db);

}
</code></pre>

<p>Этот метод вызывается, когда изменяется номер, указанный в конструкторе класса. Помните то загадочное число 33, внутри конструктора <strong>DatabaseHelper</strong>? Если Вам вдруг понадобится внести изменение в свою базу, просто поменяйте номер в конструкторе. То есть, если вы измените конструктор</p>

<pre><code>public DatabaseHelper(Context context) {

super(context, dbName, null,34);

}
</code></pre>

<p>приложение поймет, что вы хотите изменить свою базу и вызовет метод onUpgrade. Обычно внутри этого метода удаляются таблицы и создаются заново с другим набором полей. <br/>
 </p>

<h2> Управление внешними ключами</h2>

<p>Давайте создадим триггер, который будет следить при добавлении нового сотрудника за тем, чтобы указанный в описании сотрудника департамент присутствовал в таблице Dept. <br/>
 <br/>
 SQL команда, создающая такой триггер, выглядит следующим образом:</p>

<pre><code>CREATE TRIGGER fk_empdept_deptid Before INSERT ON Employees

FOR EACH ROW BEGIN

SELECT CASE WHEN ((SELECT DeptID FROM Dept WHERE DeptID =new.Dept ) IS NULL)

THEN RAISE (ABORT,'Foreign Key Violation') END;

END
</code></pre>

<p>Добавим в метод onCreate вызов метода execSQL с соответствующим запросом:</p>

<pre><code>db.execSQL("CREATE TRIGGER fk_empdept_deptid " +

" BEFORE INSERT "+

" ON "+employeeTable+



" FOR EACH ROW BEGIN"+

" SELECT CASE WHEN ((SELECT "+colDeptID+" FROM "+deptTable+

" WHERE "+colDeptID+"=new."+colDept+" ) IS NULL)"+

" THEN RAISE (ABORT,'Foreign Key Violation') END;"+

"  END;");
</code></pre>

<h1>Выполнение SQL команд в Android</h1>

<p> Как уже было отмечено выше, Вы можете выполнить любую SQL команду с помощью метода <strong>db.execSQL(String statement)</strong>. <br/>
 </p>

<h2> Добавление записи в таблицу</h2>

<p> Можно добавить новую запись в таблицу с помощью SQL команды <strong>INSERT</strong>, а можно воспользоваться методом <strong>db.insert</strong>:</p>

<pre><code>SQLiteDatabase db=this.getWritableDatabase();

ContentValues cv=new ContentValues();

cv.put(colDeptID, 1);

cv.put(colDeptName, "Sales");

db.insert(deptTable, colDeptID, cv);


cv.put(colDeptID, 2);

cv.put(colDeptName, "IT");

db.insert(deptTable, colDeptID, cv);

db.close();
</code></pre>

<p>Обратите внимание, для соединения с базой данных мы вызвали метод <strong>this.getWritableDatabase()</strong>. Класс <strong>ContentValues</strong> позволяет создать карту с параметрами ключ-значение. Эта карта затем используется методом <strong>insert</strong>, который фактически добавляет запись в таблицу. Метод <strong>ContentValues.put</strong> создает пару ключ-значение. Еще одно замечание, хорошим тоном считается закрывать базу данных вызовом метода  <strong>close()</strong> после завершения выполнения группы команд.</p>

<h2>Изменение значений в таблице</h2>

<p>Изменить значение в какой-либо записи можно с помощью SQL команды <strong>UPDATE </strong>или с помощью метода  <strong>db.update</strong>:</p>

<pre><code>public int UpdateEmp(Employee emp)

{

SQLiteDatabase db=this.getWritableDatabase();

ContentValues cv=new ContentValues();

cv.put(colName, emp.getName());

cv.put(colAge, emp.getAge());

cv.put(colDept, emp.getDept());

return db.update(employeeTable, cv, colID+"=?", new String []{String.valueOf(emp.getID())});

}
</code></pre>

<p>Метод update имеет следующие параметры: </p>

<ul>
<li><p><strong>String Table</strong>: название таблицы в которой мы хотим что-то изменить.</p></li>
<li><p><strong>ContentValues cv</strong>: пара ключ-значение с новой информацией.</p></li>
<li><p><strong>String where</strong>: строка-шаблон, определяющая условие  WHERE, которое проверяется для каждой строки таблицы. Ксли условие истинно, то в этой строке обновляется информация в соответствии с параметром cv.</p></li>
<li><p><strong>String[] args</strong>: массив с аргументами, которые подставляются в строку-шаблон where.</p></li>
</ul>


<h2>Удаление строк</h2>

<p>Удалить строку в таблице можно с помощью SQL команды <strong>DELETE</strong>, а также с помощью метода <strong>db.delete</strong>. Этот метод имеет аналогичный  <strong>update </strong>набор параметров (за исключением cv).</p>

<pre><code>public void DeleteEmp(Employee emp)

{

SQLiteDatabase db=this.getWritableDatabase();

db.delete(employeeTable,colID+"=?", new String [] {String.valueOf(emp.getID())});

db.close();

}
</code></pre>

<h2>Выполнение SQL запросов</h2>

<p> Для выполнения запросов в Android используются два метода: <strong>db.rawQuery</strong> и <strong>db.query</strong>. Давайте сделаем запрос к базе, с целью получения списка всех департаментов:</p>

<pre><code>Cursor getAllDepts()

{

SQLiteDatabase db=this.getReadableDatabase();

Cursor cur=db.rawQuery("SELECT "+colDeptID+" as _id, "+

colDeptName+" from "+deptTable,new String [] {});



return cur;

}
</code></pre>

<p> Метод <strong>rawQuery</strong> имеет два параметра:</p>

<ul>
<li><p><strong>String query</strong>: Строка с SQL запросом SELECT.</p></li>
<li><p><strong>String[] selection args</strong>: массив аргументов where, если он используется в SELECT запросе.</p></li>
</ul>


<p><strong>Замечания!</strong> В качестве результата этого запроса возвращается объект <strong>Cursor</strong>. Если в качестве ключевого поля в таблице используется колонка с именем, отличным от<strong> _id</strong>, Вам необходимо использовать alias в форме &ldquo;SELECT [Column Name] as <em>id&rdquo;. Дело в том, что объект <strong>Cursor</strong> всегда считает, что ключевое поле имеет имя **</em>id**, и если это не так, генерируется исключение.</p>

<p>Другим способом выполнения запроса к базе является вызов метода <strong>db.query</strong>. Давайте напишем метод, который выдает всех сотрудников, работающих в каком-то конкретном департаменте:</p>

<pre><code>public Cursor getEmpByDept(String Dept)

{

SQLiteDatabase db=this.getReadableDatabase();

String [] columns=new String[]{"_id",colName,colAge,colDeptName};

Cursor c=db.query(viewEmps, columns, colDeptName+"=?", new String[]{Dept}, null, null, null);

return c;

}
</code></pre>

<p>Метод <strong>db.query</strong> имеет следующий набор параметров:</p>

<ul>
<li><p><strong>String Table Name</strong>: Имя таблицы, из которой осуществляется выборка.</p></li>
<li><p><strong>String [ ] columns</strong>: список столбцов, которые войдут в результат.</p></li>
<li><p><strong>String WHERE clause</strong>: шаблон where-условия или null.</p></li>
<li><p><strong>String [ ] selection args</strong>: массив с аргументами where-условия.</p></li>
<li><p><strong>String Group by</strong>: условие группировки.</p></li>
<li><p><strong>String Having</strong>: условие HAVING.</p></li>
<li><p><strong>String Order By by</strong>: порядок сортировки.</p></li>
</ul>


<h2> Управление объектом Cursor</h2>

<p>В результате выполнения запросов нам возвращается объект <strong>Cursor</strong>, содержащий таблицу с результатами запроса. <strong>Cursor</strong>предполагает последовательную работу со строками результата. В каждый момент времени активна одна строка, на которую ссылается указатель. Ниже перечислены методы, которые используются для работы с этим объектом:</p>

<ul>
<li><p><strong>boolean moveToNext()</strong>&ndash; перемещает указатель на одну запись вперед. Возвращает false, если достигнут конец таблицы результата.</p></li>
<li><p><strong>boolean moveToFirst()</strong>&ndash; перемещает указатель на первую строку. Возвращает false, если таблица-результат не содержит строк.</p></li>
<li><p><strong>boolean moveToPosition(int position)</strong> - перемещает указатель на конкретную строку в таблице результатов. Если строки с таким номером нет &ndash; возвращает false.</p></li>
<li><p><strong>boolean moveToPrevious()</strong>&ndash; перемещает указатель на одну запись назад. Возвращает false, если достигнуто начало таблицы результата.</p></li>
<li><p><strong>boolean moveToLast()</strong>&ndash; перемещает указатель на последнюю строку. Возвращает false, если таблица-результат не содержит строк.</p></li>
<li><p><strong>int  getColumnIndex(String column)</strong> &ndash; возвращает ссылку на колонку column в текущей строке. Для получения значения по ссылке используются методы <strong>Cursor.getInt(int ColumnIndex), getShort,getString,getDouble, getBlob</strong>. </p></li>
</ul>


<p>Для определение текущей позиции указателя можно воспользоваться методами:<strong>boolean isAfterLast(), isBeforeFirst, isFirst, isLast и isNull(columnIndex)</strong>. Их назначение без труда можно понять из названий.</p>

<p>Если в результате выполнения запроса вы получили только одну строку, то извлечь из нее значения столбцов можно следующим образом:</p>

<pre><code>public int GetDeptID(String Dept)

{

SQLiteDatabase db=this.getReadableDatabase();

Cursor c=db.query(deptTable, new String[]{colDeptID+" as _id",colDeptName},colDeptName+"=?",

new String[]{Dept}, null, null, null);

c.moveToFirst();

return c.getInt(c.getColumnIndex("_id"));

}
</code></pre>

<p>В результате выполнения этого метода, мы получим значение колонки _id текущей строки.  После использования курсора его хорошо бы закрыть с помощью метода <strong>close()</strong>.<br/>
 <br/>
 Вот собственно и все. Теперь вы вполне сможете использовать базы данных в своих Android проектах.</p>

<p>Если вам понравилась статья, пишите комментарии и рассказывайте друзьям.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/android-helper/blog/2012/10/09/listfragments/">ListFragments - список</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-10-09T23:15:36+03:00" pubdate data-updated="true">Oct 9<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Добрый день друзья.</p>

<p>Я продолжаю сбор интересной информации.</p>

<p>И сегодня я нашел статью о работе с ListFragment.</p>

<p>Прошу к прочтению.</p>

<p>Вернемся к фрагментам. В Android есть несколько полезных классов – наследников класса Fragment. Мы рассмотрим несколько из них. Начнем с <a href="http://developer.android.com/reference/android/app/ListFragment.html">ListFragment</a>. В принципе, это просто Fragment, в котором есть методы, упрощающие доступ к ListView и некоторым его операциям.</p>

<p>Тут можно провести аналогию &ndash; для Activity есть класс наследник <a href="http://developer.android.com/reference/android/app/ListActivity.html">ListActivity</a>. Когда мы только знакомились со списками, я не стал рассматривать этот класс, чтобы не вносить путаницы в непростую тему. Но в учебниках и хелпе о нем обычно говорят. Думаю, многие уже сталкивались с ним и примерно знают, что это такое. Если да, то ListFragment будет совсем прост для понимания.</p>

<p>Напишем приложение и рассмотрим основные возможности ListFragment.</p>

<p>Создадим класс фрагмента, наследующий не android.app.Fragment как обычно, а android.app.ListFragment.</p>

<p><strong>MainList.java</strong>:</p>

<pre><code>import android.app.ListFragment;



public class MainList extends ListFragment {



}
</code></pre>

<p>Класс так и оставляем пока пустым. И пока что не будем создавать Layout-файл для этого фрагмента. Дело в том, что ListFragment по умолчанию уже содержит ListView и мы вполне можем обойтись им. Адаптер мы пока также никакой не создаем, посмотрим чего получится.</p>

<p>Редактируем layout для MainActivity</p>

<p><strong>main.xml</strong>:</p>

<pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;

&lt;LinearLayout

xmlns:android="http://schemas.android.com/apk/res/android"

xmlns:tools="http://schemas.android.com/tools"

android:id="@+id/LinearLayout1"

android:layout_width="match_parent"

android:layout_height="match_parent"

android:orientation="vertical"&gt;

&lt;fragment android:name="ru.startandroid.develop.p1091listfragment.MainList"

android:layout_width="match_parent"

android:layout_height="match_parent"&gt;

&lt;/fragment&gt;

&lt;/LinearLayout&gt;
</code></pre>

<p>Здесь только компонент fragment, использующий наш класс.</p>

<p>Все сохраняем, запускаем приложение.</p>

<p><img src="http://android-helper.com.ua/wp-content/uploads/2012/10/L0109_010.jpg" alt="" /></p>

<p>ListFragment показывает нам, что он ждет данных. </p>

<p>Ок, давайте дадим ему данные. Перепишем <strong>MainList.java</strong>:</p>

<pre><code>import android.app.ListFragment;

import android.os.Bundle;

import android.widget.ArrayAdapter;



public class MainList extends ListFragment {



String data[] = new String[] { "one", "two", "three", "four" };



@Override

public void onActivityCreated(Bundle savedInstanceState) {

super.onActivityCreated(savedInstanceState);

ArrayAdapter&lt;String&gt; adapter = new ArrayAdapter&lt;String&gt;(getActivity(),

    android.R.layout.simple_list_item_1, data);

setListAdapter(adapter);

}



}
</code></pre>

<p>Мы создаем адаптер и используем метод <a href="http://developer.android.com/reference/android/app/ListFragment.html#setListAdapter(android.widget.ListAdapter">setListAdapter</a>), чтобы передать его списку. Обратите внимание &ndash; мы даже не создаем или не находим (findViewById) список (ListView), он уже есть где-то внутри фрагмента и метод setListAdapter сам знает, как до него добраться. В принципе, это и есть основная фишка ListFragment &ndash; нам не надо работать с ListView.</p>

<p>Все сохраним, запустим приложение.</p>

<p><img src="http://android-helper.com.ua/wp-content/uploads/2012/10/L0109_0201.jpg" alt="" /></p>

<p>Данные появились.</p>

<p>Еще раз обращаю ваше внимание на то, что мы вообще не создавали никаких layout с ListView. ListFragment работает с каким-то своим, встроенным списком. </p>

<p>Если же вас чем-то не устраивает этот дефолтный список, можно использовать свой layout-файл для фрагмента.</p>

<p>В <strong>strings.xml</strong> добавим строки</p>

<pre><code>&lt;string name="number_list"&gt;Список чисел&lt;/string&gt;

&lt;string name="empty"&gt;Нет данных&lt;/string&gt;
</code></pre>

<p>И создадим layout файл <strong>fragment.xml</strong>:</p>

<pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;

&lt;LinearLayout

xmlns:android="http://schemas.android.com/apk/res/android"

    android:layout_width="match_parent"

    android:layout_height="match_parent"

    android:orientation="vertical"&gt;

    &lt;TextView

        android:layout_width="wrap_content"

        android:layout_height="wrap_content"

        android:text="@string/number_list"&gt;

    &lt;/TextView&gt;

&lt;ListView

     android:id="@id/android:list"

     android:layout_width="match_parent"

     android:layout_height="match_parent"&gt;

&lt;/ListView&gt;

&lt;TextView

     android:id="@id/android:empty"

     android:layout_width="match_parent"

     android:layout_height="match_parent"

     android:gravity="center"

     android:text="@string/empty"&gt;

&lt;/TextView&gt;

&lt;/LinearLayout&gt;
</code></pre>

<p>Первый TextView – просто заголовок списка. Далее идет ListView. Его ID обязательно должен быть равен <strong>@id/android:list</strong>. Чтобы ListFragment сам его нашел и мог с ним работать. Второй TextView – будет показан, если нет данных для списка. Его ID обязательно должен быть равен <strong>@id/android:empty</strong>.</p>

<p>Допишем в <strong>MainList.java</strong> метод создания View.</p>

<pre><code>@Override

public View onCreateView(LayoutInflater inflater, ViewGroup container,

  Bundle savedInstanceState) {

return inflater.inflate(R.layout.fragment, null);

 }
</code></pre>

<p>Фрагмент будет отображать компоненты из layout-файла, который мы только что создавали.</p>

<p>Все сохраняем и запускаем.</p>

<p><img src="http://android-helper.com.ua/wp-content/uploads/2012/10/L0109_030.jpg" alt="" /></p>

<p>Видим заголовок и данные. Наш layout был использован.</p>

<p>Если не дать списку данные, то приложение будет выглядеть так</p>

<p><img src="http://android-helper.com.ua/wp-content/uploads/2012/10/L0109_040.jpg" alt="" /></p>

<p>Отобразился наш второй TextView с ID = @id/android:empty. Причем, это вовсе не обязательно должен быть TextView. Главное тут именно этот ID. Компонент с этим ID будет показан вместо ListView, если нет данных.</p>

<p>Чтобы включать одиночный и множественный выбор, необходимо провести все те же действия, которые мы рассматривали в Уроке 43: передать в адаптер соответствующий layout-файл и включить соответствующий режим выбора для списка. В этом же 43-м Уроке можно посмотреть, как определять, какие пункты списка выбраны. Чтобы в ListFragment получить доступ к списку – используйте метод <a href="http://developer.android.com/reference/android/app/ListFragment.html#getListView(">getListView</a>).</p>

<p>Результаты включения режима выбора будут такие:</p>

<p>одиночный выбор</p>

<p><img src="http://android-helper.com.ua/wp-content/uploads/2012/10/L0109_050.jpg" alt="" /></p>

<p>множественный выбор</p>

<p><img src="http://android-helper.com.ua/wp-content/uploads/2012/10/L0109_060.jpg" alt="" /></p>

<p>Еще, как вариант, можно в адаптер передавать layout-файл <strong>android.R.layout.simple_list_item_activated_1</strong>.</p>

<p>В этом случае результаты будут такие:</p>

<p><img src="http://android-helper.com.ua/wp-content/uploads/2012/10/L0109_070.jpg" alt="" /></p>

<p><img src="http://android-helper.com.ua/wp-content/uploads/2012/10/L0109_080.jpg" alt="" /></p>

<p>Это хорошо подходит для случая, когда у вас на экране слева фрагмент-список, а справа фрагмент-содержимое и вы всегда видите какой именно пункт из списка сейчас просматриваете.</p>

<p>Чуть не забыл про самое главное )  Ловить нажатия можно в методе <a href="http://developer.android.com/reference/android/app/ListFragment.html#onListItemClick(android.widget.ListView,%20android.view.View,%20int,%20long">onListItemClick</a>). </p>

<p>Если добавим в MainList.java его реализацию:</p>

<pre><code>public void onListItemClick(ListView l, View v, int position, long id) {

super.onListItemClick(l, v, position, id);

Toast.makeText(getActivity(), "position = " + position, Toast.LENGTH_SHORT).show();

 }
</code></pre>

<p>то при нажатии на пункт списка, увидим результат:</p>

<p><img src="http://android-helper.com.ua/wp-content/uploads/2012/10/L0109_090.jpg" alt="" /></p>

<p>Статья взята из сайта <a href="http://startandroid.ru/uroki/vse-uroki-spiskom/179-urok-109-android-3-fragments-listfragment-spisok.html">startandroid.ru</a></p>

<p>Если вам понравилась статья, пишите ваши комментарии.</p>

<p>Если у вас есть интересные примеры решения, пишите мне и я буду их публиковать на блоге.</p>

<p>Полный проект вы можете скачать на <a href="http://android-helper.com.ua/codes/">странице с кодами</a>.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/android-helper/blog/2012/10/08/templates-mobile/">Шаблоны для проектирования программ</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-10-08T14:43:22+03:00" pubdate data-updated="true">Oct 8<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Добрый день друзья.</p>

<p>Я думаю, что каждый разработчик стыкаеться с вопросом проектирования дизайна приложения.</p>

<p>Но как часто бывает, что рисовать на бумаге намного быстрее и удобнее.</p>

<p>Чем использовать фотошоп или другие программы.</p>

<p>Сегодня я нашел отличные PDF файлы для этого. С готовыми макетами, для этих целей.</p>

<p>Вот вам ссылка на сайт <a href="http://interfacesketch.tumblr.com/">http://interfacesketch.tumblr.com/</a></p>

<p>Надеюсь вам понравилось.</p>

<p>Оставляйте свои комментарии и подписывайтесь на рассылку.</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/android-helper/blog/page/19/">&larr; Older</a>
    
    <a href="/android-helper/blog/archives">Blog Archives</a>
    
    <a class="next" href="/android-helper/blog/page/17/">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/android-helper/blog/2013/12/31/happy_new_year/">C Новым годом!</a>
      </li>
    
      <li class="post">
        <a href="/android-helper/blog/2013/12/22/skype-premium/">Skype - годовой преимум аккаунт бесплатно!</a>
      </li>
    
      <li class="post">
        <a href="/android-helper/blog/2013/11/21/custom-font/">Custom Font - свои шрифты в Android</a>
      </li>
    
      <li class="post">
        <a href="/android-helper/blog/2013/11/16/ganymotion-root/">Genymotion Root - Как получить права рут на емуляторе</a>
      </li>
    
      <li class="post">
        <a href="/android-helper/blog/2013/11/04/coaching_report/">Отчет по коучингу</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - Your Name -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
