
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Category: Интервью - Android helper</title>
  <meta name="author" content="Andrii Stakhov">

  
  <meta name="description" content="Category: Интервью">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://android-helper.com.ua/categories/intierv'iu">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/github/atom.xml" rel="alternate" title="Android helper" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Android helper</a></h1>
  
    <h2>Освоим android вместе?</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/github/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:android-helper.com.ua/" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/"><img src="../../images/home.png" style="width: 28px;"></a></li>
  <li><a href="/blog/archives">Архив</a></li>
    <!--<li><a href="/codes">Коды</a></li>-->
    <li><a href="/">Вебинары</a></li>
    <li><a href="/categories/trieninghi/">Тренинги</a></li>
    <li><a href="/">Услуги</a></li>
    <li><a href="/about">Обо мне</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article role="article">
  
  <header>
    <h1 class="entry-title">Category: Интервью</h1>
    
  </header>
  
  <div id="blog-archives" class="category">



  
  <h2>2013</h2>

<article>
  
<h1><a href="/artem-melnik-interview/">Артем Мельник - интервью для блога</a></h1>
<time datetime="2013-02-14T11:20:49+02:00" pubdate><span class='month'>Feb</span> <span class='day'>14</span> <span class='year'>2013</span></time>

<footer>
  <span class="categories">posted in <a class='category' href='/categories/intierv'iu/'>Интервью</a>, <a class='category' href='/categories/novosti-saita/'>Новости сайта</a></span>
</footer>


</article>



<article>
  
<h1><a href="/andrii_removskiy/">Видео интервью с Андреем Ремовским</a></h1>
<time datetime="2013-02-01T23:40:14+02:00" pubdate><span class='month'>Feb</span> <span class='day'>01</span> <span class='year'>2013</span></time>

<footer>
  <span class="categories">posted in <a class='category' href='/categories/intierv'iu/'>Интервью</a>, <a class='category' href='/categories/novosti-saita/'>Новости сайта</a></span>
</footer>


</article>



  
  <h2>2012</h2>

<article>
  
<h1><a href="/new-year/">С Новым годом!</a></h1>
<time datetime="2012-12-30T15:44:48+02:00" pubdate><span class='month'>Dec</span> <span class='day'>30</span> <span class='year'>2012</span></time>

<footer>
  <span class="categories">posted in <a class='category' href='/categories/intierv'iu/'>Интервью</a>, <a class='category' href='/categories/novosti-saita/'>Новости сайта</a></span>
</footer>


</article>



<article>
  
<h1><a href="/artem-melnik/">Первое интервью. В гостях Артем Мельник.</a></h1>
<time datetime="2012-12-29T15:42:17+02:00" pubdate><span class='month'>Dec</span> <span class='day'>29</span> <span class='year'>2012</span></time>

<footer>
  <span class="categories">posted in <a class='category' href='/categories/intierv'iu/'>Интервью</a>, <a class='category' href='/categories/novosti-saita/'>Новости сайта</a></span>
</footer>


</article>



<article>
  
<h1><a href="/interview_start/">Старт новой рубрики</a></h1>
<time datetime="2012-12-01T14:18:04+02:00" pubdate><span class='month'>Dec</span> <span class='day'>01</span> <span class='year'>2012</span></time>

<footer>
  <span class="categories">posted in <a class='category' href='/categories/intierv'iu/'>Интервью</a>, <a class='category' href='/categories/novosti-saita/'>Новости сайта</a></span>
</footer>


</article>

</div>

  
</article>

</div>

<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/happy_new_year/">C Новым годом!</a>
      </li>
    
      <li class="post">
        <a href="/skype-premium/">Skype - годовой преимум аккаунт бесплатно!</a>
      </li>
    
      <li class="post">
        <a href="/custom-font/">Custom Font - свои шрифты в Android</a>
      </li>
    
      <li class="post">
        <a href="/ganymotion-root/">Genymotion Root - Как получить права рут на емуляторе</a>
      </li>
    
      <li class="post">
        <a href="/coaching_report/">Отчет по коучингу</a>
      </li>
    
  </ul>
</section>



<section class="googleplus">
  <h1>
    <a href="https://plus.google.com/Android-helperUa?rel=author">
      <img src="http://www.google.com/images/icons/ui/gprofile_button-32.png" width="32" height="32">
      Google+
    </a>
  </h1>
</section>


<!--<ul>-->
    <!--&lt;!&ndash;&ndash;&gt;-->
    <!--&lt;!&ndash;<li>Что такое androidДрузья всем привет.

Я очень рад, что некоторые из ребят в коучинге пишут замечательные топики!

Вот с какой проблемой мы столкнулись в коучинге и как ее решали!

<!-- more -->


В процессе коучинга, создавая своё первое приложение - калькулятор, научился использовать кастомные шрифты. Спешу безвозмездно поделиться своим опытом!

**Какие шрифты подходят?**

Можно использовать шрифты TrueType (TTF)

**Куда положить шрифт?**

В корневой директории (на одном уровне с директориями java и res и файлом AndroidManifest.xml) создать папку assets, а внутри неё можно создать отдельную папку для шрифтов fonts
В эту папку бросить свой файл со шрифтом Custom.ttf

**Как Android узнает, где находятся кастомные шрифты?**

В файле **<project_name>.iml** в разделе configuration необходимо добавить строчку

	<configuration>
	...
	<option name="ASSETS_FOLDER_RELATIVE_PATH" value="/src/	main/assets" />
	</configuration>

а в файле **res/values/strings.xml** - строчку

	<string name="digit_keyboard_font">fonts/Custom.ttf</string>

**Как назначить шрифт своим View-элементам?**

Теперь в коде, в методе onCreate можно использовать свой шрифт. Обратите внимание на код, в котором скрывается первая секретная фишка!

	Typeface keys = Typeface.createFromAsset(getAssets(), 	getString(R.string.digit_keyboard_font));
	TextView key = (TextView)findViewById(R.id.button_about_ok);
	key.setTypeface(keys);


Как видите, таким способом можно применить шрифт к надписям на кнопках и других **View**, которые можно явно привести типу **TextView**.


Ещё одна супер-полезная и очень секретная фишка
Допустим, требуется применить шрифт к группе элементов, которые располагаются в layout-файле внутри корневого элемента типа **ViewGroup** с присвоенным ему уникальным **id**


	<LinearLayout
    android:id="@+id/digit_keyboard_layout"
    android:layout_width="wrap_content"
    android:layout_height="match_parent"
    android:layout_gravity="center_horizontal"
    android:orientation="vertical">

    <TableLayout
        android:id="@+id/table1"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content">

        <TableRow
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_weight="3">

            <Button
                android:id="@+id/button_one"
                style="@style/calc_button_style"
                android:layout_width="@dimen/button_width"
                android:text="@string/one"
                android:layout_alignParentStart="false"
                android:layout_alignParentEnd="false"
                android:layout_weight="1"/>

            <Button
                android:id="@+id/button_two"
                style="@style/calc_button_style"
                android:layout_width="@dimen/button_width"
                android:text="@string/two"
                android:layout_weight="1"/>

            <Button
                android:id="@+id/button_three"
                android:text="@string/three"
                style="@style/calc_button_style"
                android:layout_width="@dimen/button_width"
                android:layout_weight="1"
                />
        </TableRow>
    </TableLayout>
	</LinearLayout>


Используйте в коде приложения вот такой метод


	// Sets the font on all TextViews in the ViewGroup.
    public void setFont(ViewGroup group, Typeface font) {
        int count = group.getChildCount();
        View v;
        for(int i = 0; i < count; i++) {
            v = group.getChildAt(i);
            if(v instanceof TextView) {
                ((TextView)v).setTypeface(font);
            } else if(v instanceof ViewGroup) {
                setFont((ViewGroup) v, font);
            }
        }
    }

Метод рекурсивно вызывает сам себя пока не доберётся до нужного элемента в любой сложной xml-структуре **layout**. 

Вызывая этот метод устанавливаем шрифт группе элементов.

	Typeface keys = Typeface.createFromAsset(getAssets(), 	getString(R.string.digit_keyboard_font));
	ViewGroup keyboardArea = (ViewGroup)findViewById(R.id.digit_keyboard_layout);
	setFont(keyboardArea, keys);

У кого есть какие то наработки или идеи, пишите в комментариях. Мы обязательно добавим статью на блог!

Жду ваших комментариев!20 апреля в Санкт-Петербурге [ITmozg](http://spb.itmozg.ru/) снова соберет на одной площадке новичков и профессионалов IT-рынка на ежегодном Фестивале профессионального развития — [BitByte](http://bitbyte.itmozg.ru/). 









![Bitbyte](http://www.droidnews.ru/wp-content/uploads/2013/03/bitbyte_logo_2013-600x242.jpg)


 <!-- more -->

  
   
В программе:  
— Две параллельные секции докладов, посвященные техническим и карьерным вопросам;  
— Выставка, где можно напрямую пообщаться с представителями IT-компаний, узнать о возможностях трудоустройства;  
— Много активностей: головоломки и тесты, розыгрыши и подарки, сюрпризы и еще много-много интересного :)













Среди компаний-участников: Google, Oracle, EMC, Яндекс.Деньги, Sperasoft, Mail. ru Group, T-Systems, Электрон и многие другие.





Участие бесплатное! Вход только по регистрации [http://bitbyte.itmozg.ru/register#form](http://bitbyte.itmozg.ru/register#form) 





Все подробности на сайте мероприятия: [http://bitbyte.itmozg.ru](http://bitbyte.itmozg.ru/)
Ну что, кто может сказать, когда мы уже, наконец, увидим следующую версию Android? Наверное, большинство из читателей скажет, что подобное событие произойдёт на мероприятии Google I/O. Во всяком случае об этом твердит большинство источников, и именно на это намекает прошлый опыт. Так что терпеливо ждём 15 мая.









![Эволюция Android](http://www.droidnews.ru/wp-content/uploads/2013/04/Android-5.0-Key-Lime-Pie-Rumors1-600x347.jpg)



 <!-- more -->




Однако, пока мы застыли в ожидании, давайте посмотрим, какие интересные слухи и догадки блуждают по Сети касаемо Android 5.0 Key Lime Pie.









Первое, о чем можно встретить упоминание — свежее ядро Linux версии 3.8. Любители перепрошиваться знают, насколько важно в системе грамотно собранное ядро. Ведь от него во многом зависит скорость работы мультитаскинга, оно может сильно влиять на расход заряда батареи, ядро же определит, сколько оперативной свободной памяти будет выделено пользователю. Так что у многих сейчас есть надежды, что оптимизация ядра поможет улучшить ситуацию вокруг некоторых давних проблем нашей любимой ОС.





Второй интересный слух про Kie Lime Pie гласит, что эта версия Android будет работать исключительно на четырёхъядерных устройствах. Однако, лично мне кажется, что такое развитие событий очень маловероятно. Вряд ли в Google решатся так сразу оставить огромное количество чуть менее современных устройств без обновления системы.





Куда более вероятным кажется, что в Key Lime Pie появится унифицированная Google-платформа для общения Google Babel, которая объединит в себе Google Talk, Google Plus, Google Voice.





Наверняка же к Android 5.0 обновится клавиатура, которая порадует нас более обширными словарями и улучшенными алгоритмами предугадывания вводимого текста.





Интересным остаётся вопрос, на каком именно устройстве нам продемонстрируют Key Lime Pie. Будет ли это Nexus 5 или же ожидаемый многими Motorola X Phone. Что вы думаете по этому поводу?





А вам какие из этих слухов кажутся максимально достоверными? Или какие наоборот — откровенной чепухой? Чего бы хотелось, чтобы подтвердилось?









 
Компания «Доктор Веб» сделала обзор Android-угроз в 2012 году. С угрозами со стороны вредоносных программ ОС Android столкнулась практически с момента своего появления на рынке. И хотя многие пользователи поначалу восприняли этот факт скептически, постепенно их сомнения сменились обеспокоенностью за безопасность используемых мобильных устройств, так как число вредоносных приложений продолжало неуклонно расти. Прошедший 2012 год в этом плане не стал исключением.





Троянцы семейства [Android.SmsSend](http://www.ferra.ru/ru/soft/news/2011/08/30/Android-SmsSend/), появившиеся еще в 2010 году и быстро ставшие настоящей головной болю пользователей мобильных Android-устройств, по-прежнему являются наиболее распространенной и массовой угрозой для этой мобильной платформы. Эти вредоносные программы предназначены для отправки дорогостоящих SMS-сообщений и подписки абонентов на различные контент-услуги, что может повлечь за собой серьезные финансовые потери (при этом жертва даже не будет знать, что деньги списаны с ее счета). Чаще всего они распространяются под видом популярных игр и приложений, а также их обновлений, однако могут встречаться и другиAе каналы распространения.


 <!-- more -->


Учитывая возможности мобильных Android-устройств, а также принимая во внимание продолжающийся рост числа их пользователей, неудивительно, что проблема сохранности конфиденциальной информации становится все более ощутимой. Рискам в этой сфере подвержены все: как простые пользователи, так и представители коммерческого и государственного секторов. Ценные сведения, интересующие злоумышленников, могут быть самыми разнообразными.





Сами по себе вредоносные программы, шпионящие за пользователями и крадущие их конфиденциальную информацию, не уникальны и известны достаточно давно. Однако в 2012 году обозначилась четкая тенденция к появлению довольно специфической группы троянцев-шпионов, направленных против жителей Японии. Все они распространялись при помощи спам-писем, в которых пользователям предлагалось установить то или иное «полезное» приложение, начиная от эротической игры и заканчивая оптимизатором расхода аккумулятора.





Узконаправленные, точечные или таргетированные атаки несут в себе серьезную угрозу, поскольку они, в отличие от большинства обычных атак, направлены не на максимально возможное число пользователей, а на их ограниченный круг, что снижает вероятность оперативного и эффективного обнаружения используемых при преступлении вредоносных программ.





![Android-угрозы](http://www.ferra.ru/images/344/344982.jpg) 
[Android-угрозы](http://news.ferra.ru/photo/techlife/news/Dr-Web-Android-2012/1872/344982)





Применение подобных вредоносных программ никогда не было массовым явлением, в том числе и для устройств под управлением [Android](http://www.ferra.ru/ru/techlife/news/2013/01/28/Trend-Micro-Android-1000000/). В 2012 году мы стали свидетелями появления лишь нескольких новых представителей этого класса троянцев, направленных на мобильную операционную систему от Google. Ими стали [Android.SpyEye.2.origin](http://www.ferra.ru/ru/soft/news/2012/06/21/drweb-Android-SpyEye/), Android.Panda.2.origin, Android.SmsSpy.6.origin и Android.FakeSber.1.origin.





Потенциальную угрозу сохранности персональной информации продолжают нести и различные виды коммерческого программного обеспечения для мониторинга и шпионажа. В 2012 году было обнаружено значительное число не только новых модификаций уже известных программ, но и новые представители этого класса приложений.





На фоне общей массы вредоносных Android-приложений, направленных на получение той или иной материальной выгоды, [Android.Moghava](http://www.ferra.ru/ru/soft/news/2012/03/02/Android-Moghava/), обнаруженный весной 2012 года, держится особняком, будучи троянцем-вандалом. Он распространялся в модифицированной злоумышленниками версии приложения — сборника рецептов иранской кухни. Через определенные промежутки времени троянец выполнял на мобильном устройстве поиск JPEG-изображений в каталоге /DCIM/Camera/ и накладывал на них еще одно изображение. В результате этого фотографии пользователя безвозвратно портились.





По состоянию на конец 2012 года вирусные базы Dr.Web содержали почти 1300 записей для Android-угроз. С ростом популярности мобильных устройств под управлением ОС Android соответственно увеличивается число и разнообразие вредоносных приложений, представляющих опасность для пользователей этой платформы. Описанные выше типы угроз в 2012 году стали наиболее заметными, а также продемонстрировали потенциальный вектор развития вредоносных Android-программ в ближайшем будущем. Одновременно с этим могут появляться и вредоносные приложения, которые сочетают свойства самых разнообразных угроз или же являются «нестандартными» по сравнению с общей массой, что во многом повторяет ситуацию с Windows. Учитывая, что в ближайшие несколько лет мобильная платформа Android будет оставаться среди лидеров рынка, стоит ожидать дальнейшего роста числа созданных для нее вредоносных программ.





Источник [pcnews.ru](http://www.pcnews.ru/news/android-2012-smssend-2010-sms-google-spyeye-origin-panda-smsspy-fakesber-moghava-jpeg-dcim-camera-dr-web-1300-425558.html)
По последним данным агентства Strategy Analytics за 2012 год в мире было продано около 700 миллионов смартфонов, при этом 684 процента от этого количества составляли устройства на базе платформы [Android](http://androidnews.com.ua/), iOS получила 194 процента, а 122 процентов пришлось на другие программные платформы. Что касается производителей смартфонов, то лидирующие позиции в 2012 году остались за Apple и Samsung, как по уровню прибыли, так и по объемам продаж. По мнению аналитиков, именно эти две компании сегодня можно считать главными противоборствующими сторонами в мобильной индустрии, а противостояние Apple и [Google](http://androidnews.com.ua/other-news/2740-google-rabotaet-nad-android-ochkami.html) начало отходить на второй план. Также в Strategy Analytics обращают внимание на замедление темпов развития рынка смартфонов. К примеру, в 2011 году рост поставок смартфонов в мире составил 64 процента, а в прошлом только 43.
Еще одна полезная статья для владык android устройств.





Многие пользователи Android знают, что с помощью приложения Titanium Backup можно вытащить приложение из устройства в виде apk файла. Сегодня мы рассмотрим способ, с помощью которого можно вытащить apk файл приложения прямо из Google Play Store.





![](http://lifehacker.ru/wp-content/uploads/2012/05/04.png)




Плюсом данного способа является отсутствие необходимости предварительной установки приложения на устройство. К сожалению, работает этот способ только для бесплатных приложений. Итак, что нам понадобится:


 <!-- more -->


## 1. Google Chrome





Создаём на рабочем столе второй ярлык для Google Chrome.





![](http://lifehacker.ru/wp-content/uploads/2012/05/a.png)



Делаем по ярлыку правый клик, выбираем «Свойства». В поле «Объект» дописываем через пробел следующие команды:






	--ignore-certificate-errors
	--allow-running-insecure-content


Получится примерно так:

	...\chrome.exe" --ignore-certificate-errors --allow-running-insecure-content









Нажимаем «Применить» и «ОК».





![](http://lifehacker.ru/wp-content/uploads/2012/05/b.png)



После данной операции нужно перезапустить браузер, закрыв при этом все запущенные экземпляры приложения.





## 2. Имя аккаунта Google и ID устройства





По факту мы собираемся имитировать загрузку приложения на устройство, поэтому необходимо знать имя своего аккаунта, то есть имя вашего почтового ящика Google, а также идентификационный номер вашего Android устройства.





С ящиком всё понятно, а чтобы узнать ID устройства, откройте звонилку на своём смартфоне и наберите *#*#8255#*#*





На появившемся экране необходимо найти строчку «Device ID:»





Идентификационным номером является комбинация букв и цифр, следующая после «android-». К примеру, если в строке вы видите «Device ID: android-1122aa33bb445577», то идентификатором является комбинация «1122aa33bb445577». Запишите эту комбинацию.





Если по каким-то причинам у вас не получилось узнать ваш Device ID указанным выше способом, вы можете просто скачать приложение [Device ID](https://play.google.com/store/apps/details?id=com.redphx.deviceid) в Google Play Store.





## 3. APK Downloader





Скачиваем расширение для браузера под названием APK Downloader ([прямая ссылка на загрузку расширения](http://codekiem.com/apk-downloader/crx/1.2.1.crx)).





В появившемся окне вводим адрес нашего Google аккаунта, то есть адрес почты. Пароль (ага, страшно), а также Device ID. После этого нажимаем «Login».





![](http://lifehacker.ru/wp-content/uploads/2012/05/c.png)



В следующем окне выбираем свою страну и оператора сотовой связи, после чего нажимаем «Save Settings». Далее должно появиться окно с сообщением о успешной активации расширения.





![](http://lifehacker.ru/wp-content/uploads/2012/05/d.png)



## 4. Google Play Store





Теперь заходим на наш любимый [Google Play Store](https://play.google.com/) и выбираем любое бесплатное приложение. В правой части адресной строки браузера появится характерного вида зелёная голова со стрелочкой.





![](http://lifehacker.ru/wp-content/uploads/2012/05/e.png)



Нажимаем на эту иконку, и приложение успешно загружается на компьютер в виде apk файла. По сути, теперь мы умеем создавать standalone дистрибутивы бесплатных приложений.





![](http://lifehacker.ru/wp-content/uploads/2012/05/f.png)



**Убедиться в абсолютной порядочности разработчика расширения APK Downloader не представляется возможным, поэтому вводите данные своего аккаунта на собственный страх и риск. Кроме того, подобные действия в принципе нарушают правила использования Google Play Store.**





Статья из сайта [lifehacker.ru](http://lifehacker.ru/2012/05/30/kak-vytashhit-apk-fajjl-iz-google-play-store/)
Всем привет.





Очень полезная статья, для тех кто активно использует маркет. И хочет что бы все программы устанавливались на телефон.





Зачастую разработчики помечают те или иные приложения в Google Play Store как несовместимые с некоторыми устройствами по причине нестабильной работы приложения на данной модели. Тем не менее, всегда есть шанс того, что на вашем устройстве приложение всё же заработает.





  <!-- more -->



Для владельцев рутованных Android есть простой способ обмануть Play Store, представив своё устройство в качестве другой модели, которая числится для конкретного приложения в списке поддерживаемых. Этот способ избавляет от возни с предварительным выкачиванием apk файла из самого маркета.





Итак, у нас есть рутованный Android. Скачиваем из Play Store любой файловый менеджер, который позволяет получить доступ к системным файлам, а также позволит редактировать их. Мы воспользовались приложением [ES File Explorer](https://play.google.com/store/apps/details?id=com.estrongs.android.pop). После установки приложения заходим в его настройки. Необходимо включить возможность доступа к рут-директории, а также установить возможность записи в файлы, находящиеся в этой директории.





![Как установить несовместимое приложение на Android](http://lifehacker.ru/wp-content/uploads/2012/06/screenshot-1340023180361.png)
![Как установить несовместимое приложение на Android](http://lifehacker.ru/wp-content/uploads/2012/06/screenshot-1340023094634.png)




Теперь идём в папку «system» и находим там файл «build.prop». Перед любыми манипуляциями такого рода лучше конечно забекапиться, а в данном случае хотя бы сделать копию «build.prop» файла куда-нибудь на карту памяти.





![Как установить несовместимое приложение на Android](http://lifehacker.ru/wp-content/uploads/2012/06/screenshot-1340023213651.png)



Открываем файл «build.prop» с помощью встроенного редактора ES проводника как текстовый файл.





![Как установить несовместимое приложение на Android](http://lifehacker.ru/wp-content/uploads/2012/06/screenshot-1340023259603.png)
![Как установить несовместимое приложение на Android](http://lifehacker.ru/wp-content/uploads/2012/06/screenshot-1340023243358.png)




Google Play идентифицирует устройство по данным, записанным в строчках «ro.product.model» и «ro.product.manufacturer». Остаётся лишь изменить значения этих параметров. В данном случае мы подменяем старенький Wildfire на Incredible. После этого нажимаем кнопку «Menu» и сохраняем внесённые изменения.





![Как установить несовместимое приложение на Android](http://lifehacker.ru/wp-content/uploads/2012/06/screenshot-1340023338036.png)
![Как установить несовместимое приложение на Android](http://lifehacker.ru/wp-content/uploads/2012/06/screenshot-1340023633575.png)


Осталось подчистить данные в самом приложении Google Play Store. Для этого заходим в менеджер приложений, находим там Play Store и чистим кэш и данные. После этого необходимо перезагрузить устройство.





![Как установить несовместимое приложение на Android](http://lifehacker.ru/wp-content/uploads/2012/06/screenshot-1340023695040.png)
![Как установить несовместимое приложение на Android](http://lifehacker.ru/wp-content/uploads/2012/06/screenshot-1340023711828.png)




Данный способ не позволит обойти ситуации, когда приложение несовместимо из-за разницы версий операционной системы, либо из-за страны проживания.





Статья из сайта [lifehacker.ru](http://lifehacker.ru/2012/06/19/kak-ustanovit-nesovmestimoe-prilozhenie-na-android/)
Добрый день друзья.





Пару дней назад купил себе телефон [Lenovo A750](http://utc.vn.ua/product/lenovo-a750)





Телефон был уже перепрошит на Android 4.0.3, но была одна маленькая проблема.





В наборе номера не было русских букв.


<!-- more -->


Долго не думая, я решил найти как побороть эту проблему. И решение нашлось.





#### 1. [Скачиваем патч](http://android-helper.com.ua/images/uploads/2012/07/Search_T9_ICS_rus.zip).
2. Копируем его на флеш карту телефона. (Можно подключить телефон к компьютеру и скопировать туда).  
3. Заходим в recovery.





![](http://android-helper.com.ua/images/uploads/2012/07/device-2012-07-23-080632.png)



![](http://android-helper.com.ua/images/uploads/2012/07/device-2012-07-23-080658.png)




 





#### 4. Выбираем обновление.





![](http://android-helper.com.ua/images/uploads/2012/07/2012-07-23-08.jpg)





![](http://android-helper.com.ua/images/uploads/2012/07/2012-07-23-08.09.33.jpg)





![](http://android-helper.com.ua/images/uploads/2012/07/2012-07-23-08.09.20.jpg)





#### 5. Обновляем.





![](http://android-helper.com.ua/images/uploads/2012/07/2012-07-23-08.09.jpg)





#### 6. Выключаем телефон.





![](http://android-helper.com.ua/images/uploads/2012/07/2012-07-23-08.10.jpg)





#### 7. Включаем и наслаждаемся.





![](http://android-helper.com.ua/images/uploads/2012/07/device-2012-07-23-081251.png)




Если не работает поиск по русскому тексту. Тогда смените язык системы на Английский, а затем на Русский.
Добрый день.





Сегодня мы закончим серию осмотра меню.





Последний пункт меню это **_О телефоне_**





![](http://android-helper.com.ua/images/uploads/2012/04/device-2012-04-28-041409-200x300.png)


<!-- more -->

**Информация о памяти ** - показывает сколько у вас памяти.





![](http://android-helper.com.ua/images/uploads/2012/04/device-2012-04-28-041416-200x300.png)



**Информация о батарее** - показывает состояние батареи





![](http://android-helper.com.ua/images/uploads/2012/04/device-2012-04-28-041425-200x300.png)




**Информация о SIM и сетях - **показывает информацию о SIM картах и сетях (MAC адрес, Bluetooth)





![](http://android-helper.com.ua/images/uploads/2012/04/device-2012-04-28-041433-200x300.png)




![](http://android-helper.com.ua/images/uploads/2012/04/device-2012-04-28-041442-200x300.png)




![](http://android-helper.com.ua/images/uploads/2012/04/device-2012-04-28-041448-200x300.png)








Как вы могли заметить, то у меня телефон на 2 сим карты. Если кому нужен такой же, могу помочь в приобретении.





**Информация о версии -** показывает версию Android и также информацию о телефоне (модель телефона, версия ПО и т.д.)





![](http://android-helper.com.ua/images/uploads/2012/04/device-2012-04-28-041456-200x300.png)




**Правовая информация** открывает экран, на котором можно ознакомиться с правовой информацией о программном обеспечении, поставляемом вместе с телефоном.
Сегодня мы поговорим о специальных возможностях.





![](http://android-helper.com.ua/images/uploads/2012/04/device-2012-04-27-041601-200x300.png)


<!-- more -->

Настройки специальных возможностей используются для настройки подключаемых модулей специальных возможностей, установленных на телефоне.





**Спец. возможности** - установите этот флажок для включения всех установленных подключаемых модулей специальных возможностей.





**Виброотклик (KickBack)** - установите, чтобы вибрация активировалась в качестве отклика при навигации по пользовательскому интерфейсу, нажатии кнопок и т.д.





**Озвучивание интерфейса (TalkBack)** - установите этот флажок, чтобы встроенный синтезатор речи проговаривал ярлыки или названия элементов при навигации по пользовательскому интерфейсу телефона.





**Звуковой отклик (SoundBack)** - установите этот флажок для воспроизведения звука при навигации по пользовательскому интерфейсу телефона.





**Кнопка питания завершает вызов** - установите этот флажок, чтобы нажатие кнопки питания завершало вызов, а не отключало или включало экран.




Еще раз всем привет.





Сегодня продолжим список статей о настройке меню.





_Дата и время_





Для всех это очень актуальная тема.





![](http://android-helper.com.ua/images/uploads/2012/04/device-2012-04-27-035716-200x300.png)

<!-- more -->


Тут много описывать тоже не будем.





Тут все очень просто.





Единственное что я могу добавить это Автоматически - получает данные о дате и времени из настроек сети оператора. 





Но будьте бдительны, сеть не всегда возвращает корректные данные.





Поэтому рекомендую настроить вручную.
Добрый день друзья.





Сегодня речь пойдет, как по мне, о самой нужной вещи для экономии заряда аккумулятора.





Сегодня мы поговорим о такой вещи как _Расписание включения и выключения_





![](http://android-helper.com.ua/images/uploads/2012/04/device-2012-04-27-033857-200x300.png)

<!-- more -->


Тут много нечего описывать.





Есть два меню: включение и выключение.





Каждое из которых можно настроить под себя.





У меня как вы видите стоит выключение в 24:00 а включение в 6:00. Это помогает продлить жизнь моему аккумулятору на 30%.





P.S.





Не волнуйтесь, что ваш телефон не включится утром. Он включается постоянно. 





И еще один момент. Не ставьте будильник раньше чем включится телефон + 5 мин. Из-за того что он просто не сработает.





Удачи вам!
Добрый день друзья.





Сегодня я вам расскажу в чем преимущество Android устройств.





Наверное каждый, у кого есть данное устройство, задавал себе вопрос как можно устанавливать мега большое количество программ и игр.





Разрешите представить вам Adnroid Market - сейчас переименован в google play.





![](http://android-helper.com.ua/images/uploads/2012/04/device-2012-04-26-084411-200x300.png)


<!-- more -->

В этом сервисе вы можете устанавливать, обновлять и удалять ваши приложения.





Самое приятное это то, что все приложения собраны в категории. Что позволяет очень быстро находить самое необходимое.





![](http://android-helper.com.ua/images/uploads/2012/04/device-2012-04-26-084431-200x300.png)




Итак посмотрим на Игры





![](http://android-helper.com.ua/images/uploads/2012/04/device-2012-04-26-084451-200x300.png)

![](http://android-helper.com.ua/images/uploads/2012/04/device-2012-04-26-084444-200x300.png)




Как видите что игр очень много.





Управление своими приложениями.





В меню можно выбрать Мои приложения





![](http://android-helper.com.ua/images/uploads/2012/04/device-2012-04-26-084539-200x300.png)




Как вы могли заметить, то у нас есть 2 обновления. 





Выберите приложение которое хотите обновить и вуаля у вас стоит самое последнее.





Удалять можно аналогично обновлению просто выберите приложение и нажмите удалить.





![](http://android-helper.com.ua/images/uploads/2012/04/device-2012-04-26-085323-200x300.png)



Добрый день друзья.





Сегодня мы поговорим с вами о таком меню как _Приложения_





В этом меню зачастую происходит настройка ваших приложений.





![](http://android-helper.com.ua/images/uploads/2012/04/device-2012-04-23-035147-200x300.png)



 <!-- more -->



  1. **Неизвестные источники** - если в этом меню поставить галочку, то тогда вы сможете устанавливать приложения которые не находятся на PlayMarket.



  2. **Управление приложениями** - в этом меню вы можете управлять (удалять, перемещать на SD карту) установленными приложениями.



  3. **Запущенные процессы** - это меню служит для просмотра запущенных сервисов и просмотре использованной памяти



  4. **Расход заряда батареи** - можно посмотреть куда расходуется заряд батареи



  5. **Разработка** - это меню служит для разработчиков программного обеспечения для Android






Остановимся на некоторых меню.





### Управление приложениями





![](http://android-helper.com.ua/images/uploads/2012/04/device-2012-04-23-035224-200x300.png)




Как вы видите данное меню открывает центр управления приложениями.





В этом центре вы можете увидеть:








  * Сколько внутренней памяти (нужно всегда добиваться что бы было минимум, иначе телефон будет тормозить)



  * Список всех приложений (если вашего приложения тут нету, значит оно у вас стоит на SD карте и это хорошо :) )



  * Закладки:







    1. Запущенно - то что сейчас в памяти загружено



    2. В телефоне - то что стоит в памяти телефона



    3. На SD карте - то что уже на SD карте



    4. Установлено - то что вообще у вас установлено






Для того что бы приложение переместить на SD карту (ВНИМАНИЕ! не все приложения можно перемещать), удерживайте на приложение палец и у вас будет меню:





![](http://android-helper.com.ua/images/uploads/2012/04/device-2012-04-23-040304-200x300.png)







### Запущенные процессы





![](http://android-helper.com.ua/images/uploads/2012/04/device-2012-04-23-035316-200x300.png)




Тут можно выключать не нужные сервисы что бы телефон не тормозил, а лучше поставить программу по автоматической очистке памяти. 





Программу вы можете найти в разделе полезные программы.





### Расход заряда батареи





![](http://android-helper.com.ua/images/uploads/2012/04/device-2012-04-23-035353-200x300.png)




Здесь вы можете увидеть на что в процентном соотношении расходуется память.





### Разработка (только для разработчиков)





![](http://android-helper.com.ua/images/uploads/2012/04/device-2012-04-23-035414-200x300.png)




**Отладка по USB** - это меню нужно включить, что бы ваш телефон был виден как устройство для программирования





**Оставить включенным** - если неудобно что телефон постоянно выключается во время отладки, тогда ставьте галочку





**Фиктивные местоположения** разрешает использовать фиктивные местоположения для ваших программ которые работают с GPS координатами.





**На этом все!**





**Рассказывайте друзьям, помогите развиваться проекту!**
Всем читателям привет!





Сегодня я вам расскажу о интересном меню **Язык и клавиатура**





Ну что поехали?


<!-- more -->


![](http://android-helper.com.ua/images/uploads/2012/04/device-2012-04-10-114952-200x300.png)




**Выбрать язык** - в этом меню вы можете указать язык системы.





**Словарь пользователя** - можно создать свой словарь слов и использовать его при вводе.





**Клавиатура Android** - настраивает системную клавиатуру, если к примеру вы скачаете с маркета программу [Russian Keyboard](https://play.google.com/store/apps/details?id=ru.androidteam.rukeyboard&feature=search_result#?t=W251bGwsMSwxLDEsInJ1LmFuZHJvaWR0ZWFtLnJ1a2V5Ym9hcmQiXQ..), то у вас в настройках клавиатуры будет Клавиатура Russian Keyboard





**Выберите способ ввода** - выбирает способ ввода по умолчанию





### Выбрать язык





![](http://android-helper.com.ua/images/uploads/2012/04/device-2012-04-10-115547-200x300.png)




### Клавиатура Android

![](http://android-helper.com.ua/images/uploads/2012/04/device-2012-04-10-115706.png)
![](http://android-helper.com.ua/images/uploads/2012/04/device-2012-04-10-115657-200x300.png)
![](http://android-helper.com.ua/images/uploads/2012/04/device-2012-04-10-115706-200x300.png)









**Виброотклик клавиш** - вибрировать при нажатии





**Звук клавиш** - издавать звуки при нажатии (как в печатной машинке)





**Увеличение нажатых** - увеличивает нажатые буквы





**Исправление нажатием** - если удерживать долго на клавише, на которой есть буква или цифра, то можно выбрать





**Заглавные автоматически** - устанавливает заглавные буквы в верхний регистр после точки





**Кнопка настроек** - показывает либо прячет кнопку настроек на клавиатуре





**Голосовой ввод** - позволяет вводить текст голосом





**Языки ввода** - эту тему уже рассматривали [тут](http://android-helper.com.ua/?page_id=115)





**Предлагать варианты** - предлагать варианты ввода (что то типа Т9)





**Автозавершение** - завершает слово на первое предложенное после нажатия на пробел
Приветствую друзья.





Сегодня мы обсудим такой пункт меню как **Память**





![](http://android-helper.com.ua/images/uploads/2012/04/device-2012-04-10-113433-200x300.png)


<!-- more -->

В этом меню как вы видите содержится информация о памяти вашего устройства.





Тут вы можете нажать только 2 кнопки:





**Отключить SD-карту (Подключить SD-карту)** - нужно нажимать всегда если вы планируете извлечь или очистить вашу sd-карту





**Очистить SD-карту** - делает форматирование вашей карточки




Добрый день друзья.





Сегодня мы рассмотрим мега важную функцию в android. 


 <!-- more -->


А именно добавление аккаунтов и синхронизация с разными сервисами:








  * Google



  * Vkontakte



  * Facebook



  * Twiter



  * Dropbox






Разделим нашу статью на несколько блоков.








  1. Основные функции меню



  2. Добавление google аккаунтов (да их может быть несколько)



  3. Настройка синхронизации с серверами google



  4. Добавление других сервисов






### Основные функции меню





![](http://android-helper.com.ua/images/uploads/2012/04/device-2012-04-05-160303-200x300.png)




**Фоновый режим** - нужен для автоматической синхронизации сервисов в фоновом режиме. Важно помнить, что перед добавлением любого аккаунта, этот режим должен быть включен.





**Автосинхронизация** - служить для синхронизации с сервисами по определенному расписанию. Расписание можно настроить  в настройках аккаунта.





### Добавление google аккаунтов 












  1. Нажимаем Добавить аккаунт



  2. Выбираем Google



  3. Нажимаем далее



  4. Если аккаунта нету - **Создать** (можно посмотреть ролик из [урока](http://android-helper.com.ua/?p=127)), я надеюсь что у нас уже есть аккаунт - **Войти**



  5. Заполняем логин и пароль - **Войти**






















###  Настройка синхронизации с серверами google













![](http://android-helper.com.ua/images/uploads/2012/04/device-2012-04-05-164032-200x300.png)




Календарь - синхронизировать нужно если вы его используете у себя в профиле.





Контакты - синхронизировать нужно всегда. Если вы хотите иметь к ним доступ с разных устройств.





Альбом - по желанию





Документы - тоже по желанию





Gmail - синхронизировать нужно если вы пользуетесь почтой.





### Добавление других сервисов





Другие сервисы мы можем добавлять по аналогии с аккаунтом google





Для того что бы добавить сервис Вконтакте вам нужно скачать программу [Вконтакте](https://play.google.com/store/apps/details?id=com.vkontakte.android&feature=search_result#?t=W251bGwsMSwxLDEsImNvbS52a29udGFrdGUuYW5kcm9pZCJd) с маркета.









Если нужно еще что то добавить пишите в комментарии.
Для создания **профиля google** необходимо создать почтовый акаунт.


 <!-- more -->


Как это сделать вы найдете на этом видео:


{% youtube bOHawTJRuO0 %}





Сегодня мы поговорим о очень нужной функции в android.





Как вы могли догадаться из названия, речь пойдет о восстановлении и сбросе настроек системы.





![](http://android-helper.com.ua/images/uploads/2012/04/device-2012-02-15-120705-200x300.png)


 <!-- more -->

**Резервное копирование** - эта функция служит для сохранения все данных телефона на серверах Google. Для использования нужно завести учетную запись google





**Автовосстановление** - восстанавливает настройки программ из серверов Google





**Сброс настроек** - сбрасывает на заводские настройки.





**Осторожно!** В некоторых случаях удаляет IMEI с телефона. После чего телефон перестает звонить. Эта проблема была в старых версиях китайских телефонов. Но перед тем как сделать сброс. Посмотрите в интернете нету ли такой проблемы. 





Кстати только с помощью сброса на заводские настройки можно **удалить учетную запись google** с своего телефона.








Приветствую тебя читатель.





Сегодня я расскажу тебе о том, как можно добавить Русскую раскладку в свою клавиатуру.


 <!-- more -->





  1. Настройки



  2. Язык и клавиатура



  3. Клавиатура Android



  4. Языки ввода



  5. Выбираем нужный






Если нужного языка нету. Подписывайтесь на рассылку в справа.





И в следующих постах я покажу как можно добавить много языков. В том числе и Украинский.





Смотрим ролик ниже:


{% youtube LFrMwebMx5Y %}











Недавно один из моих друзей столкнулся с проблемой. Он очень хотел поменять звонок своего мобильника.





В этой статье я расскажу как поменять мелодию звонка и в конце будет один маленький бонус.


 <!-- more -->





  1. Заходим в меню приложений



  2. Открываем Музыка



  3. Выбираем любую вами песню или рингтон



  4. Удерживая некоторое время появиться диалог



  5. На диалоге есть пункт - Поставить на звонок






 





Смотрим видео урок:


{% youtube xSztZYnYxek %}


  
[Установка мелодии на звонок](http://youtu.be/xSztZYnYxek)





Также можно использовать следующую схему:





Открыв карту памяти, вы должны создать несколько папок:








  1. в корневом каталоге создайте папку **media**



  2. в папке **media** создайте еще одну папку **audio**






Затем вам нужно создать папки в зависимости от того, как вы хотите использовать ваши звуки:








  * для сигнала будильника, в папке **audio** создайте попку **alarms**



  * для оповещений (sms), в папке **audio** создайте попку **notifications**



  * для рингтонов, в папке **audio** создайте попку **ringtones**






**И наслаждаемся! :)**
Следующий пункт меню - **Местоположение**



В этом меню вы можете настраивать определение вашего местоположения другим программам.



![](http://android-helper.com.ua/images/uploads/2012/03/device-2012-03-26-165507-200x300.png)

<!-- more -->

**Беспроводные сети** - дает возможность отслеживать ваше местоположение с помощью сетей WI-FI и сетей сотовых операторов



**Спутники GPS** - определяет местоположение через встроенный GPS модуль (если он есть)



**Вспомогательные данные** - для быстрого определения вашего местоположения



**Настройки EPO** - описание ниже



**A-GPS** - использует определение вашего местоположения по сетям оператора с помощью интернет соединения (кушает ваш интернет трафик)



**Настройки A-GPS** - описание ниже



# Настройки EPO



![](http://android-helper.com.ua/images/uploads/2012/03/device-2012-03-26-170134-200x300.png)


В этом меню можно настроить загрузку положений спутников. Данные загрузки будут использованы для быстрого определения вашего местоположения.



# Настройки A-GPS



![](http://android-helper.com.ua/images/uploads/2012/03/device-2012-03-26-170457-200x300.png)


В этом меню вы сможете настроить получение данных через сервера (в моем случае используется сервер по умолчанию). 



О работе A-GPS вы также можете узнать [тут](http://ru.wikipedia.org/wiki/A-GPS)
Сегодня мы познакомимся с очень нужной функцией -** настройкой экрана.**



![](http://android-helper.com.ua/images/uploads/2012/03/device-2012-03-26-103357-200x300.png)

<!-- more -->

**Яркость** - главный инструмент, который поможет экономить заряд батареи. Рекомендую использовать Авто, потому что режим Авто сам настраивает экран. Делая его темнее либо светлее.



**Автоповорот экрана** - нужен для того что бы во время переворота экрана он переворачивался вместе с телефоном



**Анимация** - в этом меню можно выбрать, как будет происходить переход между экранами, диалогами



**Автоотключение экрана** - Здесь указывается интервал отключение экрана.



Ниже я покажу свои настройки для всех пунктов.



![](http://android-helper.com.ua/images/uploads/2012/03/device-2012-03-26-104048-200x300.png)


![](http://android-helper.com.ua/images/uploads/2012/03/device-2012-03-26-104057-200x300.png)


![](http://android-helper.com.ua/images/uploads/2012/03/device-2012-03-26-104109-200x300.png)


![](http://android-helper.com.ua/images/uploads/2012/03/device-2012-03-26-104119-200x300.png)В android устройствах, как и в большинстве других устройств, присутствует очень важная функция - **Профили звука **



![](http://android-helper.com.ua/images/uploads/2012/03/device-2012-03-21-235141-200x300.png)


 <!-- more -->



Для того что бы активизировать любой из профилей, на него нужно нажать и подержать несколько секунд.



В этом меню вы можете создавать свои звуковые схемы.



**Настройка профилей**





Для настройки профилей вам нужно:









	
  1. Оттянуть  строку нотификации


	
  2. Прокрутить на профили


	
  3. Долго нажимая на него у вас появиться настройка профиля






![](http://android-helper.com.ua/images/uploads/2012/03/device-2012-03-21-235850-200x300.png)




На примере я покажу как редактировать обычный профиль





![](http://android-helper.com.ua/images/uploads/2012/03/device-2012-03-21-235943-200x300.png)




**Виброзвонок** - не нуждается в коменариях





**Отключение аудио-плеера** - выключает аудио-плеер во время звонка





**Громкость** - устанавливает громкость сигнала





**Голосовой вызов** - именно тут можно заменить мелодию входящего звонка





**Видеовызов** - устанавливает мелодию на видеозвонок





**Уведомление о сообщениях** - устанавливает мелодию на сообщения





**Уведомления** - устанавливает мелодию на уведомления системы





**Отклик на действия** я описывать не буду, там и так все понятно.
В этой статье вы узнаете как использовать меню _**Вызовы**_



![](http://android-helper.com.ua/images/uploads/2012/03/device-2012-03-21-230703-200x300.png)



<!-- more -->


**Голосовой вызов**





![](http://android-helper.com.ua/images/uploads/2012/03/device-2012-03-21-230717-200x300.png)




**Голосовая почта** - в этом меню вы можете указать настройки голосовой почты





**Переадресация вызовов** - в этом меню вы сможете настроить (если нужно будет распишу):









	
  * Всегда на номер


	
  * Если занято


	
  * При отсутствии ответа


	
  * Если не доступен






**Запрет вызова** - в этом меню можно блокировать входящие и исходящие вызовы.





**Дополнительные настройки** - самое главное достоинство этого меню, это то что тут можно поставить галочку на **_Параллельный вызов_**. Который позволяет во время разговора получать входящие вызовы.





**Видео вызов**



![](http://android-helper.com.ua/images/uploads/2012/03/device-2012-03-21-230728-200x300.png)

![](http://android-helper.com.ua/images/uploads/2012/03/device-2012-03-21-230735-200x300.png)


К большому сожалению, видеосвязью не пользуюсь. Но пункты в меню просто супер. Жду 3G связи.





О меню вкратце:





_Изображение для замены..._ - ставит изображение по умолчанию, если камера не используется.





_Включить заднюю камеру_ - переключение между камерами





_Просмотр видео, которое ..._ - транслирует видео которое сохранено на вашем устройстве





_Исходящий вызов_ - отображает локальное видео при исходящем вызове





_Входящий вызов_ - отображает локальное видео при входящем вызове





_Переадресация вызовов_ - тут все аналогично как для обычных вызовов





_Запрет вызовов_ - аналогично





_Дополнительные настройки_ - аналогично





**Другие настройки**





![](http://android-helper.com.ua/images/uploads/2012/03/device-2012-03-21-230748-200x300.png)




**Разрешенные номера** - управляет списком разрешенных номеров которые находятся на вашей SIM карте





**Стоимость вызова** - тут можно указать валюту и стоимость 1 минуты разговора





**Информационное сообщение** - можно настроить информационные сообщения от ваших операторов





**Минутное напоминание** - телефон оповещает вас на 50 секунде каждой минуты





**Вибрировать при соединении** - очень удобная штука.





**Настройка телефона** - тут вы можете указать стандартное сообщение которое будет отправляться когда вы заняты.
**В настройки Android можно попасть следующими способами:**
	
  1. Меню - Настройки
	
  2. Программы - Настройки


![](http://android-helper.com.ua/images/uploads/2012/03/device-2012-03-20-160054-200x300.png)


 <!-- more -->


 **Беспроводные сети:**



![](http://android-helper.com.ua/images/uploads/2012/03/device-2012-03-20-160259-200x300.png)

![](http://android-helper.com.ua/images/uploads/2012/03/device-2012-03-20-160216-200x300.png)

**Режим полета** - в этом режиме телефон отключает все соединения: WiFi, 3G и так далее


**Wi-Fi** - включает, выключает Wi-Fi. Рекомендую отключить, когда не используется. Экономит зарядку батареи.


**Настройки Wi-Fi** - в этом меню вы можете настроить соединения с Wi-Fi. Об этом меню мы поговорим позже.



**Bluetooth**- добрый и всеми любимый bluetooth



**Настройка Bluetooth** - в этом меню идет настройка видимости вашего bluetooth. Это тоже мы рассмотрим дальше.



**Режим модема** - Очень нужная вещь, для тех кто хочет использовать интернет оператора либо wi-fi в своем компьютере либо ноутбуке.



**Настройки VPN** - в этом меню добавляется VPN соединение. Что такое VPN можно узнать [тут](http://ru.wikipedia.org/wiki/VPN).



**Мобильная сеть** - в этом меню настраиваем через какую карточку будет осуществятся интернет трафик (если их 2, как у меня)



**Предпочт. перед. GPRS** - это значит, что телефон не через 3G будет подключаться, а через GPRS ­— это экономит батарею, но в большинстве случаев очень сильно снижает скорость мобильного Интернета



 **Настройки Wi-Fi**



![](http://android-helper.com.ua/images/uploads/2012/03/device-2012-03-20-162111-200x300.png)

![](http://android-helper.com.ua/images/uploads/2012/03/device-2012-03-20-162140-200x300.png)







**Уведомление о сетях** - если стоит галочка, то телефон будет искать открытые Wi-Fi сети (что кушает очень много батарею)



**Подключение WPS** - многие люди прячут свои Wi-Fi сети, от публичного использования. Но могу с вами поделится своим уникальным именем или номером. По которому ваше устройство сможет подключиться к сети.



**Настройка прокси-сервера** - можно настроить доступ через прокси-сервер предприятия. На котором Wi-Fi открытый.







**Настройки Bluetooth:**



![](http://android-helper.com.ua/images/uploads/2012/03/device-2012-03-20-162914-200x300.png)







Тут все просто. Единственное что могу добавить. То это нужно поменять время видимости устройства. По умолчанию там стоит 2 мин.

</li>&ndash;&gt;-->
    <!--&lt;!&ndash;&ndash;&gt;-->
    <!--&lt;!&ndash;<li>Новости сайта{% youtube YMtKTooAyvk %}
Друзья всем привет.





Смотрю, что целый месяц мы ничего не писали для вас. Прошу меня извинить!





Этот месяц был полностью посвящен коуч группе. Что это такое возможно спросите вы?

<!-- more -->


Месяц назад был проведен вебинар, по заработку на android программах. Из этого вебинара подали заявки на участие 9 человек. Все они сейчас проходят обучение и буду в скором времени возвращать свои инвестиции.




{% youtube 0xGKIHkRF8Y %}




Что было сделано за этот месяц:








  1. Мы начали с самого начала



  2. Поработали с визуальным оформлением



  3. Выложили приложение на маркет [см. список](https://play.google.com/store/apps/developer?id=Android%20Studio%20Development%20Group&hl=ru)






А вот, то что нам написали наши учасники:





Григорий (Винница)





> 


> 
> _Месяц прошел быстро, но насыщено. Было очень интересно, прояснил для себя многие не совсем понятные моменты и самое главное удалось опубликовать свое первое приложение на маркете. Это очень мотивирует продолжать дальше. Не сомневаюсь что дальше будет еще интересней._
> 
> 







Александр





> 


> 
> _Да, первый месяц пролетел быстро ) Для себя в этом месяце открыл новые грани Андроида, узнал интересные нюансы. Продолжаем в том же духе. Дальше будет интересней )_
> 
> 







Василий





> 


> 
> _Ну что же, вот и прошёл месяц обучения. Для себя узнал много нового, и даже некоторые моменты, вроде бы ранее понятные, стали ещё более понятными, но уже на новом уровне. Спасибо преподавателю! Я записался на 2-й месяц обучения, и надеюсь что в таком ключе будем работать и дальше. По материалу 1-го месяца вопросов особо не было, но глядя на программу второго месяца понимаю, что вопросы обязательно появятся :)_
> 
> 


### Уважаемый читатель.





Обращаюсь к тебе, как к основному источнику моих идей и предложений.





Недавно мы организовали общий аккаунт (доступный только нашим подписчикам).





Думаю многим будет интересно, что же там такое есть в этом аккаунте.<!-- more -->





### Общий аккаунт





Большинство наших подписчиков и особенно тех людей которые проходят вебинар - “Android на 100%”, жалуются, что в PlayMarket есть программы которые стоят денег. Некоторые из них, не малых.





Так вот, мы подумали и решили, почему же не сделать один аккаунт и пополнять его купленными программами. Да-да вы не ошиблись, мы реально покупаем программы для этого аккаунта. Также мы подготовили небольшой список того, что уже куплено или планируется к покупке. [Список](http://android-helper.com.ua/premiumaccaount/)





### Как получить доступ?





Все очень просто, заходите [сюда](http://andrii.stakhov.justclick.ru/order/premium_account/), вводите этот номер: **AcPrAH200**. А дальше мы вам присылаем инструкции.





### ВАЖНО!





Но важно, то что нам нужна ваша помощь. Вы спросите скорее всего в чем. Так вот. Мы хотим покупать только те программы которые нужны нашим подписчикам. А не те, что считаем нужными. Так как общий аккаунт для вас, то и персонализация будет уместна.





Заполните пожайлуста вопросник ниже, с именами и ссылками на те программы которые вы хотели бы получить.





Рейтинг будет составлен на количестве повторений.





Спасибо за помощь.




Друзья привет.





Вот мы и сделали для своих друзей и читателей, рекламный ролик.





Прошу сделайте оценку и жду ваших комментариев!



{% youtube 0zJWhCQqCe0 %}








 
















Привет всем.





Вчера мы с вами посмотрели мега онлайн [трансляцию](http://android-helper.com.ua/google-io-2013/) от компании Google.





Сегодня можно посмотреть что делается за кулисами.





Думаю будет интересно.

<!-- more -->



Готовлю материалы по интересным программам.





На следующей неделе будет вебинар.

{% youtube 8kNNqcYgrsQ %}
20 апреля в Санкт-Петербурге [ITmozg](http://spb.itmozg.ru/) снова соберет на одной площадке новичков и профессионалов IT-рынка на ежегодном Фестивале профессионального развития — [BitByte](http://bitbyte.itmozg.ru/). 









![Bitbyte](http://www.droidnews.ru/wp-content/uploads/2013/03/bitbyte_logo_2013-600x242.jpg)


 <!-- more -->

  
   
В программе:  
— Две параллельные секции докладов, посвященные техническим и карьерным вопросам;  
— Выставка, где можно напрямую пообщаться с представителями IT-компаний, узнать о возможностях трудоустройства;  
— Много активностей: головоломки и тесты, розыгрыши и подарки, сюрпризы и еще много-много интересного :)













Среди компаний-участников: Google, Oracle, EMC, Яндекс.Деньги, Sperasoft, Mail. ru Group, T-Systems, Электрон и многие другие.





Участие бесплатное! Вход только по регистрации [http://bitbyte.itmozg.ru/register#form](http://bitbyte.itmozg.ru/register#form) 





Все подробности на сайте мероприятия: [http://bitbyte.itmozg.ru](http://bitbyte.itmozg.ru/)
Ну что, кто может сказать, когда мы уже, наконец, увидим следующую версию Android? Наверное, большинство из читателей скажет, что подобное событие произойдёт на мероприятии Google I/O. Во всяком случае об этом твердит большинство источников, и именно на это намекает прошлый опыт. Так что терпеливо ждём 15 мая.









![Эволюция Android](http://www.droidnews.ru/wp-content/uploads/2013/04/Android-5.0-Key-Lime-Pie-Rumors1-600x347.jpg)



 <!-- more -->




Однако, пока мы застыли в ожидании, давайте посмотрим, какие интересные слухи и догадки блуждают по Сети касаемо Android 5.0 Key Lime Pie.









Первое, о чем можно встретить упоминание — свежее ядро Linux версии 3.8. Любители перепрошиваться знают, насколько важно в системе грамотно собранное ядро. Ведь от него во многом зависит скорость работы мультитаскинга, оно может сильно влиять на расход заряда батареи, ядро же определит, сколько оперативной свободной памяти будет выделено пользователю. Так что у многих сейчас есть надежды, что оптимизация ядра поможет улучшить ситуацию вокруг некоторых давних проблем нашей любимой ОС.





Второй интересный слух про Kie Lime Pie гласит, что эта версия Android будет работать исключительно на четырёхъядерных устройствах. Однако, лично мне кажется, что такое развитие событий очень маловероятно. Вряд ли в Google решатся так сразу оставить огромное количество чуть менее современных устройств без обновления системы.





Куда более вероятным кажется, что в Key Lime Pie появится унифицированная Google-платформа для общения Google Babel, которая объединит в себе Google Talk, Google Plus, Google Voice.





Наверняка же к Android 5.0 обновится клавиатура, которая порадует нас более обширными словарями и улучшенными алгоритмами предугадывания вводимого текста.





Интересным остаётся вопрос, на каком именно устройстве нам продемонстрируют Key Lime Pie. Будет ли это Nexus 5 или же ожидаемый многими Motorola X Phone. Что вы думаете по этому поводу?





А вам какие из этих слухов кажутся максимально достоверными? Или какие наоборот — откровенной чепухой? Чего бы хотелось, чтобы подтвердилось?









 
Всем привет.





Продолжаем тему интервью.





И сегодня у меня в гостях, человек который поменял мишление и стиль жизни очень многих людей.


<!-- more -->


[Артем Мельник](http://artemmelnik.ru/) - являеться експертом №1 в области личной еффективности.





Вы спросите как же Артем попал ко мне в программу.





И вот что я вам скажу.





Однажды прочитав книгу "[Как работать по 4 часа в неделю и при этом не торчать в офисе "от звонка до звонка", жить где угодно и богатеть](http://www.bookzone.com.ua/Netshop/catalogue/catalogue_31123.html?part=11)" (**Тимоти Феррис**), я задался целью работать и отдыхать как Новые богатые.





И вот я начал копать просторы интернета и нашел сайт [Секреты новых богатых](http://nrsecrets.ru/) (автором и ведущим которого является [Артем Мельник](http://artemmelnik.ru/)).





Я пересмотрел все его видео, также нашел еще один его сайт по [личной еффективности](http://artemmelnik.ru/).





Но все это было только в одну сторону. И вот я написал Артему письмо.





В котором рассказал о себе и пригласил его себе в Винницу.





И к моему большому удивлению Артем принял мое приглашение. Но я подумал, что такие люди как он, никогда не приежают к своим зрителям. Но не тут то было. Артем через несколько дней написал, что будет в Украине и заедет ко мне.





Я долго думал, как же можно воспользоваться такой возможностью. И записал с ним видео интервью.





Смотрим!



{% youtube 6fHN1rISy7g %}





Жду ваши комментарии! А также если у вас есть вопросы к Артему. Я могу собирать их и записать еще одно видео.
Друзья всем привет.





Вот и пришел тот день, когда мы с большим удовольствием хотим вам представить, наше первое интервью, с директором IT компании.





Сегодня у меня в гостях замечательный человек и мой хороший друг **Андрей Ремовский**.


<!-- more -->


То что он являеться директором по развитию социальных игр в компании **Win Interactive**. Не мешает ему быть активным учасником не только разработок но и спортивных созтизаний.





Я очень надеюсь, что большая часть зрителей, увидет куда и как можно применить свои знания и навыки программирования под android.





Приятного вам просмотра.





Жду много, много лайков и комментариев.


{% youtube rTPENnY0Y2E %}





Компания «Доктор Веб» сделала обзор Android-угроз в 2012 году. С угрозами со стороны вредоносных программ ОС Android столкнулась практически с момента своего появления на рынке. И хотя многие пользователи поначалу восприняли этот факт скептически, постепенно их сомнения сменились обеспокоенностью за безопасность используемых мобильных устройств, так как число вредоносных приложений продолжало неуклонно расти. Прошедший 2012 год в этом плане не стал исключением.





Троянцы семейства [Android.SmsSend](http://www.ferra.ru/ru/soft/news/2011/08/30/Android-SmsSend/), появившиеся еще в 2010 году и быстро ставшие настоящей головной болю пользователей мобильных Android-устройств, по-прежнему являются наиболее распространенной и массовой угрозой для этой мобильной платформы. Эти вредоносные программы предназначены для отправки дорогостоящих SMS-сообщений и подписки абонентов на различные контент-услуги, что может повлечь за собой серьезные финансовые потери (при этом жертва даже не будет знать, что деньги списаны с ее счета). Чаще всего они распространяются под видом популярных игр и приложений, а также их обновлений, однако могут встречаться и другиAе каналы распространения.


 <!-- more -->


Учитывая возможности мобильных Android-устройств, а также принимая во внимание продолжающийся рост числа их пользователей, неудивительно, что проблема сохранности конфиденциальной информации становится все более ощутимой. Рискам в этой сфере подвержены все: как простые пользователи, так и представители коммерческого и государственного секторов. Ценные сведения, интересующие злоумышленников, могут быть самыми разнообразными.





Сами по себе вредоносные программы, шпионящие за пользователями и крадущие их конфиденциальную информацию, не уникальны и известны достаточно давно. Однако в 2012 году обозначилась четкая тенденция к появлению довольно специфической группы троянцев-шпионов, направленных против жителей Японии. Все они распространялись при помощи спам-писем, в которых пользователям предлагалось установить то или иное «полезное» приложение, начиная от эротической игры и заканчивая оптимизатором расхода аккумулятора.





Узконаправленные, точечные или таргетированные атаки несут в себе серьезную угрозу, поскольку они, в отличие от большинства обычных атак, направлены не на максимально возможное число пользователей, а на их ограниченный круг, что снижает вероятность оперативного и эффективного обнаружения используемых при преступлении вредоносных программ.





![Android-угрозы](http://www.ferra.ru/images/344/344982.jpg) 
[Android-угрозы](http://news.ferra.ru/photo/techlife/news/Dr-Web-Android-2012/1872/344982)





Применение подобных вредоносных программ никогда не было массовым явлением, в том числе и для устройств под управлением [Android](http://www.ferra.ru/ru/techlife/news/2013/01/28/Trend-Micro-Android-1000000/). В 2012 году мы стали свидетелями появления лишь нескольких новых представителей этого класса троянцев, направленных на мобильную операционную систему от Google. Ими стали [Android.SpyEye.2.origin](http://www.ferra.ru/ru/soft/news/2012/06/21/drweb-Android-SpyEye/), Android.Panda.2.origin, Android.SmsSpy.6.origin и Android.FakeSber.1.origin.





Потенциальную угрозу сохранности персональной информации продолжают нести и различные виды коммерческого программного обеспечения для мониторинга и шпионажа. В 2012 году было обнаружено значительное число не только новых модификаций уже известных программ, но и новые представители этого класса приложений.





На фоне общей массы вредоносных Android-приложений, направленных на получение той или иной материальной выгоды, [Android.Moghava](http://www.ferra.ru/ru/soft/news/2012/03/02/Android-Moghava/), обнаруженный весной 2012 года, держится особняком, будучи троянцем-вандалом. Он распространялся в модифицированной злоумышленниками версии приложения — сборника рецептов иранской кухни. Через определенные промежутки времени троянец выполнял на мобильном устройстве поиск JPEG-изображений в каталоге /DCIM/Camera/ и накладывал на них еще одно изображение. В результате этого фотографии пользователя безвозвратно портились.





По состоянию на конец 2012 года вирусные базы Dr.Web содержали почти 1300 записей для Android-угроз. С ростом популярности мобильных устройств под управлением ОС Android соответственно увеличивается число и разнообразие вредоносных приложений, представляющих опасность для пользователей этой платформы. Описанные выше типы угроз в 2012 году стали наиболее заметными, а также продемонстрировали потенциальный вектор развития вредоносных Android-программ в ближайшем будущем. Одновременно с этим могут появляться и вредоносные приложения, которые сочетают свойства самых разнообразных угроз или же являются «нестандартными» по сравнению с общей массой, что во многом повторяет ситуацию с Windows. Учитывая, что в ближайшие несколько лет мобильная платформа Android будет оставаться среди лидеров рынка, стоит ожидать дальнейшего роста числа созданных для нее вредоносных программ.





Источник [pcnews.ru](http://www.pcnews.ru/news/android-2012-smssend-2010-sms-google-spyeye-origin-panda-smsspy-fakesber-moghava-jpeg-dcim-camera-dr-web-1300-425558.html)
По последним данным агентства Strategy Analytics за 2012 год в мире было продано около 700 миллионов смартфонов, при этом 684 процента от этого количества составляли устройства на базе платформы [Android](http://androidnews.com.ua/), iOS получила 194 процента, а 122 процентов пришлось на другие программные платформы. Что касается производителей смартфонов, то лидирующие позиции в 2012 году остались за Apple и Samsung, как по уровню прибыли, так и по объемам продаж. По мнению аналитиков, именно эти две компании сегодня можно считать главными противоборствующими сторонами в мобильной индустрии, а противостояние Apple и [Google](http://androidnews.com.ua/other-news/2740-google-rabotaet-nad-android-ochkami.html) начало отходить на второй план. Также в Strategy Analytics обращают внимание на замедление темпов развития рынка смартфонов. К примеру, в 2011 году рост поставок смартфонов в мире составил 64 процента, а в прошлом только 43.
Привет друзья.





Вот и заканчивается 2012 год.





За этот год мы с вами очень много всего пережили:





Стартовал блог

<!-- more -->



Добавили больше 200 статей и видео





Записали вебинар





Стартовали рубрику интервью





Пережили конец света





Надеюсь, что 2013 год у всех вас будет более продуктивный чем 2012. Со своей стороны обещаю помощь и развитие.





А сейчас прошу к просмотру поздравления:

{% youtube KtKsjysq6SE %}


Друзья всем привет.





Сегодня хотел бы вам представить, замечательного человека - Артема Мельника.





[Артем Мельник](http://artemmelnik.ru/) - автор и ведущий программы ["Секреты Новых богатых"](http://nrsecrets.ru/).





Артем создал 2 сайта на которых он показывает людям, что можно жить не только ради работы.


<!-- more -->


Но и как перейти от работы к своему бизнесу.





Надеюсь вам понравиться. 





Лайки в социальные сети приветствуются!  :lol:


{% youtube 83PvPWGexZs %}






Пишем ваши отзывы и замечания!
Всем привет.





Сегодня я представляю вам старт новой рубрики.





Прошу к просмотру нового ролика.


{% youtube IayY3tl66RA %}


Если вам понравилось, расскажите друзьям!




Привет друзья.





Сегодня я записал видео, о том куда идет наш блог. 





И что от него можно ожидать.


 <!-- more -->


Надеюсь вам понравится и приятного просмотра.



{% youtube lmVWg9ftJAk %}





Расскажи своим друзьям. Возможно именно это они и искали!





![](http://android-helper.com.ua/images/uploads/2012/11/Концепция-развития-блога-1024x492.jpeg)



 
Продолжаем собирать интересные статьи.





На днях аналитики опубликовали сводную таблицу по рынку планшетов за 3 квартал этого года, где сравнивается общее количество планшетов на рынке, их популярность, а также динамика роста показателей по сравнению с предыдущим годом.





![](http://s.4pda.ru/wp-content/uploads/2012/10/tablets-480x332.jpg)



<!-- more -->





Итак, согласно последним полученным данным, Android стремительно набирает вес и установлен на 41,6% всех купленных планшетов, что на 12,1% больше значения предыдущего года, когда Android был установлен только на 29,2% "таблеток". В итоге, ОС от Google стремительно догоняет iOS от Apple, которая потеряла 7,8% по сравнению с 2011 годов и сейчас занимает 56,7%. Тем не менее, это большая часть рынка.





Однако, это не значит, что яблочных планшетов iPad стало меньше. Напротив, в 2012 году было приобретено на 2,9 миллионов устройств больше, чем в прошлом - целых 14 миллионов. Просто Android занял огромную нишу бюджетных планшетов с небольшой диагональю экрана, которую несколько лет не могла заполнить компания Apple. Всвязи с этим, ОС от Google показывает более высокие темпы роста как в процентном, так и в абсолютном соотношении: в 2012 году было продано более 10 миллионов планшетов, что больше почти на 5 миллионов больше, чем в прошлом.





Присутствие других игроков, кроме Google и Apple, на рынке, в общей картине, пока не заметно, но мы не сомневаемся, что к следующему году ситуация изменится вместе с выходом планшетов на Windows 8 и Windows 8 RT.





Что касается общего роста планшетов, то он замедлился более чем в 6,5 раз, по сравнению с временным промежутком 2010-2011. В этом году этот показатель составил 43,4%, в то время как в 2011 он был равен 288,6%. Оно и понятно - планшет уже окончательно перешёл из разряда девайсов "для гиков" в разряд устройств для повседневного использования. Так что, почти все, кто хотел купить планшет, уже сделали это, так что в дальнейшем ждать серьёзных скачков роста этого рынка не стоит.





Статья из сайта [4pda.ru](http://4pda.ru/2012/10/26/76248/)
Из последних новостей





Предлагаем вашему вниманию очередную подборку с ссылками на новости, интересные материалы и полезные ресурсы.  
![](http://habrastorage.org/storage2/c71/e2a/256/c71e2a2564068940c470cc5397ef9c49.png)  



<!-- more -->


### Горячая семерка














![](http://habrastorage.org/storage2/b7a/e2c/aa8/b7ae2caa8cf07084bbf46d89a8fbe15d.png)







### Прошедшие и будущие мероприятия октября














18 октября в Киеве [стартовала международная конференция IDCEE](http://habrahabr.ru/post/155337/), а сегодня [были названы победители конкурса стартапов](http://ain.ua/2012/10/19/98741). Недавно прошла Fronteers 2012 — лучшая конференция по клиентской разработке, с отчетом можно ознакомиться [здесь](http://tohtml.it/post/33822898596/fronteers2012). Также, на прошлой неделе проходила YAC, с которой уже стали доступны [видео докладов](http://events.yandex.ru/events/yac/2012/talks/#frontend). Кроме этого, намечается парочка интересных мероприятий: [Apple «покажет что-то» 23-го октября](http://www.overclockers.ru/hardnews/50140/Priglasheniya_na_meropriyatie_Apple_namechennoe_na_23_oktyabrya_uzhe_razoslany.html), а в конце месяца [Google скорее всего покажет новую версию Android](http://www.youhtc.ru/2012/10/novaya-versiya-android-v-konce-oktyabrya/)














![](http://habrastorage.org/storage2/247/739/e1b/247739e1b416af62303f69a48a14a456.png)







### Bootstrap














Проект Bootstrap продолжает оставаться в тренде среди веб-разработчиков. Отличную подборку всякого полезного для него можно найти в [этой статье](http://habrahabr.ru/post/154687/). Кроме этого, желающие могут ознакомиться с туториалом по созданию [адаптивной темы для WordPress с помощью Bootstrap](http://blog.teamtreehouse.com/responsive-wordpress-bootstrap-theme-tutorial)














![](http://habrastorage.org/storage2/262/844/666/26284466663a6ef243e812b97e20fd6c.png)







### Internet Explorer 10














Интересная статья, [где подробно можно прочесть о том, чего стоит ожидать от нового IE10](http://www.mobilexweb.com/blog/windows-8-surface-ie10-html5). А [здесь](http://timkadlec.com/2012/10/ie10-snap-mode-and-responsive-design/) можно ознакомиться с нюансами работы Responsive Design в Snap Mode. Плюс, ожидаем [предварительную верси. IE10 для Windows 7 к середине ноября](http://viennaos.net/articles/3252-predvaritelnaya-versiya-interner-explorer-10-poyavitsya-v-seredine-noyabrya.html)














![](http://habrastorage.org/storage2/084/60e/6e4/08460e6e482449212a697b8062ac9df8.png)







### Расширяем CSS














Препроцессоры становятся все популярней. [Эта статья покажет](http://ianstormtaylor.com/oocss-plus-sass-is-the-best-way-to-css/), на сколько гибкими могут стать таблицы стилей с использованием OOCSS + Sass. [Здесь можно посмотреть, как с помощью несложного SCSS-миксина грузить изображения для ретина-дисплеев](http://37signals.com/svn/posts/3271-easy-retina-ready-images-using-scss). Те, кто хорошо воспринимает на слух англоязычную информацию, могут открыть для себя [SassCast](http://sasscast.tumblr.com/) — подкаст на тему Sass. Ну, и напоследок загляните в[sassmeister](http://sassmeister.com/) — песочницу для работы с Sass/SCSS














![](http://habrastorage.org/storage2/1b4/866/b43/1b4866b439d67c0d8575aebf831026db.png)







### [Учебник jQuery для начинающих](http://habrahabr.ru/post/155107/)














Многие, кто начинал учить jQuery по русскоязычным ресурсам, не могли обойти стороной [сайт](http://anton.shevchuk.name/) Антона Шевчука, а некоторые даже начинали изучение со статей на этом сайте. Антон решился и [собрал все свои статьи из серии «jQuery для начинающих»](http://habrahabr.ru/post/155107/) в одном учебнике, который и представил на суд общественности.














![](http://habrastorage.org/storage2/f6f/062/60d/f6f06260dd80d8d31e7c4e107b461a43.png)







### Surface на подходе














[Microsoft раскрыла цены на Surface RT](http://habrahabr.ru/post/155001/) в [официальном магазине](http://surface.microsoftstore.com/store/msstore/Content/pbpage.Surface), по итогам чего [младшая модель Surface была распродана за сутки](http://itc.ua/news/microsoft-rasprodala-po-predvaritelnyim-zakazam-vse-planshetyi-surface-rt-tsenoy-499/). Тем временем Microsoft запускает на ТВ [новую рекламу Microsoft Surface](http://wpos.com.ua/microsoft-zapuskaet-na-tv-novuyu-reklamu-microsoft-surface.html) и[первый рекламный ролик Windows 8](http://www.3dnews.ru/software-news/636608/)














![](http://habrastorage.org/storage2/d6f/a12/f9c/d6fa12f9c1b7ef2e341b0771182a3a23.png)







### [Google StreetView приглашает побродить в одном из их датацентров](http://gagadget.com/other/2012-10-18-google_streetview_priglashaet_pobrodit_v_odnom_iz_ikh_datatsentrov)














В Google решили показать один из своих датацентров, находящийся в городе Ленуар. Теперь многие смогут убедиться, что креативные идеи в оформлении помещений айтишного гиганта используются не только в рабочих офисах и комнатах отдыха, но и в теж же датацентрах  
  






### ![](http://habrastorage.org/storage2/ba6/1d0/aa9/ba61d0aa90be53f9f7f44faeabb67e78.gif) Разработка












  * [Видео докладов c последнего YAC](http://events.yandex.ru/events/yac/2012/talks/#frontend)



  * [Подборка полезного для любителей Twitter Bootstrap](http://habrahabr.ru/post/154687/)



  * [Новая статья от Chris Coyier на smashingmagazine:](http://coding.smashingmagazine.com/2012/10/15/css-qa-4/) SVG Fallback, Vertical Rhythm, CSS Project Structure ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Нативная клиентская валидация для веб форм средствами браузеров](http://www.html5rocks.com/en/tutorials/forms/constraintvalidation/). Хорошо расписаны основные проблемы, возникающие при использовании html5 в формах для валидации ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Эффект разворачивания бумажной открытки](http://tympanus.net/Development/PFold/index3.html) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [LearnStreet — новый проект для интерактивного изучения JavaScript, Python, Ruby (в стиле CodeAcademy и khanacademy)](http://www.learnstreet.com/lessons/languages/javascript) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Создание параллакс-эффекта на примере простого урока](http://net.tutsplus.com/tutorials/html-css-techniques/simple-parallax-scrolling-technique/) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Как создать адаптивную тему для WordPress с помощью Bootstrap](http://blog.teamtreehouse.com/responsive-wordpress-bootstrap-theme-tutorial) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Как сделать Lazy-Loading для изображений на сайте](http://speckyboy.com/2012/10/18/how-to-create-lazy-loading-images-for-your-website/) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Использование мета тега viewport в неадаптивных шаблонах (перевод)](http://ruseller.com/lessons.php?rub=2&id=1560)



  * [Строим радиальный градиент средствами HTML5](http://www.script-tutorials.com/html5-radial-gradient/) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [HTML5 media and data URIs](http://www.iandevlin.com/blog/2012/09/html5/html5-media-and-data-uri) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [fbootstrapp](http://ckrack.github.com/fbootstrapp/) — фреймворк на основе bootstrap для создания iframe-приложений под фейсбук ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Подготовка к верстке адаптивных сайтов](http://davidwalsh.name/responsive-css) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Как переделать jQuery accordion на такой же, но на CSS3](http://www.script-tutorials.com/turn-jquery-accordion-into-css3-accordion/) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Sciter — встраиваемый HTML/CSS/scripting engine](http://habrahabr.ru/post/154697/)



  * [Готовим Sublime Text 2 для front-end](http://habrahabr.ru/post/154667/)



  * [SassCast](http://sasscast.tumblr.com/post/33342368483/in-this-episode-of-sasscast-we-sat-down-with-the) — подкаст, где ведущие разговаривают о Sass с Крисом Койером ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)










### ![](http://habrastorage.org/storage2/37d/ecd/fa7/37decdfa7563eab84a2a41fbf4690320.gif) CSS












  * [box-shadow vs. drop-shadow filter: полное сравнение](http://demosthenes.info/blog/598/boxshadow-property-vs-dropshadow-filter-a-complete-comparison) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Кнопки в Metro-стиле стиле Microsoft Windows 8 на CSS3](http://ace-subido.github.com/css3-microsoft-metro-buttons/index.html) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Ryan Seddon (css ninja) делится секретами работы с checkbox-ами](http://thecssninja.com/talks/ridiculous_checkboxes/) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [OOCSS + Sass = The best way to CSS](http://ianstormtaylor.com/oocss-plus-sass-is-the-best-way-to-css/) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Нестандартный подход к media queries](http://www.the-haystack.com/2012/10/17/nesting-media-queries/) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Flexbox – быстрый путь к раскладочному блаженству?](http://css-live.ru/articles/flexbox-bystryj-put-k-raskladochnomu-blazhenstvu.html)



  * [Загружаем изображения для ретина-дисплеев с помощью SCSS](http://37signals.com/svn/posts/3271-easy-retina-ready-images-using-scss) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Короткое видео на тему «Multiple Background Images with CSS»](http://blog.teamtreehouse.com/quick-tip-multiple-background-images-with-css) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Вращающееся меню на CSS](http://ruseller.com/lessons.php?rub=2&id=1563)










### ![](http://habrastorage.org/storage2/d72/076/bca/d72076bca6f7545c0633a6c4419d317c.gif) JavaScripts












  * [Pikaday](http://dbushell.com/2012/10/09/pikaday-javascript-datepicker/) — компонент для выбора даты ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [kwicks](http://devsmash.com/projects/kwicks) — симпатичный аккордеон ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [полезный апгрейд для табов на jQuery ui](http://jsfiddle.net/jasonday/fdhaS/embedded/result/)



  * [Учебник jQuery для начинающих](http://habrahabr.ru/post/155107/)



  * [Загрузчик модулей RequireJS](http://stepansuvorov.com/blog/2012/10/%D0%B7%D0%B0%D0%B3%D1%80%D1%83%D0%B7%D1%87%D0%B8%D0%BA-%D0%BC%D0%BE%D0%B4%D1%83%D0%BB%D0%B5%D0%B9-requirejs/)










### ![](http://habrastorage.org/storage2/7bc/3d0/d88/7bc3d0d883a49a00265feb7836c802aa.gif) Браузеры












  * [Предварительная версия IE10 для Windows 7 появится в середине ноября](http://viennaos.net/articles/3252-predvaritelnaya-versiya-interner-explorer-10-poyavitsya-v-seredine-noyabrya.html)



  * [Подробно о том, чего ожидать от нового IE10](http://www.mobilexweb.com/blog/windows-8-surface-ie10-html5), а также о том, [как в нем работает Responsive Design](http://timkadlec.com/2012/10/ie10-snap-mode-and-responsive-design/) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Internet Explorer для Xbox](http://habrahabr.ru/post/155073/)



  * [Проект Mozilla начал тестирование каталога приложений Firefox Marketplace для платформы Android](http://www.opennet.ru/opennews/art.shtml?num=35126)










### ![](http://habrastorage.org/storage2/63c/872/b21/63c872b219c18a3947a9d98a6bb6a345.gif) Новости












  * [Касперский работает над собственной ОС](http://eugene.kaspersky.ru/2012/10/16/secure-os-for-industrial-control-system-scada/)



  * [Apple приглашает на мероприятие, намеченное на 23 октября](http://www.overclockers.ru/hardnews/50140/Priglasheniya_na_meropriyatie_Apple_namechennoe_na_23_oktyabrya_uzhe_razoslany.html)



  * [IDCEE 2012 — день первый](http://habrahabr.ru/post/155337/)



  * [Названы победители конкурса стартапов на IDCEE-2012](http://ain.ua/2012/10/19/98741)



  * [В персональной поисковой выдаче Google появятся личные документы пользователя](http://habrahabr.ru/post/154949/)



  * [Google анонсировала новый Chromebook с чипом ARM по цене $249](http://itc.ua/news/google-anonsirovala-novyiy-chromebook-s-chipom-arm-po-tsene-249/)



  * [YouTube отказался от подсчета кликов для рейтинга популярности](http://habrahabr.ru/post/154671/)



  * [Google StreetView приглашает побродить в одном из их датацентров](http://gagadget.com/other/2012-10-18-google_streetview_priglashaet_pobrodit_v_odnom_iz_ikh_datatsentrov)



  * [Квартальный доход Microsoft достиг $16 млрд](http://itc.ua/news/kvartalnyiy-dohod-microsoft-dostig-16-mlrd/)



  * [Только ASUS и сама Microsoft осуществят 25 октября запуск планшетов Windows RT](http://www.3dnews.ru/news/636653/)



  * [Microsoft сообщила стоимость Surface RT на официальном сайте: от $500](http://habrahabr.ru/post/155001/), по итогам чего [младшая модель Surface была распродана за сутки](http://itc.ua/news/microsoft-rasprodala-po-predvaritelnyim-zakazam-vse-planshetyi-surface-rt-tsenoy-499/)



  * [Число одновременных пользователей Skype недавно превысило 45 млн](http://www.towave.ru/news/kolichestvo-polzovatelei-skype-prevysilo-45-mln-issledovanie.html)



  * [Проект Mozilla выпустил язык программирования Rust 0.4](http://www.opennet.ru/opennews/art.shtml?num=35097)










### ![](http://habrastorage.org/storage2/eb8/00e/9ef/eb800e9ef3b0e10e217087ef742628a3.gif) Сервисы












  * [Cacoo — сервис для создания диаграмм, вайрфреймов и т.д.](https://cacoo.com/) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [webink fontdropper — сервис-букмарклет, позволяющий применить к тексту любого сайту любой шрифт из целого набор библиотеки компании webink](http://www.webink.com/fontdropper) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Japonizer — генератор настраиваемых фоновых текстур в традиционном японском стиле](http://wanokoto.net/japonizes) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [sassmeister — песочница для работы с Sass](http://sassmeister.com/) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Сервис от Lea Verou для настройки контраста по стандартам WCAG 2.0](http://leaverou.github.com/contrast-ratio/) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)










### ![](http://habrastorage.org/storage2/eb8/00e/9ef/eb800e9ef3b0e10e217087ef742628a3.gif) Demo












  * [Atari перевели некоторые игры на HTML5](http://www.atari.com/arcade) и [как это происходило](http://youtu.be/J6QXRFuUSZs)










### ![](http://habrastorage.org/storage2/be5/3e4/256/be53e4256e771ad12bc412af8b30f91e.gif) Сайты с интересным дизайном и функциональностью












  * [Бодрый сайт-портфолио с простыми но эффектными анимационными переходами](http://www.worstprod.com/)



  * [exitzeroproject.org](http://www.exitzeroproject.org/) — современный сайт с нестандартной навигацией



  * [занимательный с любой точки зрения сайт](http://www.moma.org/interactives/exhibitions/2012/centuryofthechild/)



  * [woodwork.nl](http://woodwork.nl/) — сайт, где навигация выполнена в стиле sliding doors



  * [http://kikk.be/2012](http://kikk.be/2012/home.htm?lng=en/) — сайт для вестивая KIKK с симпатичным дизайном и интересной функциональностью










### ![](http://habrastorage.org/storage2/be5/3e4/256/be53e4256e771ad12bc412af8b30f91e.gif) Дизайн












  * [Evolution of Apple Ads 1975-2002](http://www.retronaut.co/2011/10/evolution-of-apple-ads-1975-2002/) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Скрытый смысл в действительно хороших логотипах](http://www.webdesignerdepot.com/2012/10/the-hidden-meaning-behind-really-good-logos/) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Mobile Design Details: Pull to Refresh](http://www.lukew.com/ff/entry.asp?1643) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Retro Style in Web Design](http://www.splashnology.com/article/retro-style-in-web-design/6771/) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Десять трюков для успешного создания меню в сайтах с адаптивным (responsive) дизайном](http://blog.usabilla.com/10-tips-how-to-handle-responsive-navigation-menus-successfully/) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Очень наглядный урок о создании бесшовной текстуры в фотошопе](http://www.proworks.com/blog/2012/10/18/how-to-create-a-seamless-pattern-in-photoshop/) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Создание в фотошопе 3D текста с креативным эффектом](http://www.webdesignfact.com/2012/10/photoshop-tutorial-3d-text-effects.html) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Создание разбалансированности: использование асимметрии в веб-дизайне](http://tympanus.net/codrops/2012/10/18/creating-off-center-balance-using-asymmetry-in-web-design/) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Новые техники кадрирования в фотошопе последней версии «Crop Until You Drop»](http://psd.tutsplus.com/tutorials/tools-tips/crop-until-you-drop/) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Тест на знание Photoshop CS6](http://psd.tutsplus.com/articles/quizzes/test-your-photoshop-cs6-knowledge-4/) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Техники UI при создании успешных цифровых продуктов](http://dzineblog.com/2012/10/user-interface-techniques-for-creating-successful-digital-products.html) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)










### ![](http://habrastorage.org/storage2/be5/3e4/256/be53e4256e771ad12bc412af8b30f91e.gif) Подборка бесплатных дизайнерских печенек












  * [Пять десятков шрифтов: от Sacred Place и до Kenyan Coffee](http://www.antsmagazine.com/fonts/50-fresh-free-fonts-for-download/) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Три с половиной десятка декоративных шрифтов: от Astonished в стиле гранж и до рукописного BudHand](http://www.1stwebdesigner.com/freebies/35-cool-free-fonts/) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Пакет из одиннадцати хэллоуниских шрифтов](http://www.pvmgarage.com/2012/10/11-free-creepy-halloween-fonts/) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Необычный декоративный шрифт без засечек Slinkster, в котором буквы создаются окружностями задающими форму](http://www.myfonts.com/fonts/will-ryan/slinkster/) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Исходники в PSD-формате различных вертикальных меню](http://designerves.com/article/free-vertical-menu-psd-files/) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [PSD с UI для веб-дизайна в золотых цветах с темным фоном](http://www.pixel-fabric.com/dark-gold-ui-kit-4) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Набор различных переключателей в PSD](http://www.graphicsfuel.com/2012/10/toggle-switches-ui-elements-psd/) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [За подписку предлагается пакет с iPhone UI темой для быстрого создания приложений](http://medialoot.com/item/free-iphone-app-template-appview/) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Хорошо структурированная 55Мб PSD-шка «iOS 6 iTunes & App Store GUI»](http://playground.christophebeghin.fr/ios6/) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Пакеты с Photoshop Actions для создания винтажных фото-эффектов](http://www.1stwebdesigner.com/freebies/40-free-photoshop-actions-vintage-effect/) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)










### ![](http://habrastorage.org/storage2/cc0/d6f/fe8/cc0d6ffe8d4e924a9bf96ab304d98fa0.gif) Занимательное












  * [Впечатляющая инфографика: Свежий взгляд на HTML5](http://www.script-tutorials.com/infographic-a-fresh-look-at-html5/) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Несколько интересных особенностей Windows 8](http://habrahabr.ru/post/155379/)



  * [Fronteers 2012 — лучшая конференция по клиентской разработке, часть 1](http://tohtml.it/post/33822898596/fronteers2012)



  * [diy.org — образовательный портал для детей и не только, которые хотят что либо сделать](https://diy.org/) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Подборка сервисов для расширения возможностей вашего Dropbox](http://habrahabr.ru/post/154993/)



  * [10 наиболее активных стран в Facebook](http://ain.ua/2012/10/16/98309)



  * [Акустический штрих-код прост и универсален](http://www.3dnews.ru/news/636640/)



  * [Три рекламных ролика ASUS PadFone 2](http://www.3dnews.ru/news/636704/)



  * [Уличная реклама Microsoft Surface появилась и во Франции — намёк на запуск в Европе](http://www.3dnews.ru/news/636600/)



  * [Internet Explorer 9 Commercial (Google Chrome Version) ](http://www.youtube.com/watch?v=J-HieaOI00s&feature=player_embedded)![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Видео дня: первая телевизионная реклама Microsoft Surface](http://wpos.com.ua/microsoft-zapuskaet-na-tv-novuyu-reklamu-microsoft-surface.html) и [первый рекламный ролик Windows 8](http://www.3dnews.ru/software-news/636608/)






  
  
[Ссылка](http://habrahabr.ru/company/zfort/blog/154633/) на дайджест за прошлую неделю.  
Материал подготовили [dersmoll](http://habrahabr.ru/users/dersmoll/) и [alekskorovin](http://habrahabr.ru/users/alekskorovin/)





Статья из сайта [habrahabr.ru](http://habrahabr.ru/company/zfort/blog/155431/)





От себя хочу выразить благодарность за такой труд.
Добрый день друзья.





Много времени было затрачено, на изготовление данного курса.





Надеюсь вам он очень понравиться и поможет.





И так приступим.


<!-- more -->


**Тема курса:** Пошаговая инструкция для Android





**Формат курса:** Видео.





**Содержание курса:**








1. Регистрация в Google
2. Создание новых контактов
3. Установка русского языка на телефон
4. Добавление google account в телефон
5. Синхронизация с серверами Google
6. Работа с контактами, почтой и календарем
7. Google Play - установка и удаление программ
8. 5 нужных программ
9. Установка музыки на звонок
10. Использование Google Talk или замена ICQ
11. Что делать когда ваш телефон тормозит? 






1. **Регистрация в Google**

{% youtube QleZZheJJE8 %}


2. **Создание новых контактов**

{% youtube _Gvp_3nBHsQ %}


3. **Установка русского языка на телефон**

{% youtube vj9fHNutl3 %}


4. **Добавление google account в телефон**

{% youtube UqTKVR3c34A %}


5. **Синхронизация с серверами Google**


{% youtube ah-RGWmm0Sw %}








6. **Работа с контактами, почтой и календарем**

{% youtube LPkgRf_FJro %}









7. **Google Play - установка и удаление программ**

{% youtube vHZz299UCF0 %}









8. **5 нужных программ**

{% youtube 1fB7bIMxsag %}









9. **Установка музыки на звонок**


{% youtube IsoBTiT3Jv4 %}








10. **Использование Google Talk или замена ICQ**

{% youtube lma-EzSgCYs %}









11. **Что делать когда ваш телефон тормозит?**

{% youtube _Gvp_3nBHsQ %}





Надеюсь, что вам понравилась наш тренинг.





Приглашайте друзей и освоим android вместе.
Добрый день.





Сегодня нашел очень интересную новость для владельцев android устройств.





Сегодня появились первые более-менее конкретные сведения о том, что нас ждёт в версии Android 4.2. Информацию предоставили хорошо осведомлённые Android-инсайдеры, которые в прошлом уже доказали, что им можно доверять. Что ж, давайте посмотрим, что нового появится в Android 4.2.





![](http://s.4pda.ru/wp-content/uploads/2012/10/nexus-480x360.jpg)









**Последняя информация о Nexus**





Прежде всего, скажем пару слов о линейке Nexus, новости о которой появляются по несколько раз в день. Согласно последним сведениям, они должны будут иметь определённые (стоит предполагать, довольно высокие) технические характеристики для запуска эксклюзивных "Nexus games". Кроме того, обязательным для всех устройств будет модуль NFC для совершения платежей с помощью Google Wallet.





Также стало известно, что производителям будет не обязательно использоваться слово "Nexus" в названии своих моделей, а сам Nexus станет скорее программой сертификации Google Android-устройств.





**Новый центр персонализации**





Одним из главных новшеств в Android 4.2 станет появление центра персонализации, который поможет быстро настраивать внешний вид и звуки устройства. Но, самым интересным является не это, а возможность использования шаблонов для быстрой кастомизации всего устройства. Нечто подобное сейчас предлагает оболочка от HTC, Sense. В ней эта функция называется "Обложки".





Интересным моментом является то, что хотя и Nexus будут обязаны иметь чистый интерфейс Android, распространение фирменных оболочек будет возможным как раз с помощью этих самых шаблонов. Однако, если выйдет новая версия Android, а оболочка её не поддерживает, то устройство будет обновлено, а скин возвращён к исходному от Android. Таким образом мы подошли к самому главному - устройства Android теперь можно будет обновлять без ожидания, пока производитель оптимизирует оболочку. Это огромный рывок вперёд и радостная новость для всех без исключения пользователей Android.





**Другие новшества**





Google Play получит обновление, в котором будет персонализированный поиск, больше рекламных кампаний (что очень часто бывает полезно для пользователей) и больше возможностей для оплаты приложений. Google Now сможет помогать в работе с устройством. Например, вы сможете спросить цифрового помощника о том, как настроить беспроводную точку доступа. Наконец, встроенный видеоплеер будет улучшен, будут внедрены новые api для интеграции со сторонними сервисами.





Конечно, пока это всего лишь слухи, но в нашем деле именно они зачастую оказываются правдой. Что вы думаете об улучшениях в новой версии Android?





Статья взята из [4pda.ru](http://4pda.ru/2012/10/06/73897/#more-73897)





Если вам понравилось, пишите свои комментарии. И подписывайтесь к нам на рассылку.
Привет всем.





Сегодня мы попали в самые популярные социальные сети:


<!-- more -->


[ВКонтакте](http://vk.com/androidhelper)





[Facebook](http://www.facebook.com/AndroidHelper)





[Google+](https://plus.google.com/109843462745343604592?prsrc=3)





[Twiter](https://twitter.com/HelperAndroid)
</li>&ndash;&gt;-->
    <!--&lt;!&ndash;&ndash;&gt;-->
    <!--&lt;!&ndash;<li>Программы для androidДрузья всем привет.

Есть хорошие новости. Skype дарит премиум подписку на целый год. Спеши времени осталось мало!

Подробности ниже.

Да, вам не показалось. Именно сейчас можно получить премиум подписку на целый год.

<!-- more -->

#### Что нужно сделать?

1. Переходим по [ссылке](https://collaboration.skype.com/promotion/).
2. Воодим свой емейл (на него вы получите активационный код)
3. Далее переходи на [skype.com/go/voucher](http://skype.com/go/voucher)
4. Воддим свой логин/пароль
5. Вставляем код который вы получили по почте.
6. Наслаждаемся преимумом

#### Что дает преимум?
	
1. Бесплатные голосовые и видеозвонки между абонентами Skype
2. Низкие тарифы на звонки на обычные телефоны
3. Групповые звонки
4. Обмен мгновенными сообщениями
5. Видеопочта
6. Групповая видеосвязь
7. Групповая демонстрация экрана
8. Отсутствие рекламы
9. Поддержка клиентов в формате чата
10. Неограниченные звонки в любую страну на ваш выбор

- Стационар и мобильный:
-- США
-- Канада
-- Гонконг
-- Сингапур

- Стационар:
-- Аргентина
-- Австралия
-- Австрия
-- Бельгия
-- Чили
-- Хорватия
-- Чешская Республика
-- Дания
-- Эстония
-- Финляндия
-- Франция
-- Германия
-- Греция
-- Венгрия
-- Ирландия
-- Израиль
-- Италия
-- Япония
-- Южная Корея
-- Люксембург
-- Мексика (Гвадалахара, Мехико, Монтеррей)
-- Нидерланды
-- Новая Зеландия
-- Норвегия
-- Польша
-- Португалия
-- Россия (только Москва и Санкт-Петербург)
-- Словакия
-- Испания
-- Швеция
-- Швейцария
-- Великобритания

Расскажите вашим друзьям. Общайтесь и будте ближе!### Уважаемый читатель.





Обращаюсь к тебе, как к основному источнику моих идей и предложений.





Недавно мы организовали общий аккаунт (доступный только нашим подписчикам).





Думаю многим будет интересно, что же там такое есть в этом аккаунте.<!-- more -->





### Общий аккаунт





Большинство наших подписчиков и особенно тех людей которые проходят вебинар - “Android на 100%”, жалуются, что в PlayMarket есть программы которые стоят денег. Некоторые из них, не малых.





Так вот, мы подумали и решили, почему же не сделать один аккаунт и пополнять его купленными программами. Да-да вы не ошиблись, мы реально покупаем программы для этого аккаунта. Также мы подготовили небольшой список того, что уже куплено или планируется к покупке. [Список](http://android-helper.com.ua/premiumaccaount/)





### Как получить доступ?





Все очень просто, заходите [сюда](http://andrii.stakhov.justclick.ru/order/premium_account/), вводите этот номер: **AcPrAH200**. А дальше мы вам присылаем инструкции.





### ВАЖНО!





Но важно, то что нам нужна ваша помощь. Вы спросите скорее всего в чем. Так вот. Мы хотим покупать только те программы которые нужны нашим подписчикам. А не те, что считаем нужными. Так как общий аккаунт для вас, то и персонализация будет уместна.





Заполните пожайлуста вопросник ниже, с именами и ссылками на те программы которые вы хотели бы получить.





Рейтинг будет составлен на количестве повторений.





Спасибо за помощь.




Всем привет.





Вот список того, что будет и есть в общем аккаунте:


<!-- more -->


[Moon+ Reader Pro](https://play.google.com/store/apps/details?id=com.flyersoft.moonreaderp) - **Купленно**





[Asphalt 7: Heat ](https://play.google.com/store/apps/details?id=com.gameloft.android.ANMP.GloftA7HM)- **Купленно**





[Tasker](https://play.google.com/store/apps/details?id=net.dinglisch.android.taskerm&feature=apps_topselling_paid)





[ROM Manager (Premium)](https://play.google.com/store/apps/details?id=com.koushikdutta.rommanager.license&feature=apps_topselling_paid)





[Smart Tools](https://play.google.com/store/apps/details?id=kr.aboy.tools&feature=apps_topselling_paid)





[World of Goo](https://play.google.com/store/apps/details?id=com.twodboy.worldofgoofull&feature=apps_topselling_paid)





[Fruit Ninja](https://play.google.com/store/apps/details?id=com.halfbrick.fruitninja&feature=apps_topselling_paid)





[Titanium Backup PRO Key ★ root](https://play.google.com/store/apps/details?id=com.keramidas.TitaniumBackupPro&feature=apps_topselling_paid)





[Poweramp Full Version Unlocker ](https://play.google.com/store/apps/details?id=com.maxmpz.audioplayer.unlock)- **Купленно**
Друзья всем привет.





Сегодня речь пойдет о замечательной среде разработки Android Studio.





Когда мы транслировали в прямом эфире [I\O 2013](http://android-helper.com.ua/google-io-2013/), многие из вас увидели хорошую программу для разработки и даже было несколько слов о ней сказано.





Сегодня я постараюсь сделать небольшой обзор того, почему же она вызвала такой фурор.


<!-- more -->


### Видео





Ну что глянем сначала видео?





{% youtube uWnhrW-Gu0U %}



### Краткое описание








  1. Когда я первый раз ее запустил, то увидел, что основы этой студии идут от очень хорошего продукта для разработки Intellij.






![Android studio - Начало](http://android-helper.com.ua/images/uploads/2013/05/as1.jpg)





2. Структура проекта отличается от той которую использует Eclipse.



![Android studio - Структура](http://android-helper.com.ua/images/uploads/2013/05/as3.jpg)
Android studio - Структура



### А теперь начинаются самое интересное.








  1. 



Начнем с малого. Каждый из вас думал какой цвет ему использовать в своей программе. Придумал выбрал в редакторе, вставил в код и потом на другой день просто забыл или это синий или голубоватый. Я думаю так бывало с каждым. Но эту проблему решили. ![Android studio - Цвета](http://android-helper.com.ua/images/uploads/2013/05/as2.jpg)







  2. 



Следующим по очереди идет java код. К примеру я покажу **MainActivity.java**. И дам каждому пункту описание. ![Android studio - MainActivity](http://android-helper.com.ua/images/uploads/2013/05/as4.jpg)






    1. Теперь если мы пишем для **ImageView** _setImageResource(R.drawable.bla-bla)_, то у нас слева будет показан ресурс который мы используем.



    2. Теперь не нужно переходить в **strings.xml**, что бы посмотреть какая строка у вас будет в конкретном **TextView**. Студия сама покажет вам строку. А также может показать для какого языка она не переведена.



    3. Что я заметил, так это светло-желтый цвет выделения одного из запросов. Мне стало интересно почему. Когда я навел на него мышку, то увидел, что мне подсказывает возможный **NullPointerException**. И это очень порадовало. Так как много багов потом появляется просто из-за того, что ты забыл поставить проверку.






  3. 



Еще одним замечательным свойством, есть просмотр того, что вы сделали в вашем дизайне. Это значит, что теперь с помощью одной команды вы сможете увидеть ваш layout на всех устройствах. Очень удобно. ![Android studio - Просмотр на устройсвах](http://android-helper.com.ua/images/uploads/2013/05/as5.jpg)







  4. 



Еще одним бесспорным моментом является то, что теперь сборка ваших проектов работает намного быстрее.







  5. 



Intellij всегда брала тем, что у нее очень много полезных советов для правильного и главное быстрого написания кода.







  6. Но есть и несколько недостатков. Но это все исправляют и они не существенны.






### Завершение





Надеюсь вам понравилась статья. Если кто то, что нарыл нового в студии, то пишите, буду обновлять статью.
### Что это?





Привет друзья. Каждый из вас слышал о компании **Яндекс**. Возможно даже некоторые слышали о сервисе **Яндекс.Музыка**.





Год назад, компания **Яндекс** впервые запустила мобильную версию своего сервиса для iOS.


 <!-- more -->


### Что это дало?





А дало это много. Во-первых, у пользователей мобильных платформ, появился хороший плеер как для локальных файлов, так и для **Яндекс.Музыки**. Во-вторых, в следующих версиях появилась возможность слушать радио. И еще одним большим плюсом стала возможность искать понравившуюся песню с помощью звука.





### И что дальше?





Так как пользователи iOS были очень довольны, а пользователям Android ничего не попало. Компания Яндекс решила создать и приложение под Android. И вот сегодня это приложение попало в сеть. Какое преимущество получили пользователи Android.





### Основные возможности








  1. 



Первое что попадает в глаза, это хороший и качественный интерфейс.







  2. Возможность слушать:




    * Локальные файлы



    * Музыку с Яндекс.Диска



    * Музыку с Яндекс.Музыки (плейлисты)








  3. 



Осуществлять поиск по огромнейшей базе Яндекс каталога.







  4. 



Поиск по звуковому фрагменту. Просто приставьте телефон к играющему устройству.







  5. 



Еще одно преимущество, это возможность слушать Радио. Его можно прослушивать как из меню, так и по исполнителю. А также можно сохранить себе на телефон.







  6. 



Что порадовало, так это когда ты нашел трек, то по треку можно открыть альбом в котором он есть, либо артиста. И увидеть список треков из альбома, либо от артиста.







  7. 



Для тех кто постоянно в дороге, а свою музыку он хочет слушать везде. Можно сохранить всю вашу музыку на телефон и слушать ее оффлайн.







  8. 



Из меню “Что нового?” можно следить за последними новинками и популярными песнями.







  9. 



В настройках можно указать куда кешировать и сохранять ваши треки.







  10. 



Легальность всей музыки.







  11. 



Порадовало, что когда делаешь подписку, то приложение с полным функционалом можно использовать целый месяц бесплатно и только в следующем месяце снимут 5$.










### Моя оценка





Все просто супер. Есть несколько недостатков, но я думаю, что руководство и разработчики это все быстро исправят. А также ждем версию под планшеты.





### Скачать





[![Get it on Google Play](https://developer.android.com/images/brand/ru_generic_rgb_wo_60.png)](https://play.google.com/store/apps/details?id=ru.yandex.music) 





![ymqr](http://android-helper.com.ua/images/uploads/2013/05/ymqr.png)





### Экраны





![ym18](http://android-helper.com.ua/images/uploads/2013/05/ym18-576x1024.png)
![ym17](http://android-helper.com.ua/images/uploads/2013/05/ym17-576x1024.png)
![ym16](http://android-helper.com.ua/images/uploads/2013/05/ym16-576x1024.png)
![ym15](http://android-helper.com.ua/images/uploads/2013/05/ym15-576x1024.png)
![ym14](http://android-helper.com.ua/images/uploads/2013/05/ym14-576x1024.png)
![ym13](http://android-helper.com.ua/images/uploads/2013/05/ym13-576x1024.png)
![ym12](http://android-helper.com.ua/images/uploads/2013/05/ym12-576x1024.png)
![ym11](http://android-helper.com.ua/images/uploads/2013/05/ym11-576x1024.png)
![ym10](http://android-helper.com.ua/images/uploads/2013/05/ym10-576x1024.png)
![ym9](http://android-helper.com.ua/images/uploads/2013/05/ym9-576x1024.png)
![ym8](http://android-helper.com.ua/images/uploads/2013/05/ym8-576x1024.png)
![ym7](http://android-helper.com.ua/images/uploads/2013/05/ym7-576x1024.png)
![ym6](http://android-helper.com.ua/images/uploads/2013/05/ym6-576x1024.png)
![ym5](http://android-helper.com.ua/images/uploads/2013/05/ym5-576x1024.png)
![ym4](http://android-helper.com.ua/images/uploads/2013/05/ym4-576x1024.png)
![ym3](http://android-helper.com.ua/images/uploads/2013/05/ym3-576x1024.png)
![ym2](http://android-helper.com.ua/images/uploads/2013/05/ym2-576x1024.png)
![ym1](http://android-helper.com.ua/images/uploads/2013/05/ym1-576x1024.png)
Всем привет.





Вот и закончились славные дни Google I/O.





Теперь я и моя команда будем по немногу делать описание всего того, что можно было увидеть на этой конференции.





Сегодня я вам расскажу о замечательной программе **Hangouts**.


<!-- more -->


Чем же она так понравилась пользователям и почему я сам ею пользуюсь, это все вы узнаете далее.




### История





Несколько лет назад, когда я еще работал в одной из Винницких ИТ компаний. Наш заказчик очень активно использовал сервисы Google в своей работе. И мне всегда было интересно почему?





И вот прошло некое количество времени и мне попал в руки первый смартфон на базе любимой нами системы android. И первое что я увидел, это был сервис Google Talk. Почему я его увидел первым. Все было из-за того, что с заказчиками мы общались исключительно в нем. И он мне показался очень легким и классным. И к тому же не садя батарею, я мог переписываться с женой.





Несколько месяцев назад я узнал об хорошей программе WhatsApp. Она позволяла вести переписку не только с android устройствами но и iOS.





И тут в первый день презентации, компания Google представила замечательную программу **Hangouts**. Вот об этой программе мы сегодня и поговорим.





### Описание





Что же она может делать? Спросите вы. А вот что.








  1. Видео звонки до 10 человек



  2. Вести переписку со своими друзьями, как с одним так и с многими



  3. Отправлять фото



  4. Выставить режим когда вас не беспокоить



  5. Около 255 смайлов



  6. Есть версии для Android, iOS, Web client.






Ребята, очень рекоммендую.





Кто поставит, можете меня добавить в чат. Пообщаюсь с большим удовольствием. Наша группа на [Google+](https://plus.google.com/b/109843462745343604592/109843462745343604592/posts). Там вы можете найти мой акаунт. :)





### Установка





Скачать вы можете по [ссылке](http://www.google.com/+/learnmore/hangouts/).





### Экраны





![Screenshot_2013-05-15-23-39-47-576x1024](http://android-helper.com.ua/images/uploads/2013/05/Screenshot_2013-05-15-23-39-47-576x1024.png)





![google-hangouts-7](http://android-helper.com.ua/images/uploads/2013/05/google-hangouts-7-576x1024.jpg)




 





![google-hangouts-6](http://android-helper.com.ua/images/uploads/2013/05/google-hangouts-6-576x1024.jpg)




 





![google-hangouts-5](http://android-helper.com.ua/images/uploads/2013/05/google-hangouts-5-576x1024.jpg)




 





![google-hangouts-4](http://android-helper.com.ua/images/uploads/2013/05/google-hangouts-4-576x1024.jpg)




 





![google-hangouts-3](http://android-helper.com.ua/images/uploads/2013/05/google-hangouts-3-576x1024.jpg)




 





![google-hangouts-2](http://android-helper.com.ua/images/uploads/2013/05/google-hangouts-2-576x1024.jpg)




 





![google-hangouts-1](http://android-helper.com.ua/images/uploads/2013/05/google-hangouts-1-576x1024.jpg)### Цель





Найти качественные программы для вашего бизнеса и вообще для работы.


<!-- more -->


### Ресурсы





[Видео-интервью](http://nrsecrets.ru/hodchenkov-2/) Артема Мельника и Евгения Ходченкова. Рекомендую к просмотру, тем кто хочет изменить свою жизнь.





### Видео обзор



{% youtube FMOwtZT8k6c %}





### Установить программы








  1. [Family Mobile](https://play.google.com/store/apps/details?id=com.familymobile)



  2. [Mindjet Maps for Android](https://play.google.com/store/apps/details?id=net.thinkingspace)



  3. [Any.DO To Do List | Task List](https://play.google.com/store/apps/details?id=com.anydo)



  4. [Evernote](https://play.google.com/store/apps/details?id=com.evernote)



  5. [Dropbox](https://play.google.com/store/apps/details?id=com.dropbox.android)



  6. [Английский с Лео](https://play.google.com/store/apps/details?id=com.lingualeo.android)



  7. [Скорочтение](https://play.google.com/store/apps/details?id=com.heku.readingtrainer)



  8. [uPackingList](https://play.google.com/store/apps/details?id=com.nixsolutions.upack)



  9. [Skyscanner - All Flights!](https://play.google.com/store/apps/details?id=net.skyscanner.android.main)



  10. [Passbook for Android](https://play.google.com/store/apps/details?id=org.ligi.ticketviewer)



  11. [RoboForm](https://play.google.com/store/apps/details?id=com.siber.roboform)



  12. [TED](https://play.google.com/store/apps/details?id=com.ted.android)



  13. [Aston Forex Mobile Trader](https://play.google.com/store/apps/details?id=com.astonforex.mobile)



  14. [Bump](https://play.google.com/store/apps/details?id=com.bumptech.bumpga)






### Заключенние





Надеюсь вам понравился обзор. Жду от вас предложений по интересующим вас программам.





### Благодарность





Тем кто хочет, что бы такой информации было больше, нажмите на все социальные кнопки. И пусть все ваши друзья узнают об этом обзоре.
Сервис Яндекс.Такси работает в Москве уже с октября 2011 года. За это время его отшлифовали и усовершенствовали. Среди конкурентов у Яндекса самая большая база машин, около 10000. Время подачи такси в среднем становит 10 минут. Очень хороший показатель, если учесть московские пробки. Таксопарк постоянно растет пока и улучшается. Кроме Москвы и Питера готовится к запуску и пока работает в тестовом режиме такси сервис от Яндекса в следующих городах: Воронеже, Вологде, Казани и Красноярске.![заказать такси в Санкт-Петербурге с помощью телефона Андроид](http://androidstory.org/wp-content/uploads/2013/03/Taxi-Yandex.jpg)Сервис Яндекс.Такси в Санкт-Петербурге, в отличие от Москвы, сразу показывает при вызове машины стоимость поездки. Стоимость не зависит от время простоя в пробках,которые не так критичны как в столице. С помощью [андроид приложения](https://play.google.com/store/apps/details?id=ru.yandex.taxi&hl=uk) вы можете вызвать такси в Санкт-Петербурге нажав несколько кнопок, нет необходимости звонить и объяснять ваше местоположение. Телефон сам через GPS передаст координаты, а вызывающему сообщит марку и цвет машины, имя водителя, время подачи и точную стоимость поездки.





На сегодняшний день подключены 3 таксопарка Питера, количество автомобилей 1300 штук. Яндекс обещает развивать сервис, увеличивать количество машин и качество обслуживания.
О чём вы обычно думаете, когда срочно необходимо подключиться к интернету? Интернет-кафе ещё надо найти, а домой или на работу идти нет времени. В таких случаях мы часто вспоминает о бесплатном WiFi! Бесплатных WiFi точек в крупных городах сейчас очень и очень много. Они есть в кафе, ресторанах, салонах красоты, вокзалах и других общественных местах.









![Hotspotlist](http://www.droidnews.ru/wp-content/uploads/2013/03/hotspotlist_1-600x498.jpg)




<!-- more -->




Приложение Hotspotlist поможет вам найти ближайшую место, где вы сможете бесплатно подключиться к интернету через WiFi. В базе WiFi точек проекта Hotspotlist уже есть десятки городов России и СНГ и их число увеличивается с каждым днём.









Проект Hotspotlist использует модель краудсорсинга, когда часть функций передаётся сообществу пользователей. Самый известный краудсорсинговый проект — Википедия. На сегодняшний день Википедиа является самой большой, пускай и не очень достоверной, общедоступной энциклопедией.





В рамах проекта Hotspotlist на сообщество возложена задача по добавлению на карту новых WiFi точек доступа. Участники проекта запускают в приложении режим сканирования и двигаются по привычному или новому маршруту.





Приложение в это время сканирует окружающее пространство на наличие сигнала WiFi точек. Hotspotlist собирает информацию о точке WiFi (название, координаты, метод шифрования и т.д. ) и отправляет её на сервер проекта. На серверах Hotspotlist эти данные обрабатываются и наносятся на карту. После чего уже обработанная информация становится доступа всем пользователям программы, а также посетителям сайта. Если вас волнует расход мобильного трафика, то для его экономии можно настроить синхронизацию только через WiFi подключение.









![Hotspotlist](http://www.droidnews.ru/wp-content/uploads/2013/03/hotspotlist_3-281x500.jpg)









Часто во многих кафе приходится ждать долго официанта с “паролем на бумажке”. И это лишь ради доступа к бесплатному WiFi в этом заведении. С помощью приложения Hotspotlist можно поделиться паролем с остальными участниками проекта. Благодаря этому кому-то не придётся “ждать” и они смогут подключиться к WiFi нажатием одной кнопки. Иногда, услышав о такой возможности, пользователи опасаются, что программа украдёт все их пароли от WiFi. Эти опасения беспочвенны, так как ОС Android не позволяет приложениям получить пароль от сохранённых в устройстве WiFi сетей. Только если вы сами введёте пароль в приложении и нажмёте кнопку “Поделиться”.





Важным преимуществом Hotspotlist является использование карт OpenStreetMap, ещё одного крупнейшего краудсорс-проекта. В большинстве случаев карты OpenStreetMap оказываются более детальными и точными, чем аналогичные решения корпораций (Google, Яндекс, Bing). Плюс еще один бонус от использования OpenStreetMap — работа в офлайне-режиме. Уезжая в другой регион или страну вы всегла можете рассчитывать на полностью оффлайновым справочник “бесплатного WiFi” в вашем устройстве. Для этого необходимо лишь предварительно загрузить нужную оффлайн карту, и вы сможете пользоваться ими без подключения к Интернету.





Каждый из вас может принять участие в составлении карты WiFi покрытия своего города. Для этого достаточно нажать одну кнопку и перевести программу в режим активного сканирования. Вы можете заниматься своими делами, а Hotspotlist продолжит сканировать и искать места, где можно подключиться к интернету через WiFi.









![Hotspotlist](http://www.droidnews.ru/wp-content/uploads/2013/03/hotspotlist_4-281x500.jpg)








Можно не беспокоиться об уровне заряда батареи, так как сканирование будет остановлено при достижении минимального заряда. В отличие от аналогичных проектов, Hotspotlist позволяет участнику “забрать” найденное — экспортировать все данные, которые он отправили на сервера проекта.





И еще один момент — если вы нашли баг, у вас есть предложение или идея по улучшению, пишите нам, не стесняйтесь. Мы будем рады вас услышать.





[Скачать Hotspotlist — apk](http://dfiles.ru/files/n72hzvy4t).





[Установить Hotspotlist через Gogole Play](https://play.google.com/store/apps/details?id=com.hotspotlistrelease).





![](http://www.droidnews.ru/wp-content/uploads/2013/03/hotspotlist_qr.png)








 
20 апреля в Санкт-Петербурге [ITmozg](http://spb.itmozg.ru/) снова соберет на одной площадке новичков и профессионалов IT-рынка на ежегодном Фестивале профессионального развития — [BitByte](http://bitbyte.itmozg.ru/). 









![Bitbyte](http://www.droidnews.ru/wp-content/uploads/2013/03/bitbyte_logo_2013-600x242.jpg)


 <!-- more -->

  
   
В программе:  
— Две параллельные секции докладов, посвященные техническим и карьерным вопросам;  
— Выставка, где можно напрямую пообщаться с представителями IT-компаний, узнать о возможностях трудоустройства;  
— Много активностей: головоломки и тесты, розыгрыши и подарки, сюрпризы и еще много-много интересного :)













Среди компаний-участников: Google, Oracle, EMC, Яндекс.Деньги, Sperasoft, Mail. ru Group, T-Systems, Электрон и многие другие.





Участие бесплатное! Вход только по регистрации [http://bitbyte.itmozg.ru/register#form](http://bitbyte.itmozg.ru/register#form) 





Все подробности на сайте мероприятия: [http://bitbyte.itmozg.ru](http://bitbyte.itmozg.ru/)
Какую программу вы используете для хранения заметок? Скорее всего, Evernote, но у этой программы есть всего один, но очень внушительный минус. В этой программе заметки можно хранить только в онлайновом хранилище. И вот совсем недавно для Evernote появилась реальная альтернатива. Она называется Catch Notes. Встречайте обзор новой программы для операционной системы android.









![Catch Notes](http://www.droidnews.ru/wp-content/uploads/2013/03/catch_notes_1-600x498.jpg)




 <!-- more -->


Главными достоинствами программы Catch Notes для русских пользователей являются. Первое это то, что можно хранить заметки в оффлайне, то есть на самом телефоне. И второе это то, что в отличие от уже упомянутой Evernote это приложение полностью переведено на великий и могучий русский язык. Главным же достоинством этой программы для совершенно всех пользователей. Это то, что вы может хранить не только стандартные текстовые заметки, но также фото заметки, которые можно сделать камерой или взять из любых внешних источников, голосовые заметки и даже заметки – напоминания. 













![Catch Notes](http://www.droidnews.ru/wp-content/uploads/2013/03/catch_notes_2-600x498.jpg)









К сожалению, на операционной системе IOS Catch Notes вряд ли займет лидирующие строчки. Ведь там есть, как отличное встроенное приложение, так и Evernote там работает на ура. А вот для операционной системы android ничего хорошего до данного момента не было. Ведь главный конкурент — Evernote оптимизирован очень плохо, а кроме него можно отметить только наработки, которые так и не нашли своего места на рынке или даже не дожили до полноценного релиза. Так что Catch Notes тут выглядит победителем. Он умеет сохранять и обычные текстовые заметки, что хоть [прямой номер мтс](http://www.topnomer.ru/) записывай, чтобы не забыть, умеет хранить надиктованный текст, работает с фото и порадует возможностью создавать чек-листы. Ну знаете такие, где галочками отмечается проделанное?









![Catch Notes](http://www.droidnews.ru/wp-content/uploads/2013/03/catch_notes_3-600x498.jpg)









К этой программе вышло два дополнения. Одно из них под названием Catch Widget является совершено ненужной ерундой. Ведь оно не добавляет ничего нужного. Формально она добавляет специальный виджет для добавления заметок прямо с главного экрана. Но в том то и соль, что эта функция есть основной программе и поэтому это дополнение является совсем не нужным. А вот второе из вышедших дополнений является довольно интересной штукой. Оно называется Catch Sketch HTC. С его помощью вы можете взять любое изображение из интернета, отредактировать его как хотите и потом сохранить, как заметку. Единственным минусом этого дополнения является то, что его можно установить только на устройства марки HTC и то, к сожалению, не на все.









![Catch Notes](http://www.droidnews.ru/wp-content/uploads/2013/03/catch_notes_4-600x498.jpg)









Как я уже говорил это приложение будет полезно всем пользователям операционной системы android, ведь альтернативы у них нет, а заметки это очень нужное приложение. 





Минусов у этого приложения, на мой взгляд, практически нет. Единственное — оно оптимизировано не подо все устройства. В итоге — восемь с половиной баллов. 





[Скачать Catch Notes — apk](http://dfiles.ru/files/h9wc8uwng).





[Установить Catch Notes через Google Play](https://play.google.com/store/apps/details?id=com.threebanana.notes).





![](http://www.droidnews.ru/wp-content/uploads/2013/03/catch_notes_qr.png)
Если для создания заметок на своем устройстве все обычно используют Evernote или [Catch](http://www.droidnews.ru/catch-notes-poymay-mysli-v-zametochnik), то какую программу вы используете для создания напоминаний в браузере. До недавнего времени такого приложения не существовало в принципе. Но совсем недавно появилось такое приложение от компании Google и называется оно Google Keep.









![Google Keep](http://www.droidnews.ru/wp-content/uploads/2013/03/google_keep_1-600x498.jpg)



<!-- more -->





Далеко не все проекты это гиганта были успешными. Почти пятьдесят процентов их продуктов закрываются еще на стадии развития. Я надеюсь, что Google Keep такая участь не постигнет, ведь идея этой программы и её реализация мне понравились. 









Одним из главных достоинств всех приложений Google для меня всегда было то, что все они заключены в общую экосистему. Чтобы зайти на Youtube, Gmail, Google Play и тот же Google Keep вам понадобится всего одна учетная запись. Если вы собираетесь использовать эту программу, то обязательно надо проверить. Включена ли синхронизация в настройках. Ведь без неё приложение становится практически бессмысленным. В версии приложения для операционной системы андроид существует несколько видов заметок. Первый из них – это текстовые. Второй – это голосовые. И третий это списки и графические заметки. Но радует то, что в одной заметки можно совмещать сразу несколько видов заметок. Например, на столе лежит одновременно и фотография и листок с составленным над ним списком. То есть в одной заметке вы совмещаете сразу и фото и список. 









![Google Keep](http://www.droidnews.ru/wp-content/uploads/2013/03/google_keep_2-600x498.jpg)









Из достоинств этой программы я хочу отметить то, что программа очень хорошо разбирает голосовые команды. Даже тот же Google Translate так хорошо не научился работать с голосом. Вторым пунктом, который меня радует можно назвать то, что программа отлично работает со ссылками. Даже в не составленной на самом устройстве заметке вы можете нажать на любую сслыку и перейти на нее. Например, вы фотографируете на телефон объявление на улице, а потом подключаетесь к интернету и легко переходите на ссылку, которая была на этом объявление. 









![Google Keep](http://www.droidnews.ru/wp-content/uploads/2013/03/google_keep_3-600x498.jpg)









Из минусов я хочу отметить то, что в заметке отметить, что- либо очень тяжело. Ведь для этого есть только специальный цветной шрифт. Вы выбираете часть текста, переходите в специальное меню и там выбираете цвет это фрагмента, для меня это минус. Можно тут вспомнить One Note из состава Microsoft [office 2013](http://www.softkey.ru/microsoft_office_standard_2013), где это реализовано несколько большее широко.





Это программа будет полезна тем, кто использует свой телефон, как полноценный интернет-браузер. Он может внести в эту программу что-либо на компьютере, а потом увидеть на смартфоне.





Этой программе я ставлю шесть баллов. Её вытягивают несколько функций, которые сделаны на очень высоком уровне. Но простор для развития тут явно ещё есть.









[Скачать Google Keep — apk](http://dfiles.ru/files/amkjc4fhe).





[Установить Google Keep через Google Play](https://play.google.com/store/apps/details?id=com.google.android.keep).





![](http://www.droidnews.ru/wp-content/uploads/2013/03/google_keep_qr.png)Google Translate мощная и часто полезная штука. Но, увы, раньше частенько случалось, что воспользоваться ей нет возможности, потому что для её работу требовался доступ во всемирную Сеть. А ведь не всегда есть выход в интернет. Будь ты в метро или в городе, где плохо доступен сигнал оператора. Или, может быть, в другой стране, где ещё не успел обзавестись местной сим-картой, а услуги переводчика уже потребовались, например, чтобы ту же сим-карту приобрести. 









![Google Translate](http://www.droidnews.ru/wp-content/uploads/2013/03/google_translate_1-600x350.jpg)



<!-- more -->




Теперь такой загвоздки не будет, потому что приложение Google Translate научилось работать в оффлайн-режиме. Доступно оно для версий Android 2.3 и выше. Чтобы Google Translae работало без доступа в Сеть, достаточно теперь лишь установить само приложение, а потом раз зайти в настройки и выбрать необходимые словари, которые будут закаченны на ваше устройство по wi-fi.









Как обычно, языков доступно приличное количество — все самые распространённые уже имеются. Суммарный вес всех языков пакетов превышает 100 мегабайт. После их установки появится возможность полноценно использовать Googla Translate всегда и везде без ограничений, переводя, как слова, так и фразы и предложения.





Разумеется, оффлайн-словари не такие мощные и умные, как их онлайн-коллеги. К примеру, не получится прослушать произношение слов, не работает распознавание рукописного текста, но и появившегося функционала будет достаточно в большинстве случаев.





Увы, не работает также режим переводчика, когда приложение слушает говорящего и синхронно выдаёт перевод речи. Но те, кто на своих смартфонах имеет Android 4.1 или выше, могут скачать дополнения Text To Speech, чтобы добавить этот функционал.





Само же приложение Googla Traslate уже сейчас доступно в Google Play для скачивания всем желающим.
Здравствуйте, сегодня хотелось бы рассказать о приложении для вашего Android-девайса — Гороскоп на каждый день (Daily Horoscope).









![Daily Horoscope](http://www.droidnews.ru/wp-content/uploads/2013/04/daily_horoscope-600x498.jpg)




 <!-- more -->


При рассмотрении множества астрологических сайтов, фильтры и потребности каждого из вас бывают абсолютно разными. Кто-то ищет лучший гороскоп на каждый день, кто-то на неделю, месяц, половая совместимость, карьера, бизнес и тд.









Но насколько это правдиво и удобно? по данным ученых самые правильные предсказания и самый «честный» гороскоп — можно опубликовать на ближайшие 5 дней, и при это всем необходимо точно указать дату рождения т.к. каждый Астрологический знак делится на 3 декады, что является одним из определяющих факторов.





Предсказания и гороскоп сбывается чаще у тех кто действительно ВЕРИТ, поэтому приложение «Гороскоп на каждый День» (которое является абсолютно бесплатным) — поможет вам ежедневно с утра дома, в транспорте, в офисе или просто прогуливаясь обновлять информацию о нынешнем дне,о советах и предсказаниях.





Приложение обладает максимально простым и удобным интерфейсом, чтобы даже самые юные пользователи «Гаджетов» смогли без всяких трудностей найти свой знак и получить гороскоп на сегодня, завтра, послезавтра и т.д. 





С древних времен люди пытались разгадать тайны Вселенной используя астрологию и нумерологию. Во многих культурах существуют традиции пытаться интерпретировать смысл исходя из размещения звезд и планет которые мы можем увидеть в ночном небе. Некоторые люди подчеркивают что это простое шарлатанство, но другие считают, что комплекс расположения астрономических объектов влияет на события на Земле. Для верующих в астрологию, гороскопы обеспечивает предварительный просмотр того, что ближайшее будущее приготовило для вас.





Но, как говорится, сколько людей — столько и мнений. Приложение Гороскоп на каждый День — локализовано на 20 языков для вашего удобства.





Также для любителей делиться и следить за гороскопами других интегрирована система публикации от Facebook&Twitter.





Пользуйтесь и оставляйте отзывы и комментарии.





[Скачать Daily Horoscope — apk](http://dfiles.ru/files/jx3qx7hh6).





[Установить Daily Horoscope через Google Play](https://play.google.com/store/apps/details?id=com.app.goroskop).





![](http://www.droidnews.ru/wp-content/uploads/2013/04/daily_horoscope_qr.png)Ну что, кто может сказать, когда мы уже, наконец, увидим следующую версию Android? Наверное, большинство из читателей скажет, что подобное событие произойдёт на мероприятии Google I/O. Во всяком случае об этом твердит большинство источников, и именно на это намекает прошлый опыт. Так что терпеливо ждём 15 мая.









![Эволюция Android](http://www.droidnews.ru/wp-content/uploads/2013/04/Android-5.0-Key-Lime-Pie-Rumors1-600x347.jpg)



 <!-- more -->




Однако, пока мы застыли в ожидании, давайте посмотрим, какие интересные слухи и догадки блуждают по Сети касаемо Android 5.0 Key Lime Pie.









Первое, о чем можно встретить упоминание — свежее ядро Linux версии 3.8. Любители перепрошиваться знают, насколько важно в системе грамотно собранное ядро. Ведь от него во многом зависит скорость работы мультитаскинга, оно может сильно влиять на расход заряда батареи, ядро же определит, сколько оперативной свободной памяти будет выделено пользователю. Так что у многих сейчас есть надежды, что оптимизация ядра поможет улучшить ситуацию вокруг некоторых давних проблем нашей любимой ОС.





Второй интересный слух про Kie Lime Pie гласит, что эта версия Android будет работать исключительно на четырёхъядерных устройствах. Однако, лично мне кажется, что такое развитие событий очень маловероятно. Вряд ли в Google решатся так сразу оставить огромное количество чуть менее современных устройств без обновления системы.





Куда более вероятным кажется, что в Key Lime Pie появится унифицированная Google-платформа для общения Google Babel, которая объединит в себе Google Talk, Google Plus, Google Voice.





Наверняка же к Android 5.0 обновится клавиатура, которая порадует нас более обширными словарями и улучшенными алгоритмами предугадывания вводимого текста.





Интересным остаётся вопрос, на каком именно устройстве нам продемонстрируют Key Lime Pie. Будет ли это Nexus 5 или же ожидаемый многими Motorola X Phone. Что вы думаете по этому поводу?





А вам какие из этих слухов кажутся максимально достоверными? Или какие наоборот — откровенной чепухой? Чего бы хотелось, чтобы подтвердилось?









 
Программа под названием Neatly появилась для операционной системы iOs в апреле прошлого года. Но там она не снискала популярности. Ведь для Apple есть отличный TweetBot, но вот для операционной системы Android хороших клиентов для социальной сети Twitter всегда не хватало. И Neatly в этой ситуации может стать настоящим спасением. Встречайте обзор твиттер-клиента для Android — Neatly. 









![Neatly](http://www.droidnews.ru/wp-content/uploads/2013/04/neatly_1-600x498.jpg)





<!-- more -->



Существует две версии этой программы. Одна называется Neatly for Twitter trial. Эта версия бесплатная и у неё есть всего одно отличие от полноценной версии, которую продают за пятьдесят пять рублей. Полная версия называется просто Neatly for Twitter. Полноценное приложение уже доросло до версии 2.0.5, а вот триал версия так навсегда и останется в версии 1.0.













![Neatly](http://www.droidnews.ru/wp-content/uploads/2013/04/neatly_2-600x498.jpg)









В каждом обновлении разработчики вводят что-то новое. Но только в шестидесяти процентах случаев это реально обновление. А вот в остальных сорок обновление просто чинит недостатки прошлых версий.   
Это приложение может стать очень полезной программой для тех, кто ведет в твиттере свою страничку или, наоборот, для тех, кто читает страницы других людей и всегда хочет быть в курсе всех новостей.





Аналогов у приложения на сегодняшний день уже довольно много, но у каждого есть свои недостатки. Тут уж каждый выберет сам, что ему по душе, а лично мне на их фоне Neatly выглядит вполне приятным вариантом. 









![Neatly](http://www.droidnews.ru/wp-content/uploads/2013/04/neatly_3-600x498.jpg)









Интерфейс Neatly выглядит обычно в соответствии с гайдлайнами Android. В середине экрана находится лента, на которой вы можете прочитать свежие твиты пользователей, на которых вы подписаны. Вверху находится строка поиска, которая исчезнет, если вы начнете листать ленту. С правого бока экрана выдвигается специальная шторка. В ней вы можете написать свое сообщение. А вот после этого начинаются приятные сюрпризы.





Например, в этом приложение есть много того, чего нет в оригинальном Twitter. Вы можете в этом приложение найти свой социальный статус. Стиль ведения вами своей странички: например, сколько твитов вы пишете в день. Сколько времени вы проводите в онлайне. Интересно не только следить за своей статистикой, но также и просматривать профили других пользователей. Настроек в программе не так много. 





Отметить хочется лишь то, что можно выбирать темы оформления вашей ленты. 





Если вы активно пользуетесь социальной сетью Twitter, то Neatly станет незаменимым приложением на вашем устройстве. Десять из десяти.









[Скачать Neatly — apk](http://dfiles.ru/files/70vtnki2d).





[Установить Neatly через Google Play](https://play.google.com/store/apps/details?id=f16.android.neatly).





![](http://www.droidnews.ru/wp-content/uploads/2013/04/neatly_qr.png)![](http://android.com.ua/images/News/chameleon-launcher.jpg)





У популярного лаунчера Chameleon, ранее доступного только на Android планшетах,  появилась версия и для смартфонов. Главной особенностью этого лаунчера является полностью переработанный интерфейс, состоящий из плиток разного размера, в которые пользователь может поместить виджеты. Также Chameleon поддерживает несколько профилей, что позволяет быстро переключаться между рабочим и домашним расположением виджетов а также настройками устройства.






 <!-- more -->


Всего теперь доступно две версии: полная, работающая и на планшетах и на смартфонах, и урезанная, с возможностью установки только на смартфоны. Скачать полную версию можно по цене $3.99 [здесь](https://play.google.com/store/apps/details?id=com.chameleonlauncher), а для смартфонов бесплано - [здесь](https://play.google.com/store/apps/details?id=com.chameleonlauncher.phone).
![](http://android.com.ua/images/News/3dmark_banner-630x307.jpg)





Разработчики популярного бенчмарка 3D Mark выпустили мобильную версию теста для операционной системы Android. Сейчас приложение уже поддерживает свыше тысячи различных устройств и в будущем их количество будет только расти. Сам тест включает проверку процессора и графического ядра посредством OpenGL ES 2.0.









![](http://chart.apis.google.com/chart?cht=qr&chs=150x150&chl=https://play.google.com/store/apps/details?id=com.futuremark.dmandroid.application)








  
![](http://android.com.ua/templates/Androidnew/images/rtd.gif)
![Приложение Skype обновилось: поддержка портретной ориентации и нескольких новых языков](http://android.com.ua/images/News/skype-tablets-updated.jpg)





Android клиент популярной программы для видеосвязи Skype обновился. В новой версии разработчики добавили поддержку портретной ориентации для планшетов а также добавили португальский и норвежский языки. Загрузить Skype можно бесплатно с магазина [Google Play](https://play.google.com/store/apps/details?id=com.skype.raider).





![](http://chart.apis.google.com/chart?cht=qr&chs=150x150&chl=https://play.google.com/store/apps/details?id=com.skype.raider)








Всем водителям посвящается!





Иногда во время долгих путешествий бывает сложно найти заправку для своего авто. Особенно если путь лежит через незнакомый регион. Облегчить задачу поиска АЗС сможет приложение АЗС UA.





![](http://android.com.ua/images/News/azs-ua-2.jpg)


<!-- more -->


Оно позволяет посмотреть на карте ближайшие заправки а также проложить путь до выбранной. АЗС отображаются иконками брендов, поэтому пользователь сможет быстро найти нужную ему заправку на карте среди сотен других.





В приложении используется последняя версия API Google Maps, что обеспечит более быструю работу при меньшем потреблении трафика а также работу всех последних дополнительных функций, например вращения 3D.





![](http://android.com.ua/images/News/azs-ua-3.jpg)





Помимо режима просмотра на карте, пользователю доступен также список заправок, отсортированный по расстоянию до них.





![](http://android.com.ua/images/News/azs-ua-4.jpg)





Выбрав заправку, пользователь может быстро посмотреть ее местоположение на карте или проложить маршрут.





Загрузить приложение АЗС UA можно бесплатно с [магазина Google Play](https://play.google.com/store/apps/details?id=com.pixign.gasbyme).





![](http://chart.apis.google.com/chart?cht=qr&chs=150x150&chl=https://play.google.com/store/apps/details?id=com.pixign.gasbyme)
Ну наконец то. Сделали фотошоп для телефона.





Рекомендую, очень полезная вещь.





![](http://android.com.ua/images/News/PhotoshopTouch_andr.jpg)



<!-- more -->

Adobe Systems выпустила версию известного фоторедактора Photoshop Touch для смартфонов. Как сообщает официальный блог компании, функционал программы позволяет работать со слоями изображений до 12 МП и фильтрами, то есть идентичен версии для планшетов. Приложение поддерживает работу с Creative Cloud - облачным сервисом Adobe, что позволяет иметь свободный доступ к своим работам. Для установки Photoshop Touch необходим Android 4.0 и выше. На данный момент приложение не поддерживает русский язык, однако в скором времени ожидается исправление этой ситуации. Photoshop Touch доступен в Google Play по цене $5. Загрузить его можно с [магазина Google Play](https://play.google.com/store/apps/details?id=air.com.adobe.pstouchphone).









![](http://chart.apis.google.com/chart?cht=qr&chs=150x150&chl=https://play.google.com/store/apps/details?id=air.com.adobe.pstouchphone)Всем привет.





Давно ничего не писал.





Сегодня нашел интересную статью по выбору клавиатуры для ваших устройств.





Смотрим!


<!-- more -->


Приветствуем вас, Хабралюди! Мы в Meizu считаем, что если у смартфона есть какие-то слабые места, нужно говорить о них открыто и предлагать адекватные решения проблем, а не прятаться за шаблонными фразами «наше решение удовлетворяет большинство пользователей». Поэтому сегодня я хочу поговорить про одно из слабых мест Flyme OS – экранную клавиатуру. К сожалению, она имеет минимум настроек и вряд ли подойдет для использования, если вы привыкли часто набирать на смартфоне текст, переписываться посредством SMS, WhatsApp, imo,im и так далее. К счастью, Android позволяет изменить практически любой пункт меню или интерфейса, а также заменить большинство стандартных программ на более удобные аналоги. Эта статья будет посвящена пяти качественным и удобным (на мой субъективный взгляд) сторонним клавиатурам для Android, которыми можно заменить встроенную на вашем смартфоне.





![](http://android.com.ua/images/News/kl1.jpg)









**Структура материала**





Перед началом сравнения предлагаю выбрать некоторые объективные критерии для оценки удобства той или иной клавиатуры, которыми мы будем руководствоваться при оценке.





Метод и удобство переключения языка





Возможность ввода дополнительных символов долгим нажатием





Настройка жестов





Актуальность словаря





Наличие тем оформления





Уникальные особенности









**Swype**





Эта клавиатура – одна из самых известных на Android, ее название у всех на слуху, а само слово «свайп» уже стало нарицательным. Главная особенность Swype – возможность ввода текста с помощью росчерков. Вы последовательно водите слово пальцем от буквы к букве, не отпуская его, система обрабатывает ваш росчерк и отображает на экране введенное слово.





Такой метод является более быстрым и менее энергозатратным для пальцев (вместо нескольких нажатий – один росчерк). Есть у Swype и минусы: в сравнении с традиционными клавиатурами, погрешности и ошибки встречаются чаще.





![](http://android.com.ua/images/News/kl2.jpg) ![](http://android.com.ua/images/News/kl3.jpg) ![](http://android.com.ua/images/News/kl4.jpg)





Переключение языка осуществляется двумя способами: росчерком от клавиши «S» к пробелу или долгим удержанием пробела. Хорошо – что есть выбор, плохо – что нет классического переключения языка коротким касанием одной клавиши. Клавиатура поддерживает жесты, например, чтобы быстро ввести заглавную букву, вам нужно во время росчерка выйти за пределы клавиатуры, а затем продолжить ввод. Если же вы хотите ввести один из знаков препинания, то просто проведите пальцем от пробела к нужному знаку. Для быстрого доступа к цифровой клавиатуры достаточно удерживать кнопку вызова символов. Если при вводе подобралось неверное слово, то при нажатии backspace, оно удаляется полностью.





![](http://android.com.ua/images/News/kl5.jpg) ![](http://android.com.ua/images/News/kl6.jpg)





Однако одних росчерков уже недостаточно, чтобы быть хорошей клавиатурой, поэтому в Swype добавили возможность бэкапа словаря в облако, поддержку тем и собственную систему обновления.





![](http://android.com.ua/images/News/kl7.jpg) ![](http://android.com.ua/images/News/kl8.jpg) ![](http://android.com.ua/images/News/kl9.jpg)





Еще одной особенностью Swype является установка: вы не можете скачать клавиатуру из Play Market, для ее установки нужно зайти на [страницу программы](http://beta.swype.com/android/get/) со своего смартфона и скачать apk-файл установщика, который после определения вашего устройства начнет скачивать подходящую для вас версию.





         Плюсы:








  * Удобный ввод росчерками



  * Бэкап словаря в облаке



  * Поддержка тем оформления



  * Удобные жесты для быстрого доступа к знакам препинания



  * Бесплатность






          Минусы:








  * Неудобная система переключения языка



  * Отсутствие программы в Google Play



  * Подтормаживания при обычном вводе (не росчерками)










**Smart Keyboard**





Для сторонников традиционного метода ввода я могу порекомендовать приложение Smart Keyboard.





Начнем переключения языка. В Smart Keyboard придерживаются стандартного подхода, когда за переключение отвечает отдельная кнопка. При желании ее можно отключить и назначить смену языков на свайп вправо или влево. В правом нижнем углу расположилась клавиша со смайликом, при ее удержании вы можете выбрать один из нескольких вариантов смайлов. Раз уж речь зашла про дополнительные клавиши, то стоит отметить детальную настройку контекстной кнопки «.com», вы можете переназначить ее например на «.ru»





![](http://android.com.ua/images/News/kl10.jpg) ![](http://android.com.ua/images/News/kl11.jpg) ![](http://android.com.ua/images/News/kl12.jpg)





Второй интересный момент – возможность выбора из двух русских раскладок, одна из них трехстрочная, другая – четырехстрочная. Дополнительные символы присутствуют как в первой, так и во второй. Что касается внешнего вида, то тут вам полное раздолье – есть поддержка множества тем, настройка высоты клавиш, включение навигационных стрелок и даже изменение прозрачности клавиатуры.





![](http://android.com.ua/images/News/kl13.jpg) ![](http://android.com.ua/images/News/kl14.jpg)





Словарь я бы оценил на «четверку», всё же некоторых слов не хватает. При желании вы можете сделать бэкап пользовательского словаря и сохранить его на карте памяти (облачного бэкапа как в Swype, увы, нет). Любители звукового сопровождения и вибрации также останутся довольны – в Smart Keyboard можно настроить продолжительность вибрации и громкость звукового сопровождения. Можно даже выбрать звуки как в iPhone или фирменный «чпок» из Windows Phone.





Последняя особенность Smart Keyboard связана с предугадыванием: если вы нажали на предложенное слово, то вам сразу же предложат быстро нажать точку, запятую или другой знак.





          Плюсы:








  * Поддержка тем



  * Отдельная кнопка переключения языка



  * Возможность ввода дополнительных символов долгим нажатием



  * Возможность настройки звука и вибрации



  * Настройка действий на жесты



  * Дополнительные символы на кнопках






          Минусы








  * Стоимость



  * Любителям традиционного ввода обязательно стоит попробовать Trial-версию Smart Keyboard, чтобы оценить ее самим, лично я не жалею отданных 150 рублей за эту клавиатуру.






[Trial версия Smart Keyboard в Google Play](https://play.google.com/store/apps/details?id=net.cdeguet.smartkeyboardtrial)





[Pro версия Smart Keyboard в Google Play](https://play.google.com/store/apps/details?id=net.cdeguet.smartkeyboardpro)









**SlideIT Keyboard**





Популярность Swype не дает многим разработчикам покоя, и они выпускают собственные аналоги этого приложения, SlideIT Keyboard – один из них. Начнем с внешнего вида: думаю, вы сразу обратили внимание на самый верхний ряд клавиатуры с двумя переключателями – левый отвечает за высоту клавиш, а правый переключает между методом ввода росчерками и традиционным вводом.





![](http://android.com.ua/images/News/kl15.jpg) ![](http://android.com.ua/images/News/kl16.jpg) ![](http://android.com.ua/images/News/kl17.jpg)





При удержании клавиши «S», перед вами появляется ряд кнопок, в том числе: быстрый переход к камере или SMS, копирование и вставка текста, а также вызов настроек клавиатуры.





![](http://android.com.ua/images/News/kl18.jpg)





Продолжая тему внешнего вида, стоит отметить отдельную клавишу переключения языков и дополнительные символы на кнопках.





Как и другие клавиатуры, SlideIT поддерживает множество тем, большинство пользователей найдут что-то на свой вкус. Интересная настройка в SlideIT – режим сокращений. Вы можете задать сочетание букв при вводе которого оно будет трансформироваться в выбранную вами фразу, например назначить на сочетание «хп» фразу «Хабр, привет!».





![](http://android.com.ua/images/News/kl19.jpg) ![](http://android.com.ua/images/News/kl20.jpg)





Не позабыли создатели SlideIT и про настройки звука и вибрации, вам доступна возможность изменения громкости звуков при нажатии клавиш, а также продолжительности вибрации.





Ключевая особенность SlideIT – ввод с помощью росчерков. На первый взгляд он работает отлично, но используя клавиатуру более продолжительное время, начинаешь замечать, что она допускает уж очень много ошибок. Непонятно, связано ли это со скудным словарем или же с системой обработки росчерков, но факт остается фактом – опечаток в SlideIT много.





          Плюсы:








  * Ввод с помощью росчерков



  * Детальная настройка внешнего вида



  * Поддержка тем



  * Режим сокращений



  * Быстрый переход к настройкам



  * Настройки звука и вибрации клавиш






          Минусы:








  * Большое количество опечаток



  * Стоимость SlideIT – 122 рубля, есть бесплатный триал. Я бы рекомендовал вам самостоятельно проверить эту клавиатуру и дать ей шанс, вполне возможно, что вам повезет больше с распознаванием, чем мне.






[Trial версия SlideIT в Google Play](https://play.google.com/store/apps/details?id=com.dasur.slideit.vt.lite)





[Pro версия SlideIT в Google Play](https://play.google.com/store/apps/details?id=com.dasur.slideit)









**SwiftKey Keyboard**





Главной особенностью SwiftKey является предугадывание. Вы «скармливаете» клавиатуре свои переписки из Gmail, твиттера и Facebook, и на их основе она предугадывает следующее слово. Идея необычная и довольно интересная, однако ее эффективность напрямую зависит от подробности «скормленных» источников.





![](http://android.com.ua/images/News/kl21.jpg) ![](http://android.com.ua/images/News/kl22.jpg) ![](http://android.com.ua/images/News/kl23.jpg)





Начнем традиционно с внешнего вида. Как вы можете видеть, в клавиатуре есть дополнительные символы, вызываемые долгим нажатием. Переключение языка осуществляется скольжением по пробелу, назначить отдельную кнопку на это действие нельзя. Клавиша Enter совмещена с вызовом смайликов, а долгое нажатие на точку вызывает остальные знаки препинания. Что касается интеллектуальной клавиши «S», то с ее помощью можно быстро вызвать настройки, справку или включить голосовой ввод.





![](http://android.com.ua/images/News/kl24.jpg) ![](http://android.com.ua/images/News/kl25.jpg)





Клавиатура поддерживает темы, по умолчанию есть несколько предустановленных. Также при желании вы можете добавить навигационные стрелки еще одним рядом и изменить высоту букв. Присутствует настройка громкости звукового сопровождения и длительности вибрации при вводе (если она включена). Не обошли стороной и поддержку росчерков, но на мой взгляд, она работает хуже, чем в том же Swype или даже SlideIT.





         Плюсы:








  * Уникальная система предугадывания



  * Поддержка тем



  * Удобная интеллектуальная клавиша



  * Настройка звукового сопровождения и вибрации






         Минусы:








  * Отсутствие отдельной клавиши для переключения языков



  * Малое количество настроек, по сравнению с конкурентами



  * Как я уже говорил, эффективность SwiftKey напрямую зависит от подробности «скормленных» ей источников. Если вы редко переписываетесь в том же Gmail, Facebook или Twitter’e, то SwiftKey вряд ли вам подойдет.






[Trial версия SwiftKey Keyboard в Google Play](https://play.google.com/store/apps/details?id=com.touchtype.swiftkey.phone.trial)





[Pro версия SwiftKey Keyboard в Google Play](https://play.google.com/store/apps/details?id=com.touchtype.swiftkey)









**Go Keyboard**





Начало прошлого года можно назвать «звездным часом» Go Dev Team, все их продукты (лаунчер, диалер, SMS-клиент, клавиатура) пользовались огромной популярностью, со временем появлялись более сильные конкуренты, но даже сейчас решения от Go Dev выглядят весьма достойно.





При первом открытии Go Keyboard сразу обращаешь внимание на панель над клавиатурой. С ее помощью можно быстро перейти к смайликам, режиму навигации, сменить язык, открыть цифровой блок или символьный. Кроме того вы можете переключить язык и привычным способом, к счастью в Go Keyboard есть отдельная клавиша для таких целей.





![](http://android.com.ua/images/News/kl26.jpg) ![](http://android.com.ua/images/News/kl27.jpg) ![](http://android.com.ua/images/News/kl28.jpg)





Внешнему виду посвящено целых два раздела настроек – один отвечает за темы оформления (их кстати для Go Keyboard огромное количество) и за внешний вид клавиатуры – вы можете изменить высоту клавиш, размер шрифта и включить навигационные стрелки.





![](http://android.com.ua/images/News/kl29.jpg) ![](http://android.com.ua/images/News/kl30.jpg)





Go Keyboard поддерживает ввод с помощью росчерков, но работает он не так хорошо, как тот же Swype.





Никуда не делись и настройки звукового сопровождения и силы вибрации.





         Плюсы:








  * Огромное количество тем



  * Наличие навигационных стрелок



  * Отдельная клавиша смены языков



  * Интересное решение с дугой настроек






         Минусы:








  * Посредственный перевод настроек на русский язык



  * Скудный словарь



  * Назойливая реклама






В Go Keyboard постарались «напихать» побольше всяких настроек, но не озаботились их адаптацией, поэтому конечный результат не так хорош, как мог бы быть.





[Go Keyboard в Google Play](https://play.google.com/store/apps/details?id=com.jb.gokeyboard)





Материалы из сайта [android.com.ua](http://android.com.ua/soft/tools/19415-pyat-klaviatur-dlya-android.html)





А что используешь ты?
Как часто вы не можете заснуть?





Именно для этой цели была придумана программа, которая включает вам хорошую музыку.





Слушая которую вы не просто засыпаете, а .....





Приятные фортепианные мелодии для сна. Таймер сна поможет выключить музыку, после того как Вы или Ваш ребенок уснул. А это значит что Вам не нужно будет следить за тем, выключится музыка или нет. Можете поставить таймер и спокойно засыпать.





Управление настолько простое, что с ним справится даже 2-х летний малыш.


<!-- more -->


**Версия: **1.1





**Русский интерфейс: **Да





**Технические требования: **Android 2.1 и выше





**Категория:** Мультимедиа









Хотите лучше засыпать? Фортепианная музыка поможет Вам отдохнуть и поспать! Закройте глаза, оденьте наушники, включите это приложение. Вы можете выбрать музыку для сна. Вы можете выбрать время проигрывания музыки.





![](http://s.4pda.ru/wp-content/uploads/2013/02/screen1.jpg)
![](http://s.4pda.ru/wp-content/uploads/2013/02/screen2.jpg)








  * Вы можете выбрать музыку.



  * Красочные фоновые картинки.



  * Вы можете установить таймер сна.



  * Отличное качество звука.



  * Лучшие мелодии для отдыха!






**Стоимость:** Содержит рекламу





**Обсуждение на 4pda:** [http://4pda.ru/forum/index.php?showtopic=428757](http://4pda.ru/forum/index.php?showtopic=428757)





**Ссылка на Google Play:** ![QR](http://s.4pda.ru/forum/style_images/1/qr_code.gif)[http://play.google.com/store/apps/details?id=ua.com.mitim.sleepbookpiano](http://play.google.com/store/apps/details?id=ua.com.mitim.sleepbookpiano)





 Статья из сайта [4pda.ru](http://4pda.ru/2013/02/06/88764/#more-88764)
Для жителей России будет полезно.





Не просто программа, а шпион в вашем телефоне.





Абонент-Инфо – это определение местоположения (города, региона, страны) и оператора (сотовой, фиксированной) связи абонента по номеру телефона России во время входящего или исходящего вызова, в истории вызовов и сообщений от неизвестныx телефонных номеров и в контактах.


<!-- more -->


**Версия: **1.0.5





**Русский интерфейс: **Да





**Технические требования: **Android 2.0





**Категория:** Связь









Реализовано:








  * Определение по номеру телефона во время входящих и исходящих вызовов



  * Определение в истории вызовов и сообщений от неизвестныx телефонных номеров



  * Определение в контактах



  * Поиск по номерам телефонов



  * Настройка всплывающего сообщения






Запланировано:








  * Поиск по местоположениям



  * Поиск по операторам связи



  * Информация по местоположению



  * Информация по оператору связи






ВНИМАНИЕ:








  * Не отображается всплывающее сообщение? Отключите защиту от прослушивания в настройках вызовов



  * Бренд оператора не соответствует? Сообщите нам!






![](http://s.4pda.ru/wp-content/uploads/2013/02/calling-288x480.png)
![](http://s.4pda.ru/wp-content/uploads/2013/02/contacts-288x480.png)
![](http://s.4pda.ru/wp-content/uploads/2013/02/numbers-288x480.png)
![](http://s.4pda.ru/wp-content/uploads/2013/02/search-288x480.png)
![](http://s.4pda.ru/wp-content/uploads/2013/02/settings-288x480.png)





**Стоимость:** Содержит рекламу





**Обсуждение на 4pda:** [http://4pda.ru/forum/index.php?showtopic=422509](http://4pda.ru/forum/index.php?showtopic=422509)





**Ссылка на Google Play:** ![QR](http://s.4pda.ru/forum/style_images/1/qr_code.gif)[https://play.google.com/store/apps/details?id=com.indipax.callerinfo.free](https://play.google.com/store/apps/details?id=com.indipax.callerinfo.free&referrer=utm_source%3D4pda.ru)





Статья из сайта [4pda.ru](http://4pda.ru/2013/02/07/88833/#more-88833)
Бывают такие моменты, когда хочешь поздравить своих друзей.





Но потом видешь, что пропал интернет и вы не можете посмотреть в социальных сетях.





На помощь приходит следующая программа.





Программа напоминает о днях рождений ваших друзей из социальных сетей ВКонтакте и Facebook, умеет отправлять сообщения на стену, присутствует возможность добавления/редактирования контактов, есть виджеты, живой поиск и другие плюшки.


 <!-- more -->


**Версия: **1.2a





**Русский интерфейс: **Да





**Технические требования: **Android 2.1+





**Категория:** Социальная









Больше ты можешь не беспокоиться, что перепутаешь даты или просто закрутишься и забудешь про дни рождения своих близких и знакомых. С приложением My Birthday Reminder ты всегда будешь держать руку на пульсе событий! Данная программа позволяет загрузить даты дней рождений друзей из таких популярных социальных сетей как ВКонтакте и Facebook, а также добавить иные важные для тебя события. My Birthday Reminder обязательно напомнит тебе о них! А при наличии доступа в Интернет можно моментально отправить имениннику текстовое или графическое поздравление на его страницу в социальных сетях.








  * загрузка списка друзей из ВКонтакте или Facebook;



  * быстрая и удобная отправка сообщений именинникам прямо на стену;



  * живой поиск по списку Ваших друзей;



  * гибкая сортировка (по имени, по ближайшей дате, по отмеченным контактам);



  * добавление и редактирование контактов;



  * виджеты и другие возможности.






![](http://s.4pda.ru/wp-content/uploads/2013/02/1resized-480x262.jpg)







**Стоимость:** Содержит рекламу





**Ссылка на Google Play:** ![QR](http://s.4pda.ru/forum/style_images/1/qr_code.gif)[http://play.google.com/store/apps/details?id=com.app.mybirthdayreminder](http://play.google.com/store/apps/details?id=com.app.mybirthdayreminder)





Статья из сайта [4pda.ru](http://4pda.ru/2013/02/08/88957/#more-88957)
Всем привет.





Хорошая программа, иногда даже очень нужная.





Посмотрим, что скажут разработчики.





Конвертер единиц: Размерности, Время, Механика, Энергия, Движение, Электричество, Информатика, разное… Обладает очень большим функционалом которые еще увеличивается. Пользователь может выбрать точность округления переведенной величины, присутствует гибкая настройка масштабирования (шрифты, кнопки). Имеется возможность создавать свои простенькие конвертеры(умножение и деление).


<!-- more -->


**Версия: **5.0





**Русский интерфейс: **Да





**Технические требования: **Android v2.1 и выше





**Категория:** Офисная программа









Конвертер единиц измерения.





Имеется возможность конвертирования: Длина, Объём, Площадь, Угловые величины, Время, Временные зоны, Частота, Давление, Числа, Валюта, Одежда, Масса, Сила, Скорость, Эл. ток, Энергия, Мощность, Темп-ра, Хранение данных.





Стремлюсь сделать как можно больше единиц измерения, и более удобный функционал.





Имеется удобный поиск.





![](http://s.4pda.ru/wp-content/uploads/2013/02/2013-02-08_09-14-33-288x480.jpg)





В большинстве случаев пользователям не требуются все величины, поэтому имеется возможность отключить ненужные величины, а также можно по сортировать величины в таком порядке как вам будет удобно.





![](http://s.4pda.ru/wp-content/uploads/2013/02/2013-02-08_09-15-08-288x480.png)



Также в программе имеется избранное, поэтому часто используемые конвертеры чтобы не искать постоянно в общем списке можно добавить в избранное. В настройках программы можно выставить что будет открываться при старте приложения: главное меню, список с выбором конвертеров, избранное или последнее используемое. Также можно выставить точность округления (знаков после запятой), доступна точность до 15 символов после запятой.





В настройках приложения можно под себя настроить размер шрифта, а также размеры кнопок.





![](http://s.4pda.ru/wp-content/uploads/2013/02/2013-02-08_09-18-17-288x480.jpg)





В программе также можно создавать свои конвертеры, доступны только элементарные действия: умножить, разделить. Многим этого хватит, но если вам надо что-то больше, всегда можно написать в обратную связь чего вам не хватает и я постараюсь реализовать.





![](http://s.4pda.ru/wp-content/uploads/2013/02/2013-02-08_09-15-073-288x480.png)




**Стоимость:** Содержит рекламу





**Обсуждение на 4pda:** [http://4pda.ru/forum/index.php?showtopic=383875](http://4pda.ru/forum/index.php?showtopic=383875)





**Ссылка на Google Play:** ![QR](http://s.4pda.ru/forum/style_images/1/qr_code.gif)[https://play.google.com/store/apps/details?id=com.kuzmin.konverter](https://play.google.com/store/apps/details?id=com.kuzmin.konverter)









Статья из сайта [4pda.ru](http://4pda.ru/2013/02/08/88953/#more-88953)
Недавно я писал о вредоносных программах.





Но нашел статью, где есть целая подборка таких программ.





Читаем и не устанавливаем их себе.


 <!-- more -->


С угрозами со стороны вредоносных программ ОС Android столкнулась практически с момента своего появления на рынке. И хотя многие пользователи поначалу восприняли этот факт скептически, постепенно их сомнения сменились обеспокоенностью за безопасность используемых мобильных устройств, так как число вредоносных приложений продолжало неуклонно расти. Прошедший 2012 год в этом плане не стал исключением. В этом обзоре мы рассмотрим наиболее интересные и заметные прошлогодние события, связанные с Android-угрозами.





![](http://www.droidnews.ru/wp-content/uploads/2013/01/android_2012_1.jpg)




**СМС-троянцы**  
Троянцы семейства Android.SmsSend, появившиеся еще в 2010 году и быстро ставшие настоящей головной болью пользователей мобильных Android-устройств, по-прежнему являются наиболее распространенной и массовой угрозой для этой мобильной платформы. Эти вредоносные программы предназначены для отправки дорогостоящих СМС-сообщений и подписки абонентов на различные контент-услуги, что может повлечь за собой серьезные финансовые потери (при этом жертва даже не будет знать, что деньги списаны с ее счета). Чаще всего они распространяются под видом популярных игр и приложений, а также их обновлений, однако могут встречаться и другие каналы распространения.









![](http://www.droidnews.ru/wp-content/uploads/2013/01/android_2012_2.jpg)




![](http://www.droidnews.ru/wp-content/uploads/2013/01/android_2012_3.jpg)





Для создания большинства подобных программ не требуется особых знаний, большого количества времени и средств, а получаемая злоумышленниками прибыль от их использования многократно компенсирует все затраты.





Широкое распространение троянцев обусловлено хорошо развитой сетью партнерских программ, которые предлагают весьма выгодные условия оплаты всем своим участникам. Кроме того, летом 2012 года были зафиксированы многочисленные случаи взлома легитимных веб-сайтов, которые модифицировались злоумышленниками таким образом, что пользователи, посещающие их с мобильных устройств, перенаправлялись на мошеннические ресурсы, распространяющие эти вредоносные программы.





Именно благодаря относительной простоте, высокой окупаемости и эффективности применяемых методов распространения семейство Android.SmsSend доминировало в прошедшем году среди остальных вредоносных приложений.  
Увеличение риска кражи конфиденциальной информации, негласный мониторинг и кибершпионаж





Учитывая возможности мобильных Android-устройств, а также принимая во внимание продолжающийся рост числа их пользователей, неудивительно, что проблема сохранности конфиденциальной информации становится все более ощутимой. Рискам в этой сфере подвержены все: как простые пользователи, так и представители коммерческого и государственного секторов. Ценные сведения, интересующие злоумышленников, могут быть самыми разнообразными.  
Шпионы — пособники спамеров





Сами по себе вредоносные программы, шпионящие за пользователями и крадущие их конфиденциальную информацию, не уникальны и известны достаточно давно. Однако в 2012 году обозначилась четкая тенденция к появлению довольно специфической группы троянцев-шпионов, направленных против жителей Японии. Все они распространялись при помощи спам-писем, в которых пользователям предлагалось установить то или иное «полезное» приложение, начиная от эротической игры и заканчивая оптимизатором расхода аккумулятора. 





![](http://www.droidnews.ru/wp-content/uploads/2013/01/android_2012_4.jpg)




![](http://www.droidnews.ru/wp-content/uploads/2013/01/android_2012_6.jpg)




![](http://www.droidnews.ru/wp-content/uploads/2013/01/android_2012_7.jpg)




![](http://www.droidnews.ru/wp-content/uploads/2013/01/android_2012_5.jpg)





К этой группе относятся такие вредоносные программы как Android.MailSteal.1.origin, Android.Maxbet.1.origin, Android.Loozfon.origin и Android.EmailSpy.origin. Их основная задача — похищение адресов электронной почты из книги контактов мобильного устройства и отправка их на удаленный сервер. Помимо этого, некоторые троянцы могут отправлять злоумышленникам не только адреса электронной почты, но и всю информацию из телефонной книги, а также идентификаторы устройства, включая номер сотового телефона. Добытая таким образом информация в дальнейшем может быть использована киберпреступниками для организации новых спам-кампаний и для продажи на черном рынке, а для владельцев похищенных адресов это несет потенциальную угрозу фишинг-атак и вероятность заражения их персональных компьютеров самыми разными вредоносными программами, использующими для инфицирования каналы электронной почты.





**Узконаправленные атаки — угроза с повышенным риском**  
Узконаправленные, точечные или таргетированные атаки несут в себе серьезную угрозу, поскольку они, в отличие от большинства обычных атак, направлены не на максимально возможное число пользователей, а на их ограниченный круг, что снижает вероятность оперативного и эффективного обнаружения используемых при преступлении вредоносных программ.





Одним из вариантов точечной атаки является Advanced Persistent Threat или APT-атака. Ее суть заключается в том, чтобы вредоносная программа как можно дольше оставалась в скомпрометированной системе без обнаружения и получила при этом максимально возможный объем ценных сведений. Жертвами обычно становятся различные компании, организации и государственные структуры.





До сих пор под ударом подобных кампаний находились лишь «большие» компьютерные системы, такие как рабочие станции и серверы. Однако в 2012 году была зафиксирована новая APT-атака, в процессе изучения которой обнаружилась вредоносная программа Android.Luckycat.origin. Функционал троянца включал выполнение команд, поступающих с управляющего сервера, загрузка различных файлов с мобильного устройства и на него, сбор идентификационных данных и некоторые другие возможности.





![](http://www.droidnews.ru/wp-content/uploads/2013/01/android_2012_8.jpg)





![](http://www.droidnews.ru/wp-content/uploads/2013/01/android_2012_9.jpg)





![](http://www.droidnews.ru/wp-content/uploads/2013/01/android_2012_10.jpg)





Несмотря на то, что троянец находился в стадии разработки, и свидетельств его применения на практике не было, факт существования такого инструмента дает серьезное основание полагать, что мобильные Android-устройства в скором времени могут стать такой же привычной мишенью APT-атак, как и обычные компьютеры.





Еще одним инструментом проведения таргетированных атак с целью завладения конфиденциальной и ценной информацией стали мобильные банковские троянцы, крадущие одноразовые коды mTAN. Для обеспечения безопасности финансовых операций в сети Интернет банковские системы отправляют СМС-сообщения с этими кодами на привязанный к клиентскому счету номер мобильного телефона. Чтобы успешно завершить транзакцию, пользователь должен ввести в специальную веб-форму полученный код. Мобильные банковские троянцы предназначены для перехвата СМС-сообщений, кражи этих кодов и передачи их злоумышленникам, которые выполняют различные финансовые операции с электронными счетами ничего не подозревающих жертв (например, совершают онлайн-покупки).





Применение подобных вредоносных программ никогда не было массовым явлением, в том числе и для устройств под управлением Android. В 2012 году мы стали свидетелями появления лишь нескольких новых представителей этого класса троянцев, направленных на мобильную операционную систему от Google. Ими стали Android.SpyEye.2.origin, Android.Panda.2.origin, Android.SmsSpy.6.origin и Android.FakeSber.1.origin.





![](http://www.droidnews.ru/wp-content/uploads/2013/01/android_2012_11.jpg)



![](http://www.droidnews.ru/wp-content/uploads/2013/01/android_2012_12.jpg)




![](http://www.droidnews.ru/wp-content/uploads/2013/01/android_2012_13.jpg)





![](http://www.droidnews.ru/wp-content/uploads/2013/01/android_2012_14.jpg)





![](http://www.droidnews.ru/wp-content/uploads/2013/01/android_2012_15.jpg)




![](http://www.droidnews.ru/wp-content/uploads/2013/01/android_2012_16.jpg)




Типичный способ распространения таких вредоносных программ — социальная инженерия, когда пользователя вводят в заблуждение, предлагая срочное обновление операционной системы или установку некоего сертификата безопасности, необходимого для дальнейшего получения финансовых услуг. Несмотря на то, что случаи появления банковских троянцев для ОС Android являются редкими, проводимые с их помощью атаки весьма эффективны. Именно благодаря неширокой распространенности таких приложений и направленности на пользователей конкретных банковских систем снижается вероятность их быстрого обнаружения и обеспечения необходимой защиты от них.





Среди всех этих вредоносных программ стоит особо выделить Android.FakeSber.1.origin: он стал первым банковским Android-троянцем, направленным против клиентов российского банка. До его появления киберпреступников интересовали лишь зарубежные пользователи. Кроме того, в отличие от своих собратьев, распространяющихся при помощи мошеннических сайтов, данный троянец был помещен злоумышленниками непосредственно в официальный каталог приложений Google Play. К счастью, к моменту, когда троянец был удален из каталога, установить его успели немногие. Тем не менее, потенциальная опасность, которую он представлял, была весьма существенной.





Принцип, по которому работал Android.FakeSber.1.origin, был схож со схемами, применяемыми злоумышленниками в других банковских Android-троянцах. Во-первых, для того чтобы заставить пользователей выполнить его установку, была использована весьма распространенная тактика запугивания: на официальным веб-сайте банка посетителям демонстрировалось сообщение о необходимости авторизации при помощи мобильного телефона (это сообщение отображалось благодаря Windows-троянцу, заразившему компьютеры жертв и работавшему в связке с Android.FakeSber.1.origin). Пользователям предлагалось установить специальное приложение, которое на самом деле и было мобильным банковским троянцем. Во-вторых, попав на мобильное устройство, эта вредоносная программа имитировала ожидаемый функционал, усыпляя бдительность пользователя. В конечном итоге Android.FakeSber.1.origin скрытно перехватывал все входящие сообщения и пересылал полученные из них сведения на удаленный сервер, поэтому помимо mTAN-кодов в руках киберпреступников могли оказаться и другие конфиденциальные сведения, например, частная переписка. 





**Коммерческое шпионское ПО**  
Потенциальную угрозу сохранности персональной информации продолжают нести и различные виды коммерческого программного обеспечения для мониторинга и шпионажа. В 2012 году было обнаружено значительное число не только новых модификаций уже известных программ, но и новые представители этого класса приложений. Большинство подобных шпионов может использоваться как легально, с согласия владельца мобильного устройства, так и без его ведома. Для их установки обычно требуется физический доступ к мобильному устройству, однако после установки данные [Приложения для Андроид](http://smartfon.dp.ua/) способны скрывать свое присутствие в системе (например, не создавая иконку на главном экране, а также маскируясь под системное ПО). Наиболее распространенными функциями таких шпионов являются отслеживание СМС-сообщений, получение координат пользователя, перехват совершаемых им звонков, а также запись происходящего вокруг в аудиофайл.





**Затруднение анализа, разделение функционала и активное противодействие удалению**  
Борьба с вредоносными Android-программами при помощи антивирусных средств и постепенное повышение компьютерной грамотности владельцев мобильных устройств на базе ОС от Google заставляет злоумышленников искать способы обхода возникающих трудностей. И если раньше троянцы представляли собой единственный программный пакет, содержащий весь вредоносный функционал, сейчас все чаще встречаются более сложные схемы их построения и работы.





Весьма интересным решением киберпреступников была своеобразная матрешка из трех вредоносных приложений, обнаруженных в мае 2012 года. Дроппер Android.MulDrop.origin.3 содержал в своих ресурсах зашифрованный пакет, который также являлся дроппером (Android.MulDrop.origin.4). Он, в свою очередь, имел в своих ресурсах еще один зашифрованный пакет, представляющий собой троянца-загрузчика Android.DownLoader.origin.2, способного получать с удаленного сервера список приложений для загрузки на мобильное устройство.





![](http://www.droidnews.ru/wp-content/uploads/2013/01/android_2012_17.jpg)




Для успешного функционирования разработанной схемы были необходимы root-привилегии, а так как основной дроппер находился в модифицированном злоумышленниками легитимном приложении, для работы которого требовался root-доступ, у пользователей не должно было возникнуть серьезных опасений в связи с необходимостью предоставления ему соответствующих прав. Примененный в данном случае механизм может быть весьма эффективным способом избежать лишних подозрений и увеличить шансы успешного заражения мобильного Android-устройства.





Другим примером разделения функционала между несколькими вредоносными приложениями являются троянцы Android.SmsSend.405.origin и Android.SmsSend.696.origin. Первый в различных модификациях распространялся в каталоге Google Play под видом сборника обоев для рабочего стола, доступ к которым пользователь мог получить, нажав кнопку «Далее». В этом случае приложение подключалось к облачному сервису Dropbox и загружало второй программный пакет, который являлся СМС-троянцем. По всей видимости, подобным переносом основного функционала во второе приложение, расположенное вне Google Play, злоумышленники пытались обойти систему Bouncer, которая контролирует каталог на предмет наличия вредоносных программ.





Весьма тревожит появление у вредоносных Android-приложений функционала по противодействию своему удалению. В мае 2012 года был обнаружен троянец Android.Relik.origin, который завершал работу популярных китайских антивирусных средств, а также запрашивал у пользователя доступ к режиму администратора мобильного устройства. В случае активации этого режима другие антивирусные программы уже не смогли бы удалить троянца, однако для избавления от этой вредоносной программы пользователю ничто не мешало убрать вредоносное приложение из списка администраторов.





Идея противодействия удалению в дальнейшем была значительно развита в другом китайском троянце, Android.SmsSend.186.origin. Практически сразу после установки он отображал требование предоставить ему права администратора мобильного устройства, причем в случае отказа требование выводилось вновь до тех пор, пока троянец не получал соответствующие права.





![](http://www.droidnews.ru/wp-content/uploads/2013/01/android_2012_18.jpg)





![](http://www.droidnews.ru/wp-content/uploads/2013/01/android_2012_19.jpg)





После получения троянцем необходимых прав попытки убрать его из списка администраторов мобильного устройства на некоторых версиях ОС Android заканчивались полным провалом, так как Android.SmsSend.186.origin препятствовал этому, не давая владельцу мобильного устройства зайти в необходимые системные настройки. Антивирусные средства, не располагающие функционалом по нейтрализации таких угроз, также не могли избавить систему от инфицирования, даже если и детектировали вредоносную программу. Самостоятельно же избавиться от троянца было весьма проблематично, поскольку это требовало выполнения ряда нетривиальных действий и определенной доли терпения. Ко всему прочему, эта вредоносная программа распространялась при помощи дроппера, помещенного киберпреступниками в «живые обои», которые при установке не требовали никаких специальных разрешений для своей работы. Таким образом, Android.SmsSend.186.origin представляет собой одну из самых серьезных за последнее время Android-угроз.





Нельзя не отметить тенденцию к росту использования авторами вредоносных программ обфускации кода, которая призвана затруднить анализ троянцев и помешать их детектированию антивирусными средствами. Например, обфускация встречается в целом ряде представителей семейства Android.SmsSend. 





**Интересные и необычные угрозы**  
Весьма интересной вредоносной программой, обнаруженной в 2012 году, стал троянец Android.MMarketPay.origin, который самостоятельно покупал приложения в электронном магазине китайского оператора связи China Mobile. Для этого он перехватывал СМС-сообщения с кодами подтверждения совершения покупки, а также обходил проверку captcha, отправляя на удаленный сервер соответствующие изображения для анализа. Целью создания этого троянца могло стать как желание недобросовестных разработчиков увеличить прибыль за счет подобной незаконной продажи своих приложений, так и обычное желание злоумышленников досадить пользователям и сотовому оператору, репутация которого могла заметно пострадать.





**Рынок заказных услуг киберпреступников?**  
Не секрет, что большая часть современных вредоносных программ создается не из простого любопытства — эта сфера незаконной деятельности уже давно стала источником заработка для самых разнообразных групп киберпреступников. И появившихся в 2012 году Android-троянцев Android.Spambot.1.origin и Android.DDoS.1.origin вполне обоснованно можно отнести к инструментам осуществления киберкриминальных услуг. Android.Spambot.1.origin представлял собой троянца, предназначенного для массовой рассылки СМС-спама. Текст сообщений и номера, по которым осуществлялась рассылка, загружались с удаленного сервера, принадлежащего злоумышленникам, поэтому им не составляло большого труда выполнить спам-рассылку для заинтересованных лиц. Чтобы скрыть свою вредоносную деятельность, троянец удалял все сведения об отправляемых СМС, и владельцы инфицированных мобильных устройств могли не сразу обнаружить подозрительную активность. Что же касается Android.DDoS.1.origin, то это — вредоносная программа, предназначенная для осуществления DoS-атак с использованием мобильных Android-устройств. Параметры, необходимые для их проведения, троянец получал посредством СМС-сообщений, в которых указывались имя сервера и требуемый порт. Особенность этой вредоносной программы — в том, что атакуемый сайт мог быть абсолютно любым, поэтому теоретически воспользоваться возможностями этой вредоносной программы могли все, кто проявит должный интерес и заплатит соответствующую цену за оказание незаконной услуги.





Вандализм — редкая, но опасная угроза c деструктивным потенциалом





На фоне общей массы вредоносных Android-приложений, направленных на получение той или иной материальной выгоды, Android.Moghava, обнаруженный весной 2012 года, держится особняком, будучи троянцем-вандалом. Он распространялся в модифицированной злоумышленниками версии приложения — сборника рецептов иранской кухни. Через определенные промежутки времени троянец выполнял на мобильном устройстве поиск JPEG-изображений в каталоге /DCIM/Camera/ и накладывал на них еще одно изображение. В результате этого фотографии пользователя безвозвратно портились.





![](http://www.droidnews.ru/wp-content/uploads/2013/01/android_2012_20.jpg)





![](http://www.droidnews.ru/wp-content/uploads/2013/01/android_2012_21.jpg)





Обычно вирусописатели создают подобные вредоносные программы с целью громко заявить о себе, либо в качестве мести или простого развлечения. Более редкой причиной является попытка совершить диверсию среди определенной группы лиц. Так или иначе, ущерб от подобных приложений может быть весьма существенным.





**Выводы**  
По состоянию на конец 2012 года вирусные базы Dr.Web содержали почти 1300 записей для Android-угроз. Их процентное распределение представлено на следующей диаграмме:





![](http://www.droidnews.ru/wp-content/uploads/2013/01/android_2012_22_450.jpg)





Следует учитывать тот факт, что специалисты компании проводят постоянную оптимизацию баз, поэтому число соответствующих вирусных записей может со временем уменьшаться.





С ростом популярности мобильных устройств под управлением ОС Android соответственно увеличивается число и разнообразие вредоносных приложений, представляющих опасность для пользователей этой платформы. Описанные выше типы угроз в 2012 году стали наиболее заметными, а также продемонстрировали потенциальный вектор развития вредоносных Android-программ в ближайшем будущем. Одновременно с этим могут появляться и вредоносные приложения, которые сочетают свойства самых разнообразных угроз или же являются «нестандартными» по сравнению с общей массой, что во многом повторяет ситуацию с Windows. Учитывая, что в ближайшие несколько лет мобильная платформа Android будет оставаться среди лидеров рынка, стоит ожидать дальнейшего роста числа созданных для нее вредоносных программ.





Источник [droidnews.ru](http://www.droidnews.ru/obzor-android-ugroz-v-2012-godu-osnovnye-riski-dlya-polzovateley)
Компания «Доктор Веб» сделала обзор Android-угроз в 2012 году. С угрозами со стороны вредоносных программ ОС Android столкнулась практически с момента своего появления на рынке. И хотя многие пользователи поначалу восприняли этот факт скептически, постепенно их сомнения сменились обеспокоенностью за безопасность используемых мобильных устройств, так как число вредоносных приложений продолжало неуклонно расти. Прошедший 2012 год в этом плане не стал исключением.





Троянцы семейства [Android.SmsSend](http://www.ferra.ru/ru/soft/news/2011/08/30/Android-SmsSend/), появившиеся еще в 2010 году и быстро ставшие настоящей головной болю пользователей мобильных Android-устройств, по-прежнему являются наиболее распространенной и массовой угрозой для этой мобильной платформы. Эти вредоносные программы предназначены для отправки дорогостоящих SMS-сообщений и подписки абонентов на различные контент-услуги, что может повлечь за собой серьезные финансовые потери (при этом жертва даже не будет знать, что деньги списаны с ее счета). Чаще всего они распространяются под видом популярных игр и приложений, а также их обновлений, однако могут встречаться и другиAе каналы распространения.


 <!-- more -->


Учитывая возможности мобильных Android-устройств, а также принимая во внимание продолжающийся рост числа их пользователей, неудивительно, что проблема сохранности конфиденциальной информации становится все более ощутимой. Рискам в этой сфере подвержены все: как простые пользователи, так и представители коммерческого и государственного секторов. Ценные сведения, интересующие злоумышленников, могут быть самыми разнообразными.





Сами по себе вредоносные программы, шпионящие за пользователями и крадущие их конфиденциальную информацию, не уникальны и известны достаточно давно. Однако в 2012 году обозначилась четкая тенденция к появлению довольно специфической группы троянцев-шпионов, направленных против жителей Японии. Все они распространялись при помощи спам-писем, в которых пользователям предлагалось установить то или иное «полезное» приложение, начиная от эротической игры и заканчивая оптимизатором расхода аккумулятора.





Узконаправленные, точечные или таргетированные атаки несут в себе серьезную угрозу, поскольку они, в отличие от большинства обычных атак, направлены не на максимально возможное число пользователей, а на их ограниченный круг, что снижает вероятность оперативного и эффективного обнаружения используемых при преступлении вредоносных программ.





![Android-угрозы](http://www.ferra.ru/images/344/344982.jpg) 
[Android-угрозы](http://news.ferra.ru/photo/techlife/news/Dr-Web-Android-2012/1872/344982)





Применение подобных вредоносных программ никогда не было массовым явлением, в том числе и для устройств под управлением [Android](http://www.ferra.ru/ru/techlife/news/2013/01/28/Trend-Micro-Android-1000000/). В 2012 году мы стали свидетелями появления лишь нескольких новых представителей этого класса троянцев, направленных на мобильную операционную систему от Google. Ими стали [Android.SpyEye.2.origin](http://www.ferra.ru/ru/soft/news/2012/06/21/drweb-Android-SpyEye/), Android.Panda.2.origin, Android.SmsSpy.6.origin и Android.FakeSber.1.origin.





Потенциальную угрозу сохранности персональной информации продолжают нести и различные виды коммерческого программного обеспечения для мониторинга и шпионажа. В 2012 году было обнаружено значительное число не только новых модификаций уже известных программ, но и новые представители этого класса приложений.





На фоне общей массы вредоносных Android-приложений, направленных на получение той или иной материальной выгоды, [Android.Moghava](http://www.ferra.ru/ru/soft/news/2012/03/02/Android-Moghava/), обнаруженный весной 2012 года, держится особняком, будучи троянцем-вандалом. Он распространялся в модифицированной злоумышленниками версии приложения — сборника рецептов иранской кухни. Через определенные промежутки времени троянец выполнял на мобильном устройстве поиск JPEG-изображений в каталоге /DCIM/Camera/ и накладывал на них еще одно изображение. В результате этого фотографии пользователя безвозвратно портились.





По состоянию на конец 2012 года вирусные базы Dr.Web содержали почти 1300 записей для Android-угроз. С ростом популярности мобильных устройств под управлением ОС Android соответственно увеличивается число и разнообразие вредоносных приложений, представляющих опасность для пользователей этой платформы. Описанные выше типы угроз в 2012 году стали наиболее заметными, а также продемонстрировали потенциальный вектор развития вредоносных Android-программ в ближайшем будущем. Одновременно с этим могут появляться и вредоносные приложения, которые сочетают свойства самых разнообразных угроз или же являются «нестандартными» по сравнению с общей массой, что во многом повторяет ситуацию с Windows. Учитывая, что в ближайшие несколько лет мобильная платформа Android будет оставаться среди лидеров рынка, стоит ожидать дальнейшего роста числа созданных для нее вредоносных программ.





Источник [pcnews.ru](http://www.pcnews.ru/news/android-2012-smssend-2010-sms-google-spyeye-origin-panda-smsspy-fakesber-moghava-jpeg-dcim-camera-dr-web-1300-425558.html)
По последним данным агентства Strategy Analytics за 2012 год в мире было продано около 700 миллионов смартфонов, при этом 684 процента от этого количества составляли устройства на базе платформы [Android](http://androidnews.com.ua/), iOS получила 194 процента, а 122 процентов пришлось на другие программные платформы. Что касается производителей смартфонов, то лидирующие позиции в 2012 году остались за Apple и Samsung, как по уровню прибыли, так и по объемам продаж. По мнению аналитиков, именно эти две компании сегодня можно считать главными противоборствующими сторонами в мобильной индустрии, а противостояние Apple и [Google](http://androidnews.com.ua/other-news/2740-google-rabotaet-nad-android-ochkami.html) начало отходить на второй план. Также в Strategy Analytics обращают внимание на замедление темпов развития рынка смартфонов. К примеру, в 2011 году рост поставок смартфонов в мире составил 64 процента, а в прошлом только 43.
Хорошая программа, для тех кто постоянно пытаеться что то сделать с файлами или папками, на своем андроид устройстве.





И так давайте посмотрим, что же нам пишет автор.





datFM - двухпанельный файловый менеджер, в первую очередь, ориентированный на планшеты.


<!-- more -->


Возможности:  
- Две активные панели  
- Мультивыделение  
- Пакетная передача файлов, включая каталоги  
- Пакетное переименование, включая каталоги  
- копирование, перемещение, удаление, создание директорий.  
- Режим Камикадзе! Для храбрых! (отключен по умолчанию)  
- Настраиваемый UI, скрытие различных его элементов, полезно любителям минимализма и устройствам с небольшим экраном.  
- Сохранение путей при выходе (можно отключить)  
- Фокусировка на папке из которой вы только что вышли (можно отключить)  
- Возможность мгновенного перехода в только что созданный каталог (можно отключить)  
- Быстрое создание новых каталогов.





![](http://s.4pda.ru/wp-content/uploads/2013/01/122-480x300.png)




**Версия: **0.1.0b





**Русский интерфейс: **Да





**Технические требования: **2.2 и выше





**Категория:** файловый менеджер





При создании каталога, если оставить поле ввода пустым и просто кликнуть ок, будет создан каталог "Новая папка", если он уже есть "Новая папка (1)" и т.д.





Пакетная передача файлов: просто выделите в списке несколько папок и файлов и отправьте их кнопкой Share. Только без фанатизма, если выбрать каталог с 1 млн файлов, он вряд ли будет передан.





Для выделения, мультивыделения - удерживайте палец или кликайте если уже выбрали хотя бы один.





![](http://s.4pda.ru/wp-content/uploads/2013/01/48-480x300.png)




Переименование: если выделить один файл в списке, то он будет переименован полностью, т.е. включая расширение. Если вы выбрали несколько файлов и каталогов, расширения для файлов остаются.





Например было:





folder  
folder a  
file.apk  
file.doc





Переименуем их в "for_sending", получаем:





for_sending_1





for_sending_2





for_sending_3.apk





for_sending_4.doc





 





![](http://s.4pda.ru/wp-content/uploads/2013/01/35-480x300.png)
![](http://s.4pda.ru/wp-content/uploads/2013/01/122-480x300.png)



**Используйте режим камикадзе с осторожностью!**





**ВАЖНО: Это все еще pre-beta, не используйте ее для работы с важными данными!**





** **





**Стоимость:** Бесплатно





**Обсуждение на 4pda:** [http://4pda.ru/forum/index.php?showtopic=423956](http://4pda.ru/forum/index.php?showtopic=423956)





**Ссылка на Google Play:** ![QR](http://s.4pda.ru/forum/style_images/1/qr_code.gif)[https://play.google.com/store/apps/details?id=com.zlab.datFM](https://play.google.com/store/apps/details?id=com.zlab.datFM)





**Бонусы от разработчика:** Буду рад помощи, комментариям, поддержке, советам, конструктивной критике и хорошим предложениям. Все клевые идеи из комментариев, будут добавлены в функционал.





Источник [4pda.ru](http://4pda.ru/2013/01/30/87638/)
Не так давно китайские товарищи, выпускали телефоны с телевизором.





Ну вот их эра уже давно закончилась.





Теперь все использую андроид.





Но что же, разве андроид не позволяет смотреть видео и фильмы? - Позволяет.





Так почему же нельзя сделать ТВ для андроид?


<!-- more -->


Как только я задал себе эти вопросы, я сразу же и получил список программ, которые позволяют это делать.





Надеюсь вам понравиться.





Превратите ваш смартфон в полноценный телевизор. В приложении Вы найдете популярные телеканалы и телепрограмму к ним.





![Разработчик: Premium TV - Android телевизор в кармене](http://s.4pda.ru/wp-content/uploads/2013/01/premium-tv1-287x480.jpg)





**Версия: **1.1





**Русский интерфейс: **Да





**Технические требования: **не менее 2.1





**Категория:** Мультимедиа









В приложении реализована телепрограмма на неделю по каждому каналу. Если у Вас установлен MX Player приложение автоматически открывает тв поток используя MX Player.





![](http://s.4pda.ru/wp-content/uploads/2013/01/premium-tv3-287x480.jpg)
![](http://s.4pda.ru/wp-content/uploads/2013/01/tv-premium21-287x480.jpg)




**Стоимость:** Бесплатно





**Ссылка на Google Play:** ![QR](http://s.4pda.ru/forum/style_images/1/qr_code.gif)[https://play.google.com/store/apps/details?id=com.roolez.mplayer01](https://play.google.com/store/apps/details?id=com.roolez.mplayer01)





Источник [4pda.ru](http://4pda.ru/2013/01/25/87064/)
Круто знать много английских слов.





И это приложение как раз то, что позволяет их хорошо заучивать.





Смотрим, что же нам приготовили авторы.





Любой человек, активно изучающий иностранный язык, знает как важно постоянно пополнять свой словарный запас. Новые слова попадают к нам из разных источников. Их дают репетиторы на уроках, мы выписываем их из блогов, журналов. К сожалению, многим из нас не хватает времени на заучивание накопившихся слов, но согласитесь, что в течение дня часто находятся свободные минутки, которые нечем занять, к примеру, ожидание приема врача, путь до работы или домой.





Для тех, кто старается каждую минуту провести с пользой я хочу представить приложение для заучивания иностранных слов “Я учу слова PRO”.





Далее пойдет рассказ о приложении и о возможностях, которыми оно обладает на сегодняшний день.





![](http://s.4pda.ru/wp-content/uploads/2013/01/teach1.png)




**Версия: **0.1





**Русский интерфейс: **Да





**Технические требования: **Android 2.1 и выше





**Категория:** Образование









Изначально этот обзор планировался чуть позже, но публикуется именно сейчас. Тем кто дочитает его до конца я объясню почему.





При первом запуске приложение предложит вам выбрать изучаемый язык. После этого вам будут показаны имеющиеся для данного языка базовые словари. Нажав на один из них можно сразу приступить к изучению слов либо при помощи вкладки “Добавить” создать свой собственный словарь.





![](http://s.4pda.ru/wp-content/uploads/2013/01/select_languages.png)
![](http://s.4pda.ru/wp-content/uploads/2013/01/select_dictionary.png)



Если вы выбрали базовый словарь, то можете смело пропустить пару абзацев, т.к. в них я расскажу о добавлении собственных слов в созданный вами словарь.





И так. После добавления собственного словаря вы будете переправлены на страницу изучения слов. Так как словарь пуст, вам будет предложено добавить слова через приложение, либо добавить на специальном сайте и импортировать в приложение.  
Первый вариант создан прежде всего для экстренного добавления слова, когда компьютера под рукой нет, а добавить его просто необходимо.





![](http://s.4pda.ru/wp-content/uploads/2013/01/add_words.png)



Импорт же дает множество преимуществ, а именно автоматическое определение транскрипций для английских слов и автоматическое определение переводов. А еще можно загрузить готовые списки в форматах Microsoft Excel (95 и выше), OpenOffice Calc, CSV и TSV.





![](http://s.4pda.ru/wp-content/uploads/2013/01/site-480x291.png)



После добавления слов вам нужно будет просто ввести полученный код в приложении, после чего все слова будут добавлены в ваш словарь.





![](http://s.4pda.ru/wp-content/uploads/2013/01/import_words.png)




Теперь о главном. Изучение происходит сессиями. Приложение выбирает определенное количество слов из вашего словаря (устанавливается в настройках, по умолчанию 50) и показывает их по кругу. Если у какого либо слова будет нажата клавиша “Выучил”, слово отмечается как изученное и отправляется в очередь на проверку, а количество слов в сессии уменьшается на одно. Когда в сессии их останется 10, приложение дополнит её до 50-и.





![](http://s.4pda.ru/wp-content/uploads/2013/01/teach.png)




Кстати, при нажатии на транскрипцию в английском словаре можно увидеть ее расшифровку.





Как я говорил ранее все выученные вами слова попадают в очередь на проверку.  
Интервалы проверок можно указать в настройках.  
Изначально в приложении установлены следующие интервалы:








  1. первая через сутки;



  2. вторая через 3 дня;



  3. третья через неделю;



  4. четвертая через месяц;






Помимо интервалов имеются разные методики проверки знаний.








  1. видим слово - выбираем перевод;



  2. видим перевод - выбираем слово;



  3. видим перевод - пишем слово;






Для каждого интервала вы можете установить методику по вашему вкусу в настройках приложения.





![](http://s.4pda.ru/wp-content/uploads/2013/01/check.png)
![](http://s.4pda.ru/wp-content/uploads/2013/01/check2.png)
![](http://s.4pda.ru/wp-content/uploads/2013/01/check3.png)




Если при проверки вы допустите ошибку, слово будет отправлено на повторное изучение.





Методика изучения и проверки построена таким образом, чтобы можно было занимать любое количество времени. И не важно сколько у вас появилось свободных минут 1 или 30!





Настройки приложения:





![](http://s.4pda.ru/wp-content/uploads/2013/01/settings.png)
![](http://s.4pda.ru/wp-content/uploads/2013/01/settings2.png)




На этом все о приложении.





Данную версию я считаю стабильной, но она далека от того, что должно получиться в итоге. В самое ближайшее время будет закончена работа по полной синхронизации словарей между устройствами и сайтом. Появится возможность просмотра словарей, управления ими на сайте. Все данные будут синхронизироваться через ваш google аккаунт. Помимо этого к синхронизации будет подключен браузер Google Chrome, так что в один клик можно будет добавить любые слова и из него.





Стоимость приложения всего 48 рублей. Тем кто много курит, могу посоветовать пропустить одну пачку и сделать вклад в свое развитие. :-)





Всем спасибо за внимание. Учите языки, становитесь умнее!





**Стоимость:** 48руб.





**Ссылка на Google Play:** ![QR](http://s.4pda.ru/forum/style_images/1/qr_code.gif)[https://play.google.com/store/apps/details?id=com.shelestov.ilw.pro](https://play.google.com/store/apps/details?id=com.shelestov.ilw.pro)





Источник [4pda.ru](http://4pda.ru/2013/01/26/87314/)
Вот встретил прикольную программу.





Которая дописывает к вашим контактам дополнительную информацию.





И выводит, когда совершается звонок.





Я часто добавляю заметки к контактам в адресной книге, так как людей с одинаковыми именами много, и их надо как-то различать. А память иногда подводит. Но во время звонка, именно когда эти заметки особенно нужны, они недоступны. Поэтому я решил упростить жизнь себе и другим и создал приложение Call Notes.





![](http://s.4pda.ru/wp-content/uploads/2013/01/call_notes_banner-300x146.png)

<!-- more -->

**Версия: **2.3





**Русский интерфейс: **Да





**Технические требования: **Froyo, Gingerbread, ICS, Jelly Bean





**Категория:** Бизнес









Приложение выводит на экран заметку из адресной книги во время звонка, без разницы, входящий это звонок или исходящий.  Таким образом, вы можете быстро понять или вспомнить, кто вам звонит, и решить, стоит ли вообще подходить к телефону! :)





Возможности:












  * выводить заметку на экран в течение всего разговора или установленного промежутка времени;



  * отображать дополнительную информацию, например день рождения, должность, название компании (PRO версия);



  * быстро редактировать заметку напрямую из приложения и даже во время самого звонка! (PRO версия);



  * модифицировать заметку в соответствии со своими предпочтениями, меняя выравнивание, цвет и размер шрифта, цвет фона.










Поддерживает Froyo, Gingerbread, ICS и Jelly Bean Android версии. HTC Sense, к сожалению, не поддерживается.





![](http://s.4pda.ru/wp-content/uploads/2013/01/unnamed-287x480.png)
![](http://s.4pda.ru/wp-content/uploads/2013/01/unnamed6-270x480.jpg)



![](http://s.4pda.ru/wp-content/uploads/2013/01/unnamed-1-287x480.png)
![](http://s.4pda.ru/wp-content/uploads/2013/01/unnamed-2-287x480.png)



У приложения две версии: бесплатная (без рекламы) и платная Pro версия.





**Стоимость:** Бесплатно





**Обсуждение на 4pda:** [http://4pda.ru/forum/index.php?showtopic=247891](http://4pda.ru/forum/index.php?showtopic=247891)





**Ссылка на Google Play:** ![QR](http://s.4pda.ru/forum/style_images/1/qr_code.gif)[http://play.google.com/store/apps/details?id=com.nikanorov.callnotes](http://play.google.com/store/apps/details?id=com.nikanorov.callnotes) (Бесплатная версия)





**Ссылка на Google Play:** ![QR](http://s.4pda.ru/forum/style_images/1/qr_code.gif)[http://play.google.com/store/apps/details?id=com.nikanorov.callnotespro](http://play.google.com/store/apps/details?id=com.nikanorov.callnotespro) (Платная версия)





Источник [4pda.ru](http://4pda.ru/2013/01/28/87506/)
Когда то в детстве я очень мечтал научиться играть на клавишах всем извесной Ямахи.





Но вот как то не сложилось, и я только научился играть на клавишах клавиатуры.





А сейчас время не стоит на месте. И авторы этой программы как раз об этом и рассказывают.





Простой и быстрый "читатель" и проигрыватель гитарных табов. Может читать и играть Guitar Pro файлы. Есть веб поиск.





![](http://s.4pda.ru/wp-content/uploads/2013/01/vmlite-android-v4_21-480x360.png)

<!-- more -->

**Версия: **2.1.4





**Русский интерфейс: **Да





**Технические требования: **>= Android 2.1





**Категория:** Для музыкантов









Хотите чтобы ваши табулатуры всегда были с вами? Guitar Tab Player позволяет читать и проигрывать любой Guitar Pro формат. Причем делать это быстро и удобно.





![](http://s.4pda.ru/wp-content/uploads/2013/01/vmlite-android-v4_2-480x360.png)
![](http://s.4pda.ru/wp-content/uploads/2013/01/vmlite-android-v4_3-480x360.png)



![](http://s.4pda.ru/wp-content/uploads/2013/01/vmlite-android-v4-480x360.png)



Вы увидите все нюансы произведений, заложенные авторами на вашем мобильном устройстве. Восходящий-, нисходящий-, глиссандо- слайд, точные переходы от приема к приему, вибрато с бендом, и прочее - все это отображается как и должно, никаких упрощений.





Практически мгновенная скорость загрузки, удобный и не перегруженный интерфейс, возможность автоматического поиска табов в интернете - все это Guitar Tab Player.





**Стоимость:** Содержит рекламу





**Обсуждение на 4pda:** [http://4pda.ru/forum/index.php?showtopic=414655&st=0&p=18240684](http://4pda.ru/forum/index.php?showtopic=414655&st=0&p=18240684)





**Ссылка на Google Play:** ![QR](http://s.4pda.ru/forum/style_images/1/qr_code.gif)[http://play.google.com/store/apps/details?id=guitartab.player](http://play.google.com/store/apps/details?id=guitartab.player)





Источник [4pda.ru](http://4pda.ru/2013/01/29/87484/)
Всем привет друзья.





Сегодня я хотел бы поведать вам о программе которая поможет вам не попасть в ловушку при оформлении кредита.





Почему это так важно. Да все по тому, что большинство людей берут товары в кредит, при этом даже не подозревают, что на одной покупке можно с экономить до 10-20%.





Ну, что посмотрим, что нам покажет автор.


 <!-- more -->


Программа позволяет рассчитывать досрочные погашения при оплате кредита рассчитанных по схеме аннуитетных платежей.





![](http://s.4pda.ru/wp-content/uploads/2013/01/unnamed1.png)





**Версия: **1.1





**Русский интерфейс: **Да





**Технические требования: **Android 2.2





**Категория:** Программа









![график ](http://s.4pda.ru/wp-content/uploads/2013/01/unnamed-11.png)



Программа позволяет рассчитывать досрочные погашения при оплате кредита рассчитанных по схеме аннуитетных платежей.  Допустим мы берем кредит в банке и платим по графику равными долями, так как насчитал банк, но в следующем месяце у нас появился какой-то доход, премия, халтура и.д. С помощью этой программы можно очень просто рассчитать сколько будет следующий платеж если мы досрочно внесли сумму.





Например 10 000р. на 10мес. под 10% ежемесячный платеж 1046р., но через 3 месяца мы получили премию 2000, и хотим досрочно погасить 3046р. (2000+1046), тогда в четвертом месяце мы уже будем платить 786р.





Также программа может работать в обратном режиме, рассчитать долг по ежемесячному платежу а потом рассчитать досрочные погашения.





**Стоимость:** 30руб.





**Ссылка на Google Play:** ![QR](http://s.4pda.ru/forum/style_images/1/qr_code.gif)[https://play.google.com/store/apps/details?id=com.sumac](https://play.google.com/store/apps/details?id=com.sumac&feature=search_result#?t=W251bGwsMSwxLDEsImNvbS5zdW1hYyJd)





Источник [4pda.ru](http://4pda.ru/2013/01/29/87628/)
Как часто вы ищете значение того, или иного слова.





Иногда, я сам смотрю, что это, что то....





Вот нашел, что выпустили приложение, решил поделится.





В нашей стране вряд ли найдется такой человек, который хоть раз, да не услышал краем уха про Большую советскую энциклопедию. Из всех своих аналогов и «конкурентов» именно БСЭ является самой известной, популярной и полной универсальной энциклопедией.





![Большая Советская Энциклопедия](http://www.droidnews.ru/wp-content/uploads/2013/01/bolshaya_sovetskaya_enciklopedia_1.jpg)

 <!-- more -->



Выпускалась данная энциклопедия аж с 1926 года (по 1990), а теперь она стала доступна не только в издании из шестидесяти пяти томов, но и на простых устройствах.





Приложение для планшетов и смартфонов с OS Android « Большая Советская Энциклопедия» содержит примерно девяносто пять тысяч уникальных статей. Причем все они доступны в режиме оффлайн, что позволяет найти нужную информацию даже в тех случаях, когда доступ к интернету ограничен, или и вовсе отсутствует.









![Большая Советская Энциклопедия](http://www.droidnews.ru/wp-content/uploads/2013/01/bolshaya_sovetskaya_enciklopedia_2.jpg)





Для установки приложения «Большая Советская Энциклопедия» вам не придется долго сидеть и ждать, ведь основная часть статей (архив размером около двух с половиной сотен МБ) загружается уже при первом запуске т.е после установки). Желательно при скачивании использовать Wi-Fi соединение, ведь мало того, что вы минимизируете вероятность потери пакетов данных, так ещё и не получите счет на круглую сумму, ведь статей в эциклопедди действительно много. Хотите по биологии что-то узнать или хоть про [воздуховоды для вентиляции](http://ventfabrika.com/) — пожалуйста!





![Большая Советская Энциклопедия](http://www.droidnews.ru/wp-content/uploads/2013/01/bolshaya_sovetskaya_enciklopedia_3.jpg)





В приложении найдется не мало «примочек», которые выгодно отличают его от аналогов:  
1. Каждое слово, которое вы когда-то искали в Большой Советской Энциклопедии, сохранится в истории, и вы всегда сможете в несколько касаний вернуться на нужную вам статью.  
2. Закладки – нажмите на «звездочку» и нужная статья появится в закладках и в следующий раз вам не придется долго искать её.  
3. Редактирование списков (закладки и история): как только старая закладка окажется вам ненужной, вы сможете стереть её или отредактировать.  
4. Множество настроек позволит вам сделать энциклопедию максимально комфортной, ведь шрифт, вид и даже тему вы сможете настроить так, как вам хочется.  
5. Если вы не знаете, как что-то, то с помощью модуля TEXT-TO-SPEECH вы запросто сможете превратить текст в речевую форму и прослушать, как правильно произносить то или иное слово. (Данная функция использует интернет-соединение).  
6. Хотите узнать перевод какого-то слова? Просто нажмите на него прямо в статье и вы тут же узнаете все возможные варианты перевода.  
7. Случайное слово – функция, которая ежедневно выводит одно слово из энциклопедии на ваш стол (с помощью виджета), однако для этого приложение нужно устанавливать в память телефона.





[Скачать Большая Советская Энциклопедия — apk](http://depositfiles.com/files/j3fvft0ta).





[Установить Большая Советская Энциклопедия через Google Play](https://play.google.com/store/apps/details?id=com.vpdevelopment.dict.rusbse.free).





![](http://www.droidnews.ru/wp-content/uploads/2013/01/bolshaya_sovetskaya_enciklopedia_qr.png)







Источник [droidnews.ru](http://www.droidnews.ru/bolshaya-sovetskaya-ehnciklopediya-ona-deystvitelno-bolshaya)
Посмотрим, что же android может предложить нам в плане фотографий!?









**Pixlr Express** – это очень мощный инструмент для обработки фотографий прямо на устройствах под управлением операционной системы Android. Приложение позволяет обрезать фотографии, устанавливать баланс цветов, контраст, применять огромное количество фильтров, дополнительных эффектов, а также устанавливать всевозможные рамки. Поскольку Pixlr Express – это разработка компании Autodesk Inc, то можно смело сказать приложение качественное.













В приложении присутствует более 600 эффектов, накладок и рамок, с помощью которых можно картинку менять как угодно. Если на фотографии Вы увидели красные глаза или не очень белые зубы, то с помощью данного приложения от этих изъянов можно быстро избавится. Почувствуйте себя профессионалом в обработке изображений используя лишь свой смартфон или планшет.  





Особенности Pixlr Express:


<!-- more -->


- обрезка, изменение размера, выравнивание и поворот изображений в одно движение;





- быстрое исправление фотографий, балансировка цвета, поправки темных фото или фото сделанных в плохих условиях освещения;





-   инструменты для исправления красных глаз и отбеливания зубов;





- эффект наложения для усиления тонуса, добавления сюрреалистических оттенков;





- световые эффекты для добавления блеска или четкости взгляду;





- возможность регулировки интенсивности и направленности эффектов;





- исправление эффектов размытия, удаление шумов и много другое;





- большое количество инструментов для настройки контрастности, яркости;





- делитесь прямо их приложения своими фотографиями в социальных сетях Facebook, Instagram, Twitter;





- возможность редактировать любое изображение, а не только фотографий сделанных с помощью камеры.













**Версия Android: 2.2 и выше**

















![pixlr_express1.jpg](http://all4pda.org/cache/com_zoo/images/pixlr_express1_1fe5c9e8a2e6a9fbc95abaf6c4faa384.jpg)
![pixlr_express2.jpg](http://all4pda.org/cache/com_zoo/images/pixlr_express2_b529cf9067ed5eedd87c7d21d4bb686a.jpg)
![pixlr_express3.jpg](http://all4pda.org/cache/com_zoo/images/pixlr_express3_3c9a0955b836c001bf424b68bcdffb64.jpg)
![pixlr_express4.jpg](http://all4pda.org/cache/com_zoo/images/pixlr_express4_0e744ae485af21a6842dd740861dcb41.jpg)
![pixlr_express5.jpg](http://all4pda.org/cache/com_zoo/images/pixlr_express5_96f6f007aa06582b28fbccb71f3b8994.jpg)












 













**Перейти на маркет**





![](http://all4pda.org/media/images/Android-Market.png)












 Источник [all4pda.org](http://all4pda.org/multimediya/pixlr-express-instrument-dlya-obrabotki-fotografij.html)




Купил вот себе android box.





Подключил его к телевизору.





Думаю как же мне теперь смотреть мои любимые сериалы?





И тут я нашел программу **Ex.ua** использую сам и вам рекомендую.





Глянем, что она может делать?


 <!-- more -->






Все поклонники ресурса ex.ua, на котором собрано огромное количество видеофайлов, могут просматривать видео прямо из своего смартфона или планшета под управлением Android. Специально для этого  было создано приложение **EX****.****UA** **видео**, которое позволяет без регистрации, а главное совершенно бесплатно просматривать любое содержимое от самых последних фильмов до фильмов раритетного возраста. Нет необходимости бродить по огромному количеству сайтов, теперь все доступно из одного приложения.













Все содержимое очень удобно расположено и разбито по категориям, что позволит в несколько кликов найти [бесплатные сериалы](http://www.ivi.ru/videos/all/series/all/by_day/), фильмы, клипы, мультфильмы или передачу по конкретному жанру, названию, режиссёру или актеру. Все сделано для пользователя, удобный интерфейс и быстрая работа.





Выбрав интересующий фильм, можно перейти на страничку с его описанием, скриншотами самых важных моментов  и комментариями пользователей. Но самое главное – это то, что здесь можно найти список файлов, которые можно просмотреть прямо из приложения или же скачать себе на устройство. Многие фильмы имеют файл FLV, который значительно меньше размером основного файла, что позволит без проблем просматривать фильмы на низкоскоростных подключениях к Интернету. Все просмотренные фильмы и клипы попадают в историю, кроме того без проблем можно делать закладки с интересующим контентом.





Приложение позволит проводит закачку нескольких файлов одновременно, в случае обрыва соединения предусмотрена докачка. Во время загрузки есть возможность просматривать видеофайлы прямо на ходу. Для того чтобы все фильмы шли необходимо на устройство установить кодеки или же профессиональный плеер MX Player PRO.





Приложение построено на контенте популярного ресурса ex.ua, который предлагает своим пользователям тысячи разнообразных видеофайлов.













**Версия Android: 2.0 и выше**













![](http://all4pda.org/images/programs/multimedia/ex_ua/ex_ua1.jpg)





![](http://all4pda.org/images/programs/multimedia/ex_ua/ex_ua2.jpg)





![](http://all4pda.org/images/programs/multimedia/ex_ua/ex_ua3.jpg)





![](http://all4pda.org/images/programs/multimedia/ex_ua/ex_ua4.jpg)









 













**Перейти на маркет**





![](http://all4pda.org/media/images/Android-Market.png)








Источник [all4pda.org](http://all4pda.org/multimediya/exua-filmy-onlajn.html)
Привет друзья.





Огромное количество браузеров сейчас лежит на маркете.





И вот я наткнулся на статью, в которой описываю все возможности этих браузеров.





Читайте и комментируйте.


 <!-- more -->






Не секрет, что сегодня платформа Android набрала больших оборотов и робота с Web станицами стала просто необходимостью. Каждый пользователь, покупая смартфон или планшет, желает получить полнофункциональное устройство для работы Интернетом. Браузер – это инструмент, который позволит осуществить полнофункциональную работу с Web. Многие производители устройств оснащают устройства браузерами, но они обладают довольно скромными возможностями. Для этого много производителей софта разрабатывают свои браузеры Android.





Рассмотрим самые распространенные браузеры для ОС Android













**Opera mobile (**[перейти на страницу скачки](http://all4pda.org/index.php?option=com_zoo&task=item&item_id=88&category_id=32&Itemid=155))





Один из самых популярных браузеров. Opera mobile позволяет сжимать трафик, что позволяет значительно экономить трафик и ускоряет передачу данных. Все сайты загружаются через прокси-сервера Opera, и из серверов в сжатом виде передаются на устройство. Главная страница открывается в виде плитки в которой можно лицезреть любимые сайты. В низу расположена удобная кнопка меню, а также кнопка переключения вкладок. Интерфейс очень удобный и понятный, легкий в использовании.





![](http://all4pda.org/media/ckfinder/images/opera%20mobile.jpg)![](http://all4pda.org/media/ckfinder/images/opera%20mobile1.jpg)





Плюсы:





- сжатие трафика по необходимости;





- хорошо продуманный интерфейс;





- низкие требования железу.





Минусы:





- нет перелистывания кнопками переключения громкости;





- отсутствует голосовой поиск;





- нет полноэкранного режима.









**Dolphin Browser (**[перейти на страницу скачки](http://all4pda.org/internet/internet-brauzer-dolphin-browser.html)**) **





Один наиболее популярных браузеров для платформы Android. В браузере присутствует огромное количество плагинов, которые можно легко установить. Кроме этого в браузере предусмотрен голосовой поиск, а также поддержка жестов. Для их активации необходимо использовать специальный символ, который находится в нижнем углу. Как особенность - Dolphin browser работает с устройствами на Android 2+.





![](http://all4pda.org/media/ckfinder/images/dolphin%20browser.jpg)![](http://all4pda.org/media/ckfinder/images/dolphin%20browser1.jpg)





Плюсы:





- наличие большого количества плагинов;





- голосовой поиск;





- предусмотрена синхронизация закладок.





Минусы:





- нет перелистывания кнопками переключения громкости;





- нет докачки после разрыва соединения.









**UC Browser (**[прейти на страницу скачки](http://all4pda.org/internet/mobilnyj-brauzer-uc-browser.html)**)**





Это еще один браузер для Android с возможность сжатия трафика (составит конкуренцию Opera Mobile). Он довольно новы и уже вошел в топ скачиваемых программ. В браузере предусмотрено очень удобное переключение вкладок. Также предусмотрена возможность докачки файлов, что важно при работе с мобильным интернетом. В UC предусмотрена возможность работы со страницами с помощью кнопок громкости, а также голосовой поиск. Отличный браузер для любых устройств на ОС Android.





![](http://all4pda.org/media/ckfinder/images/uc%20brawser.jpg)![](http://all4pda.org/media/ckfinder/images/uc%20brawser1.jpg)





Плюсы:





- сжатие трафика;





- перелистывание страниц кнопками громкости;





- докачка файлов;





- удобный голосовой поиск.





Минусы:





- не предусмотрена синхронизация закладок.









**Firefox mobile (**[перейти на страницу закачки](http://all4pda.org/internet/firefox-nabiraet-oboroty-na-android.html)**)**





Не секрет, что для компьютера одним из лучших браузеров, подерживающих различные [шаблоны сайтов](http://joomla-master.org/), есть Firefox. Вот и для платформы Android разработчики создали мобильный браузер. В нем предусмотрена возможность использования огромного количества плагинов, которые можно доустановить. В целом браузер немного сыроват и значительно уступает аналогам других производителей по скорости и производительности работы. Возможно в будущем разработчики наверстают





![](http://all4pda.org/media/ckfinder/images/firefox1.jpg)![](http://all4pda.org/media/ckfinder/images/firefox.jpg)





Плюсы:





- синхронизация вкладок, закладок и паролей;





- возможность использовать множество плгинов.





Минусы:





- тяжелый в работе;





- нет перелистывания страниц кнопками громкости;





- нет поиска по голосу.









**Matrox mobile ([перейти на страницу закачки](http://all4pda.org/internet/internet-brauzer-maxthon-mobile.html))**





Это довольно удобный мобильный браузер в котором есть очень удобный и продуманный интерфейс. В Matrox mobile также есть возможность работы с кнопками регулировки звука, синхронизация закладок с сервером. Для расширения функционала предусмотрено огромное количество плагинов.





![](http://all4pda.org/media/ckfinder/images/matrex.png)![](http://all4pda.org/media/ckfinder/images/matrex1.jpg)





Плюсы:





- очень удобный интерфейс;





- поддержка плагинов;





- синхронизация закладок с сервером;





- работа с кнопками регулировки громкости.





Минусы:





- нет голосового поиска.





[Мобильные браузеры для андроид скачать бесплатно](http://www.androidik.me/programmy/brauzery/) можно прямо на нашем сайте в разделе интернет. В данной статье перечислены только самые популярные браузеры для платформы Android. Как видно, функционал рассмотренных браузеров позволит выполнить все основные функции работы с Web. Выбор за Вами!









Источник [all4pda.org](http://all4pda.org/obzory/vybor-brauzera-dlya-platformy-android.html)




Всем привет.





Очередная подборка полезных программ.





Часто ли вам приходится путешествовать по своему телефону, а как часто вы пытаетесь, что то найти в ваших папках?





Тогда приложение **X-Plore File Manager **для вас.





Посмотрим, что пишут авторы.


<!-- more -->






Сейчас трудно представить работу на ПК без нормального файлового менеджера, который позволит значительно экономить время при просмотре файлов и папок, сделает работу с файлами удобной и быстрой. Вот и для устройств на мобильной платформе Android созданы подобные приложения, ярким представителем которых есть **X-Plore****File ****Manager. **Данное приложение уже не один год трудится на различных мобильных ОС и зарекомендовало себя с лучшей стороны.













Приложение позволяет выполнять все основные функции: копирование, перенос, создание папок и файлов, но кроме этого в нем присутствует еще множество функций, которые делают его использование выгоднее по сравнению с другими. Также есть возможность закрыть доступ к системным папкам, что позволит уберечь систему от нежелательных действий неопытных пользователей.





X-Plore File Manager имеет очень гибкую систему работы с мультимедиа, что выражается в возможности воспроизведения таких файлом прямо из интерфейса приложения. Вы можете легко перейти к древовидной структуре папок, что позволит легко ориентироваться в файловой системе. Также предусмотрено две панели, которые дают возможность быстро осуществлять все основные операции.





**Особенности X-Plore File Manager:**





- быстрый и удобный поиск в текстовых файлах;





- поддержка хранения данных и их обработка в системах Microsoft SkyDrive, Dropbox, Яндекс.диск, Google Drive (облачное хранилище);





- возможность работы с серверами данных при помощи Wi-Fi;





- возможность делится изображениями с миром прямо из интерфейса;





- предусмотрен алгоритм подсчета MD5 / SHA1 контрольных сумм фалйлов;





- возможность редактирования файлов с помощью встроенного редактора HEX;





- поддержка большинства существующих типов архивирования;





- копирование ссылок в буфер обмена;





- проведена оптимизация для ОС Android 4.1;





- возможность просмотра скрытых папок и файлов;





- гибкость настройки;





- улучшенная система работы в локальной сети.





X-Plore File Manager – это действительно нужное приложение на любом смартфоне или планшете под управлением Android. Это приложение может взять на себя много функций, для выполнения которых необходимо доставлять различный софт. Плюсы очевидны: дополнительное место в памяти, нет необходимости учится работать с разными приложениями, высокое показатели скорости при работе с файлами.













**Версия Android: 2.1 и выше**

















![x_plore_file_manager1.jpg](http://all4pda.org/cache/com_zoo/images/x_plore_file_manager1_28644ebe0f3fabc8b2b9c048a03baf95.jpg)
![x_plore_file_manager2.jpg](http://all4pda.org/cache/com_zoo/images/x_plore_file_manager2_11752a33dab096ed3dc4a4d12441baeb.jpg)
![x_plore_file_manager3.jpg](http://all4pda.org/cache/com_zoo/images/x_plore_file_manager3_4a2f5f8348bf4e6633eb177170c0cafe.jpg)
![x_plore_file_manager4.jpg](http://all4pda.org/cache/com_zoo/images/x_plore_file_manager4_f01b1940b76c21bb746786e1f879a781.jpg)
![x_plore_file_manager5.jpg](http://all4pda.org/cache/com_zoo/images/x_plore_file_manager5_8d03243b49c80d0bf7d93a3ce1ab9993.jpg)












 













**Перейти на маркет**





![](http://all4pda.org/media/images/Android-Market.png)












 Источник [all4pda.org](http://all4pda.org/sistemnye/x-plore-file-manager-udobstvo-i-prostota-raboty-s-fajlovoj-sistemoj.html)




Не успел опубликовать предыдущую статью.





Как нашел статью, где целый ряд поддельных программ.





Смотрим и удаляем из своего устройства.





А и чуть не забыл, пишем комментарии и лайки приветствуются тоже  :lol:


<!-- more -->


В последнее время в магазине Google Play все чаще стали появляться поддельные приложения, маскирующиеся под именитые и популярные аналоги. Об этом вчера в своем отчете сообщили эксперты из компании [Help Net Security](http://droider.ru/goto/http://www.net-security.org/).





![Help Net Security](http://droider.ru/wp-content/uploads/2013/01/125-521x400.jpg)





По данным исследователей, такая проблема существует не только на Android. С поддельными приложениями сталкиваются и пользователи яблочной платформы. Но в **App Store** такие программы долго не задерживаются. Да и нанести особого ущерба пользователям, по данным экспертов, они не могут.





С **Android** ситуация обстоит несколько иначе. Владельцы Android устройств, которые установили поддельные приложения, рискуют лишиться своей личной информации, или получить целую гору рекламных сообщений и уведомлений.





 ![Help Net Security](http://droider.ru/wp-content/uploads/2013/01/224-518x400.jpg)





В большинстве случаев поддельные приложения похожи на оригинал не только названием.  Обычно разработчики таких программ используют оригинальные скриншоты, а иногда и копируют часть описания.





Чтобы обезопасить себя от поддельных приложений в **Google Play**, мы настоятельно рекомендуем пользователям перед скачиванием внимательно прочитать описание приложения, просмотреть его рейтинг и отзывы.





Источник [droider.ru](http://droider.ru/post/help-net-security-v-google-play-mnogo-poddelnyih-prilozheniy-22-01-2013/)




Прикольная программа для видео.





Посмотрев ролик, я понял что нужно ставить теперь себе на балкон камеру.





И буду теперь наблюдать как растет у меня там сосулька.





Может потом на канале дискавери, мне дадут вести передачу о макро съемке.





Что то меня не туда понесло.

<!-- more -->



Читаем и смотрим видео. И еще, пишем ваши комменты и ставим лайки.





Storyboard Days - замедленная киносъёмка или фотосъёмка с точным количеством кадров в минуту. Если взять любой достаточно медленный процесс: стройка, ремонт, восход, бегущие по небу облака, вид из окна "многоэтажки" тоже подойдет. И снять его на камеру, а потом ужать до короткого ролика. Мы получим отличное видео.





![](http://s.4pda.ru/wp-content/uploads/2013/01/market_11-480x288.jpg)




**Версия: **1.0.3





**Русский интерфейс: **Да





**Технические требования: **Android 2.2 и выше





**Категория:** Развлечения, Фотография









Storyboard Days - замедленная киносъёмка или фотосъёмка с точным количеством кадров в минуту. Если взять любой достаточно медленный процесс: стройка, ремонт, восход, бегущие по небу облака, вид из окна "многоэтажки" тоже подойдет. И снять его на камеру, а потом ужать до короткого ролика. Мы получим отличное видео:









Собственно в этом и есть суть time lapse видео. А проект Storyboard Days позволяет делать такие видео с помощью простого смартфона или планшета на Android.





Безусловно это не первая программа делающая такие видео, но аналоги не обладают некоторыми преимуществами:








  * Видео можно формировать задом наперед, это делает видео более необычным для глаза.



  * На картинке можно выбрать прямоугольник из которого будет создано видео.



  * Можно менять разрешение и количество кадров в секунду для уже отснятого материала.



  * Полученные снимки можно редактировать(удалять неудачные или лишние).



  * Необязательно создавать видео из всех полученных снимков. Можно выбрать нужный интервал.



  * Если что то не получилось с первого раза, из отснятого материал всегда можно пере рисовать видео снова, с новыми настройками.



  * Проект позволяет делать отличные HD видео, даже на медленных устройствах.






Все эти мелочи, делают программу более профессиональной и удобной в работе.





Но эти возможности требуют внешних ресурсов, фотографии перед обработкой должны быть закачены на сайт [http://storyboarddays.com](http://storyboarddays.com/), поэтому программа передает по WiFi (или 3G), и не дай бог по 2G, большие объемы данных. Это нужно понимать перед тем как начинать работать с программой.





Есть в программе возможность съемки в ручную, такой режим удобен при создании анимации. Вряд ли такой функционал будет полезен профессионалам, но на уровне детского сада, школы - запросто. Вот пару примеров:

















![](http://s.4pda.ru/wp-content/uploads/2013/01/market_2-480x288.jpg)
![](http://s.4pda.ru/wp-content/uploads/2013/01/market_3-480x288.jpg)
![](http://s.4pda.ru/wp-content/uploads/2013/01/market_7-480x288.jpg)




**Стоимость:** Бесплатно





**Ссылка на Google Play:** ![QR](http://s.4pda.ru/forum/style_images/1/qr_code.gif)[http://play.google.com/store/apps/details?id=com.alexey_golubev.saveyourday](http://play.google.com/store/apps/details?id=com.alexey_golubev.saveyourday)





 Материал из сайта [4pda.ru](http://4pda.ru/2013/01/06/84990/)
Что то меня потянуло на всякие там английские штучки.





И сегодня уже вторая статья на эту тему.





Только тут я расскажу (вернее автор), что за чудо книгу он придумал.





Не будем затягивать. Читаем и комментируем.


<!-- more -->


Приложение позволяет максимально облегчить процесс чтения англоязычной литературы. Вы можете изучать английский язык, одновременно наслаждаясь любимыми книгами.





![](http://s.4pda.ru/wp-content/uploads/2013/01/main.jpg)



**Версия: **1.6





**Русский интерфейс: **Да





**Технические требования: **Android 2.1+





**Категория:** Утилиты









Каждый, кто когда-либо более или менее серьезно занимался изучением иностранного языка, знает, что это очень трудоемкий процесс, требующий огромных усилий и времени, и чем ниже уровень знаний у обучаемого, тем больше усилий приходится прилагать.





English Books Reader позволяет значительно облегчить этот процесс. Используя приложение, Вы можете читать свои любимые книги на английском языке, превращая изучение Английского в довольно приятное занятие. Достаточно лишь иметь смартфон под рукой.





Приложение работает с форматами TXT, EPUB и FB2. Перевод открывается при нажатии на слово. Для работы нет необходимости быть подключенным к Интернету. Помимо перевода слова, Вы получаете дополнительную информацию:





Исходное слово - слово, от которого образовано переводимое, для лучшего понимания семантики. Например, для слова “hardship” перевод содержит:








  * hardship - лишение, нужда; тяжёлое испытание; трудность;



  * hard – трудный, тяжёлый; твёрдый, жёсткий; настойчиво;






Взаимосвязанные слова усваиваются легче.





![English Books Reader](http://s.4pda.ru/wp-content/uploads/2013/01/ultimately.jpg)



Приложение также подскажет, если слово является частью фразового глагола или идиомы. На данный момент в программе есть информация о более чем 2500 таких выражений.





![English Books Reader](http://s.4pda.ru/wp-content/uploads/2013/01/settling.jpg)
![English Books Reader](http://s.4pda.ru/wp-content/uploads/2013/01/kept.jpg)



Если слово достаточно редкое, либо является сленговым и отсутствует в словаре, оно будет переведено через Google Translate.





Для особо ленивых в приложении есть несколько предустановленных книг. Поскольку приложение не бесплатное, а сделать возврат можно только в течение 15 минут, это дает возможность быстро “пощупать” его на своем устройстве.





Форматы файлов с затрудненным доступом к тексту, либо хранящие текст в виде изображений (напр. pdf, djvu), по очевидным причинам не поддерживаются.





Если Вы любите прослушивать каждое переводимое слово, в настройках можно включить автоматическое проигрывание произношения при открытии перевода.





![](http://s.4pda.ru/wp-content/uploads/2013/01/device-2012-12-16-120957.png)
![](http://s.4pda.ru/wp-content/uploads/2013/01/device-2012-12-16-112712.png)



Приятного чтения!





**Стоимость:** 5.99$





**Ссылка на Google Play:** ![QR](http://s.4pda.ru/forum/style_images/1/qr_code.gif)[https://play.google.com/store/apps/details?id=com.mzavadski.enreaderpro](https://play.google.com/store/apps/details?id=com.mzavadski.enreaderpro)





Материалы из сайта [4pda.ru](http://4pda.ru/2013/01/16/86167/)
Я еще остался под впечатлениям от предыдущего поста.





Но пора переключится на более приятные вещи ....





Хочу познакомить вас с блокнотом, как по мне простым до безобразия.





Глянем как его описывают авторы.


 <!-- more -->


m> notes — это простое, но симпатичное приложения для создания заметок. Так сложилось, что приложения под Android в силу различных причин зачастую отличаются не в лучшую сторону от iOS аналогов в плане внешнего вида и дизайна в целом. В нише приложений для заметок сложилась такая ситуация: популярные приложения выглядят достаточно хорошо и современно, но при этом содержат уйму функционала, нужного далеко не каждому пользователю, более же простые приложения выглядят совершенно непритязательно, а иногда и просто невзрачно. Занимаясь дизайном m> notes мы хотели занять место “между” этими двумя категориями. Мы стремимся создать приложение, которым приятно и удобно пользоваться, в котором ваша коллекция заметок выглядела бы красиво и аккуратно. Расскажем о том, что у нас вышло на сегодняшний день.





![](http://s.4pda.ru/wp-content/uploads/2013/01/screenshot-1-ru-288x480.png)





**Версия: **2.1.0





**Русский интерфейс: **Да





**Технические требования: **Android OS 2.3





**Категория:** офисная программа









Для организации заметок мы выбрали простую, но эффективную структуру — заметки содержатся в тематических блокнотах, при этом каждая заметка может содержать в себе список подзаметок. На наш взгляд такой уровень вложенности может удовлетворить абсолютное большинство пользователей. Вот как выглядит один блокнот:





**![](http://s.4pda.ru/wp-content/uploads/2013/01/screenshot-6-ru-288x480.png)**





Для перемещения между блокнотами, равно как и между всеми элементами одного уровня, достаточно просто потянуть пальцем влево или вправо. На экранах содержимого блокнота или отдельной заметки навигации помогает Action Bar, одинаково хорошо работающий на всех поддерживаемых приложением версиях Android (2.2 - 4.2). Долгое нажатие на заметку в списке вызывает контекстное меню, с помощью которого удобно выполнять все возможные действия над заметкой, например, выбрать одну из иконок.





**![](http://s.4pda.ru/wp-content/uploads/2013/01/screenshot-7-ru-288x480.png)**





Последним большим нововведением является возможность прикреплять к заметкам фотографии (либо просто любые картинки из галереи). Прикрепленные файлы хранятся на SD-карте в отдельной папке, так что они не пропадут из приложения при удалении из галереи.





**![](http://s.4pda.ru/wp-content/uploads/2013/01/screenshot-2-ru-288x480.png)**





Не всем нравится наш фирменный шрифт по умолчанию, поэтому в платную версию приложения мы включили набор из 8 шрифтов плюс возможность выбрать стандартный Roboto.





**![](http://s.4pda.ru/wp-content/uploads/2013/01/screenshot-5-ru-288x480.png)**





Платная версия также содержит виджеты для быстрого добавления заметок в выбранный блокнот.





**![](http://s.4pda.ru/wp-content/uploads/2013/01/widgets-288x480.png)**





**Стоимость:** Бесплатно





**Обсуждение на 4pda:** [http://4pda.ru/forum/index.php?showtopic=372393](http://4pda.ru/forum/index.php?showtopic=372393)





**Ссылка на Google Play:** ![QR](http://s.4pda.ru/forum/style_images/1/qr_code.gif)[https://play.google.com/store/apps/details?id=com.devmiles.mnotes.free&feature=more_from_developer](https://play.google.com/store/apps/details?id=com.devmiles.mnotes.free&feature=more_from_developer)





Материалы из сайта [4pda.ru](http://4pda.ru/2013/01/17/86418/)
Поскольку не являюсь сильным носителем английского языка.





И в принципе нету возможности разговаривать на нем каждый день.





Ищу альтернативу.





Нашел вот программу, надеюсь и вам она поможет.



<!-- more -->


Жду ваши комментарии, а сейчас глянем, что пишут о ней ее авторы.





LearnWords - приложение для Android, задача которого помочь, в простой игровой форме, сохранить и расширить активный словарный запас, необходимый для владения иностранными языками.





![](http://s.4pda.ru/wp-content/uploads/2013/01/screen0_ru-288x480.png)





**Версия: **1.3





**Русский интерфейс: **Да





**Технические требования: **Android 2.2 и выше





**Категория:** Образование









Все методики изучения иностранных языках строятся на некотором наборе базисов, которые считаются критически важными для развития и закрепления знаний о языке.





Одним из таких базисов является словарный запас — т. е. возможность использования некоторого набора слов для получения новых и закреплении имеющихся навыков владения языком.





Профессиональные лингвисты и специалисты по обучению языкам утверждают, что:








  * 400-500 слов — это активный словарный запас для владения языком на базовом (пороговом) уровне .



  * 800-1000 слов — активный словарный запас для того, чтобы объясниться; или пассивный словарный запас для чтения на базовом уровне.



  * 1500-2000 слов — активный словарный запас, которого вполне хватит для того, чтобы обеспечить повседневное общение в течении всего дня; или пассивный словарный запас, достаточный для уверенного чтения.



  * 3000-4000 слов — в общем, достаточно для практически свободного чтения газет или литературы по специальности.



  * 8000 слов - обеспечивают полноценное общение для среднего европейца. Практически не нужно знать больше слов для того, чтобы свободно общаться как устно, так и письменно, а также читать литературу любого рода.



  * 10 000-20 000 слов — активный словарный запас образованного носителя языка.



  * 50 000-100 000 слов — пассивный словарный запас образованного носителя языка.






Таким образом, изучая иностранный язык, нам необходимо довести уровень нашего активного словарного запаса до 2-4 тысяч слов. Это задача не из разряда не выполнимых, но тут таится серьезная проблема — наш словарный запас имеет тенденцию сокращаться.





Отсутствие постоянной языковой практики и использования языковых навыков сугубо в профессиональных целях приводит к тому, что слова, изученные нами постепенно переходят из активного словарного запаса в пассивный, а от туда, со временем, пропадают вовсе. Так мы приходим к тому, что еще недавно мы успешно завершили языковые курсы, благополучно прошли экзамены, но через несколько месяцев отсутствия постоянной практики неспособны продемонстрировать и половины изученного или не можем изъясниться с иностранцем во время заграничного отпуска, при этом свободно читая иностранную литературу, связанную с нашей работой.





Задача приложения LearnWords состоит в помощи сохранения и расширения активного словарного запаса в простой игровой форме, не требующей от пользователя серьезных волевых усилий.








  * Игровая форма обучения, применяемая в LearnWords, позволяет поддерживать нацеленность мозга на достижение результата, повышая эффективность запоминания слов, не позволяя при этом сформироваться чувству навязчивость процесса обучения.



  * LearnWords — это приложение для мобильных устройств (телефонов и планшетов), которые становятся неотъемлемыми спутниками нашей жизни. Это позволяет использовать использовать любой удобный момент для поддержания и развития активного словарного запаса.



  * Наличие возможности произносить изучаемые слова, позволяет использовать LearnWords на самых ранних стадиях изучения иностранных языков, позволяя запоминать не только написание и значение слов, но и правильное произношение.



  * LearnWords — это динамично развивающееся приложение. Команда разработчиков непрерывно ведет работу надо добавлением новых функций, повышающих эффективность обучения и расширяющих возможности применения LearnWords.



  * Словари LearnWords регулярно пополняются и обновляются в фоновом режиме, не требуя дополнительных усилий от пользователя.



  * Удобный и простой в использовании интерфейс LearnWords, позволяет приступить к тренировкам, сразу после установки приложения.



  * Задания в LearnWords соответствуют текущему уровню активного словарного запаса пользователя и дают возможность к постепенному усложнению, по мере совершенствования знаний.






![](http://s.4pda.ru/wp-content/uploads/2013/01/screen1_ru-288x480.png)
![](http://s.4pda.ru/wp-content/uploads/2013/01/screen2_ru-288x480.png)
![](http://s.4pda.ru/wp-content/uploads/2013/01/screen3_ru-288x480.png)



**Стоимость:** 10$





**Ссылка на Google Play:** ![QR](http://s.4pda.ru/forum/style_images/1/qr_code.gif)[https://play.google.com/store/apps/details?id=com.softrose.learnwords](https://play.google.com/store/apps/details?id=com.softrose.learnwords)





Материалы из сайта [4pda.ru](http://4pda.ru/2013/01/17/86206/)
Всем привет.





Дополняю нашу библиотеку, интересными программами.





Одна из которых **Office Document Unlocker**





Ну, что же посмотрим, что о ней пишут авторы.


<!-- more -->


Забыли пароль от защищенного DOCX или XLSX файла? Разблокируйте его при помощи Office Document Unlocker! Просто выберите файл и подождите пару секунд.





![](http://s.4pda.ru/wp-content/uploads/2013/01/unnamed3-300x480.jpg)





**Версия: **0.4





**Русский интерфейс: **Да





**Технические требования: **Android 2.2 и выше





**Категория:** офисная программа, утилиты









Office Document Unlocker - это очень простая в использовании программа для разблокирования защищенных паролем от редактирования документов MS Office. На данный момент приложение поддерживает DOCX и XLSX. Шифрованные файлы не поддерживаются.





Приложение действительно предельно просто в использовании:





1. На главном экране всего одна кнопка, это кнопка выбора файла.





2. В файловом менеджере открывающемся при выборе файла, документы XLSX и DOCX выделены соответствующими иконками.





![](http://s.4pda.ru/wp-content/uploads/2013/01/26.jpg)





3. После выбора файла, приложение проверит есть ли в нем защищенные блоки, если да то удалит их и сохранит файл под новым именем. Имя исходного и нового файла отображается на главном экране.





4. Так же после успешной разблокировки становится доступна кнопка открытия нового, не защищенного файла.





![](http://s.4pda.ru/wp-content/uploads/2013/01/39.jpg)




5. После чего офисное приложение откроет разблокированный документ.





![](http://s.4pda.ru/wp-content/uploads/2013/01/46.jpg)





Так как стояла цель сделать приложение простым и прямолинейным, внешний вид без излишеств. Планируется добавить опцию - "Открывать мгновенно", в этом режиме при запуске приложения будет сразу открываться встроенный файловый менеджер, а при выборе в нем файла, сразу будет открыт уже не защищенный документ. Это избавит вас от необходимости нажимать целых 2 кнопки в интерфейсе приложения, а также избавит приложение от необходимости иметь вообще какой либо интерфейс кроме как файлового менеджера. Также можно будет добавить Mime types для привязки приложения к DOCX и XLSX, в таком случае ему вообще не нужен будет интерфейс, вы просто выберите файл в вашем любимом файловом менеджере и при запросе приложения которым вы хотите открыть его, кликните на Office Document Unlocker, он молча сделает всю работу по разблокировке и откроет уже не защищенный документ. Пока идеи по развитию примерно такие.





Если у кого то из пользователей 4PDA есть предложения по развитию и улучшению данного приложения, буду рад выслушать, спасибо за внимание!





**Стоимость:** 30руб.





**Ссылка на Google Play:** ![QR](http://s.4pda.ru/forum/style_images/1/qr_code.gif)[https://play.google.com/store/apps/details?id=com.zlab.officepasswordrecovery](https://play.google.com/store/apps/details?id=com.zlab.officepasswordrecovery)





**Бонусы от разработчика:** Чуть позднее в маркет будет загружена бесплатная версия приложения для пользователей из стран СНГ, а также станут доступны исходные коды.





Думаю, что вы ее зацените.





Материалы из сайта [4pda.ru](http://4pda.ru/2013/01/19/86591/)




Ребята всем привет.





На вебинаре меня спрашивали как получать прибыль с продажи.





К сожалению, для Украины прямого получения нету. (Как получать я узнаю.)





Но для России есть.


<!-- more -->


И сегодня я нашел статью, как можно получать деньги с PlayMarket.





Прошу к прочтению.





В октябре 2012 [вступили в силу новые правила получения платежей от продаж на Google Play](http://droidblog.merigotech.com/?p=70) и, одновременно, [новая инструкция ЦБ РФ О порядке предоставления документов, связанных с проведением валютных операций](http://droidblog.merigotech.com/?p=73) (Инструкция Банка России от 04.06.2012 № 138-И - [PDF](http://www.cbr.ru/analytics/standart_acts/currency_regulations/138-i.pdf)). В результате, платежи с Google Checkout теперь можно получать напрямую на расчетный счет индивидуального предпринимателя. Это позволяет избавиться от[работы с AdSense](http://aldro.ru/internet-i-biznes/29-nalogi-adsens.html) и связанных с ней [морем вопросов](http://forum.searchengines.ru/archive/index.php/t-646949.html).   
  
Многие разработчики уже [опробовали](http://habrahabr.ru/post/151831/) новую схему. Попробовал и я - на днях пришел первый платеж. Хочу поделиться подробностями организации работы с банком.





## РАСЧЕТНЫЙ СЧЕТ





Для получения платежей требуется долларовый расчетный счет ИП. Процесс открытия валютного счета я уже [подробно описывал](http://derevyanko.blogspot.ru/2010/09/1.html). При открытии счета вам откроют два счета: текущий и транзитный.   
  
В настройка Google Checkout в разделе Settings\Financials нужно будет указать информацию о банке





![](http://2.bp.blogspot.com/-1-qNj7K21xo/UK71gaD83GI/AAAAAAAAAOA/u0Bw14FL3qM/s320/checkout.jpg)




На примере [реквизитов Сибирского филиала Промсвязьбанка](http://www.sibenergocom.ru/contact):




    
    Сибирский филиал ОАО «Промсвязьбанк» г. Новосибирск  
    
    Рс/сч (20-значное число)
    
    Кор/сч 30101810500000000816 
    
    БИК 045004816
    
    Intermediary Bank (Банк – Посредник): Deutsche Bank Trust Company Americas
    
     New York, NY, USA
    
     SWIFT: BKTR US 33
    
    Account with Institution (Банк Бенефициара): ОJSC "Promsvyazbank"
    
     SIBIRSKY BRANCH,
    
    SWIFT: PRMSRUMMNSB
    
    





Здесь BIK = 045004816 (это БИК вашего банка). Account number = номер вашего**транзитного** счета. SWIFT = PRMSRUMMNSB. Bank name = ОJSC "Promsvyazbank". Account holder name = ваши фамилия и имя.   
  






## ДОКУМЕНТЫ В БАНК





Получение денег на валютный расчетный счет связано с обязательной процедурой валютного контроля. Принципиально вас ожидает то же самое, что при [получении денег от иностранного заказчика](http://derevyanko.blogspot.ru/2010/09/blog-post.html). При поступлении платежа требуется:








  1. Представить в банк договор с Google



  2. Создать справку о валютной операции и перевести деньги с транзитного счета на текущий валютный или сразу же с продать валюту с транзитного валютного счета на текущий рублевый.






Банк требует предоставить оригинал и перевод соглашения [Accept payments through Google - Terms of Service. Google Checkout - Terms of Service (https://checkout.google.com/termsOfService?type=SELLER)](https://checkout.google.com/termsOfService?type=SELLER) (для просмотра требуется войти в свой аккаунт Android-разработчика). С оригиналом - проблем нет. А вот перевода на русский в сети мне найти не удалось. Пришлось переводить самому...   
  
[Выкладываю перевод](http://code.google.com/p/dvsrc/downloads/detail?name=20120919v1_%D0%9F%D0%B5%D1%80%D0%B5%D0%B2%D0%BE%D0%B4%20Accept%20payments%20through%20Google%20-%20Terms%20of%20Service.7z&can=2&q=) в свободный доступ. (Качество перевода, прямо говоря, не очень - уж слишком много там юридической терминологии... Буду признателен, если кто-нибудь укажет на официальный или более качественный перевод. Если кто-нибудь возьмется править перевод - могу предоставить доступ к оригинальному документу в google docs, - параграфы на английском и русском чередуются. Пишите мне на dvpublic0 на гмейле).   
  
Судя по [комментариям на Хабре](http://habrahabr.ru/post/151831/), в некоторых банках могут требовать и другие документы, например, скришнот Payouts.   
  
Если у вас есть все необходимые документы, то дальше проблем особых нет. Создаете справку о валютной операции и заявление о переводе/продаже валюты с транзитного счета. Здесь главное уложиться в 15 дней с момента поступления платежа. Штрафы за опоздание могут быть [ОЧЕНЬ](http://habrahabr.ru/blogs/Dura_Lex/114069/) высокими. Лично мне Google перевел первый платеж чуть ли не в тот же день, как я вбил реквизиты банка в Google Checkout (а вовсе не в конце месяца). В итоге я чуть было этот платеж не пропустил.





## ПАСПОРТ СДЕЛКИ





Если совокупная сумма платежей по договору превысит $50 000, то потребуется, как мне сказали в банке, "открыть паспорт сделки или подписать новый договор". Сразу открывать паспорт сделки не требуется.





Статья из сайта [derevyanko.blogspot.com](http://derevyanko.blogspot.com/2012/11/google-play.html)





Расскажите своим друзьям.
Всем привет.





Новая подборка программ и игр.





 Памятка как выжить в экстремальных ситуациях и условиях. Что взять с собою из дома в экстренном случае? Как выжить в условиях отсутствия цивилизации? Полезная инструкция по выживанию, памятка что должно быть дома про запас, и как вести себя в случае наступления Конца Света или иных катастроф! Тревожные чемоданчики, подготовка квартиры и многое другое в одном приложении. Плюс бонус для тех, у кого все в порядке с чувством юмора.





![](http://s.4pda.ru/wp-content/uploads/2012/12/116-287x480.jpg)!


<!-- more -->

**Версия: **1.4





**Русский интерфейс: **Да





**Технические требования:** Android 2.2 и выше





**Категория:** стиль жизни, образование, справочник





По человеческой природе люди часто убегают от проблем в работу, в йогу, в другую страну. 21 декабря 2012 года возможности бежать не будет –попросту некуда. А ты готов как можно скорее завершить свои дела? Слетать в Нью-Йорк, заняться боксом,  очистить совесть перед Вечностью?





Если амбиции и планы- личное дело каждого, то помочь морально и физически  подготовиться поможет наше Приложение. Вы сможете избавиться от  тяготящих душу метаний, морально подготовиться к Наступлению Вечности, получить «Сертификат Чистой Совести» в разделе "Спастись", который поспособствует уверенной встрече Конца Света.





Для тех кто все-таки хочет остаться на Земле и посмотреть «Что будет?»  мы подготовили целый перечень полезных советов, руководств и средств для выживания. Остаться вопреки календарю Майя, параду Планет и магическому набору цифр 21.12.2012.





Как известно, кто владеет информацией - владеет миром. Получив сведения из нашего приложения и вооружившись «Сертификатом Чистой Совести» предлагаем Вам поэкспериментировать с подготовкой к Концу Света – возможно, вы еще многое не учли.





**Стоимость:** Бесплатно





**Обсуждение на 4pda:** [http://4pda.ru/forum/index.php?showtopic=407625&st=0&gopid=17718903](http://4pda.ru/forum/index.php?showtopic=407625&st=0&gopid=17718903)





**Ссылка на Google Play:** ![QR](http://s.4pda.ru/forum/style_images/1/qr_code.gif)[https://play.google.com/store/apps/details?id=ru.chebro.doomsday](https://play.google.com/store/apps/details?id=ru.chebro.doomsday)





**Бонусы от разработчика:** Присланные интересные материалы от "выживальщиков" будут размещены в приложении!





![](http://s.4pda.ru/wp-content/uploads/2012/12/24-287x480.jpg)
![](http://s.4pda.ru/wp-content/uploads/2012/12/37-287x480.jpg)




![](http://s.4pda.ru/wp-content/uploads/2012/12/45-287x480.jpg)
![](http://s.4pda.ru/wp-content/uploads/2012/12/54-287x480.jpg)





![](http://s.4pda.ru/wp-content/uploads/2012/12/64-287x480.jpg)



Статья из сайта [4pda.ru](http://4pda.ru/2012/12/12/82303/#more-82303)
Всем привет.





Новая подборка программ и игр.









Aximedia Slide Show Creator - приложение, предназначенное для создание презентаций из фотографий и музыкальных композиций имеющихся на Вашем устройстве.





![](http://s.4pda.ru/wp-content/uploads/2012/12/assc_hires_512-480x480.png)


 <!-- more -->


**Версия: **1.5





**Русский интерфейс: **Нет





**Технические требования:** Android 2.1 и выше





**Категория:** редактор, фото, видео









Недавно компания Aximedia разработала приложение Aximedia Slide Show Creator 1.5 - полезный, простой и нужный продукт, позволяющий в несколько кликов преобразовывать фотографии в видеоролики. Пошаговый, понятный алгоритм создания ролика настолько прост, что, как говорится, «… даже моя бабушка может сделать это!»





Серия статичных изображений может за две минуты превратиться в эффектное видео с музыкальным сопровождением, которое легко отправлять друзьям и размещать в социальные сети.





Приложение очень пригодится вам, если вы хотите поделиться вашими фотографиями c проведенного отдыха, с праздника, с проделками ребенка или домашнего животного, но сделать это не стандартно, а преобразовать их в увлекательную презентацию с оформлением.





Новомодные «облачные вычисления» позволяют не загружать ваш смартфон, а задать данные и отправить на сервер, где за секунды он выполнит команды и пришлет вам только ссылку на просмотр видео и ссылку на скачивание.





На любом этапе создания ролика можно вернуться назад и внести коррективы. Музыка может быть использована собственная или с сайта Aximedia. Язык программы: английский, китайский, русский - в перспективе.





**Стоимость:** 47руб.





**Обсуждение на 4pda:** [http://4pda.ru/forum/index.php?showtopic=408371](http://4pda.ru/forum/index.php?showtopic=408371)





**Ссылка на Google Play:** ![QR](http://s.4pda.ru/forum/style_images/1/qr_code.gif)[https://play.google.com/store/apps/details?id=com.amem&feature=search_result#?t=W251bGwsMSwxLDEsImNvbS5hbWVtIl0.](https://play.google.com/store/apps/details?id=com.amem&feature=search_result#?t=W251bGwsMSwxLDEsImNvbS5hbWVtIl0.)





Статья из сайта [4pda.ru](http://4pda.ru/2012/12/13/82537/#more-82537)
Всем привет.





Новая подборка программ и игр.





 Представляю вашему вниманию программу Gt Voyager, которая может быть использована в качестве второго навигационного приложения, независящего от наличия и степени подробности карт.





![](http://s.4pda.ru/wp-content/uploads/2012/12/scr14-480x300.jpg)


<!-- more -->

**Версия: **1.32





**Русский интерфейс: **Да





**Технические требования: **Android 2.2 и выше





**Категория:** Путешествия









Основные идеи применения программы изложены на сайте проекта, здесь я расскажу только о самом интересном.





Интерфейс программы изначально был разработан для планшетов. Позже была добавлена возможность комфортной работы и на телефонах. Если запустить Gt Voyager на планшете, то основное меню будет показано в левом нижнем углу. Где им удобно пользоваться большим пальцем не перекладывая планшет в руках. На телефонах отображается обычное классическое нижнее меню, без изысков.





![](http://s.4pda.ru/wp-content/uploads/2012/12/nscr2-288x480.jpg)
![](http://s.4pda.ru/wp-content/uploads/2012/12/nscr1-480x300.jpg)







**Просмотр карты**





Просто так смотреть на карту или спутниковые снимки не интересно. Хорошо, когда на экране есть маркеры, которыми отмечены интересные места. Особенно, когда они не пытаются скрыть от Вашего взгляда самое ценное. И вдобавок, хорошо, когда их не приходится искать на экране при каждом изменении масштаба.  
В программе Gt Voyager потерять маркеры не получится.









**Маршруты**





Основное назначение программы - прокладывание персональных маршрутов и последующее их использование. Персональные маршруты - это когда Вас не устраивает то, что предлагает Вам навигатор или для выбранной местности вообще нет электронных карт.





Обычный навигатор прокладывает маршруты по дорогам общего пользования. Но объекты интереса могут располагаться на значительном удалении от  дорог и могут иметь совсем нетривиальные подходы. Нырнуть под арку, обойти слева, пересечь газон. Наверное, всем приходилось слышать подобные инструкции. Выполнить их бывает не так-то просто без "местного проводника".  Определиться - куда двигаться дальше может помочь  Gt Voyager.





Для создания персональных маршрутов есть два способа. Первый - нарисовать маршрут самостоятельно в редакторе - это совсем не сложно. И второй - записать GPS лог.





GPS-логгер отбирает точки алгоритмом чем-то похожим на фильтр Калмана.  В результате получается достаточно подробный маршрут без лишних точек.





![](http://s.4pda.ru/wp-content/uploads/2012/12/nscr3-288x480.jpg)
![](http://s.4pda.ru/wp-content/uploads/2012/12/nscr4-288x480.jpg)



![](http://s.4pda.ru/wp-content/uploads/2012/12/nscr5-288x480.jpg)
![](http://s.4pda.ru/wp-content/uploads/2012/12/nscr6-288x480.jpg)







**Поиск**





Со временем у Вас может накопиться большое количество маршрутов и GPS-логов.





Названия маршрутов могут совсем не говорить о том, через какие места они проложены. Вручную перебирать всю коллекцию в поисках чего-нибудь полезного - занятие не самое приятное.





На помощь придёт функция поиска маршрутов проходящих через две точки.  Поиск ведётся либо от Вашего местоположения, либо от центра экрана и до выбранной точки.









**Обмен маршрутами**





Обладать коллекцией маршрутов нет никакого смысла, если её никак нельзя воспользоваться.  
Мы предлагаем не только создавать, но активно пользоваться!





Например, Вы можете рассказать другу, как добраться, чтобы он присоединился к Вам на рыбалке или на охоте. Или сообщить подруге самую короткую тропинку до метро.  При этом  вы можете находиться в разных населённых пунктах.





Для этого достаточно отправить ссылку на маршрут любым доступным для Вашего мобильного устройства способом. Сам маршрут будет передан через сервис обмена. Получателю придёт ссылка, которую он может открыть в программе Gt Voyager или посмотреть в любом браузере. Никакой регистрации для отправки и получения не требуется.  Необходимо лишь наличие Интернета. Загрузка и просмотр маршрута буду доступна в течение 24х часов, после чего данные будут физически удалены с сервера.









**Навигация**





Полная версия Gt Voyager, в отличии от версии lite, содержит функции навигации: следование по маршруту и поиск точки.





![](http://s.4pda.ru/wp-content/uploads/2012/12/nscr7-288x480.jpg)
![](http://s.4pda.ru/wp-content/uploads/2012/12/nscr8-288x480.jpg)



**Следование по маршруту**





Если Вы ездили за рулём автомобиля по малоизвестному городу с более-менее оживлённым движением, то наверняка заметили странную вещь. Сколько на карту перед поездкой не смотри, обязательно хотя бы один поворот да пропустишь.





Режим следования по маршруту несколько отличается от работы класических навигаторах. Так как  маршрут, по которому нужно следовать, не содержит информации о реальной конфигурации дороги, в нём есть только данные - как по этому маршруту двигался  другой человек.





Если Вы ещё не добрались до начальной точки маршрута или ушли с него, то программа будет работать в режиме поиска ближайшей точки маршрута. Gt Voyager автоматически определяет повороты и заблаговременно извещает о них либо за 30 секунд, либо за 50 метров до начала.









**Поиск точки**





Поиск точки - режим, который поможет не потерять направление, когда Вы можете добраться до места несколькими маршрутами или когда Вы ищете дорогу. Поможет не заблудиться в лесу или незнакомом городе.









**Когда нет Интернета**





Конечно, без Интернета на Вашем мобильном устройстве, ни карты ни спутниковых снимков Вы не увидите. Зато всё остальное будет работать корректно. Ведь Ваши точки и маршруты всегда с собой.





Это далеко не всё, что есть в программе.





Приятных путешествий!





**Стоимость:** Бесплатно





**Ссылка на Google Play:** ![QR](http://s.4pda.ru/forum/style_images/1/qr_code.gif)[http://play.google.com/store/apps/details?id=a2u.gotofree](http://play.google.com/store/apps/details?id=a2u.gotofree)





Статья из сайта [4pda.ru](http://4pda.ru/2012/12/15/82815/#more-82815)
Всем привет.





Новая подборка программ и игр.





Ну что начнем?





Вы любите когда вам звонят на мобильный телефон? Или вы каждый раз вздрагиваете от стандартной мелодии, которая дополняет симфонию из звуков вж-вж-вж, издаваемых вибрацией? Почему бы не поставить любимую песню на рингтон, чтобы каждый раз, при входящем звонке, вам хотелось танцевать и подпевать? Выбрать лучший момент песни для этих целей вам поможет программа, о которой я расскажу.





![](http://s.4pda.ru/wp-content/uploads/2012/12/featured-graphic-480x234.png)


 <!-- more -->

**Версия: **1.01





**Русский интерфейс: **Да





**Технические требования: **Android 2.2+





**Категория:** Аудиоредактор









**По порядку рассчитайсь!**





При запуске программы нас встретит простенький проводник по файловой системе устройства. В списке поддерживаемых музыкальных форматов имеются: MP3, WAV, AAC/MP4, AMR. Выбираем нужный нам файлик и приступаем к процессу редактирования.





![](http://s.4pda.ru/wp-content/uploads/2012/12/screenshot_2012-12-18-19-20-33-291x480.png)
![](http://s.4pda.ru/wp-content/uploads/2012/12/screenshot_2012-12-18-19-21-36-291x480.png)







**Начнём операцию над музыкальным файлом**





После появления экрана редактора мы увидим «волну» звукового файла, два ползунка выделения и несколько кнопок.





Пройдёмся по основным элементам управления. Чтобы начать проигрывание аудио с любого места — просто тапните пальцем по звуковой волне и вы услышите звук именно с того момента, на котором тапнули. При нажатии на кнопку Play начнётся воспроизведение только выделенного фрагмента. Доступен режим неприрывного повтора. Для продолжительных аудиозаписей можно воспользоваться 5 уровнями приближения, управление которыми осуществляется жестом pinch-to-zoom. С выделением тоже всё просто, вы можете таскать ползунки пальцем или выбрать всю видимую область, нажав на кнопку выделения.





После того, как мы найдём подходящий момент песни — будет достаточно нажать на кнопку сохранения и выбрать тип и имя сохраняемого аудиофайла. После сохранения файл будет доступен в настройках звука системы и вы легко сможете установить его в качестве рингтона, мелодии оповещения или будильника.





![](http://s.4pda.ru/wp-content/uploads/2012/12/screenshot_2012-12-18-19-23-11-291x480.png)
![](http://s.4pda.ru/wp-content/uploads/2012/12/screenshot_2012-12-18-19-23-24-291x480.png)







**Приложение должно радовать глаз, не так ли?**





Если не понравится цветовая гамма — в настройках доступны четыре на выбор. Темы сменяются на лету, так что попробовать все и выбрать самую приятную для внутреннего эстета очень легко.





![](http://s.4pda.ru/wp-content/uploads/2012/12/screenshot_2012-12-18-19-59-16-480x288.png)
![](http://s.4pda.ru/wp-content/uploads/2012/12/screenshot_2012-12-18-19-59-10-480x288.png)



![](http://s.4pda.ru/wp-content/uploads/2012/12/screenshot_2012-12-18-19-59-03-480x288.png)
![](http://s.4pda.ru/wp-content/uploads/2012/12/screenshot_2012-12-18-19-58-56-480x288.png)







**Сухой остаток**





Приложение находится в стадии Beta версии, поэтому верно выполняет только одну, главную, функцию — обрезание файлов. В дальнейшем будут добавлены различные обработки звука, такие как эффекты затухания/наростания громкости, нормализация, компрессия и т.д.





Я, как разработчик, открыт к критике и предложениям, поэтому если у вас есть идеи — добро пожаловать в обсуждение на форуме.





**Стоимость:** Бесплатно





**Обсуждение на 4pda:** [http://4pda.ru/forum/index.php?showtopic=409728](http://4pda.ru/forum/index.php?showtopic=409728)





**Ссылка на Google Play:** ![QR](http://s.4pda.ru/forum/style_images/1/qr_code.gif)[http://play.google.com/store/apps/details?id=com.sergeyotro.ringtoneslicer](http://play.google.com/store/apps/details?id=com.sergeyotro.ringtoneslicer)





Статья из сайта [4pda.ru](http://4pda.ru/2012/12/18/83145/)
Даже не знаю как рассказать.





А вообщем читайте сами.





Сегодня я расскажу вам сказку про белого б… осьминога. Начинается она так: «Жили да были молодцы удалые. Попутал их как-то бес влезть в Android Market-а лес. Долго они выход искали и насилу воротились. А как домой возвратились – приложение написали». О сервисе, который поможет не потеряться в Google Play и пойдет речь в этом обзоре.


<!-- more -->


![](http://s.4pda.ru/wp-content/uploads/2012/12/pic.png)









**Версия: **1.0.05





**Русский интерфейс: **Да





**Технические требования:** Андроид 2.1+





**Категория:** поисковое приложение





Найти что-то путевое в огромном изобилии приложений без чьей-либо помощи очень сложно. Описания приложений выглядят одинаково привлекательно, а полагаться на комментарии и рейтинги в Google Play из-за накруток можно не всегда. Для того, чтобы не тратить свое время на ерунду, можно довериться рекомендациям знакомых или пролистать обзоры приложений. Но есть еще один способ – заглянуть в контент самого приложения до установки. В этом поможет приложение osmino apps, которое индексирует контент внутри мобильного ПО наряду с их описаниями. В данный момент это в основном касается текстового контента. Не мудрствуя лукаво, запустим приложение и посмотрим, как оно работает.









## **Поиск по интересам**





![](http://s.4pda.ru/wp-content/uploads/2012/12/osmino-apps9-270x480.png)





Главный экран приветствует нас большой картинкой с названием приложения, окошком для поиска и несколькими абзацами поясняющего текста. Функциональная часть на первом экране одна – это окно ввода поискового запроса. Здесь можно вручную забить искомый запрос или попросить желаемое голосом.





![](http://s.4pda.ru/wp-content/uploads/2012/12/osmino-apps7-270x480.png)



В качестве пробного запроса я выбрал слово «аркады» - дело к зиме, а скуку развеять чем-то по вечерам надо.  Первый выстрел ушел в молоко. К сожалению, аркад я не нашел, зато смог почитать, что это такое на Википедии и еще в паре мест. То же самое произошло при запросе «стратегии».





![](http://s.4pda.ru/wp-content/uploads/2012/12/osmino-apps8-270x480.png)



Для второго запроса был выбран «гоночный симулятор». На 6-ой строчке оказался релевантный ответ «GT Racing». Бегло проглядываю список –  еще пара гонок. Удивляюсь, что среди них нет Asphalt, и ввожу новый запрос. К слову, каждый пункт из списка ответов снабжен полным названием приложения и датой его добавления. Нажимая на тот или иной пункт, мы попадаем прямиком в Google Play на страницу скачивания этого приложения.





![](http://s.4pda.ru/wp-content/uploads/2012/12/osmino-apps3-270x480.png)



С развлекательно-игровой частью запросов все понятно – если думать над запросом, то что-нибудь подходящее на крючок попадется. А что насчет контентных приложений. Например, тех же фильмов?





Вбиваю запрос «Фильмы» и просматриваю список результатов: здесь уже знакомые ivi, Stream и новый для меня VideoMix. Все это - мобильные версии онлайн-сервисов просмотра фильмов за умеренную денежку. Что ж, в этом сегменте приложений все стандартно  - новинок в ближайшее время ждать не стоит. Если же требуется найти какой-то конкретный фильм, osmino apps сообщит, в каких приложениях его нужно искать. Удобно.





А вот что не совсем удобно – так это то, что osmino apps уже проиндексировал контент VideoMix и Литрес с бесконечными описаниями фильмов и книг. Так что эти два приложения попадают практически в любой список ответов. То же касается и Википедии.





![](http://s.4pda.ru/wp-content/uploads/2012/12/osmino-apps1-270x480.png)

Если с приложениями для просмотра фильмов есть некоторая альтернатива, то по запросу «Музыка» osmino apps выдает только один ответ: приложение «MP3 Поиск». Ок, едем дальше.





![](http://s.4pda.ru/wp-content/uploads/2012/12/osmino-apps5-270x480.png)




Что касается запроса «рецепты» - кроме предложения купить книгу рецептов у Литреса ждать ничего не стоит. А вот по запросу «рецепты приложение» список ответов меня более чем удовлетворил. Здесь нашлось не меньше десяти приложений о том, как вкусно готовить. Одно из них даже осело на мой смартфон – «Рецепты Кофе», предлагающее 300 способов приготовления любимого напитка. Делаю вывод: чтобы получить внятный ответ, нужно правильно задать вопрос.





![](http://s.4pda.ru/wp-content/uploads/2012/12/osmino-apps6-270x480.png)



Запрос «Изучение Английского» выдает объемный список приложений, обещающих научить пользователя английскому за 3 недели, 2 недели и совсем не приличное время. Релевантных ответов здесь существенно больше, чем посторонних. Кажется, после небольшой тренировки я научился составлять правильные поисковые запросы.









## **Что искать?**





Сами разработчики задумывали приложение, как адекватный поиск нужных приложений и просто мобильный поиск. То есть такой поиск информации, который использует мобильные приложения в качестве источника контента, оформленного в удобном для смартфонов виде. Идея благородная и уже приносит первые плоды. Так, мне показалось удобным искать обучающие программы, рецепты, заглядывать во внутренний контент понравившихся приложений до установки, а также искать конкретные фильмы, при условии, что я хочу посмотреть их в высоком качестве (и готов заплатить за это ivi или stream-у).









## **Индексация новых приложений – как попасть  в osmino**





Коллектив разработчиков osmino apps добавляют в поисковую систему все новые и новые приложения. В списке проиндексированных сейчас находятся более полутора миллионов единиц контента из приложений, среди которых ivi, Википедия, Чемпионат.ру и другие. В список проиндексированных потенциально может попасть любой разработчик – это бесплатно. Кроме того, такое сотрудничество выглядит выгодным для обеих сторон. С одной стороны – конечные разработчики приложений, которые получают трафик из поисковой системы, с другой – авторы сервиса, увеличивающие охват поисковой системы. Ну и с третьей – счастливые пользователи =)





Ниже небольшая выдержка о том, как попасть в суп приложений osmino:





Для индексации контента внутри приложений требуется: Доступ к контенту, подлежащему индексированию, схема URI. (**более подробно можно [прочитать здесь](http://apps.osmino.com/developers.html)**)









## **Большие перспективы**





С точки зрения функционала приложение не имеет ничего лишнего. Созданное для того, чтобы искать информацию в приложениях и о приложениях Google Play, оно неплохо справляется с этой задачей. Немаловажно, что osmino apps может выдать информацию из какого-то конкретного приложения без установки последнего.  Идея приложения мне чрезвычайно понравилась, однако приложение требует ряда доработок. Так, необходимо сократить  долю ответов, приходящуюся на Википедию, Литрес, VideoMix и некоторые другие приложения с огромным массивом текстовой информации. Или же сделать возможность исключать такие приложения выборочно, занеся в отдельный список. Следующий очевидный шаг – разделение приложений по тематическим группам и поиск в рамках какой-то выбранной группы, например «бесплатные игры» ;)





В данный момент приложение доступно для Андроид. Версия iOS – на аппруве.









**Стоимость:** бесплатно









**[Скачать приложение на Андроид](http://goo.gl/seFdJ)**









В заключение, пожелаю будущим пользователям osmino apps потренироваться в поисковых запросах, а разработчикам - успеха в улучшении приложения. Надеюсь, новые версии с расширенным функционалом не заставят себя ждать.





**Спасибо за внимание!**





Источник [4pda.ru](http://4pda.ru/2012/12/04/81169/)
А вот это круто.





Сегодня пользователи Android OS стали получать обновление программы Поиск Google, но радоваться, в первую очередь, необходимо пользователям версий Android 4.1 Jelly Bean и более поздних, потому что оно содержит огромное количество новых карточек для Google Now.





![](http://s.4pda.ru/wp-content/uploads/2012/12/google-now-480x398.png)

<!-- more -->






Согласно официальному заявлению Google, приложение поиска для Android 4.1+ получит следующие новые функции:





**Карточки**








  * События рядом



  * Предложения, который помогут вам в ваших исследованиях (правда неясно что это значит)



  * Билеты на самолёт (пока только для США)



  * Возможность сканирования окружающего мира камерой (как в [Google Goggles](http://4pda.ru/2012/02/17/55635/))



  * Погода в местах, которые вы вскоре посетите



  * [Примерный учёт физической активности при ходьбе и езде на велосипеде](http://4pda.ru/2012/11/04/77377/)



  * Дни рождения






**Голосовые команды**








  * Сделать запись в Google+



  * Сказать "Что это за песня?" чтобы найти название и исполнителя



  * Сказать "Отсканируй баркод" чтобы получить закодированную информацию






Отрадно, что компания постоянно улучшает свои сервисы. Конечно, в России доступны пока не все функции приложение, но Google Now уже стал полноценным инструментом и незаменимым помощником и информатором в повседневных делах.





Источник[ 4pda.ru](http://4pda.ru/2012/12/06/81472/)
Полезная программа.





Сейчас очень много читаю.





Этот обзор посвящен программе eReader, разработанной Prestigio. Вообще, Prestigio не специализируется на софте, но так как у компании есть собственное софтверное подразделение, то они помимо прошивок для устройств решили разработать своё приложение-ридер для Android. За основу взяли популярную программу FBReader. Итак, давайте рассмотрим подробнее, что у них в итоге получилось.





![](http://s.4pda.ru/wp-content/uploads/2012/12/01-288x480.png)


<!-- more -->






## **Интерфейс, главное меню**





Prestigio eReader поддерживает более 20 языков в меню. Естественно, есть и русский язык.





Идея оформления главного меню в виде книжной полки не нова. Но в Prestigio eReader 2.1 она реализована весьма удачно и функционально. Верхняя полка выделяется серым цветом. На ней отображаются последние прочтенные книги. При горизонтальной ориентации (ландшафтный режим) на экране помещаются две полки - это восемнадцать книг. При вертикальной (портретный режим) – на трех полках отображаются иконки двенадцати книжек. Prestigio eReader 2.1 поддерживает автоматическую смену ориентации при перевороте устройства.





![](http://s.4pda.ru/wp-content/uploads/2012/12/01-288x480.png)




![](http://s.4pda.ru/wp-content/uploads/2012/12/02-480x288.png)




В верхней части экрана находятся вкладки «Полка», «Моя библиотека» и «Магазин».





Под верхней полкой разместились некоторые полезные элементы интерфейса: слева переключатель, позволяющий упорядочить книги по названию или автору, отобразить недавно добавленные или «избранные» книги. Справа находится строка поиска. Посередине – кнопки перелистывания содержимого полок, если все книги не помещаются на одном экране, хотя при небольшом количестве страниц листать удобнее используя сенсорый экран. Здесь же – окошко для быстрого перехода на страницу по номеру.





Чуть ниже этих элементов на декоративном выступе находится панель выбора активной коллекции. Кнопки для создания коллекций и их редактирования размещены слева и справа в нижней части экрана.









## **Функции**





В приложении реализована возможность создания коллекций для книг определенной тематики. Чтоб добавить книгу в коллекцию достаточно нажать кнопку «Редактировать», выбрать книгу, нажать на появившуюся «Переместить» и выбрать коллекцию, в которую книгу нужно добавить. Папкой для книг по умолчанию считается папка Books в корне карты памяти. Книги из этой папки автоматически индексируются и отображаются на «Полке». Настройки приложения позволяют указать для книг другой каталог.





Вкладка «Моя библиотека» является текстовой версией «Полки» с большими возможностями сортировки книг. Здесь, кроме режимов просмотра, схожих с функционалом «Полки» присутствуют также файловый браузер, опции просмотра книг по сериям и категориям. Информация о серии и категории берётся из метаданных файлов книг. Книги в формате FB2 с иллюстрациями отображаются миниатюрками, исключение составляют книги в ZIP-архивах. С чтением архивов проблем у Prestigio eReader не возникает.





![](http://s.4pda.ru/wp-content/uploads/2012/12/03-288x480.png)








## **Поговорим о возможностях**





**Поддержка форматов**





Prestigio eReader  2.1 позволяет работать с небольшим количеством форматов: EPUB, OEB, FB2 (ZIP), HTML, PDF, TXT. Опытным путем установлено, что файлы RTF тоже читаются, но в них можно наткнуться на проблемы с форматированием.





**Настройки режима чтения**





В меню режима чтения доступна навигация по оглавлению, закладки, переключение между дневным и ночным режимом, поиск, настройки форматирования. Кнопка «Еще» отображает информацию о книге, диалог перехода на любую страницу, кнопки уменьшения/увеличения шрифта.





![](http://s.4pda.ru/wp-content/uploads/2012/12/041-288x480.png)




Приложение предоставляет огромное количество настроек экрана чтения. Пользователь может выбрать разные варианты фона (текстуру или просто цвет), тип и размер шрифта, варианты начертания, отступы, величину межстрочного интервала, отображение таких элементов, как полоса прокрутки, строка состояния, индикатор заряда батареи и т.п.





В разделе настроек текста пункт «Другие стили» позволяет «гурманам» настроить отображение текста до мелочей. Здесь можно определить, как будет отображаться обычный текст, как заголовок или название главы, какой будет цитата или сноска.









**Экранное управление**





Разные области экрана отвечают за выполнение различных функций: страницы можно листать как смахиванием, так и тапом в левой или правой части экрана. Вертикальное движение пальцем в левой части экрана позволяет регулировать яркость, прикосновение к верхней центральной части вызывает индикатор количества прочитанных страниц.









**Словари/переводчики**





Prestigio eReader 2.1 поддерживает работу с разными типами словарей и переводчиков, но их нужно скачивать дополнительно.









**Магазин контента**





![](http://s.4pda.ru/wp-content/uploads/2012/12/051-288x480.png)




Последняя основная вкладка ведет пользователя в Интернет магазин контента PrestigioPlaza.com, в котором можно выбрать книгу из около 250 тысяч предложенных на двух десятках языков. Для работы с магазином необходима учетная запись, которую можно создать прямо из Prestigio eReader. Выбор книг в магазине можно осуществлять как вручную (просматривая предложенные категории), так и посредством поиска.





![](http://s.4pda.ru/wp-content/uploads/2012/12/061-288x480.png)







## **Резюме**





**Достоинства**








  * приятный, понятный интерфейс



  * широкие возможности категоризации книг



  * детальные настройки отображения






**Недостатки**








  * некоторые элементы меню, например, кнопки «Коллекция» и «Редактировать» слишком маленькие. Работа с ними на устройствах с диагональю 8-9 дюймов может и будет комфортной, но владельцам небольших смартфонов придется просто запомнить назначение кнопок управления коллекциями – рассмотреть надписи практически невозможно;



  * во время тестирования приложения оно несколько раз прекращало работу при использовании файлового менеджера. Будем надеяться, что этот баг скоро пофиксят.






Prestigio eReader – весьма удобное приложение для чтения с приятным дизайном. Оно, несомненно, найдет своих почитателей – соблюдены все «традиции» хорошей программы-ридера и привнесено несколько необычных ноу-хау.





**![QR](http://s.4pda.ru/forum/style_images/1/qr_code.gif)[Скачать Prestigio eReader 2.1 из Google Play](https://play.google.com/store/apps/details?id=com.prestigio.ereader)**





Источник [4pda.ru](http://4pda.ru/2012/12/07/81541/#more-81541)
Прикольная программа.





Когда вы кому-то звоните, это же так естественно, слышать музыку которую ВЫ любите, а не то что ваш абонент себе поставил.  Слушайте то, что ВАМ нравится!





![](http://s.4pda.ru/wp-content/uploads/2012/12/poster_ru-480x234.png)


<!-- more -->

**Версия: **0.9





**Русский интерфейс: **Да





**Технические требования: **Android 2.2+





**Категория:** Аудио









Данная программа позволяет заменить звук гудков, когда вы кому-либо звоните, на ВАШУ мелодию. Пусть вас больше не беспокоят чьи-то пристрастия к шансону или попсе - слушайте то, что ВАМ нравится!





![](http://s.4pda.ru/wp-content/uploads/2012/12/4_ru.png)
![](http://s.4pda.ru/wp-content/uploads/2012/12/5_ru.png)




Поддерживаются старые и A2DP стандарты Bluetooth гарнитуры!





**Стоимость:** 0.99$





**Ссылка на Google Play:** ![QR](http://s.4pda.ru/forum/style_images/1/qr_code.gif)[http://play.google.com/store/apps/details?id=com.inoysoft.callbeepchangerbeta&hl=ru](http://play.google.com/store/apps/details?id=com.inoysoft.callbeepchangerbeta&hl=ru)





Источник [4pda.ru](http://4pda.ru/2012/12/10/81954/)
Надоело искать файлы?





Многофункциональный и удобный файловый менеджер с поддержкой root-доступа, приятным интерфейсом и хорошим набором функций.





![](http://s.4pda.ru/wp-content/uploads/2012/12/omich_files_header1-480x160.png)

<!-- more -->

**Версия: **1.00





**Русский интерфейс: **Да





**Технические требования: **Android OS 1.5+





**Категория:** системное приложение









**Краткое описание возможностей:**








  * Поддержка стандартных операций для любого файлового менеджера



  * Root-проводник, работа с папками data/cache/efs/system (_только в платной версии_)



  * Удобное распределение папок в корневой директории



  * Работа с Хранилищем мультимедиа (псевдопапка media)



  * Удобный поиск по файлам с использованием регулярных выражений (опционально)



  * Адресная строка с полноценной возможностью ввода адреса






**Интерфейс программы**





Основной интерфейс программы представлен в виде списка каталогов и файлов. Переход в предыдущую директорию осуществляется нажатием клавишей назад, то есть истории переходов как таковой нет - клавиша возврата возвращает нас в предыдущую директорию.





С верху находится адресная строка, представленная в виде горизонтального списка папок, по которым был осуществлён переход. Можно нажать на элемент строки и вернуться сразу на несколько папок назад.





Нажатие на адресную строку в свободном месте (или долгое нажатие на название папки) открывает возможность ввести полный путь.





![](http://s.4pda.ru/wp-content/uploads/2012/12/ss-omich-files-media-0011-288x480.png)



![](http://s.4pda.ru/wp-content/uploads/2012/12/ss-omich-files-interface-0021.png)



**Операции**





Доступ к основным операциям происходит по длительному нажатию на элемент. Операции копирования и перемещения выполняются при помощи встроенного буфера обмена: выделив файлы и скопировав (вырезав) их, мы переходим в нужную директорию и по нажатию клавиши "меню" производим вставку.





![](http://s.4pda.ru/wp-content/uploads/2012/12/ss-omich-files-cp-0011-288x480.png)


![](http://s.4pda.ru/wp-content/uploads/2012/12/ss-omich-files-cp-0021.png)



**Root-проводник**





Root-проводник работает аналогично обычному, отличие лишь в том, что у пользователя может возникнуть окно с запросом разрешения прав Суперпользователя. Подтвердив операцию, все остальные операции будут проходить так же, как и обычно.





![](http://s.4pda.ru/wp-content/uploads/2012/12/ss-omich-files-root-0011-288x480.png)
![](http://s.4pda.ru/wp-content/uploads/2012/12/ss-omich-files-root-0021-288x480.png)


**Поиск**





В файловый менеджер также встроена функция поиска. В настройках можно включить использование простейших регулярных выражений, на которые тоже стоит обратить внимание.





Открыв окно поиска, мы вводим ключевое слово в строку и нажимаем кнопку "Поиск". При этом будут искаться все файлы и папки, в названии которых встречается искомое слово.





Используя регулярные выражения, поиск становится более гибким. Основные символы при использовании такого поиска - * (звёздочка) и ? (знак вопроса). Символ * означает любое количество любых символов (в том числе полное их отсутствие), ? - один символ. Таким образом, по запросу "sc*" мы сможем найти файлы "screenshot-001.png", "scores.dat", "sc" и прочие. Наличие ? в поиске заменяет собой 1 символ. Данная опция нужна для более продвинутых пользователей.





История поиска также сохраняется, и после закрытия окна поиска и повторого его открытия, мы увидим недавно найденные элементы.





![](http://s.4pda.ru/wp-content/uploads/2012/12/ss-omich-files-search-0011-288x480.png)


**Работа с хранилищем мультимедиа**





В корневом каталоге находится псевдопапка media, через которую можно осуществлять быструю навигацию по медиа файлам.





![](http://s.4pda.ru/wp-content/uploads/2012/12/ss-omich-files-media-0011-288x480.png)
![](http://s.4pda.ru/wp-content/uploads/2012/12/ss-omich-files-media-0021-288x480.png)



**Что же дальше?**





Приложение находится в стадии бета-тестирования, исправляются ошибки. Из планов на будущее хотелось бы выделить возможность плиточного отображения файлов, а также распаковку архивов (в отдельном apk файле). Также имеются некоторые значительные ошибки в интерфейсе на некоторых устройствах, которые в конечном итоге также будут исправлены.





**Стоимость:** 2.49$ / Бесплатно





**Обсуждение на 4pda:** [http://4pda.ru/forum/index.php?showtopic=397300](http://4pda.ru/forum/index.php?showtopic=397300)





**Ссылка на Google Play: **![QR](http://s.4pda.ru/forum/style_images/1/qr_code.gif)[https://play.google.com/store/apps/details?id=com.omichsoft.filemanager](https://play.google.com/store/apps/details?id=com.omichsoft.filemanager) (платная версия)





**Ссылка на Google Play:** ![QR](http://s.4pda.ru/forum/style_images/1/qr_code.gif)[https://play.google.com/store/apps/details?id=com.omichsoft.filemanagerfree](https://play.google.com/store/apps/details?id=com.omichsoft.filemanagerfree) (бесплатная версия)





Источник [4pda.ru](http://4pda.ru/2012/12/10/81820/)
Прекрасная новость.





Официальный магазин приложений разработчика Android, Google Play, теперь не только магазин приложений. Да, случилось то, чего все долго ждали - Google последовала примеру Apple (которая начала продажи контента в iTunes в начале декабря), и теперь, помимо программ и игр, пользователям из России предлагаются и фильмы с книгами.





![](http://s.4pda.ru/wp-content/uploads/2012/12/google-play-480x358.png)


<!-- more -->






Изменения сразу бросаются в глаза, как при входе в нативный клиент магазина на Android OS, так и на его официальный сайт. Внимание пользователей привлекаются баннеры с предложениями купить самые популярные книги и фильмы. Конечно же, тем, кто захочет покупать новый контент в Google придётся установить два дополнительных приложение - Google Play Фильмы и Google Play Книги. И, если раньше они едва ли могли быть полезными для российских пользователей, с сегодняшнего дня мы, наконец-то, можем использовать их в полном объёме.





![](http://s.4pda.ru/wp-content/uploads/2012/12/screenshot_2012-12-11-14-29-57-270x480.png)
![](http://s.4pda.ru/wp-content/uploads/2012/12/screenshot_2012-12-11-14-27-08-270x480.png) 
![](http://s.4pda.ru/wp-content/uploads/2012/12/screenshot_2012-12-11-14-35-00-270x480.png)



Конечно, цену на контент никак нельзя назвать низкой. Так, самое недорогой вариант просмотра фильма - прокат, обойдётся вам от 49 до 69 рублей, причём, только для стандартного качества. За HD придётся доплатить ещё 20-30 рублей. Сама концепция проката в Google Play означает то, что фильм будет доступен для просмотра только в течение 30 дней после оплаты или в течение 2 суток после того, как вы хотя бы раз открыли файл. После истечения этого срока фильм будет удалён из вашего аккаунта.





![](http://s.4pda.ru/wp-content/uploads/2012/12/play-film-480x443.png)




Если вы желаете купить фильм навсегда, то его цена, особенно в хорошем качестве, будет равняться недорогому билету в кинотеатр. Максимальная стоимость популярных фильмов сейчас составляет 349 рублей.





![](http://s.4pda.ru/wp-content/uploads/2012/12/play-film-2-480x444.png)





Но, если цены на фильмы примерно соответствуют друг другу, то в случае с книгами мы видим огромный разброс цен: от 50 до 350 рублей. Однако, немало и книг бесплатных, прежде всего, русской и зарубежной классики. Купленную литературу можно читать трёмя способами: с Android- и iOS-устройств с помощью официальных приложений, с помощью любых устройств с возможностью выхода в интернет - через веб-интерфейс Google Play, а также после загрузки на поддерживаемые электронные книги (в основном от Sony и Barnes & Noble).





![](http://s.4pda.ru/wp-content/uploads/2012/12/books-480x351.png)



![](http://s.4pda.ru/wp-content/uploads/2012/12/play-books-2-480x313.png)




Сейчас нельзя точно сказать, будут ли эти сервисы пользоваться популярностью среди российских пользователей, особенно при распространении пиратского контента в нашей стране. Но, вне всякого сомнения, найдутся и те, кто захочет покупать лицензионные фильмы и книги, чтобы поддержать их авторов.





Ну, а кроме того, теперь нам остаётся ждать, когда же Google запустит в нашей стране и музыкальный магазин, чтобы мы могли пользоваться услугами компании как любая другая европейская страна.





Источник [4pda.ru](http://4pda.ru/2012/12/11/82113/)
И снова новая программа.





Представляем вашему вниманию программу для управления персональными финансами под Android - Grimble (Гримбл). Основное отличие Grimble от конкурентов - программа официально бесплатна (всегда будет бесплатна) и сделана "нашими" разработчиками из Казахстана для пользователей в СНГ.





Проект недавно запущен, однако уже позволяет полноценно следить за личными расходами и доходами. Разработчики живо реагируют на критику и предложения - есть хороший шанс направить развитие программы так, как это будет удобно именно вам.





![](http://s.4pda.ru/wp-content/uploads/2012/12/screenshot_2012-12-11-17-07-08-288x480.png)

<!-- more -->


**Версия: **0.9.4





**Русский интерфейс: **Да





**Технические требования: **Android 2.1 и выше





**Категория:** финансы









Что сейчас позволяет делать Grimble?








  * Учитывать доходы и расходы;



  * Планировать бюджет и контролировать его перерасход;



  * Ставить финансовые цели и планировать накопления;



  * Анализировать структуру расходов и доходов;



  * Интерфейс поддерживает Русский, Английский, Казахский и Китайский языки;



  * Поддерживаются любые виды валют, с конвертацией;



  * Бэкапирование данных в Dropbox'e;



  * Поддерживается работа с планшетами, однако специальная "планшетная" версия пока находится в разработке.






После первого запуска программы запускается программа обучения, которая позволяет быстро освоится с интерфейсом приложения:





![](http://s.4pda.ru/wp-content/uploads/2012/12/screenshot_2012-12-11-16-39-211-288x480.png)
![](http://s.4pda.ru/wp-content/uploads/2012/12/screenshot_2012-12-11-16-39-25-288x480.png)
![](http://s.4pda.ru/wp-content/uploads/2012/12/screenshot_2012-12-11-16-39-43-288x480.png)




![](http://s.4pda.ru/wp-content/uploads/2012/12/screenshot_2012-12-11-17-14-20-288x480.png)
![](http://s.4pda.ru/wp-content/uploads/2012/12/screenshot_2012-12-11-16-39-531-288x480.png)
![](http://s.4pda.ru/wp-content/uploads/2012/12/screenshot_2012-12-11-16-39-38-288x480.png)



Для тех кому с трудом удается накопить средстав на серьёзную покупку будет интерсна функция "Финансовые цели" позволяющая наглядно оценить достижимость желаемого.





Для любителей анализировать - нажатие на график бюджета в нижней части экрана откроет раздел со статистикой:





![](http://s.4pda.ru/wp-content/uploads/2012/12/screenshot_2012-12-11-17-35-02-288x480.png)



Мы будем рады любым вашим комментариям, предложениям, багрепортам и прочим волеизъявлениям. Обсуждение открыто на форуме 4pda.





**Стоимость:** Бесплатно





**Обсуждение на 4pda:** [http://4pda.ru/forum/index.php?showtopic=407738](http://4pda.ru/forum/index.php?showtopic=407738)





**Ссылка на Google Play:** ![QR](http://s.4pda.ru/forum/style_images/1/qr_code.gif)[https://play.google.com/store/apps/details?id=kz.crystalspring.nine](https://play.google.com/store/apps/details?id=kz.crystalspring.nine)





Статья из сайта [4pda.ru](http://4pda.ru/2012/12/11/82112/)
Продолжаем наполнять наш блог интересными программами.





У каждого человека есть много личных счетов, за которыми нужно следить. Как минимум, это счет мобильного телефона. Но кроме него это могут быть счет домашнего интернета, счет на банковской карте, информация по кредиту, счет на бонусной карте, коммунальные платежи, счет в любимой игре, да мало ли чего! А ещё может быть необходимо следить за счетами родных и близких. В голове это всё не удержать...





В этом вам может помочь новая программа для Android - AnyBalance. С её помощью, все нужные цифры и другая информация с ваших счетов будут наглядно представлены в вашем телефоне. Можно отображать их на виджетах прямо на рабочем столе, а можно настроить уведомления, и программа уведомит вас в нужный момент, например, при приближении баланса к 0 или при наступлении срока платежа по кредиту (последнее, кстати, может реально спасти много нервов и денег).





Как это может быть возможно?

<!-- more -->



![](http://s.4pda.ru/wp-content/uploads/2012/12/accounts5-288x480.png)

**Версия: **2.9.600





**Русский интерфейс: **Да





**Технические требования: **Android 2.1+





**Категория:** финансы, виджеты









А возможно это становится с помощью программы AnyBalance.





Большинство операторов, провайдеров, банков поддерживают интернет-сайты, личные кабинеты, на которые можно зайти и получить информацию о своём счете. Но заходить туда вручную обычно не слишком удобно, да и баланс легко забыть. Так вот суть AnyBalance заключается в том, что она способна вам в этом помочь: она может автоматически соединяться с вашим личным кабинетом, читать оттуда значения балансов и показывать их в удобном кратком виде.





На данный момент AnyBalance уже поддерживает почти 300 различных провайдеров, среди них, конечно, и сотовые операторы Мегафон, Билайн, МТС, и различные интернет-провайдеры, и банки Сбербанк, Связной банк, Альфабанк, и бонусные программы вроде Малины, Много.ру, коммунальные службы, игры и даже погода. В общем-то, провайдеры добавляются в программу по просьбе её пользователей, так что если вы не смогли найти свой провайдер, вы можете обратиться к автору и в течение пары дней ваш провайдер появится в каталоге.





Кроме отображения балансов программа позволяет отслеживать историю их изменения. Всегда можно посмотреть, когда примерно произошло списание денег. А можно настроить уведомления, тогда программа сама будет следить за изменениями баланса и уведомлять вас при необходимости, например, при приближении баланса к 0. Это очень полезно, когда вы следите за большим числом счетов. Можно даже настроить напоминание по дате! Например, у кредитных карт есть такое понятие, как льготный период. В течение этого времени вам не надо платить проценты за пользование кредитом. Но не дай бог немного просрочить платеж - придется заплатить проценты в полной мере. Банки не любят напоминать о приближении конца льготного периода. А AnyBalance можно настроить, чтобы за определенное время до наступления даты платежа она вас предупредила!





![](http://s.4pda.ru/wp-content/uploads/2012/12/history-288x480.png)







**Безопасность**





Как программа хранит логины и пароли к личным кабинетам? Это правильный вопрос. В AnyBalance безопасности уделено должное внимание. Самое главное, что ваши данные хранятся только на вашем телефоне. Никуда не передаются, кроме соответствующих личных кабинетов. Это все равно, что вы с телефона через браузер зашли бы в свой личный кабинет. При этом хранение данных организовано в личной области памяти программы, куда никакие другие программы доступа не имеют, и дополнительно данные зашифрованы. Передача данных по интернет для входа в личные кабинеты осуществляется по зашифрованному соединению (https, при поддержке соответствующего личного кабинета), что исключает перехват паролей.





![](http://s.4pda.ru/wp-content/uploads/2012/12/widgets-288x480.png)



Кроме того провайдеры для AnyBalance (плагины, которые позволяют программе работать с конкретным личным кабинетом) имеют открытый исходный код - все желающие могут посмотреть, как они устроены, и что делают, а также могут написать свой провайдер и добавить его в общий каталог.





Виджеты





Часть или все балансы можно вынести на рабочий стол в виде виджетов. Программа позволяет очень гибко настраивать внешний вид виджетов. Можно быстро создать виджет с настройками по умолчанию, а можно углубиться в настройки и полностью настроить виджет под себя.





Первоначальная настройка





Настроить AnyBalance при начале использования очень просто, особенно, если у вас уже есть доступ к нужному личному кабинету. Например, покажем настройку баланса МТС.








  1. Запускаем AnyBalance.



  2. Там нажимаем кнопку Меню и выбираем меню Провайдеры...



  3. Далее снова меню Из каталога... Откроется каталог провайдеров, как на нижнем скриншоте. Там надо выбрать МТС. Обратите внимание, в описании провайдера написано, как получить пароль к личному кабинету, если у вас его ещё нет.



  4. Устанавливаем провайдер - он теперь появился в списке установленных.



  5. Кликаем по провайдеру, открываются настройки для создания аккаунта.



  6. Вводим в настройки логин и пароль от личного кабинета, нажимаем кнопку Назад, сохраняем изменения.



  7. Всё, программа сама теперь запросит данные из личного кабинета и сразу отобразит их.






Так можно настроить и все остальные личные кабинеты - устанавливаем нужные провайдеры, создаём на их основе аккаунты и пользуемся.





![](http://s.4pda.ru/wp-content/uploads/2012/12/catalog-cell-288x480.png)








**Стоимость**





Программа бесплатна, но есть дополнительные возможности, за которые можно заплатить. В первый месяц использования действует полная функциональность. Далее программа продолжает работать бесплатно в базовой функциональности.









**Базовая функциональность**:








  * создание до 7 аккаунтов,



  * автоматическое и ручное обновление балансов аккаунтов через временной интервал, после звонка, после смс,



  * установка провайдеров из файлов с сайта [http://any-balance-providers.googlecode.com](http://any-balance-providers.googlecode.com/) (или с сд-карты),



  * уведомления в первом аккаунте об изменении баланса, о достижении порога, уведомление по счетчику-дате и др.



  * сообщения о появлении обновленной версии провайдеров на сайте.






**Полная функциональность**: в дополнение к базовой








  * неограниченное число аккаунтов



  * уведомления во всех аккаунтах,



  * установка провайдеров прямо из каталога внутри программы,



  * автоматическое поддержание самой свежей версии провайдеров






Полная лицензия привязывается к устройству и даёт право автоматически получать обновления провайдеров, пользоваться каталогом провайдеров и другими преимуществами полной функциональности в течение всей жизни вашего устройства. В ближайшем будущем может появиться годовая полная лицензия с привязкой к Google Account.





**Стоимость:** Бесплатно





**Обсуждение на 4pda:** [http://4pda.ru/forum/index.php?showtopic=300836](http://4pda.ru/forum/index.php?showtopic=300836)





**Ссылка на Google Play:** ![QR](http://s.4pda.ru/forum/style_images/1/qr_code.gif)[https://play.google.com/store/apps/details?id=com.dukei.android.apps.anybalance](https://play.google.com/store/apps/details?id=com.dukei.android.apps.anybalance)





Статья из сайта [4pda.ru](http://4pda.ru/2012/12/11/82234/)
Всем привет.





Сегодня набрел на Google Play Service. И мне стало интересно, что это такое.





И как его можно применить в разработке.


 <!-- more -->


Нашел очень хорошую статью на [Хабре](http://habrahabr.ru/post/153341/).





На Google I/O 2012 было объявлено о скором появлении на свет некоей «платформы Google Play Services». Платформы для разработчиков, которые жаждут интегрировать сервисы Google в свои приложения.  
  
26 сентября в [блоге на G+](https://plus.google.com/+AndroidDevelopers/posts/J1A5hc1ZnS1) было объявлено о запуске Google Play Services v.1.0  
  






#### Что это?





  
Сервисы Google Play (Google Play Services) — это платформа, предназначенная для интеграции продуктов Google, таких как Google+, в ваши Android-приложения. Платформа Google Play Services состоит из системного сервиса, работающего на устройстве, и тонкого клиента. Тонким клиентом выступает ваше приложение с подключенной клиентской библиотекой. Можно изобразить это так:  
![](http://habrastorage.org/storage2/725/647/caf/725647caf708eb37b4480dddfa7b5c7e.png)  
Google Play Services распространяется в виде обычного приложения через Google Play Store и поэтому независима от вашего оператора связи или производителя устройства. Новые девайсы имеют подержку Google Play Services «с завода». Устройства на платформе Android 2.2 (Froyo) или выше, имеющие доступ к Google Play Store получат обновления в течение ближайших нескольких дней. Это позволит вам использовать новейшие API на подавляющем большинстве устройств в экосистеме Android. Устройства с Android ниже версии 2.2 или не подключенные к Google Play Store не поддерживаются.  
  
Платформа Google Play services содержит бо́льшую часть логики взаимодействия с продуктами Google. Доступ к использованию возможностей платформы предоставляется через простую процедуру аутентификации, которая проста как для разработчика так и для пользователя. Для разработчика процедура заключается в вызове пары методов клиентской библиотеки, а остальную работу за него выполнят компоненты Google Play services. Для пользователя приложения процедура аутентификации — это несколько кликов.  
  






#### Компоненты Google Play services





  
Google Play services 1.0 включает в себя следующие компоненты и API:








  * OAuth 2.0 аутентификация в сервисах Google



  * Google+ sign-in — аутентификация с помощью аккаунта G+



  * Гугло-кнопка +1 в вашем приложении






  
Не густо, конечно, но обещают развивать и дополнять платформу новыми сервисами и API  
  
Подробности по установке, использованию и вообще есть [здесь](https://developers.google.com/android/google-play-services/).





Сейчас думаю как же его можно использовать в своих программах.





Жду предложений в комментариях.
Очередное описание програмы





В программе собраны станции (40), вещающие музыку из игр старых консолей, NES, SEGA, SNES, Niniendo 64 и других. Стиль 8bit и chiptune, также есть немного станций с музыкой из современных игр.





![](http://s.4pda.ru/wp-content/uploads/2012/12/device-2012-11-28-030624-288x480.png)

 <!-- more -->

**Версия: **1.0.0





**Русский интерфейс: **Да





**Технические требования:** Android 1.6+





**Категория:** Музыка, Радио









Музыка из старых добрых игр: NES, SEGA, SNES, Atari, Nintendo 64, DOS! И немного из современных. Возможность записи радиопотока, поиска по названию песни на YouTube и Google. Список избранных станций, чтение игровых новостей на разных языках. Регулярные обновления.





![Виджет Game Radio](http://s.4pda.ru/wp-content/uploads/2012/12/device-2012-11-28-030950-288x480.png)
![Чтение новостей](http://s.4pda.ru/wp-content/uploads/2012/12/device-2012-12-01-114133-288x480.png)





Особенности:








  * Более 30 станций игровой тематики + добавляются при каждом обновлении



  * Виджет



  * Список прослушаных треков



  * Возможность записывать поток



  * Можно добавлять свои станции



  * Настройки для улучшения качества приема



  * Игровые новости



  * Бесплатно, а рекламный баннер можно убрать!






**Стоимость:** Содержит рекламу





**Обсуждение на 4pda:** [http://4pda.ru/forum/index.php?showtopic=403999](http://4pda.ru/forum/index.php?showtopic=403999)





**Ссылка на Google Play:** ![QR](http://s.4pda.ru/forum/style_images/1/qr_code.gif)[https://play.google.com/store/apps/details?id=com.maxxt.gameradio](https://play.google.com/store/apps/details?id=com.maxxt.gameradio)





Стаття из сайта [4pda.ru](http://4pda.ru/2012/12/01/80840/)
Всем привет.





Очередное описание новых программ.





Любите поломать голову над интересными загадками? Хотите развить эрудицию и мыслительные способности мозга? Тогда вам точно подойдет это приложение. Здесь собрано большое количество (5+ тысяч) вопросов популярной теле- и спорт-викторины "Что? Где? Когда?"





![](http://s.4pda.ru/wp-content/uploads/2012/12/screenshot_2012-12-01-16-55-57-269x480.png)


<!-- more -->

**Версия: **1.3.0





**Русский интерфейс: **Да





**Технические требования: **Android 2.2+





**Категория:** Головоломка









После запуска приложения можно видеть загруженный список пакетов, каждый из которых содержит несколько десятков вопросов. Кстати, каждый пакет когда-то был игран на турнирах ЧГК разных лет. Пакеты можно искать с помощью поля для поиска.





![](http://s.4pda.ru/wp-content/uploads/2012/11/screenshot_2012-11-20-22-01-33-269x480.png)


Если нет разницы, какой пакет играть, есть возможность выбрать случайный пакет с помощью кнопки на верхней панели. Выпадающий список поможет отфильтровать список пакетов, также доступны кнопки "Обновить" и "Настройки":





![](http://s.4pda.ru/wp-content/uploads/2012/12/screenshot_2012-12-01-16-55-13-e1354368729726.png)




При загрузке пакета он автоматически сохраняется к вам на sd-карту (есть возможность скачать все пакеты) и можно будет играть без доступа к сети. Также у вас есть возможность добавить понравившийся пакет в избранное.





Для перехода к следующему вопросу нужно пролистнуть страницу с текущим вопросом, а для просмотра ответа - вытащить панель снизу:





![](http://s.4pda.ru/wp-content/uploads/2012/11/screenshot_2012-11-20-22-05-50-269x480.png)
![](http://s.4pda.ru/wp-content/uploads/2012/11/screenshot_2012-11-20-22-06-40-269x480.png)



Пользователю также доступна опция таймера для отсчета времени на ответ (время настраивается). Таймер активируется нажатием на цифры. По истечении времени автоматически показывается правильный ответ.





Большинство из описанных функций (например, автозагрузка списка при запуске или открытие ответа по истечении времени) можно настроить с помощью соответствующего раздела:





![](http://s.4pda.ru/wp-content/uploads/2012/12/screenshot_2012-12-01-17-25-36-269x480.png)



Там же можно загрузить или удалить пакеты. Вопросы — основной контент сайта [http://db.chgk.info](http://www.google.com/url?q=http://db.chgk.info&sa=D&usg=AFQjCNFR_XS3XTw7W_iYK803F1royBef9g) в соответствии с Лицензией на использование вопросов.





**Стоимость:** Содержит рекламу





**Ссылка на Google Play:** ![QR](http://s.4pda.ru/forum/style_images/1/qr_code.gif)[https://play.google.com/store/apps/details?id=com.mrcyber.whatwherewhen](https://play.google.com/store/apps/details?id=com.mrcyber.whatwherewhen)





Оригинал статьи [4pda.ru](http://4pda.ru/2012/12/01/80782/)
Привет всем.





Сегодня  бы хотел написать о программе которую мы разработали специально для владельцев сайтов.





Много блогеров и просто владельцев сайтов используют систему webomer.





Эта система показывает посещаемость сайта.


 <!-- more -->


Я статистику блога проверяю несколько раз на день. И вижу, что это не очень удобно, если у тебя нету под рукой компьютера.





Именно из этих соображений я написал программу для android. Которая показывает посещаемость вашего сайта.





Статистика актуальна на 100%, так как напрямую получает данные с Webomer.





Программа доступна для бесплатного использования.





Программа работает на 2 языках: английский и русский





Надеюсь и для вас она будет полезной.





Скачать можно с [PlayMarket](https://play.google.com/store/apps/details?id=com.android_helper.liveinternet)





Несколько картинок:





![](http://android-helper.com.ua/images/uploads/2012/11/device-2012-11-11-154104.png)





![](http://android-helper.com.ua/images/uploads/2012/11/device-2012-11-11-154227.png)



![](http://android-helper.com.ua/images/uploads/2012/11/device-2012-11-11-154256.png)


![](http://android-helper.com.ua/images/uploads/2012/11/device-2012-11-11-154525.png)



![](http://android-helper.com.ua/images/uploads/2012/11/device-2012-11-11-154632.png)Еще одна полезная статья для владык android устройств.





Многие пользователи Android знают, что с помощью приложения Titanium Backup можно вытащить приложение из устройства в виде apk файла. Сегодня мы рассмотрим способ, с помощью которого можно вытащить apk файл приложения прямо из Google Play Store.





![](http://lifehacker.ru/wp-content/uploads/2012/05/04.png)




Плюсом данного способа является отсутствие необходимости предварительной установки приложения на устройство. К сожалению, работает этот способ только для бесплатных приложений. Итак, что нам понадобится:


 <!-- more -->


## 1. Google Chrome





Создаём на рабочем столе второй ярлык для Google Chrome.





![](http://lifehacker.ru/wp-content/uploads/2012/05/a.png)



Делаем по ярлыку правый клик, выбираем «Свойства». В поле «Объект» дописываем через пробел следующие команды:






	--ignore-certificate-errors
	--allow-running-insecure-content


Получится примерно так:

	...\chrome.exe" --ignore-certificate-errors --allow-running-insecure-content









Нажимаем «Применить» и «ОК».





![](http://lifehacker.ru/wp-content/uploads/2012/05/b.png)



После данной операции нужно перезапустить браузер, закрыв при этом все запущенные экземпляры приложения.





## 2. Имя аккаунта Google и ID устройства





По факту мы собираемся имитировать загрузку приложения на устройство, поэтому необходимо знать имя своего аккаунта, то есть имя вашего почтового ящика Google, а также идентификационный номер вашего Android устройства.





С ящиком всё понятно, а чтобы узнать ID устройства, откройте звонилку на своём смартфоне и наберите *#*#8255#*#*





На появившемся экране необходимо найти строчку «Device ID:»





Идентификационным номером является комбинация букв и цифр, следующая после «android-». К примеру, если в строке вы видите «Device ID: android-1122aa33bb445577», то идентификатором является комбинация «1122aa33bb445577». Запишите эту комбинацию.





Если по каким-то причинам у вас не получилось узнать ваш Device ID указанным выше способом, вы можете просто скачать приложение [Device ID](https://play.google.com/store/apps/details?id=com.redphx.deviceid) в Google Play Store.





## 3. APK Downloader





Скачиваем расширение для браузера под названием APK Downloader ([прямая ссылка на загрузку расширения](http://codekiem.com/apk-downloader/crx/1.2.1.crx)).





В появившемся окне вводим адрес нашего Google аккаунта, то есть адрес почты. Пароль (ага, страшно), а также Device ID. После этого нажимаем «Login».





![](http://lifehacker.ru/wp-content/uploads/2012/05/c.png)



В следующем окне выбираем свою страну и оператора сотовой связи, после чего нажимаем «Save Settings». Далее должно появиться окно с сообщением о успешной активации расширения.





![](http://lifehacker.ru/wp-content/uploads/2012/05/d.png)



## 4. Google Play Store





Теперь заходим на наш любимый [Google Play Store](https://play.google.com/) и выбираем любое бесплатное приложение. В правой части адресной строки браузера появится характерного вида зелёная голова со стрелочкой.





![](http://lifehacker.ru/wp-content/uploads/2012/05/e.png)



Нажимаем на эту иконку, и приложение успешно загружается на компьютер в виде apk файла. По сути, теперь мы умеем создавать standalone дистрибутивы бесплатных приложений.





![](http://lifehacker.ru/wp-content/uploads/2012/05/f.png)



**Убедиться в абсолютной порядочности разработчика расширения APK Downloader не представляется возможным, поэтому вводите данные своего аккаунта на собственный страх и риск. Кроме того, подобные действия в принципе нарушают правила использования Google Play Store.**





Статья из сайта [lifehacker.ru](http://lifehacker.ru/2012/05/30/kak-vytashhit-apk-fajjl-iz-google-play-store/)
Всем привет.





Очень полезная статья, для тех кто активно использует маркет. И хочет что бы все программы устанавливались на телефон.





Зачастую разработчики помечают те или иные приложения в Google Play Store как несовместимые с некоторыми устройствами по причине нестабильной работы приложения на данной модели. Тем не менее, всегда есть шанс того, что на вашем устройстве приложение всё же заработает.





  <!-- more -->



Для владельцев рутованных Android есть простой способ обмануть Play Store, представив своё устройство в качестве другой модели, которая числится для конкретного приложения в списке поддерживаемых. Этот способ избавляет от возни с предварительным выкачиванием apk файла из самого маркета.





Итак, у нас есть рутованный Android. Скачиваем из Play Store любой файловый менеджер, который позволяет получить доступ к системным файлам, а также позволит редактировать их. Мы воспользовались приложением [ES File Explorer](https://play.google.com/store/apps/details?id=com.estrongs.android.pop). После установки приложения заходим в его настройки. Необходимо включить возможность доступа к рут-директории, а также установить возможность записи в файлы, находящиеся в этой директории.





![Как установить несовместимое приложение на Android](http://lifehacker.ru/wp-content/uploads/2012/06/screenshot-1340023180361.png)
![Как установить несовместимое приложение на Android](http://lifehacker.ru/wp-content/uploads/2012/06/screenshot-1340023094634.png)




Теперь идём в папку «system» и находим там файл «build.prop». Перед любыми манипуляциями такого рода лучше конечно забекапиться, а в данном случае хотя бы сделать копию «build.prop» файла куда-нибудь на карту памяти.





![Как установить несовместимое приложение на Android](http://lifehacker.ru/wp-content/uploads/2012/06/screenshot-1340023213651.png)



Открываем файл «build.prop» с помощью встроенного редактора ES проводника как текстовый файл.





![Как установить несовместимое приложение на Android](http://lifehacker.ru/wp-content/uploads/2012/06/screenshot-1340023259603.png)
![Как установить несовместимое приложение на Android](http://lifehacker.ru/wp-content/uploads/2012/06/screenshot-1340023243358.png)




Google Play идентифицирует устройство по данным, записанным в строчках «ro.product.model» и «ro.product.manufacturer». Остаётся лишь изменить значения этих параметров. В данном случае мы подменяем старенький Wildfire на Incredible. После этого нажимаем кнопку «Menu» и сохраняем внесённые изменения.





![Как установить несовместимое приложение на Android](http://lifehacker.ru/wp-content/uploads/2012/06/screenshot-1340023338036.png)
![Как установить несовместимое приложение на Android](http://lifehacker.ru/wp-content/uploads/2012/06/screenshot-1340023633575.png)


Осталось подчистить данные в самом приложении Google Play Store. Для этого заходим в менеджер приложений, находим там Play Store и чистим кэш и данные. После этого необходимо перезагрузить устройство.





![Как установить несовместимое приложение на Android](http://lifehacker.ru/wp-content/uploads/2012/06/screenshot-1340023695040.png)
![Как установить несовместимое приложение на Android](http://lifehacker.ru/wp-content/uploads/2012/06/screenshot-1340023711828.png)




Данный способ не позволит обойти ситуации, когда приложение несовместимо из-за разницы версий операционной системы, либо из-за страны проживания.





Статья из сайта [lifehacker.ru](http://lifehacker.ru/2012/06/19/kak-ustanovit-nesovmestimoe-prilozhenie-na-android/)
Хорошая статья как по мне.





Современные мобильные телефоны постепенно становятся все более умными и справляются с самым широким кругом задач — начиная от организации ваших тренировок и заканчивая рабочими процессами и развлечениями. Тем досаднее бывает, если ваш мобильный помощник становится жертвой воришек или вашей рассеянности. Впрочем, существует реальный способ не только вернуть свой смартфон обратно, но и довести злодеев до нервного срыва.





Программ, осуществляющих обнаружение и удаленное управления некоторыми функциями вашего смартфона существует довольно много, но все они, как правило имеют платный статус, а если и имеют бесплатный вариант, то с до предела ограниченной функциональностью. Приложение **Android Lost Free** в этом смысле является уникальной — многие ее возможности не имеют аналогов, а использование полностью бесплатно.


<!-- more -->


Для начала необходимо установить небольшую [программу-клиент](https://play.google.com/store/apps/details?id=com.androidlost&feature=related_apps) весом около 140 кб из магазина приложений Google. После ее запуска появится всего одно окошко с несколькими опциями. Здесь, для полноценной работы программы, вам потребуется предоставить ей административные права и возможность принимать и отправлять SMS сообщения.





Для связи с вашим телефоном требуется, разумеется, какой-либо канал связи. Android Lost Free задействует для этого сразу два метода: ваше текущее интернет-подключение и управление с помощью специальных SMS. Таким образом, если до вашего аппарата хоть как-то можно достучаться, то программа сделает это.









Основным инструментом для работы с вашим потерянным телефоном является[специальный веб сервис](http://www.androidlost.com/). Возможно его оформление не вызывает энтузиазма, но со своей задачей он справляется на отлично. Для начала вам потребуется войти с помощью своей учетной записи в Google, так как это необходимо для отправки сообщений. После этого можно приступить к изучению возможностей сервиса.





![](http://lifehacker.ru/wp-content/uploads/2012/10/122-e1350390264650.png)





Функций программа имеет огромное количество и все они удобно рассортированы по нескольким вкладкам в разделе _Controls_. Приведем список самых интересных из множества доступных возможностей:





**Alarm** — по вашему сигналу телефон начинает истошно звенеть и мигать. что может вам пригодиться, если вы вышли на след злоумышленника;





**GPS** — определение положения телефона на карте.





![](http://lifehacker.ru/wp-content/uploads/2012/10/29.png)





**Phone Status** — при нажатии на эту кнопку телефон отсылает вам подробную информацию о своем состоянии, в том числе модель, статус батареи, номер imei и так далее.





**Message popup** — отображение вашего сообщения на экране телефона. Таким образом вы можете попросить вернуть вашу пропажу.





**SMS post** — с помощью этой функции вы сможете отослать SMS с вашего телефона на выбранный номер.





**Message Picture** — хитрая функция, позволяющая отослать сообщение на ваш телефон, а в  тот момент когда на него среагируют, фронтальная камера сделает снимок и отошлет его вам. Хорошая возможность увидеть лицо нового владельца вашего аппарата.





![](http://lifehacker.ru/wp-content/uploads/2012/10/48-e1350393835746.png)





**Lock phone** — блокирует телефон, причем для входа теперь понадобится вводить установленный вами цифровой код.





**Call List** — получить список всех телефонных разговоров за последнее время. Может быть полезно, если вам нужно выяснить контакты злоумышленника.





**Sound Recording, Front Camera, Rear Camera** — да, вы можете заставить свой телефон записывать звук, делать снимки передней и задней камерой. А результаты, само собой, будут немедленно высланы вам.





**SMS commands** — вы имеете возможность управлять своим телефоном с помощью эсэмсок с другого телефона. Список доступных команд очень обширен и доступен на[этой странице](http://www.androidlost.com/#sms).





Это далеко не полный перечень возможностей программы, но достаточно ярко иллюстрирующий ее незаурядные возможности. Да, я уже предвижу голоса скептиков, которые скажут, что при краже телефона его обычно полностью выключают, а потом сразу же перепрошивают, так что никакая даже самая хитрая программа не поможет. Но во-первых, это происходит не всегда моментально, так что шанс на обнаружения все же есть, особенно если новый владелец захочет покопаться в ваших данных. А во-вторых, программа **Android Lost Free** дает некоторый шанс на возвращение телефона, а ее отсутствие сводит их к полному нулю. Так что ставим, тестируем, делимся впечатлениями в комментариях.





**[Android Lost Free](https://play.google.com/store/apps/details?id=com.androidlost&feature=related_apps)**





Статья из сайта [lifehacker.ru](http://lifehacker.ru/2012/10/17/kak-vernut-svojj-poteryannyjj-android/)
Полезные программы, продолжают наполнять блог.





Сегодня это будет калькулятор





Приятно вспомнить те чудесные времена, когда нам, будучи детьми, не нужно было ничего считать вне рамок школьного курса математики. Теперь считать приходится всё и постоянно. Мало кто из нас занимается планированием бюджета, обходясь только ручкой и листом бумаги. А если найти толковый многофункциональный калькулятор, то ему можно найти место не только в финансовой составляющей жизни.


<!-- more -->


Штатный калькулятор Android не отличается навороченностью и особым удобством при использовании, а чтобы не тратить время на поиски подходящей вменяемой альтернативы в Google Play Store, мы советуем вам попробовать на практике бесплатный калькулятор под названием [Easy Calculator Pro](https://play.google.com/store/apps/details?id=com.msj.easycalcpro).





Данный калькулятор очень универсален и подойдёт для любых целей. Основная панель кнопок ничем не отличается от привычных калькуляторов. Для того, чтобы уместить больше операций в минимальном наборе кнопок, оставляя их как можно большего размера для удобства нажатия, некоторые дополнительные значения кнопок вызываются длительным нажатием на них. Стоит заметить, что Easy Calculator Pro считает всё в процессе ввода выражения. Иными словами, пользователю не нужно нажимать «=» для получения результата. По мере ввода чисел и операций ответ выводится в реальном времени.





![Easy Calculator Pro](http://lifehacker.ru/wp-content/uploads/2012/10/Screenshot_2012-10-22-11-29-34-e1350894170200.png)
![Easy Calculator Pro](http://lifehacker.ru/wp-content/uploads/2012/10/Screenshot_2012-10-22-11-29-45-e1350894187381.png)





Очень важно, что все операции заносятся в журнал вычислений, что позволяет вернуться к ранее проводимым расчётам. Для каждой записи в журнале можно добавить комментарий, либо использовать для дальнейших расчётов. Тем же, кто использует многоступенчатые вычисления с занесением результатов в память, понравится то, что у этого калькулятора количество ячеек памяти не ограничено.





![Easy Calculator Pro](http://lifehacker.ru/wp-content/uploads/2012/10/Screenshot_2012-10-22-11-38-57-e1350894236410.png)
![Easy Calculator Pro](http://lifehacker.ru/wp-content/uploads/2012/10/Screenshot_2012-10-22-12-12-08-e1350894253763.png)





Как и любой претендующий на массовость продукт, данный калькулятор снабжён дополнительной панелью кнопок, превращающий его в инженерный калькулятор. Несмотря на то, что эти опции востребованы довольно узким кругом людей, будь то студенты технических специальностей и прочие математики мира сего, есть здесь и несколько дополнительных возможностей, которые могут пригодиться любому человеку в повседневной жизни.





![Easy Calculator Pro](http://lifehacker.ru/wp-content/uploads/2012/10/Screenshot_2012-10-22-11-40-08-500x281.png)




К примеру, Easy Calculator Pro умеет по-умному работать с процентами. Нужно рассчитать процент от сложного выражения в одно действие? Достаточно приписать в конце выражения нужный процент.





![Easy Calculator Pro](http://lifehacker.ru/wp-content/uploads/2012/10/Screenshot_2012-10-22-11-48-37-500x281.png)




Часто возникает необходимость проводить множество вычислений с участием одного и того же числа. Калькулятор позволяет запомнить определённое число и даже часть выражения в виде шаблона, который потом вызывается нажатием одной клавиши. К примеру, мы считаем некоторые суммы с учётом налога НДС. Вводим выражение 1.18* и зажимаем клавишу C (set). Теперь при нажатии C автоматически вставляется запомненное выражение. Для возврата клавиши C к исходному назначению нужно просто «запомнить» пустое поле для ввода.





![Easy Calculator Pro](http://lifehacker.ru/wp-content/uploads/2012/10/Screenshot_2012-10-23-10-09-50-e1350975031463.png)
![Easy Calculator Pro](http://lifehacker.ru/wp-content/uploads/2012/10/Screenshot_2012-10-23-10-10-52-e1350975053438.png)




Чтобы пользователю приходилось тратить меньше времени на переключение между простой и расширенной панелью кнопок, в калькуляторе есть «умная кнопка», расположенная в левом верхнем углу и позволяющая получать доступ к некоторым дополнительным функциям прямо из текущей клавиатуры.





![Easy Calculator Pro](http://lifehacker.ru/wp-content/uploads/2012/10/Screenshot_2012-10-23-10-08-31-e1350975331770.png)




Ещё одна очень полезная функция — работа с датами и временными периодами. Нужно быстро подсчитать количество дней между двумя датами или узнать дату, следующую через n-ое количество дней после заданной? Легко.





![Easy Calculator Pro](http://lifehacker.ru/wp-content/uploads/2012/10/Screenshot_2012-10-23-10-04-11-500x281.png)




В случае возникновения синтаксической ошибки в выражении калькулятор не уходит в Error, а сообщает о некорректном вводе. При этом весь синтаксис выражения подсвечивается другим цветом текста.





![Easy Calculator Pro](http://lifehacker.ru/wp-content/uploads/2012/10/Screenshot_2012-10-23-10-04-48-500x281.png)




Для того, чтобы быстро перейти в ту часть выражения, которую нужно исправить, здесь предусмотрен курсор. Это гораздо удобнее, нежели пытаться попасть в нужную часть выражения прицельными микротапами по экрану.





![Easy Calculator Pro](http://lifehacker.ru/wp-content/uploads/2012/10/Screenshot_2012-10-23-10-05-10-500x281.png)




Для ещё более удобной работы здесь есть буфер обмена. Нужно просто тапнуть и удерживать палец на нужной области, после чего появится соответствующий интерфейс.





![Easy Calculator Pro](http://lifehacker.ru/wp-content/uploads/2012/10/Screenshot_2012-10-23-10-05-48-500x281.png)




Зачастую необходимо, чтобы результат вычислений был представлен в том или ином конкретном виде. Здесь это можно сделать, просто удерживая палец на результате.





![Easy Calculator Pro](http://lifehacker.ru/wp-content/uploads/2012/10/Screenshot_2012-10-23-10-05-38-500x281.png)




В появившемся меню есть опция «Вид», позволяющая указать формат отображения.





![Easy Calculator Pro](http://lifehacker.ru/wp-content/uploads/2012/10/Screenshot_2012-10-23-10-05-28-500x281.png)




Ещё калькулятор отлично поддерживает работу с углами в формате градусы-минуты-секунды. Функция ввода углов в таком формате находится на дополнительной клавиатуре, но для быстрого доступа легко вешается на умную кнопку, а результат также может отображаться в нужном виде через долгий тап по нему.





![Easy Calculator Pro](http://lifehacker.ru/wp-content/uploads/2012/10/Screenshot_2012-10-24-10-30-00-500x281.png)




![Easy Calculator Pro](http://lifehacker.ru/wp-content/uploads/2012/10/Screenshot_2012-10-24-10-30-16-500x281.png)



Помимо этого, в калькуляторе есть множество констант, что значительно упрощает ввод необходимых выражений с их использованием, а настраиваемая точность до 40 значимых символов будет достаточна абсолютному большинству пользователей.





Для полного ознакомления со всеми возможностями калькулятора можно вызвать встроенную справку, в которой описаны все нюансы использования этого инструмента.





![Easy Calculator Pro](http://lifehacker.ru/wp-content/uploads/2012/10/Screenshot_2012-10-23-10-18-56-e1350974972962.png)





**Easy Calculator Pro** | [Google Play Store](https://play.google.com/store/apps/details?id=com.msj.easycalcpro) (free)





Статья из сайта [lifehacker.ru](http://lifehacker.ru/2012/10/27/easy-calculator-pro-android/)
Продолжаем собирать интересные статьи.





Хотите развлечься в минуты ожидания, а заодно потренировать память и внимание? Тогда возьмите в руки свой Android-смартфон и установите новую головоломку EvoMemo. Игра поможет взрослым и детям развить память и улучшить запоминательные процессы в игровой форме.





![](http://s.4pda.ru/wp-content/uploads/2012/10/130.jpg)


<!-- more -->

**Версия: **1.0





**Русский интерфейс: **Нет





**Технические требования: **Android 1.5 и выше





**Поддержка установки на SD:** Нет





**Категория:** головоломки









В игре есть два режима: Evo и Memo. В первом перед игроком находится поле, состоящее из большого количества квадратиков. Все квадратики повернуты тыльной стороной, не позволяя игроку увидеть содержание. Квадратик переворачивается, когда вы его выбираете. Цель игрока – открыть все квадратики, находя последовательности из трех картинок, представляющих собой эволюцию какой-то вещи (например, телефона, ружья и т.д.).





![](http://s.4pda.ru/wp-content/uploads/2012/10/43.jpg)





Во втором режиме цель игрока – запомнить определенную вещь на картинке, а затем найти ее на поле среди множества других. Внимание! Время в этом режиме ограничено. Еще одна особенность состоит в том, что количество вещей, которые нужно запомнить, со временем увеличивается.





EvoMemo предлагает 3 размера игрового поля (9, 30 и 42 клетки) и встроенную энциклопедию.





![](http://s.4pda.ru/wp-content/uploads/2012/10/37.jpg)





**Стоимость:** Бесплатно





**Ссылка на Google Play:** [https://play.google.com/store/apps/details?id=com.andreysapps.evomemo](https://play.google.com/store/apps/details?id=com.andreysapps.evomemo)





Статья из сайта[ 4pda.ru](http://4pda.ru/2012/10/22/75712/)
Продолжаем собирать интересные статьи.





Чтение динамических и сохраненных параметров из ECU автомобилей поддерживающих стандарт OBD-II. Поддержка чтения данных для машин с несколькими ECU.





![](http://s.4pda.ru/wp-content/uploads/2012/10/a_e37512ce.jpg)


 <!-- more -->


**Версия: **1.19





**Русский интерфейс: **Нет





**Технические требования: **Android 1.6 и выше





**Поддержка установки на SD:** Нет





**Категория:** транспорт









Принцип работы приложения OBD Авто Доктор - чтение динамических и сохраненных параметров из блока управления двигателем (ECU) автомобилей поддерживающих стандарт OBD-II, а также поддержка чтения данных для машин с несколькими ECU.





![](http://s.4pda.ru/wp-content/uploads/2012/10/obd-car-doctor-1-287x4801.png)
![](http://s.4pda.ru/wp-content/uploads/2012/10/obd-car-doctor-1-287x4801.jpg)
![](http://s.4pda.ru/wp-content/uploads/2012/10/obd-car-doctor-2-287x4801.png)



Фишка приложения OBD Авто Доктор в том, что – оно связывается с бортовым компьютером любой машины, поддерживающей спецификации OBD-II (система бортовой диагностики автомобиля), не зависимо от протокола связи и марки авто. Это все американские машины, выпущенные с 1996 года и европейские - начиная с 2001 года, дизель - с 2004г.





Для работы приложения  требуется OBD-II Bluetooth адаптер на базе контролера ELM 327 или совместимый.





После подключения такого адаптера к диагностическому разъему OBD-II – необходимо зайти в окружение Bluetooth и найти ваш адаптер. Далее, произвести сопряжение устройств. Секретный код сопряжения, как правило 1234, или 0000. Затем назначаете COM порт. Указываете этот номер COM порта приложению диагностики OBD Авто Доктор, установленному на Вашем смартфоне.





Также, для получения точных данных мы рекомендуем избегать одновременного запуска нескольких программ чтения OBD,  водителю нужно убедиться, что другие приложения не держат в активном состоянии подключение к OBD.





**Возможности приложения OBD Авто Доктор:**








  * Чтение ошибок и их расшифровка (DTC память)



  * Стирание ошибок (погасить лампочку MIL – Check Engine), а также других сохраняемых параметров



  * Чтение параметров в режиме реального времени:




    * Обороты двигателя



    * Нагрузка двигателя



    * Температура охлаждающей жидкости



    * Состояние топливной системы



    * Скорость движения автомобиля



    * Долгосрочный расход топлива



    * Абсолютное давление воздуха



    * Опережение зажигания



    * Температура всасываемого воздуха



    * Массовый расход воздуха



    * Положение дроссельной заслонки



    * Лямбда-зонд (коррекция режима двигателя)



    * Давление топлива



    * И другое - зависит от конкретного авто...








  * Чтение VIN номера кузова






**Стоимость:** Бесплатно





**Ссылка на Google Play:** [https://play.google.com/store/apps/details?id=com.pnn.obdcardoctor](https://play.google.com/store/apps/details?id=com.pnn.obdcardoctor)





Статья из сайта [4pda.ru](http://4pda.ru/2012/10/28/76381/)
Продолжаем собирать интересные статьи.





На днях аналитики опубликовали сводную таблицу по рынку планшетов за 3 квартал этого года, где сравнивается общее количество планшетов на рынке, их популярность, а также динамика роста показателей по сравнению с предыдущим годом.





![](http://s.4pda.ru/wp-content/uploads/2012/10/tablets-480x332.jpg)



<!-- more -->





Итак, согласно последним полученным данным, Android стремительно набирает вес и установлен на 41,6% всех купленных планшетов, что на 12,1% больше значения предыдущего года, когда Android был установлен только на 29,2% "таблеток". В итоге, ОС от Google стремительно догоняет iOS от Apple, которая потеряла 7,8% по сравнению с 2011 годов и сейчас занимает 56,7%. Тем не менее, это большая часть рынка.





Однако, это не значит, что яблочных планшетов iPad стало меньше. Напротив, в 2012 году было приобретено на 2,9 миллионов устройств больше, чем в прошлом - целых 14 миллионов. Просто Android занял огромную нишу бюджетных планшетов с небольшой диагональю экрана, которую несколько лет не могла заполнить компания Apple. Всвязи с этим, ОС от Google показывает более высокие темпы роста как в процентном, так и в абсолютном соотношении: в 2012 году было продано более 10 миллионов планшетов, что больше почти на 5 миллионов больше, чем в прошлом.





Присутствие других игроков, кроме Google и Apple, на рынке, в общей картине, пока не заметно, но мы не сомневаемся, что к следующему году ситуация изменится вместе с выходом планшетов на Windows 8 и Windows 8 RT.





Что касается общего роста планшетов, то он замедлился более чем в 6,5 раз, по сравнению с временным промежутком 2010-2011. В этом году этот показатель составил 43,4%, в то время как в 2011 он был равен 288,6%. Оно и понятно - планшет уже окончательно перешёл из разряда девайсов "для гиков" в разряд устройств для повседневного использования. Так что, почти все, кто хотел купить планшет, уже сделали это, так что в дальнейшем ждать серьёзных скачков роста этого рынка не стоит.





Статья из сайта [4pda.ru](http://4pda.ru/2012/10/26/76248/)
Эх химия, химия.





Для школьников и студентов химического факультета.





Periodic Table – это удобная периодическая система химических элементов. В ней вы можете найти информацию о всех известных науке 118 химических элементах. На основном экране вам представлена таблица элементов в привычном для всех виде. Каждый элемент обозначен цветом, который определяет к какой категории относится элемент. При нажатии на элемент вы видите самую часто используемую информацию об элементе.





![](http://s.4pda.ru/wp-content/uploads/2012/10/pt1-480x270.png)

 <!-- more -->


**Версия: **1.5.3





**Русский интерфейс: **Да





**Технические требования: **Android 3.0 и выше





**Поддержка установки на SD:** Да





******Категория:** Образование









Помимо базовой информации об элементе вы можете посмотреть более подробную информацию о его свойствах (физических, химических и т.п.), а также диаграмму электронной оболочки.





![](http://s.4pda.ru/wp-content/uploads/2012/10/pt2-480x270.png)




Программа поддерживает как смартфоны, так и планшеты. Мы протестировали приложение на следующих устройствах:








  1. Смартфоны с разрешением 800x480, 854x480, 1280x720, 1280x800



  2. Планшеты с разрешением: 1280x720, 1280x800






Программа поддерживает русский и английский языки.





Программа постоянно развивается, в ближайшую версию мы планируем добавить поддержку еще большого числа устройств и добавить поиск по элементам. Также в планах добавление изображений для каждого элемента и базовой текстовой информации о каждом элементе.





**Стоимость:** Бесплатно





**Обсуждение на 4pda:** [http://4pda.ru/forum/index.php?showtopic=371331](http://4pda.ru/forum/index.php?showtopic=371331)





**Ссылка на Google Play:** [https://play.google.com/store/apps/details?id=jqsoft.apps.periodictable.hd](https://play.google.com/store/apps/details?id=jqsoft.apps.periodictable.hd)





Статья из сайта [4pda.ru](http://4pda.ru/2012/10/17/74929/)
А это будет интересно родителям в первую очередь.





Смартфоны все прочнее входят в жизнь современного человека. Это не только средство связи, помощник в бизнесе или мультимедийное устройство - это еще и желанный подарок для любого ребенка. Kinder Phone– приложение для смартфонов на операционной системе Android, которое позволит родителям присматривать за ребенком на расстоянии. Программа может ограничить функции устройства, отслеживать передвижения малыша и многое другое.





![Разработчик: Kinderphone – приложение для контроля детского смартфона](http://s.4pda.ru/wp-content/uploads/2012/10/vvodnaya.jpg)



 <!-- more -->

**Версия: **1.0





**Русский интерфейс: **Нет





**Технические требования: **Android 2.2 и выше





**Поддержка установки на SD:** Нет





**Категория:** Связь









Kinder Phone – приложение для детей и их родителей, которое превращает обычный смартфон в полноценный детский телефон и позволяет контролировать устройство в руках ребенка. Пока что приложение находится на этапе тестирования, а разработчики собирают отзывы о работе агента в реальных условиях.





Само приложение для смартфона на платформе Android. Kinder Phone устанавливается поверх стандартного пользовательского интерфейса и меняет его на свой, более простой и понятный для ребенка. Родитель устанавливает пароль для выхода из интерфейса Kinder Phone, который в свою очередь включается даже после перезагрузки телефона. Приложение позволяет ограничивать список контактов и возможность использования приложений и игр (в том числе по времени - очередной уровень Angry Birds получится пройти только завтра). Кроме того, в интерфейсе программы появляется вкладка check-in для контроля перемещения ребенка. Информация о сделанных check-in’ах может приходить родителям в виде sms.





![](http://s.4pda.ru/wp-content/uploads/2012/10/114.jpg)





Виртуальный кабинет для родителей, который становится доступным сразу после регистрации. В личном кабинете можно настроить функции детского телефона, отслеживать его перемещение по карте Google, просматривать сделанные check-in’ы, а также наблюдать за любыми активностями: играми, звонками, фотографированием, зарядом аккумулятора. Родительский кабинет поддерживает статистику сразу по нескольким телефонам - а значит, все дети в семье могут находиться под контролем.





Разработчики не останавливаются на достигнутом. В будущих версиях программы появятся новые функции, которые смогут еще больше облегчить жизнь родителям и их детям. Планируется добавление видеозвонков, возможности изменения детьми оформления интерфейса, обмена фотографиями и сообщениями внутри приложения, а также многое другое.





![](http://s.4pda.ru/wp-content/uploads/2012/10/114.jpg)





KinderPhone можно скачать из Google Market абсолютно бесплатно.





**Стоимость:** Бесплатно





**Ссылка на Google Play:** [https://play.google.com/store/apps/details?id=com.kinderphone.kinder](https://play.google.com/store/apps/details?id=com.kinderphone.kinder)





Статья из сайта [4pda.ru](http://4pda.ru/2012/10/16/74824/)
Из последних новостей





Предлагаем вашему вниманию очередную подборку с ссылками на новости, интересные материалы и полезные ресурсы.  
![](http://habrastorage.org/storage2/c71/e2a/256/c71e2a2564068940c470cc5397ef9c49.png)  



<!-- more -->


### Горячая семерка














![](http://habrastorage.org/storage2/b7a/e2c/aa8/b7ae2caa8cf07084bbf46d89a8fbe15d.png)







### Прошедшие и будущие мероприятия октября














18 октября в Киеве [стартовала международная конференция IDCEE](http://habrahabr.ru/post/155337/), а сегодня [были названы победители конкурса стартапов](http://ain.ua/2012/10/19/98741). Недавно прошла Fronteers 2012 — лучшая конференция по клиентской разработке, с отчетом можно ознакомиться [здесь](http://tohtml.it/post/33822898596/fronteers2012). Также, на прошлой неделе проходила YAC, с которой уже стали доступны [видео докладов](http://events.yandex.ru/events/yac/2012/talks/#frontend). Кроме этого, намечается парочка интересных мероприятий: [Apple «покажет что-то» 23-го октября](http://www.overclockers.ru/hardnews/50140/Priglasheniya_na_meropriyatie_Apple_namechennoe_na_23_oktyabrya_uzhe_razoslany.html), а в конце месяца [Google скорее всего покажет новую версию Android](http://www.youhtc.ru/2012/10/novaya-versiya-android-v-konce-oktyabrya/)














![](http://habrastorage.org/storage2/247/739/e1b/247739e1b416af62303f69a48a14a456.png)







### Bootstrap














Проект Bootstrap продолжает оставаться в тренде среди веб-разработчиков. Отличную подборку всякого полезного для него можно найти в [этой статье](http://habrahabr.ru/post/154687/). Кроме этого, желающие могут ознакомиться с туториалом по созданию [адаптивной темы для WordPress с помощью Bootstrap](http://blog.teamtreehouse.com/responsive-wordpress-bootstrap-theme-tutorial)














![](http://habrastorage.org/storage2/262/844/666/26284466663a6ef243e812b97e20fd6c.png)







### Internet Explorer 10














Интересная статья, [где подробно можно прочесть о том, чего стоит ожидать от нового IE10](http://www.mobilexweb.com/blog/windows-8-surface-ie10-html5). А [здесь](http://timkadlec.com/2012/10/ie10-snap-mode-and-responsive-design/) можно ознакомиться с нюансами работы Responsive Design в Snap Mode. Плюс, ожидаем [предварительную верси. IE10 для Windows 7 к середине ноября](http://viennaos.net/articles/3252-predvaritelnaya-versiya-interner-explorer-10-poyavitsya-v-seredine-noyabrya.html)














![](http://habrastorage.org/storage2/084/60e/6e4/08460e6e482449212a697b8062ac9df8.png)







### Расширяем CSS














Препроцессоры становятся все популярней. [Эта статья покажет](http://ianstormtaylor.com/oocss-plus-sass-is-the-best-way-to-css/), на сколько гибкими могут стать таблицы стилей с использованием OOCSS + Sass. [Здесь можно посмотреть, как с помощью несложного SCSS-миксина грузить изображения для ретина-дисплеев](http://37signals.com/svn/posts/3271-easy-retina-ready-images-using-scss). Те, кто хорошо воспринимает на слух англоязычную информацию, могут открыть для себя [SassCast](http://sasscast.tumblr.com/) — подкаст на тему Sass. Ну, и напоследок загляните в[sassmeister](http://sassmeister.com/) — песочницу для работы с Sass/SCSS














![](http://habrastorage.org/storage2/1b4/866/b43/1b4866b439d67c0d8575aebf831026db.png)







### [Учебник jQuery для начинающих](http://habrahabr.ru/post/155107/)














Многие, кто начинал учить jQuery по русскоязычным ресурсам, не могли обойти стороной [сайт](http://anton.shevchuk.name/) Антона Шевчука, а некоторые даже начинали изучение со статей на этом сайте. Антон решился и [собрал все свои статьи из серии «jQuery для начинающих»](http://habrahabr.ru/post/155107/) в одном учебнике, который и представил на суд общественности.














![](http://habrastorage.org/storage2/f6f/062/60d/f6f06260dd80d8d31e7c4e107b461a43.png)







### Surface на подходе














[Microsoft раскрыла цены на Surface RT](http://habrahabr.ru/post/155001/) в [официальном магазине](http://surface.microsoftstore.com/store/msstore/Content/pbpage.Surface), по итогам чего [младшая модель Surface была распродана за сутки](http://itc.ua/news/microsoft-rasprodala-po-predvaritelnyim-zakazam-vse-planshetyi-surface-rt-tsenoy-499/). Тем временем Microsoft запускает на ТВ [новую рекламу Microsoft Surface](http://wpos.com.ua/microsoft-zapuskaet-na-tv-novuyu-reklamu-microsoft-surface.html) и[первый рекламный ролик Windows 8](http://www.3dnews.ru/software-news/636608/)














![](http://habrastorage.org/storage2/d6f/a12/f9c/d6fa12f9c1b7ef2e341b0771182a3a23.png)







### [Google StreetView приглашает побродить в одном из их датацентров](http://gagadget.com/other/2012-10-18-google_streetview_priglashaet_pobrodit_v_odnom_iz_ikh_datatsentrov)














В Google решили показать один из своих датацентров, находящийся в городе Ленуар. Теперь многие смогут убедиться, что креативные идеи в оформлении помещений айтишного гиганта используются не только в рабочих офисах и комнатах отдыха, но и в теж же датацентрах  
  






### ![](http://habrastorage.org/storage2/ba6/1d0/aa9/ba61d0aa90be53f9f7f44faeabb67e78.gif) Разработка












  * [Видео докладов c последнего YAC](http://events.yandex.ru/events/yac/2012/talks/#frontend)



  * [Подборка полезного для любителей Twitter Bootstrap](http://habrahabr.ru/post/154687/)



  * [Новая статья от Chris Coyier на smashingmagazine:](http://coding.smashingmagazine.com/2012/10/15/css-qa-4/) SVG Fallback, Vertical Rhythm, CSS Project Structure ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Нативная клиентская валидация для веб форм средствами браузеров](http://www.html5rocks.com/en/tutorials/forms/constraintvalidation/). Хорошо расписаны основные проблемы, возникающие при использовании html5 в формах для валидации ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Эффект разворачивания бумажной открытки](http://tympanus.net/Development/PFold/index3.html) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [LearnStreet — новый проект для интерактивного изучения JavaScript, Python, Ruby (в стиле CodeAcademy и khanacademy)](http://www.learnstreet.com/lessons/languages/javascript) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Создание параллакс-эффекта на примере простого урока](http://net.tutsplus.com/tutorials/html-css-techniques/simple-parallax-scrolling-technique/) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Как создать адаптивную тему для WordPress с помощью Bootstrap](http://blog.teamtreehouse.com/responsive-wordpress-bootstrap-theme-tutorial) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Как сделать Lazy-Loading для изображений на сайте](http://speckyboy.com/2012/10/18/how-to-create-lazy-loading-images-for-your-website/) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Использование мета тега viewport в неадаптивных шаблонах (перевод)](http://ruseller.com/lessons.php?rub=2&id=1560)



  * [Строим радиальный градиент средствами HTML5](http://www.script-tutorials.com/html5-radial-gradient/) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [HTML5 media and data URIs](http://www.iandevlin.com/blog/2012/09/html5/html5-media-and-data-uri) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [fbootstrapp](http://ckrack.github.com/fbootstrapp/) — фреймворк на основе bootstrap для создания iframe-приложений под фейсбук ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Подготовка к верстке адаптивных сайтов](http://davidwalsh.name/responsive-css) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Как переделать jQuery accordion на такой же, но на CSS3](http://www.script-tutorials.com/turn-jquery-accordion-into-css3-accordion/) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Sciter — встраиваемый HTML/CSS/scripting engine](http://habrahabr.ru/post/154697/)



  * [Готовим Sublime Text 2 для front-end](http://habrahabr.ru/post/154667/)



  * [SassCast](http://sasscast.tumblr.com/post/33342368483/in-this-episode-of-sasscast-we-sat-down-with-the) — подкаст, где ведущие разговаривают о Sass с Крисом Койером ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)










### ![](http://habrastorage.org/storage2/37d/ecd/fa7/37decdfa7563eab84a2a41fbf4690320.gif) CSS












  * [box-shadow vs. drop-shadow filter: полное сравнение](http://demosthenes.info/blog/598/boxshadow-property-vs-dropshadow-filter-a-complete-comparison) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Кнопки в Metro-стиле стиле Microsoft Windows 8 на CSS3](http://ace-subido.github.com/css3-microsoft-metro-buttons/index.html) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Ryan Seddon (css ninja) делится секретами работы с checkbox-ами](http://thecssninja.com/talks/ridiculous_checkboxes/) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [OOCSS + Sass = The best way to CSS](http://ianstormtaylor.com/oocss-plus-sass-is-the-best-way-to-css/) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Нестандартный подход к media queries](http://www.the-haystack.com/2012/10/17/nesting-media-queries/) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Flexbox – быстрый путь к раскладочному блаженству?](http://css-live.ru/articles/flexbox-bystryj-put-k-raskladochnomu-blazhenstvu.html)



  * [Загружаем изображения для ретина-дисплеев с помощью SCSS](http://37signals.com/svn/posts/3271-easy-retina-ready-images-using-scss) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Короткое видео на тему «Multiple Background Images with CSS»](http://blog.teamtreehouse.com/quick-tip-multiple-background-images-with-css) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Вращающееся меню на CSS](http://ruseller.com/lessons.php?rub=2&id=1563)










### ![](http://habrastorage.org/storage2/d72/076/bca/d72076bca6f7545c0633a6c4419d317c.gif) JavaScripts












  * [Pikaday](http://dbushell.com/2012/10/09/pikaday-javascript-datepicker/) — компонент для выбора даты ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [kwicks](http://devsmash.com/projects/kwicks) — симпатичный аккордеон ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [полезный апгрейд для табов на jQuery ui](http://jsfiddle.net/jasonday/fdhaS/embedded/result/)



  * [Учебник jQuery для начинающих](http://habrahabr.ru/post/155107/)



  * [Загрузчик модулей RequireJS](http://stepansuvorov.com/blog/2012/10/%D0%B7%D0%B0%D0%B3%D1%80%D1%83%D0%B7%D1%87%D0%B8%D0%BA-%D0%BC%D0%BE%D0%B4%D1%83%D0%BB%D0%B5%D0%B9-requirejs/)










### ![](http://habrastorage.org/storage2/7bc/3d0/d88/7bc3d0d883a49a00265feb7836c802aa.gif) Браузеры












  * [Предварительная версия IE10 для Windows 7 появится в середине ноября](http://viennaos.net/articles/3252-predvaritelnaya-versiya-interner-explorer-10-poyavitsya-v-seredine-noyabrya.html)



  * [Подробно о том, чего ожидать от нового IE10](http://www.mobilexweb.com/blog/windows-8-surface-ie10-html5), а также о том, [как в нем работает Responsive Design](http://timkadlec.com/2012/10/ie10-snap-mode-and-responsive-design/) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Internet Explorer для Xbox](http://habrahabr.ru/post/155073/)



  * [Проект Mozilla начал тестирование каталога приложений Firefox Marketplace для платформы Android](http://www.opennet.ru/opennews/art.shtml?num=35126)










### ![](http://habrastorage.org/storage2/63c/872/b21/63c872b219c18a3947a9d98a6bb6a345.gif) Новости












  * [Касперский работает над собственной ОС](http://eugene.kaspersky.ru/2012/10/16/secure-os-for-industrial-control-system-scada/)



  * [Apple приглашает на мероприятие, намеченное на 23 октября](http://www.overclockers.ru/hardnews/50140/Priglasheniya_na_meropriyatie_Apple_namechennoe_na_23_oktyabrya_uzhe_razoslany.html)



  * [IDCEE 2012 — день первый](http://habrahabr.ru/post/155337/)



  * [Названы победители конкурса стартапов на IDCEE-2012](http://ain.ua/2012/10/19/98741)



  * [В персональной поисковой выдаче Google появятся личные документы пользователя](http://habrahabr.ru/post/154949/)



  * [Google анонсировала новый Chromebook с чипом ARM по цене $249](http://itc.ua/news/google-anonsirovala-novyiy-chromebook-s-chipom-arm-po-tsene-249/)



  * [YouTube отказался от подсчета кликов для рейтинга популярности](http://habrahabr.ru/post/154671/)



  * [Google StreetView приглашает побродить в одном из их датацентров](http://gagadget.com/other/2012-10-18-google_streetview_priglashaet_pobrodit_v_odnom_iz_ikh_datatsentrov)



  * [Квартальный доход Microsoft достиг $16 млрд](http://itc.ua/news/kvartalnyiy-dohod-microsoft-dostig-16-mlrd/)



  * [Только ASUS и сама Microsoft осуществят 25 октября запуск планшетов Windows RT](http://www.3dnews.ru/news/636653/)



  * [Microsoft сообщила стоимость Surface RT на официальном сайте: от $500](http://habrahabr.ru/post/155001/), по итогам чего [младшая модель Surface была распродана за сутки](http://itc.ua/news/microsoft-rasprodala-po-predvaritelnyim-zakazam-vse-planshetyi-surface-rt-tsenoy-499/)



  * [Число одновременных пользователей Skype недавно превысило 45 млн](http://www.towave.ru/news/kolichestvo-polzovatelei-skype-prevysilo-45-mln-issledovanie.html)



  * [Проект Mozilla выпустил язык программирования Rust 0.4](http://www.opennet.ru/opennews/art.shtml?num=35097)










### ![](http://habrastorage.org/storage2/eb8/00e/9ef/eb800e9ef3b0e10e217087ef742628a3.gif) Сервисы












  * [Cacoo — сервис для создания диаграмм, вайрфреймов и т.д.](https://cacoo.com/) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [webink fontdropper — сервис-букмарклет, позволяющий применить к тексту любого сайту любой шрифт из целого набор библиотеки компании webink](http://www.webink.com/fontdropper) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Japonizer — генератор настраиваемых фоновых текстур в традиционном японском стиле](http://wanokoto.net/japonizes) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [sassmeister — песочница для работы с Sass](http://sassmeister.com/) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Сервис от Lea Verou для настройки контраста по стандартам WCAG 2.0](http://leaverou.github.com/contrast-ratio/) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)










### ![](http://habrastorage.org/storage2/eb8/00e/9ef/eb800e9ef3b0e10e217087ef742628a3.gif) Demo












  * [Atari перевели некоторые игры на HTML5](http://www.atari.com/arcade) и [как это происходило](http://youtu.be/J6QXRFuUSZs)










### ![](http://habrastorage.org/storage2/be5/3e4/256/be53e4256e771ad12bc412af8b30f91e.gif) Сайты с интересным дизайном и функциональностью












  * [Бодрый сайт-портфолио с простыми но эффектными анимационными переходами](http://www.worstprod.com/)



  * [exitzeroproject.org](http://www.exitzeroproject.org/) — современный сайт с нестандартной навигацией



  * [занимательный с любой точки зрения сайт](http://www.moma.org/interactives/exhibitions/2012/centuryofthechild/)



  * [woodwork.nl](http://woodwork.nl/) — сайт, где навигация выполнена в стиле sliding doors



  * [http://kikk.be/2012](http://kikk.be/2012/home.htm?lng=en/) — сайт для вестивая KIKK с симпатичным дизайном и интересной функциональностью










### ![](http://habrastorage.org/storage2/be5/3e4/256/be53e4256e771ad12bc412af8b30f91e.gif) Дизайн












  * [Evolution of Apple Ads 1975-2002](http://www.retronaut.co/2011/10/evolution-of-apple-ads-1975-2002/) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Скрытый смысл в действительно хороших логотипах](http://www.webdesignerdepot.com/2012/10/the-hidden-meaning-behind-really-good-logos/) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Mobile Design Details: Pull to Refresh](http://www.lukew.com/ff/entry.asp?1643) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Retro Style in Web Design](http://www.splashnology.com/article/retro-style-in-web-design/6771/) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Десять трюков для успешного создания меню в сайтах с адаптивным (responsive) дизайном](http://blog.usabilla.com/10-tips-how-to-handle-responsive-navigation-menus-successfully/) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Очень наглядный урок о создании бесшовной текстуры в фотошопе](http://www.proworks.com/blog/2012/10/18/how-to-create-a-seamless-pattern-in-photoshop/) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Создание в фотошопе 3D текста с креативным эффектом](http://www.webdesignfact.com/2012/10/photoshop-tutorial-3d-text-effects.html) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Создание разбалансированности: использование асимметрии в веб-дизайне](http://tympanus.net/codrops/2012/10/18/creating-off-center-balance-using-asymmetry-in-web-design/) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Новые техники кадрирования в фотошопе последней версии «Crop Until You Drop»](http://psd.tutsplus.com/tutorials/tools-tips/crop-until-you-drop/) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Тест на знание Photoshop CS6](http://psd.tutsplus.com/articles/quizzes/test-your-photoshop-cs6-knowledge-4/) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Техники UI при создании успешных цифровых продуктов](http://dzineblog.com/2012/10/user-interface-techniques-for-creating-successful-digital-products.html) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)










### ![](http://habrastorage.org/storage2/be5/3e4/256/be53e4256e771ad12bc412af8b30f91e.gif) Подборка бесплатных дизайнерских печенек












  * [Пять десятков шрифтов: от Sacred Place и до Kenyan Coffee](http://www.antsmagazine.com/fonts/50-fresh-free-fonts-for-download/) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Три с половиной десятка декоративных шрифтов: от Astonished в стиле гранж и до рукописного BudHand](http://www.1stwebdesigner.com/freebies/35-cool-free-fonts/) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Пакет из одиннадцати хэллоуниских шрифтов](http://www.pvmgarage.com/2012/10/11-free-creepy-halloween-fonts/) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Необычный декоративный шрифт без засечек Slinkster, в котором буквы создаются окружностями задающими форму](http://www.myfonts.com/fonts/will-ryan/slinkster/) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Исходники в PSD-формате различных вертикальных меню](http://designerves.com/article/free-vertical-menu-psd-files/) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [PSD с UI для веб-дизайна в золотых цветах с темным фоном](http://www.pixel-fabric.com/dark-gold-ui-kit-4) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Набор различных переключателей в PSD](http://www.graphicsfuel.com/2012/10/toggle-switches-ui-elements-psd/) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [За подписку предлагается пакет с iPhone UI темой для быстрого создания приложений](http://medialoot.com/item/free-iphone-app-template-appview/) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Хорошо структурированная 55Мб PSD-шка «iOS 6 iTunes & App Store GUI»](http://playground.christophebeghin.fr/ios6/) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Пакеты с Photoshop Actions для создания винтажных фото-эффектов](http://www.1stwebdesigner.com/freebies/40-free-photoshop-actions-vintage-effect/) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)










### ![](http://habrastorage.org/storage2/cc0/d6f/fe8/cc0d6ffe8d4e924a9bf96ab304d98fa0.gif) Занимательное












  * [Впечатляющая инфографика: Свежий взгляд на HTML5](http://www.script-tutorials.com/infographic-a-fresh-look-at-html5/) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Несколько интересных особенностей Windows 8](http://habrahabr.ru/post/155379/)



  * [Fronteers 2012 — лучшая конференция по клиентской разработке, часть 1](http://tohtml.it/post/33822898596/fronteers2012)



  * [diy.org — образовательный портал для детей и не только, которые хотят что либо сделать](https://diy.org/) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Подборка сервисов для расширения возможностей вашего Dropbox](http://habrahabr.ru/post/154993/)



  * [10 наиболее активных стран в Facebook](http://ain.ua/2012/10/16/98309)



  * [Акустический штрих-код прост и универсален](http://www.3dnews.ru/news/636640/)



  * [Три рекламных ролика ASUS PadFone 2](http://www.3dnews.ru/news/636704/)



  * [Уличная реклама Microsoft Surface появилась и во Франции — намёк на запуск в Европе](http://www.3dnews.ru/news/636600/)



  * [Internet Explorer 9 Commercial (Google Chrome Version) ](http://www.youtube.com/watch?v=J-HieaOI00s&feature=player_embedded)![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Видео дня: первая телевизионная реклама Microsoft Surface](http://wpos.com.ua/microsoft-zapuskaet-na-tv-novuyu-reklamu-microsoft-surface.html) и [первый рекламный ролик Windows 8](http://www.3dnews.ru/software-news/636608/)






  
  
[Ссылка](http://habrahabr.ru/company/zfort/blog/154633/) на дайджест за прошлую неделю.  
Материал подготовили [dersmoll](http://habrahabr.ru/users/dersmoll/) и [alekskorovin](http://habrahabr.ru/users/alekskorovin/)





Статья из сайта [habrahabr.ru](http://habrahabr.ru/company/zfort/blog/155431/)





От себя хочу выразить благодарность за такой труд.
Из последних новостей





Этим летом на выставке Google I/O была представлена новая консоль разработчика для магазина Google Play. Ранее она проходила этап закрытого тестирования совместно с несколькими разработчиками программ и игр, выбранными Google. Консоль имеет улучшенные возможности поиска и управления нужными данными, в том числе и статистикой загрузок, что позволит разработчикам быстрее реагировать на замечания пользователей и точнее отслеживать популярность своих программ. Со вчерашнего дня новая консоль доступна для всех разработчиков, имеющих аккаунт в магазине Google Play. Подробности доступны в [официальном блоге](http://android-developers.blogspot.com/2012/10/new-google-play-developer-console.html) для разработчиков.





Статья из сайта [android.com.ua](http://android.com.ua/development/18922-google-otkryla-novuyu-konsol-razrabotchikov-v-google-play-dlya-vsex-zhelayushhix.html)
Из последних новостей





Разработчики Google продолжают усовершенствовать свой магазин приложений Google Play. Теперь пользователи могут сохранять понравившиеся программы и игры в списке желаний.





![](http://android.com.ua/images/News/play-wishlist.jpg)

  <!-- more -->



Данная функция доступна в текущей актуальной версии 3.9.16 так, что Вам не придется ждать обновлений самого магазина.





Статья из сайта [android.com.ua](http://android.com.ua/android/18927-v-google-play-poyavilis-spiski-zhelanij.html)
Из последних новостей





Компания Google выпустила приложение Календарь, позволяющее синхронизировать события со своего аккаунта на мобильном устройстве. Программа доступна для обладателей смартфонов и планшетов с Android 4.0.3 и выше.





![](http://android.com.ua/images/News/google-calender-new-2.jpg) ![](http://android.com.ua/images/News/google-calender-new-3.jpg)


<!-- more -->


Сам календарь полностью аналогичный тому, который установлен на устройствах Nexus и предназначен скорее для обладателей смартфонов со сторонними оболочками. Загрузить Google Календарь можно на [сайте Google Play](https://play.google.com/store/apps/details?id=com.google.android.calendar).





![](http://chart.apis.google.com/chart?cht=qr&chs=150x150&chl=https://play.google.com/store/apps/details?id=com.google.android.calendar)





Статья из сайта [android.com.ua](http://android.com.ua/)
Новинка от разработчиков программ.





Музыка ВКонтакте.





С помощью данного плеера вы сможете слушать всю всю музыку из ВКонтакта... плейлисты, новости, стены, закладки, альбомы исполнителей и даже ласт.фм радио без подписки.





![](http://s.4pda.ru/wp-content/uploads/2012/09/logonewv4-480x234.png)


 <!-- more -->


**Версия:** 2.24





**Русский интерфейс:** да





**Технические требования: **Android 2.1 и выше





**Необходимы права root: **нет





**Установка на SD: **да





**Категория:** Программы, Музыка и аудио





В плеере есть возможность слушать музыку из всех привычных разделов ВКонтакте таких как: Аудиозаписи, стены, новости, закладки. Кроме этого плеер умеет сортировать аудиозаписи по исполнителям, альбомам и стилям. Понравившиеся аудиозаписи можно сохранить в оффлайн плейлист, добавить в плейлист ВКонтакте, добавить в любимые ласт.фм или кинуть на стену друга. В настройках можно включить ласт.фм скробблинг и уведомления в статус ВКонтакте.





![](http://s.4pda.ru/wp-content/uploads/2012/09/ed_jfttlgoa-288x480.jpg)
![](http://s.4pda.ru/wp-content/uploads/2012/09/gn2lbtlgtw4-288x480.jpg)





В меню радио можно найти разделы: wiki информация об исполнителе, текст текущей песни, поиск клипа в YouTube, фото галерея исполнителя, таймер.





**Возможности приложения:**








  * Плейлисы пользователей и групп ВКонтакте.



  * Аудиозаписи из новостей ВКонтакте.



  * Аудиозаписи из закладок ВКонтакте.



  * Аудиозаписи со стен пользователей и групп ВКонтакте.



  * Радио по исполнителям, пользователям ласт.фм и стилю.



  * Альбомы и списки аудиозаписей исполнителей и групп.



  * Скробблер ласт.фм и уведомления в статус ВКонтакте.



  * Сохранение аудиозаписей в собственный плейлист ВКонтакте.



  * Добавление в любимые аудиозаписи ласт.фм.



  * Сохранение песен в оффлайн список как в официальном приложении.



  * Отправка аудиозаписей на свою стену или стену друга.



  * Просмотр тестов песен и wiki страниц исполнителей.



  * Фото галерея исполнителей с возможностью сохранять на карту памяти.



  * Поиск клипов в YouTube.



  * Поиск и добавление текстов песен к своему плейлисту ВКонтакте.






**Стоимость программы:** бесплатно с рекламой, платная без рекламы в середине октября





**Обсуждение на 4pda:** [http://4pda.ru/forum/index.php?showtopic=307091](http://4pda.ru/forum/index.php?showtopic=307091)





**Ссылка на Google Play:** [https://play.google.com/store/apps/details?id=com.protoss5482.vlastnext](https://play.google.com/store/apps/details?id=com.protoss5482.vlastnext)





![](http://s.4pda.ru/wp-content/uploads/2012/09/5vrgyhygiqm-288x480.jpg)
![](http://s.4pda.ru/wp-content/uploads/2012/09/63ggfubfkjg-288x480.jpg)



![](http://s.4pda.ru/wp-content/uploads/2012/09/dt2zqn4hxys-288x480.jpg)
![](http://s.4pda.ru/wp-content/uploads/2012/09/86misvfbcuo-288x480.jpg)



![](http://s.4pda.ru/wp-content/uploads/2012/09/zcxkjku3rmg-288x480.jpg)
![](http://s.4pda.ru/wp-content/uploads/2012/09/s0mzmj0govs-288x480.jpg)





Статья из сайта [4pda.ru](http://4pda.ru/2012/10/15/73004/)
Продолжаю собирать программы для android.





Попадали ли вы в такую ситуацию, что во время разговора по мобильному телефону забывали о количестве своих бесплатных минут, в следствии чего тратили последние деньги? Приложение “Ваши бесплатные минуты” создано специально для того, чтобы экономить деньги на мобильном телефоне.





![](http://s.4pda.ru/wp-content/uploads/2012/10/unnamed5-480x234.jpg)


 <!-- more -->


**Версия: **1.0.0.2





**Русский интерфейс: **Нет





**Технические требования: **Android 2.1 и выше





**Поддержка установки на SD:** Нет





**Категория: **связь









Вам всего лишь нужно указать приложению количество бесплатных минут, которые предоставляет вам оператор мобильной связи на сутки, а также код этого оператора.





После ввода данной информации - приложение начнет считать потраченные вами бесплатные минуты во время исходящих звонков. Как только лимит минут будет подходить к критическому минимуму (меньше минуты) - телефон во время разговора подаст вам вибро-сигнал, который будет означать, что пора прекращать звонок.





Таким образом, вы имеете возможность скачать себе приложение, которое станет следить за экономией ваших денег при помощи уникальной системы оповещения. Пора забыть о случайной трате денег и нулевом балансе.





**Стоимость:** Содержит рекламу





**Обсуждение на 4pda:** [http://4pda.ru/forum/index.php?showtopic=387583](http://4pda.ru/forum/index.php?showtopic=387583)





**Ссылка на Google Play:** [https://play.google.com/store/apps/details?id=com.demian.android.happyminutes](https://play.google.com/store/apps/details?id=com.demian.android.happyminutes)





![](http://s.4pda.ru/wp-content/uploads/2012/10/shot_0000074-272x480.png)
![](http://s.4pda.ru/wp-content/uploads/2012/10/shot_000008-272x480.png)





![](http://s.4pda.ru/wp-content/uploads/2012/10/shot_000010-272x480.png)




Статья из сайта [4pda.ru](http://4pda.ru/2012/10/14/74711/)
Продолжаю собирать программы для android.





Твое мнение - это социальное приложение для создания голосований, которое поможет быстро узнать мнение всего мира, своей страны или друзей, используя критерии статистики: страна, город, пол, возраст, семейное положение и т.д.





![Разработчик:](http://s.4pda.ru/wp-content/uploads/2012/10/111-288x480.png)


<!-- more -->


**Версия: **1.0.2





**Русский интерфейс: **Нет





**Технические требования: **Android 2.2+





**Поддержка установки на SD:** Нет





**Категория:** социальные









Хочешь узнать мнение других или поделиться своим? Хочешь чтобы твое мнение узнал весь мир? Значит это приложение специально для тебя. Нужно принять решение или сделать выбор, а на раздумья всего сутки? Это приложение поможет тебе.





Твое мнение - это социальное приложение для создания голосований, которое поможет быстро узнать мнение всего мира, своей страны или друзей, используя критерии статистики: страна, город, пол, возраст, семейное положение и т.д.





Ключевые возможности:








  * создать вопрос используя одну из трех предложенных форм (Одиночная, Противопоставление, Множественная) в виде текста или изображения;



  * выбрать целевую аудиторию на которую задаешь вопрос: Мир, Страна, Друзья (Facebook, ВКонтакте);



  * каждый заданный вопрос автоматически переводится на Английский, Русский, Немецкий, Французский, Испанский, Китайский, Индийский, Украинский и доступен каждому пользователю на понятном языке.



  * просмотреть результаты голосования в текущий момент, а также более подробную статистику по странам, городам и критериям персональной информации пользователей;



  * вопросы задаваемые ранее всегда доступны в разделе "Архив";






**Стоимость:** Бесплатно





**Обсуждение на 4pda:** [http://4pda.ru/forum/index.php?showtopic=387787](http://4pda.ru/forum/index.php?showtopic=387787)





**Ссылка на Google Play:** [https://play.google.com/store/apps/details?id=com.ua.makeev.youropinion](https://play.google.com/store/apps/details?id=com.ua.makeev.youropinion)





![](http://s.4pda.ru/wp-content/uploads/2012/10/36-288x480.png)
![](http://s.4pda.ru/wp-content/uploads/2012/10/44-288x480.png)




![](http://s.4pda.ru/wp-content/uploads/2012/10/52-288x480.png)
![](http://s.4pda.ru/wp-content/uploads/2012/10/6-288x480.png)




![](http://s.4pda.ru/wp-content/uploads/2012/10/7-288x480.png)




Статья из сайта [4pda.ru](http://4pda.ru/2012/10/14/74652/)
Продолжаю собирать список из хороших программ.





Переводчик OneTapTranslator необходим для тех, кто занимается изучением иностранных языков, переводом текстов, чтением электронных книг или просто серфит в интернете. Вы сразу почувствуете легкость и удобство использования переводчика OneTap Translator, который буквально в одно касание переведет Вам текст в любом приложении.





![](http://s.4pda.ru/wp-content/uploads/2012/10/triple-480x256.png)

<!-- more -->


**Версия: **1.0.9





**Русский интерфейс: **Нет





**Технические требования: **Android 3.0 или выше





**Поддержка установки на SD:** Нет





**Категория:** Книги и справочники









Многие представленные на мобильном рынке переводчики не могут похвастаться своим качеством переводов, да и тем более удобством использования. Например пользователь читающий электронную книгу на английском языке, постоянно будет отвлекаться от содержания книги, переключаясь между читалкой и переводчиком, переводя каждое слово.





Для  быстрого и удобного перевода и было разработано приложение OneTap Translator, Вы сразу почувствуете легкость и удобство использования переводчика OneTap Translator, который буквально в одно касание переведет Вам текст в любом приложении, при этом не будет необходимости переключаться между приложением и каким-либо переводчиком.





Чтобы воспользоваться переводом, достаточно запустить приложение и оно уже готово к работе.





![](http://s.4pda.ru/wp-content/uploads/2012/10/s1.png)





Для перевода текста, просто скопируйте текст в любом приложении в буфер обмена и переводчик незамедлительно покажет вам перевод в виде всплывающего окна.





![](http://s.4pda.ru/wp-content/uploads/2012/10/s2-288x480.png)
![](http://s.4pda.ru/wp-content/uploads/2012/10/s3-288x480.png)




В главном окне приложения Вы сможете выбрать перевод более чем на 30 различных языков. Также приложение OneTap Translator поддерживает голосовое произношение переводимого текста, что очень удобно для изучения иностранных языков.





Для того чтобы закончить работу приложения, нажмите на кнопку "STOP".





Основные возможности:








  * Перевод в одно касание в любом приложении



  * Не нужно переключаться на программу переводчик



  * Возможность прослушивания переводимого текста



  * Приложение оптимизировано для работы на планшетах



  * Бесплатный пакет для перевода 500 слов (+10 слов каждый день)



  * Поддержка 34 языков: German, English, Estonian, Finnish, French, Dutch, Greek, Hebrew, Haitian Creole, Hungarian, Indonesian, Italian, Japanese, Korean, Lithuanian, Latvian, Norwegian, Polish, Portuguese, Romanian, Spanish, Russian, Slovak, Slovene, Swedish, Thai, Turkish, Ukrainian, Vietnamese, Simplified Chinese, Traditional Chinese, Arabic, Czech, Danish






Изучайте новые иностранные слова с OneTap Translator!





**Стоимость:** Бесплатно





**Ссылка на Google Play:** [https://play.google.com/store/apps/details?id=nikolotov.clipboardtrans](https://play.google.com/store/apps/details?id=nikolotov.clipboardtrans)





Статья из сайта [4pda.ru](http://4pda.ru/2012/10/13/74600/)
Еще одна интересная новость.





У зарубежного сайта Android Police оказался apk-файл новой версии почтового приложения для Android, Gmail 4.2. Возможно, apk был вытащен из дампа прошивки нового LG Optimus G Nexus, новости о котором будоражат Интернет практически каждый день в течение последних пары недель. Чего же нового нам ждать от обновлённого Gmail?





![](http://s.4pda.ru/wp-content/uploads/2012/10/gmail-4-2-1-270x480.jpg)

 <!-- more -->



В первую очередь, Google наконец-то прислушалась к многочисленным пожеланиям пользователей и реализовала функцию pinch-to-zoom для отдельных писем. Эта самая долгожданная функция Gmail набрала более 1600 отметок на[баг-трекере Android](http://code.google.com/p/android/issues/detail?id=15745). Её работу можно посмотреть на видео ниже:









Следующее немаловажное изменение касается появления функций "swipe to delete" и "swipe to archive". Первая, как нетрудно догадаться, удаляет письмо с помощью жеста swipe, а вторая - его архивирует. Настройки этой функции содержат три возможных варианта действий при свайпе: "ничего не делать", "удалять или архивировать", "всегда удалять". Если выбрать вторую функцию, то при нахождении в папке "Входящие" свайп будет архивировать письма, во всех остальных папках - удалять, а при просмотре сообщений с определённым тегом - удалять тег с сообщения.





![](http://s.4pda.ru/wp-content/uploads/2012/10/gmail-4-2-2-270x480.png)
![](http://s.4pda.ru/wp-content/uploads/2012/10/gmail-4-2-3-270x480.png)




![](http://s.4pda.ru/wp-content/uploads/2012/10/gmail-4-2-4-270x480.png)
![](http://s.4pda.ru/wp-content/uploads/2012/10/gmail-4-2-5-270x480.png)



Ну и последнее замеченное обновление - появление возможности сообщить о фишинге в письме, что позволит повысить безопасность обмена письмами.





![](http://s.4pda.ru/wp-content/uploads/2012/10/gmail-4-2-6-270x480.png)
![](http://s.4pda.ru/wp-content/uploads/2012/10/gmail-4-2-71-270x480.png)



Кроме того, ребята из Android Police сообщают, что пока не имеют права опубликовать apk-файл Gmail 4.2, но стараются получить разрешение. Работать новая версия сможет на любых устройствах начиная с версии Andoid 4.0 ICS. Мы обязательно сообщим вам о доступности приложения, если у журналистов получится решить этот вопрос.





Ждем с нетерпением.





Статья из сайта [4pda.ru](http://4pda.ru/2012/10/12/74478/)
Добрый день друзья.





Не мог я пройти мимо такого обновления в Play Market.





Ну, что посмотрим:





Сегодняшний день - просто день новостей об обновлениях нативных программ от Google. Мы рады вам сообщить, что приложение магазина Google для Android получило обновление до версии 3.9.16. Какими же новыми функциями сможет похвастаться обновлённый Google Play?





![](http://s.4pda.ru/wp-content/uploads/2012/10/google-play-5-270x480.jpg)

<!-- more -->


Главной новой функцией станет возможность удаления программ из списка ранее установленных приложений. Если вы любитель устанавливать множество различных программ "на пробу", то, несомненно, будете очень рады этой возможности. Теперь на вкладке "Все" раздела "Мои приложения" рядом с неустановленными приложениями появится значок его удаления из списка. Более того, можно удалять не по одному приложению, а с помощью мультивыбора, путём долгого удержания пальца на элементе списка.





![](http://s.4pda.ru/wp-content/uploads/2012/10/google-play-1-270x480.jpg)
![](http://s.4pda.ru/wp-content/uploads/2012/10/google-play-3-270x480.jpg)
![](http://s.4pda.ru/wp-content/uploads/2012/10/google-play-270x480.jpg)





Другим обновлением станет изменение сообщений в панели уведомлений об установке программ и доступности обновлений. Уведомление об обновлениях теперь будет расширямым, а иконка уведомления об установке новой программы теперь будет иконкой самого приложения. Примеры вы можете посмотреть на сриншотах ниже:





![](http://s.4pda.ru/wp-content/uploads/2012/10/google-play1-270x480.png)
![](http://s.4pda.ru/wp-content/uploads/2012/10/google-play-4-300x480.jpg)




Новая версия Google Play имеет размер 5,22 МБ и доступна для скачивания на нашем [форуме](http://4pda.ru/forum/index.php?showtopic=203803).





Статья из сайта [4pda.ru](http://4pda.ru/2012/10/13/74491/)
Продолжаю искать список полезных программ.





Как часто утром вы просыпались и хотели посмотреть значение сна.





Так вот я нашел такую программу.





Прошу к прочтению.


<!-- more -->


Сонники. Всегда под рукой - cборник из 18 сонников и более 10000 толкований снов. Удобная навигация по книге сновидений, голосовой поиск. Поиск сразу по нескольким сонникам.





![](http://s.4pda.ru/wp-content/uploads/2012/09/1024-480x234.png)




**Версия:** 1.0





**Русский интерфейс:** да





**Технические требования:** Android 2.1 и выше





**Особенности:** Голосовой и текстовый поиск сразу по нескольким сонникам.





**Необходимы права root?** нет





**Установка на SD поддерживается?** нет





**Категория**: Книги и справочники





****





Приложение содержит 18 сонников и 10000 толкований. Возможен выбор необходимого толкования из определенного сонника, а так же голосовой и текстовый поиск сразу по всем сонникам. Результаты выводятся в удобном виде.





![](http://s.4pda.ru/wp-content/uploads/2012/09/screen1.png)
![](http://s.4pda.ru/wp-content/uploads/2012/09/screen2.png)





![](http://s.4pda.ru/wp-content/uploads/2012/09/screen3.png)
![](http://s.4pda.ru/wp-content/uploads/2012/09/screen4.png)




**Стоимость программы:** Бесплатно





**Обсуждение на 4pda:** [http://4pda.ru/forum/index.php?showtopic=379872&st=0&gopid=15764945&#entry15764945](http://4pda.ru/forum/index.php?showtopic=379872&st=0&gopid=15764945&#entry15764945)





**Market / Store:** [https://play.google.com/store/apps/details?id=paltooz.dev.zzz](https://play.google.com/store/apps/details?id=paltooz.dev.zzz)





Статья взята из [4pda.ru](http://4pda.ru/2012/09/21/72056/#more-72056)





Если вам понравилось, жми мне нравиться ниже.
Думал, что можно посоветовать своим читателям и нашел.





Интернет большой и прочитать его целиком не получится при всем желании, ведь нужно хотя бы иногда вставать из-за компьютера. Но теперь, когда [Surfingbird.ru](http://goo.gl/AvrBD) выпустил долгожданное приложение для Android, весь Интернет можно взять с собой!





Surfingbird.ru помогает сделать серфинг по Интернету быстрым и удобным. Сервис показывает сайты, отобранные на основе интересов и предпочтений пользователя.





![](http://s.4pda.ru/wp-content/uploads/2012/10/screenshot_2012-09-28-16-52-41-480x299.png)


<!-- more -->


Для начала работы с сервисом необходимо зарегистрироваться или выполнить вход при помощи профиля в Facebook или Вконтакте.





![](http://s.4pda.ru/wp-content/uploads/2012/10/screenshot_2012-09-28-16-54-10-480x299.png)





Затем обязательно выбрать категории, которые тебе интересны: фото, гаджеты или дизайн.





![](http://s.4pda.ru/wp-content/uploads/2012/10/screenshot_2012-09-28-16-55-14-480x299.png)




Нажатие кнопки “Серф!” запускает показ страниц, отобранных персонально для тебя. Оценить или добавить в избранное позволяют кнопки, расположенные на панели сверху.





![](http://s.4pda.ru/wp-content/uploads/2012/10/screenshot_2012-09-28-17-00-32-480x299.png)





Обязательно оценивай показанный тебе контент — жми на кнопки “Нравится” и “Не нравится”. Есть даже возможность вносить отдельные домены и серферов в черные списки. Таким образом ты помогаешь рекомендательной системе лучше понять твои предпочтения.





Контент на сайт добавляют сами пользователи. В приложении также есть возможность добавить понравившуюся страницу, ролик или картинку.





На главной странице расположены кнопки, которые позволяют посмотреть, что добавили, оценили и внесли в избранное серферы, которых ты читаешь. Также с этой панели можно перейти в раздел “Популярное”, отредактировать список интересов и профиль пользователя.





![](http://s.4pda.ru/wp-content/uploads/2012/10/screenshot_2012-09-28-17-01-09-480x299.png)



Нижняя панель позволяет оставить комментарий, поделиться страницей в соцсетях или отправить ссылку по электронной почте. Здесь же можно включить серфинг по какой-то одной категории, домену или пользователю, а кликнув на фото сёрфера в левом нижнем углу страницы, можно зайти в его профиль и там же подписаться на него.





![](http://s.4pda.ru/wp-content/uploads/2012/10/screenshot_2012-09-28-17-02-36-480x299.png)





В целом, приложение получилось удобным и приятным глазу. Только аккуратнее — серфинг затягивает!





**Скачать его бесплатно можно из Google Play:** [https://play.google.com/store/apps/details?id=ru.surfingbird](http://goo.gl/92Wzm)





Статья взята [4pda.ru](http://4pda.ru/2012/10/01/73395/#more-73395)





Если вам понравилась статья, ставьте мне нравится!
Каждый из нас имеет множество записей у себя. 





Кто то пишет в блокнот, кто то в телефон, многие на руке :lol: .





Сегодня я расскажу вам о программе которую давно использую сам.


<!-- more -->


[Evernote](https://play.google.com/store/apps/details?id=com.evernote) – это не просто программа, это мобильное приложение популярного сервиса.





Что умеет делать эта программа:








  * Синхронизировать ваши записи (компьютер, телефон, интернет)



  * Сохранять фото



  * Записывать аудио



  * Совместное редактирование записей






  












Читать я не очень люблю. 





Но иногда просто от того, что нечем заняться я ищу книгу и начинаю читать.





В основном я читаю книги бизнес направления и программирования.


<!-- more -->


На Play Google есть очень много программ подобного рода. Но я остановился на программе [GoBook](https://play.google.com/store/apps/details?id=com.jb.gobook) не случайно.





Данная программа поддерживает все форматы для чтения. Что очень удобно.





Также, в этой программе есть много стилей для чтения. И каждый пользователь подберет для себя нужный.





Удачи вам и много прекрасного чтения!


















В предыдущем топике мы говорили о Skype. 





Сегодня же мы рассмотрим другую программу для звонков не только среди абонентов но и звонков как на мобильные так и на стационарные телефоны.


<!-- more -->


[Mobile Voip](https://play.google.com/store/apps/details?id=finarea.MobileVoip) – мобильная программа которая в основе своей использует SIP связь.





Что делает ее более универсальной чем Skype.





У меня эта программа настроена на SIP сервис от [JustVoip](http://www.justvoip.com/).





Почему именно эта программа? А все очень просто. У меня много друзей и знакомых во всем мире.





А этот сервис позволяет звонить моим друзьям абсолютно бесплатно.
















Все давно знают о такой программе как [Skype](https://play.google.com/store/apps/details?id=com.skype.raider). 





И действительно, это наиболее дешевый способ общения между пользователями. Тем более что Wi-Fi интернет сейчас практически в любом городе.





Описывать ее нету смысла.





Единственное что могу добавить. Видео звонки идут не на всех телефонах.







Добрый день уважаемые подписчики и гости сайта.





Сегодня мы с вами продолжим осмотр нужных программ для вашего Android устройства.


<!-- more -->


Программа которую мы с вами сегодня осмотрим это Dropbox.






Эта программа относится к мобильной версии своей системы программ.





Вкратце я только могу сказать, что это программа которая синхронизирует все файлы которые у вас на компьютере с телефоном и интернет.





Дополнительно об использовании данной программы вы можете посмотреть на сайте разработчика.







Оставайтесь на связи с друзьями с помощью приложения Facebook для Android.





Facebook для Android позволяет Вам оставаться на связи и обмениваться информацией с друзьями на ходу.





Загружайте фотографии, просматривайте новые фотографии и статусы друзей, находите номера телефонов и многое другое с помощью Вашего устройства Android.




















Описание с маркета
Официальное приложение [ВКонтакте.](https://play.google.com/store/apps/details?id=com.vkontakte.android)





Предоставляет удобный доступ к функционалу социальной сети.


<!-- more -->


В последней версии доступно:








  * Новости и друзья



  * Публикация записей и фотографий



  * Личные сообщения и групповые беседы



  * Аудиозаписи



  * Просмотр профилей



  * Фотоальбомы



  * Синхронизация контактов с вашим устройством



  * Виджеты


















 Описание с маркета
Еще раз всем привет.





Следующая программа из нашей рубрики - [Advanced Task Manager](https://play.google.com/store/apps/details?id=mobi.infolife.taskmanager&feature=search_result#?t=W251bGwsMSwxLDEsIm1vYmkuaW5mb2xpZmUudGFza21hbmFnZXIiXQ..)





Вы меня спросите почему я пользуюсь ею.


<!-- more -->


На этот вопрос у меня есть несколько ответов:








  1. Экономия батареи



  2. Выгрузка не нужных сервисов из памяти телефона (высокая отзывчивость даже слабых телефонов)



  3. Удобный виджет



  4. Удаление программ


И так, что же это за программа такая.





Как вы уже наверное могли догадаться, то эта программа полностью управляет всеми процессами вашего устройства.





С ее помощью вы можете:








  * удалить процесс из памяти



  * удалить приложение



  * поставить авто-очистку памяти



  * и с помощью виджета, одним нажатием освободить память от всех не нужных программ






**Рекомендую!**




Добрый день друзья.





Сегодня я решил начать серию обзоров тех программ и сервисов которые использую сам.





Почта от Google - GMail


<!-- more -->


Описание из [маркета](https://play.google.com/store/apps/details?id=com.google.android.gm&feature=more_from_developer#?t=W251bGwsMSwxLDEwMiwiY29tLmdvb2dsZS5hbmRyb2lkLmdtIl0.)





Непрерывное общение – где бы вы ни были





Благодаря Gmail работа с электронной почтой становится простой, эффективной, удобной и увлекательной. Мгновенно узнавайте о новых письмах через push-оповещения, используйте поиск по почтовому ящику, читайте письма и отвечайте на них онлайн или офлайн. Также с помощью Gmail вы можете:





* управлять несколькими аккаунтами;  
* просматривать и сохранять прикрепленные файлы;  
* настраивать оповещения по ярлыкам.














![](https://lh5.ggpht.com/15MY570cV3b978U5iisVQ6tM09ovoBqFY56KHghaux_IFVuBTj5Bwe384QQOLSOHXFw)



![](https://lh4.ggpht.com/grRqkwldr-cG3qqHTbbVTpBGzYbgc5WCcJ5JXHPddM3gtyMJM12Sjnezg-pfEjoClQ)




![](https://lh3.ggpht.com/3e_BFCuySxuePjIXEMQ4v7YhmWY68bD5p8sm51fAef21a_HJIfH3odWAP8nyHZUa7wRT)



![](https://lh6.ggpht.com/x57TlTPwemv1mBjFtT3B76qU3YiwHi12yTuXVjZ5C3iGuiHbGbahXCnzgJ496-MHmkzV)










Эта программа установлена по умолчанию на всех android устройствах.





Вместе с этой программой вы получаете замену Skype и ICQ - GTalk.





C помощью, этой программы вы можете вести переписку или говорить голосом со своими друзьями у которых тоже стоит такая же программа.





Большой плюс этой программы в том, что она не загружает память устройства как программы аналоги.





А она полностью интегрирована в систему.





Пользуюсь сам и рекомендую вам.
</li>&ndash;&gt;-->
    <!--&lt;!&ndash;&ndash;&gt;-->
    <!--&lt;!&ndash;<li>Android для начинающихДрузья всем привет.

Я очень рад, что некоторые из ребят в коучинге пишут замечательные топики!

Вот с какой проблемой мы столкнулись в коучинге и как ее решали!

<!-- more -->


В процессе коучинга, создавая своё первое приложение - калькулятор, научился использовать кастомные шрифты. Спешу безвозмездно поделиться своим опытом!

**Какие шрифты подходят?**

Можно использовать шрифты TrueType (TTF)

**Куда положить шрифт?**

В корневой директории (на одном уровне с директориями java и res и файлом AndroidManifest.xml) создать папку assets, а внутри неё можно создать отдельную папку для шрифтов fonts
В эту папку бросить свой файл со шрифтом Custom.ttf

**Как Android узнает, где находятся кастомные шрифты?**

В файле **<project_name>.iml** в разделе configuration необходимо добавить строчку

	<configuration>
	...
	<option name="ASSETS_FOLDER_RELATIVE_PATH" value="/src/	main/assets" />
	</configuration>

а в файле **res/values/strings.xml** - строчку

	<string name="digit_keyboard_font">fonts/Custom.ttf</string>

**Как назначить шрифт своим View-элементам?**

Теперь в коде, в методе onCreate можно использовать свой шрифт. Обратите внимание на код, в котором скрывается первая секретная фишка!

	Typeface keys = Typeface.createFromAsset(getAssets(), 	getString(R.string.digit_keyboard_font));
	TextView key = (TextView)findViewById(R.id.button_about_ok);
	key.setTypeface(keys);


Как видите, таким способом можно применить шрифт к надписям на кнопках и других **View**, которые можно явно привести типу **TextView**.


Ещё одна супер-полезная и очень секретная фишка
Допустим, требуется применить шрифт к группе элементов, которые располагаются в layout-файле внутри корневого элемента типа **ViewGroup** с присвоенным ему уникальным **id**


	<LinearLayout
    android:id="@+id/digit_keyboard_layout"
    android:layout_width="wrap_content"
    android:layout_height="match_parent"
    android:layout_gravity="center_horizontal"
    android:orientation="vertical">

    <TableLayout
        android:id="@+id/table1"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content">

        <TableRow
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_weight="3">

            <Button
                android:id="@+id/button_one"
                style="@style/calc_button_style"
                android:layout_width="@dimen/button_width"
                android:text="@string/one"
                android:layout_alignParentStart="false"
                android:layout_alignParentEnd="false"
                android:layout_weight="1"/>

            <Button
                android:id="@+id/button_two"
                style="@style/calc_button_style"
                android:layout_width="@dimen/button_width"
                android:text="@string/two"
                android:layout_weight="1"/>

            <Button
                android:id="@+id/button_three"
                android:text="@string/three"
                style="@style/calc_button_style"
                android:layout_width="@dimen/button_width"
                android:layout_weight="1"
                />
        </TableRow>
    </TableLayout>
	</LinearLayout>


Используйте в коде приложения вот такой метод


	// Sets the font on all TextViews in the ViewGroup.
    public void setFont(ViewGroup group, Typeface font) {
        int count = group.getChildCount();
        View v;
        for(int i = 0; i < count; i++) {
            v = group.getChildAt(i);
            if(v instanceof TextView) {
                ((TextView)v).setTypeface(font);
            } else if(v instanceof ViewGroup) {
                setFont((ViewGroup) v, font);
            }
        }
    }

Метод рекурсивно вызывает сам себя пока не доберётся до нужного элемента в любой сложной xml-структуре **layout**. 

Вызывая этот метод устанавливаем шрифт группе элементов.

	Typeface keys = Typeface.createFromAsset(getAssets(), 	getString(R.string.digit_keyboard_font));
	ViewGroup keyboardArea = (ViewGroup)findViewById(R.id.digit_keyboard_layout);
	setFont(keyboardArea, keys);

У кого есть какие то наработки или идеи, пишите в комментариях. Мы обязательно добавим статью на блог!

Жду ваших комментариев!Добрый день друзья.
Сегодня наша статья будет полезна не только гуру android программирования, но и тем кто только стал на этот не легкий тернистый путь.

Сегодня мы поговорим о том как с помощь Intent намерений можно выполнять самые различные операции.

Ну что поехали?

<!-- more -->

**Открыть браузер**

	Uri uri = Uri.parse("http://www.google.com");
	Intent it  = new Intent(Intent.ACTION_VIEW,uri);
	startActivity(it);

**Открыть карту с координатами**

	Uri uri = Uri.parse("geo:38.899533,-77.036476");
	Intent it = new Intent(Intent.Action_VIEW,uri);
	startActivity(it); 

**Показать путь**

	Uri uri = Uri.parse("http://maps.google.com/maps?f=d&saddr=startLat%20startLng&daddr=endLat%20endLng&hl=en");
	Intent it = new Intent(Intent.ACTION_VIEW,URI);
	startActivity(it);

**Позвонить с программы**

	Uri uri = Uri.parse("tel:xxxxxx");
	Intent it = new Intent(Intent.ACTION_DIAL, uri);  
	startActivity(it);  

	Uri uri = Uri.parse("tel.xxxxxx");
	Intent it =new Intent(Intent.ACTION_CALL,uri);

Не забудьте добавить разрешение в манифесте.

	<uses-permission id="android.permission.CALL_PHONE" />

**Отправка сообщения с помощью встроенной программы**

	Intent it = new Intent(Intent.ACTION_VIEW);   
	it.putExtra("sms_body", "The SMS text");   
	it.setType("vnd.android-dir/mms-sms");   
	startActivity(it);  

**Отправка сообщения на номер телефона**

	Uri uri = Uri.parse("smsto:0800000123");   
	Intent it = new Intent(Intent.ACTION_SENDTO, uri);   
	it.putExtra("sms_body", "The SMS text");   
	startActivity(it);  

**Отправка MMS**

	Uri uri = Uri.parse("content://media/external/images/media/23");   
	Intent it = new Intent(Intent.ACTION_SEND);   
	it.putExtra("sms_body", "some text");   
	it.putExtra(Intent.EXTRA_STREAM, uri);   
	it.setType("image/png");   
	startActivity(it); 

**Отправка почты**
 
	Uri uri = Uri.parse("mailto:xxx@abc.com");
	Intent it = new Intent(Intent.ACTION_SENDTO, uri);
	startActivity(it);

	Intent it = new Intent(Intent.ACTION_SEND);   
	it.putExtra(Intent.EXTRA_EMAIL, "me@abc.com");   
	it.putExtra(Intent.EXTRA_TEXT, "The email body text");   
	it.setType("text/plain");   
	startActivity(Intent.createChooser(it, "Choose Email Client"));  

	Intent it=new Intent(Intent.ACTION_SEND);     
	String[] tos={"me@abc.com"};     
	String[] ccs={"you@abc.com"};     
	it.putExtra(Intent.EXTRA_EMAIL, tos);     
	it.putExtra(Intent.EXTRA_CC, ccs);     
	it.putExtra(Intent.EXTRA_TEXT, "The email body text");     
	it.putExtra(Intent.EXTRA_SUBJECT, "The email subject text");     
	it.setType("message/rfc822");     
	startActivity(Intent.createChooser(it, "Choose Email Client"));   


**Добавление файлов**

	Intent it = new Intent(Intent.ACTION_SEND);   
	it.putExtra(Intent.EXTRA_SUBJECT, "The email subject text");   
	it.putExtra(Intent.EXTRA_STREAM, "file:///sdcard/mysong.mp3");   
	sendIntent.setType("audio/mp3");   
	startActivity(Intent.createChooser(it, "Choose Email Client"));

**Проигрывание музыки**

	Intent it = new Intent(Intent.ACTION_VIEW);
	Uri uri = Uri.parse("file:///sdcard/song.mp3");
	it.setDataAndType(uri, "audio/mp3");
	startActivity(it);

	Uri uri = Uri.withAppendedPath(MediaStore.Audio.Media.INTERNAL_CONTENT_URI, "1");   
	Intent it = new Intent(Intent.ACTION_VIEW, uri);   
	startActivity(it);  

**Удаление программы**

	Uri uri = Uri.fromParts("package", strPackageName, null);   
	Intent it = new Intent(Intent.ACTION_DELETE, uri);   
	startActivity(it);

	Uri uninstallUri = Uri.fromParts("package", "xxx", null);
	returnIt = new Intent(Intent.ACTION_DELETE, uninstallUri);

**Установка программы**

	Uri installUri = Uri.fromParts("package", "xxx", null);
	returnIt = new Intent(Intent.ACTION_PACKAGE_ADDED, installUri);

**Поиск на маркете**

	Uri uri = Uri.parse("market://search?q=pname:pkg_name");  
	Intent it = new Intent(Intent.ACTION_VIEW, uri);  
	startActivity(it);  


**Показать детали программы**

	Uri uri = Uri.parse("market://details?id=app_id");  
	Intent it = new Intent(Intent.ACTION_VIEW, uri);  
	startActivity(it);  

**Поиск в Google**

	Intent intent = new Intent();
	intent.setAction(Intent.ACTION_WEB_SEARCH);
	intent.putExtra(SearchManager.QUERY,"searchString")
	startActivity(intent);


Ну вот и все, расскажи своим друзьям. Нажимай лайки и пиши свои комментарии.В этой статье я расскажу как как установить среду разработки Android используя Android Studio и Genymotion. При переходе от Eclispe/ADT к Android Studio я исследовал альтернативные конфигурации для улучшения сборочной среды. Нашел неплохой эмулятор Genymotion. Интересный, довольно быстрый и очень простой.





**Что нам нужно?**




<!-- more -->



  * [Android Studio](http://android-helper.com.ua/android-studio/)



  * [Oracle VM VirtualBox](https://www.virtualbox.org/wiki/Downloads)



  * [Genymotion Android emulator](http://www.genymotion.com/)



  * [Genymotion Android studio plugin](http://www.genymotion.com/)






**Установка Oracle VM VirtualBox** Если вы используете Windows в загруженном вами пакете будет все необходимое, в противном случае вам нужно будет скачать и установить ее самостоятельно. Процесс простой и прямолинейный но эти действия необходимо выполнить иначе Android Emulator не запуститься.





**Установка Genymotion Android device emulator** Первое что нужно это сделать создать аккаунт, чтобы иметь возможность скачать эмулятор. Вы можете выбирать среди платформ, в моем случае это Mac OS X. Когда вы его скачали и установили у вас должно получиться что-то такое:



![Genymotion Android device emulator](https://lh4.googleusercontent.com/-XTLtY_Lu-uo/UdZ1ohxTDpI/AAAAAAAAIxU/UHNpDYatWSE/w878-h549-no/emulator1.png)  
  
Genymotion Android device emulator



У вас может быть доступно множество эмуляторов. Вы выбираете и грузите его с сети. Как результат у вас готовый эмулятор.



![Genymotion Android device emulator](https://lh3.googleusercontent.com/-bSICk3KwvT0/UdZ1oresDZI/AAAAAAAAIxE/VXQYFWzmdBs/w878-h549-no/emulator2.png)  
  
Genymotion Android device emulator



**Установка Android Studio Plugin** Чтобы интегрировать средство разработки с эмулятором вам необходимо установить плагин для Android Studio. Зайдите в Preferences там Plugin, выбираем нужный нам. Добавляем плагин который мы уже скачали и видим:



![Genymotion Android Studio Plugin](https://lh3.googleusercontent.com/-7ESa9bvI8oY/UdZ1ouyWdyI/AAAAAAAAIxQ/cod9TPdH1Qc/w878-h549-no/emulator3.png)  
  
Genymotion Android Studio Plugin



**Результат**





Теперь вы можете запустить Android проект и вы увидите:



![Genymotion Android Studio Plugin](https://lh4.googleusercontent.com/-pu_27RpWvZI/UdZ1pYXK1xI/AAAAAAAAIxM/qk4W1XYDUw4/w878-h549-no/emulator4_1.png)  
  
Genymotion Android Studio Plugin



Эмулятор полностью интегрирован в вашу среду разработки . Первый раз когда вы запустите эмулятор вы можете увидеть диалог который спросит путь к Android SDK:



![Genymotion Android Studio Plugin](https://lh3.googleusercontent.com/-kJdXolrj9RQ/UdZ1pOHCHFI/AAAAAAAAIxI/L8cSs1wTSNk/w878-h549-no/emulator4.png)  
  
Genymotion Android Studio Plugin



Как-только все настроено можно запускать свой проект. ![Genymotion Android Studio Plugin](https://lh4.googleusercontent.com/-vvfjkEI4RRw/UdZ1ph1p7II/AAAAAAAAIxc/n31dDQvUqj4/w878-h549-no/emulator5.png)





**Видео**



{% youtube 63T-8YRlFmE %}





Надеюсь статья была для вас полезной. Если да нажимайте рассказать друзьям :)
Всем привет.





За этих 2 дня мы посомтрели очень много полезной информации.





Сегодня же стартует не менее важная презентация.


<!-- more -->




**Google I/O Pitch Night**





Что вы можете тут взять для себя?





Как делать стартапы и правильно их презентовать.





Ну что смотрим?


{% youtube 9yZ6KpZ6y44 %}

Срочно!





Все трансляции в одном месте!<!-- more -->





**Google I/O 2013: Day 2 Android Sessions**





**Google I/O 2013 Technical Sessions 2**





**Google I/O 2013 Chrome Sessions**




{% youtube hXPAXKb-LQE %}Всем привет.





Сегодня стартует очень популярная конференция **Google I/O 2013**.





И наш сайт ведет онлайн трансляцию.



 <!-- more -->

Что будет и сама трансляция








  * на ней будет представлена новая версия операционной системы Android 4.3



  * новые планшеты семейства Nexus



  * умные очки Google Glass






**Онлайн трансляция:**


{% youtube 9pmPa_KxsAM %}






Расскажите друзьям.
> 


> 
> Привет друзья. Я очень рад, приветствовать вас на нашем блоге. Сегодня мы рассмотрим следующую задачу.
> 
> 







### Задача





Нужно сделать вывод сообщения поверх ActionBar.


 <!-- more -->

![device-2013-05-03-234631](http://android-helper.com.ua/images/uploads/2013/05/device-2013-05-03-234631.png)]
![device-2013-05-03-234636](http://android-helper.com.ua/images/uploads/2013/05/device-2013-05-03-234636.png)
![device-2013-05-03-234643](http://android-helper.com.ua/images/uploads/2013/05/device-2013-05-03-234643.png)
![device-2013-05-03-234657](http://android-helper.com.ua/images/uploads/2013/05/device-2013-05-03-234657.png)




### Краткое описание





И так наша задача вывести нотификацию поверх ActionBar. Ну скажем это одно из требований дизайна и заказчика.





### Видео


{% youtube xIuhouqkX8E %}






### Коды для реализации





**MainActivity.java**




    
    @Override
    
    public void onCreate(Bundle savedInstanceState) {
    
        super.onCreate(savedInstanceState);
    
        ActionBar actionBar = getActionBar();
    
        actionBar.setDisplayOptions(ActionBar.DISPLAY_SHOW_HOME
    
                | ActionBar.DISPLAY_SHOW_TITLE | ActionBar.DISPLAY_SHOW_CUSTOM);
    
    
    
        setContentView(R.layout.main);
    
    
    
        prepareNotificationBar();
    
    
    
        initButtons();
    
    }
    
    
    
    private void prepareNotificationBar() {
    
        android.view.Window window = getWindow();
    
    
    
        // Получаем полное строенние вашего приложения
    
        ViewGroup decor = (ViewGroup) window.getDecorView();
    
        // Берем первый элемент, это то что было построенно
    
        View allcontent = decor.getChildAt(0);
    
        // Удаляем его что бы очистить строение
    
        decor.removeView(allcontent);
    
    
    
        LayoutInflater li = getLayoutInflater();
    
        // загружаем части элементов
    
        FrameLayout main = (FrameLayout) li.inflate(R.layout.content_frame, null);
    
        FrameLayout notificationFrame = (FrameLayout) li.inflate(R.layout.notification_frame, null);
    
        // находим нужные нам фреймы
    
        notificationBar = (ViewGroup) main.findViewById(R.id.notificationLayout);
    
        content = (ViewGroup) main.findViewById(R.id.contentLayout);
    
    
    
        // ВАЖНО! получаем высоту статус бара
    
        // -----
    
        int resourceId = getResources().getIdentifier("status_bar_height", "dimen", "android");
    
    
    
        statusBarHeight = 0;
    
    
    
        if (resourceId > 0) {
    
            statusBarHeight = getResources().getDimensionPixelSize(resourceId);
    
        }
    
        // -----
    
    
    
        // Сдвигаем наши фреймы на высоту статус бара
    
        notificationBar.setPadding(notificationBar.getPaddingLeft(), statusBarHeight, notificationBar.getPaddingRight(),
    
                0);
    
        notificationBar.addView(notificationFrame);
    
    
    
        content.setPadding(content.getPaddingLeft(), statusBarHeight, content.getPaddingRight(),
    
                0);
    
    
    
        // добавляем фреймы
    
        content.addView(allcontent);
    
        decor.addView(main);
    
    }
    
    







### Скачать коды





Скачать коды программы вы можете на нашей [странице](http://android-helper.com.ua/codes/)





### Скачать приложение





Также мы выложили на [Play Market](https://play.google.com/store/apps/details?id=com.android_helper.ActionBarNotification) наше приложение. Установив его, вы сможете посмотреть как оно работает. (Не забудьте поставить +1 и написать позитивный комментарий :) ).





[![Android app on Google Play](https://developer.android.com/images/brand/en_app_rgb_wo_45.png)](https://play.google.com/store/apps/details?id=com.android_helper.ActionBarNotification)





### Оценка статьи





Надеюсь, что вам понравилась статья. Жду ваши комментарии и несколько лайков.
### Задача





Красочный переход между Activity.


 <!-- more -->


### Краткое описание





Многие из вас видели как красиво в некоторых приложениях идут переходы между Activity. Если взять простые примеры от Google, то вы увидите только плавное смещение с лева на право. А у нас с вами задача сделать так, что бы из первого Activity появлялось второе.





### Видео урок



{% youtube Bfh0cJBOASQ %}





### Коды





**Activity1.java**




    
    	SplitAnimation.startActivity(Activity1.this, new Intent(Activity1.this, Activity2.class));





**Activity2.java**




    
    
		@Override
    
    protected void onCreate(Bundle savedInstanceState) {
    
        super.onCreate(savedInstanceState);
    
    
    
        // Preparing the 2 images to be split
    
        SplitAnimation.prepareAnimation(this);
    
    
    
        setContentView(R.layout.act_two);
    
    
    
        // Animating the items to be open, revealing the new activity
    
        SplitAnimation.animate(this, 1000);
    
    }
    
    
    
    @Override
    
    protected void onStop() {
    
        // If we're currently running the entrance animation - cancel it
    
        SplitAnimation.cancel();
    
    
    
        super.onStop();    //To change body of overridden methods use File | Settings | File Templates.
    
    }
    
    



**SplitAnimation.java**




    
    	public static void startActivity(Activity currActivity, Intent intent) {
    
        // Подготовка acticity
    
        prepare(currActivity);
    
    
    
        currActivity.startActivity(intent);
    
        // Чистка анимаций текущей activity
    
        currActivity.overridePendingTransition(0, 0);
    
    }
    
    
    
    private static void prepare(Activity currActivity) {
    
    
    
        // Получаем content activity и делаем из него bitmap
    
        View root = currActivity.getWindow().getDecorView().findViewById(android.R.id.content);
    
        root.setDrawingCacheEnabled(true);
    
        Bitmap bmp = root.getDrawingCache();
    
    
    
        // Указываем в какой части экрана будет делится activity
    
        splitYCoord = bmp.getHeight() / 2;
    
    
    
        // Разделяем экран
    
        mBmp1 = Bitmap.createBitmap(bmp, 0, 0, bmp.getWidth(), splitYCoord);
    
        mBmp2 = Bitmap.createBitmap(bmp, 0, splitYCoord, bmp.getWidth(), bmp.getHeight() - splitYCoord);
    
    
    
        // Указываем координаты положения частей activity
    
        mLoc1 = new int[]{0, root.getTop()};
    
        mLoc2 = new int[]{0, root.getTop() + splitYCoord};
    
    }
    
    
    
    public static void prepareAnimation(final Activity destActivity) {
    
        mTopImage = createImageView(destActivity, mBmp1, mLoc1);
    
        mBottomImage = createImageView(destActivity, mBmp2, mLoc2);
    
    }
    
    
    
    private static ImageView createImageView(Activity destActivity, Bitmap bmp, int loc[]) {
    
        ImageView imageView = new ImageView(destActivity);
    
        imageView.setImageBitmap(bmp);
    
    
    
        WindowManager.LayoutParams windowParams = new WindowManager.LayoutParams();
    
        windowParams.gravity = Gravity.TOP;
    
        windowParams.x = loc[0];
    
        windowParams.y = loc[1];
    
        windowParams.height = ViewGroup.LayoutParams.WRAP_CONTENT;
    
        windowParams.width = ViewGroup.LayoutParams.WRAP_CONTENT;
    
        windowParams.flags =
    
                WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN
    
        ;
    
        windowParams.format = PixelFormat.TRANSLUCENT;
    
        windowParams.windowAnimations = 0;
    
        destActivity.getWindowManager().addView(imageView, windowParams);
    
    
    
        return imageView;
    
    }
    
    
    
    public static void animate(final Activity destActivity, final int duration) {
    
        animate(destActivity, duration, new DecelerateInterpolator());
    
    }
    
    
    
    public static void animate(final Activity destActivity, final int duration, final TimeInterpolator interpolator) {
    
    
    
        // Post this on the UI thread's message queue. It's needed for the items to be already measured
    
        new Handler().post(new Runnable() {
    
    
    
            @Override
    
            public void run() {
    
                mSetAnim = new AnimatorSet();
    
                mTopImage.setLayerType(View.LAYER_TYPE_HARDWARE, null);
    
                mBottomImage.setLayerType(View.LAYER_TYPE_HARDWARE, null);
    
                mSetAnim.addListener(new Animator.AnimatorListener() {
    
                    @Override
    
                    public void onAnimationStart(Animator animation) {
    
                    }
    
    
    
                    @Override
    
                    public void onAnimationEnd(Animator animation) {
    
                        clean(destActivity);
    
                    }
    
    
    
                    @Override
    
                    public void onAnimationCancel(Animator animation) {
    
                        clean(destActivity);
    
                    }
    
    
    
                    @Override
    
                    public void onAnimationRepeat(Animator animation) {
    
    
    
                    }
    
                });
    
    
    
                // Animating the 2 parts away from each other
    
                Animator anim1 = ObjectAnimator.ofFloat(mTopImage, "translationY", mTopImage.getHeight() * -1);
    
                Animator anim2 = ObjectAnimator.ofFloat(mBottomImage, "translationY", mBottomImage.getHeight());
    
    
    
                if (interpolator != null) {
    
                    anim1.setInterpolator(interpolator);
    
                    anim2.setInterpolator(interpolator);
    
                }
    
    
    
                mSetAnim.setDuration(duration);
    
                mSetAnim.playTogether(anim1, anim2);
    
                mSetAnim.start();
    
            }
    
        });
    
    }
    


### Скачать коды





Скачать коды программы вы можете на нашей [странице](http://android-helper.com.ua/codes/)





### Скачать приложение





Также мы выложили на [Play Market](https://play.google.com/store/apps/details?id=com.android_helper.SplitActivityAnimation) наше приложение. Установив его, вы сможете посмотреть как оно работает. (Не забудьте поставить +1 и написать позитивный комментарий :) ).





[![Android app on Google Play](https://developer.android.com/images/brand/en_app_rgb_wo_45.png)](https://play.google.com/store/apps/details?id=com.android_helper.SplitActivityAnimation)





### Оценка статьи





Надеюсь, что вам понравилась статья. Жду ваши комментарии и несколько лайков.




Добрый день.





14 выпуск передачи — Программирование под андроид.





Сегодня в уроке : Добавление звука на Splashscreen 


<!-- more -->


Смотрим, учимся, рассказываем друзьям.

{% youtube mOs_M8_Tyks %}


Добрый день.





13 выпуск передачи — Программирование под андроид.





Сегодня в уроке : жизненный цикл activity.


<!-- more -->


Смотрим, учимся, рассказываем друзьям.


{% youtube IL5APBsiaIQ %}

Добрый день друзья.





12 выпуск передачи - Программирование под андроид.


<!-- more -->


Смотрим, учимся, рассказываем друзьям.


{% youtube tYVErdtRY9o %}

Всем привет.





Один из моих читателей попросил написать, как можно сделать картинку на весь экран.





Я думаю, что он хочет сделать скажем так splashscreen.



 <!-- more -->

Если же нет, то тогда и он и все остальные новички, смогут увидеть эту реализацию.





Смотрим уроки и комментируем.


{% youtube nMnGGQ-M1YQ %}

{% youtube zrrH7VpDfrw %}

{% youtube -OkikdXA4y8 %}














Рассказывайте друзьям!
Всем привет.





Сегодня один из моих читателей попросил написать статью как можно изменять цвет елементам.





В своем примере я покажу, как можно менять цвет выбранной кнопки.




 <!-- more -->




А теперь части кода:





**colors.xml**





	<color name="widget_button_pressed">#FFFF00</color>

	<color name="widget_button">#00000000</color>

	<color name="widget_background">#FF000000</color>



	<?xml version="1.0" encoding="utf-8"?>

	<selector xmlns:android="http://schemas.android.com/apk/res/android">



		<item android:drawable="@color/widget_button_pressed" android:state_pressed="true"/>

		<item android:drawable="@color/widget_button_pressed" android:state_selected="true"/>

		<item android:drawable="@color/widget_button_pressed" android:state_focused="true"/>

		<item android:drawable="@color/widget_button"/>

	</selector>



	<Button

		android:layout_width="wrap_content"

		android:layout_height="wrap_content"

		android:background="@drawable/button_selector"

		android:text="@string/hello_world" />





Полный проект вы можете скачать на нашей [странице с кодами](http://android-helper.com.ua/codes/).
Всем привет друзья.





Сегодня я подготовил для вас видео урок.





Как использовать Switch елемент для android 4.0+, а для версий ниже использовать CheckBox.

 <!-- more -->

{% youtube Ifs96nSYUlg %}






**Коды**





**/layout-v14/switch_for_include.xml**



	<?xml version="1.0" encoding="utf-8"?>

	<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"

    android:layout_width="match_parent"

    android:layout_height="match_parent"

    android:orientation="horizontal" >



    <Switch

        android:id="@+id/checkBox1"

        android:layout_width="fill_parent"

        android:layout_height="wrap_content"

        android:text="Android-helper.com.ua" />



	</LinearLayout>


**/layout/switch_for_include.xml**



	<?xml version="1.0" encoding="utf-8"?>

	<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"

    android:layout_width="match_parent"

    android:layout_height="match_parent"

    android:orientation="horizontal" >



    <TextView

        android:layout_width="fill_parent"

        android:layout_height="wrap_content"

        android:layout_weight="1"

        android:text="Android-helper.com.ua" />



    <CheckBox

        android:id="@+id/checkBox1"

        android:layout_width="wrap_content"

        android:layout_height="wrap_content"

        android:layout_weight="0" />



	</LinearLayout>


**/layout/activity_main.xml**


	<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"

    xmlns:tools="http://schemas.android.com/tools"

    android:layout_width="match_parent"

    android:layout_height="match_parent"

    android:orientation="vertical"

    tools:context=".MainActivity" >



    <TextView

        android:layout_width="wrap_content"

        android:layout_height="wrap_content"

        android:gravity="center"

        android:paddingBottom="30dp"

        android:text="Пример того как использовать Swich на разных устройствах" />



    <include layout="@layout/switch_for_include" />



	</LinearLayout>




**MainActivity.java**



	public class MainActivity extends Activity implements OnCheckedChangeListener {



    @Override

    protected void onCreate(Bundle savedInstanceState) {

        super.onCreate(savedInstanceState);

        setContentView(R.layout.activity_main);

        CompoundButton compoundButton = (CompoundButton) findViewById(R.id.checkBox1);

        compoundButton.setOnCheckedChangeListener(this);

    }



    @Override

    public void onCheckedChanged(CompoundButton arg0, boolean arg1) {

        Toast.makeText(this, "Все работает сейчас у нас " + arg1, Toast.LENGTH_LONG).show();

    }



	}


Коды программы вы можете скачать [тут](http://android-helper.com.ua/codes/)




Очень познавательная статья.





Читать всем разработчикам!





Перед любым начинающим Android-разработчиком рано или поздно встает вопрос о том, где и как удобнее запускать и отлаживать свои программы.













Самый верный способ — через Android Debug Bridge на реальном Android-устройстве. Но если, по каким то причинам, этот способ не подходит, то остается два варианта — воспользоваться штатным эмулятором Android Virtual Device (AVD) из Android SDK, или установить Android на виртуальную машину.  Про второй вариант я и хочу рассказать в этой статье. Android на виртуальной машине серьезно превосходит AVD по быстродействию и времени загрузки, но есть и недостатки — сложнее эмулировать телефонию (возможно, при помощи дополнительных программ), пока не разобрался как смонтировать SD-карту.







 <!-- more -->





**Итак! Нам понадобится**:





1. Готовая к работе среда разработки и Android SDK Tools - см. StartAndroid.ru урок 2.  
[http://startandroid.ru/uroki/vse-uroki-spiskom/9-urok-2-ustanovka-i-nastrojka-sredy-razrabotki.html](http://startandroid.ru/uroki/vse-uroki-spiskom/9-urok-2-ustanovka-i-nastrojka-sredy-razrabotki.html)





2. VirtualBox последней версии.  
[https://www.virtualbox.org/](https://www.virtualbox.org/).





3. Образ Android. Выбираем любую версию с сайта проекта Android-x86.  
[http://code.google.com/p/android-x86/](http://code.google.com/p/android-x86/)









### Шаг 1 — устанавливаем Virtual Box.





![](http://startandroid.ru/images/stories/articles/A0002/A0002_050.png)





![](http://startandroid.ru/images/stories/articles/A0002/A0002_060.png)





![](http://startandroid.ru/images/stories/articles/A0002/A0002_070.png)





![](http://startandroid.ru/images/stories/articles/A0002/A0002_080.png)





![](http://startandroid.ru/images/stories/articles/A0002/A0002_090.png)





![](http://startandroid.ru/images/stories/articles/A0002/A0002_100.png)













### Шаг 2 — Создаем виртуальную машину с Android.





![](http://startandroid.ru/images/stories/articles/A0002/A0002_110.png)





![](http://startandroid.ru/images/stories/articles/A0002/A0002_120.png)





![](http://startandroid.ru/images/stories/articles/A0002/A0002_130.png)





![](http://startandroid.ru/images/stories/articles/A0002/A0002_140.png)





![](http://startandroid.ru/images/stories/articles/A0002/A0002_150.png)





![](http://startandroid.ru/images/stories/articles/A0002/A0002_160.png)





![](http://startandroid.ru/images/stories/articles/A0002/A0002_170.png)













### Шаг 3 — настройка виртуальной машины и её запуск.





![](http://startandroid.ru/images/stories/articles/A0002/A0002_180.png)





![](http://startandroid.ru/images/stories/articles/A0002/A0002_190.png)





![](http://startandroid.ru/images/stories/articles/A0002/A0002_200.png)





![](http://startandroid.ru/images/stories/articles/A0002/A0002_210.png)





![](http://startandroid.ru/images/stories/articles/A0002/A0002_220.png)





Система не может найти диск для загрузки и останавливается. Монтируем скачанный образ Android.





![](http://startandroid.ru/images/stories/articles/A0002/A0002_230.png)





![](http://startandroid.ru/images/stories/articles/A0002/A0002_240.png)









Выбрать можно любой, но я советую работать с версией для EEEPC, например  
[android-x86-3.2-RC2-eeepc.iso](http://code.google.com/p/android-x86/downloads/detail?name=android-x86-3.2-RC2-eeepc.iso&can=4&q=). В других может возникнуть проблема — из под Android не будет виден виртуальный сетевой адаптер.





Перегружаем машину.





![](http://startandroid.ru/images/stories/articles/A0002/A0002_250.png)





![](http://startandroid.ru/images/stories/articles/A0002/A0002_260.png)





![](http://startandroid.ru/images/stories/articles/A0002/A0002_270.png)





Нажимаем ENTER и ждет загрузки Android.





![](http://startandroid.ru/images/stories/articles/A0002/A0002_280.png)





Закрываем обучающие подсказки. И выключаем функцию интеграции мыши, которая некорректно работает с нашей ОС, скрывая курсор.





![](http://startandroid.ru/images/stories/articles/A0002/A0002_290.png)













### Шаг 4 — настройка сети в виртуальном Android.





Щелкаем внутри окна и оказываемся в пространстве виртуальной машины.   
(чтобы вернуть курсор нужно нажать **правый CTRL**)





![](http://startandroid.ru/images/stories/articles/A0002/A0002_300.png)









Нажимаем **Alt+F1** и оказываемся в консоли.





![](http://startandroid.ru/images/stories/articles/A0002/A0002_310.png)









Присваиваем адрес сетевому адаптеру командой **ifconfig**:  
**ifconfig eth0 192.168.56.2 netmask 255.255.255.0**









Проверяем или переходим к следующему шагу. Основной комп пингуется по адресу 192.168.56.1 ("VirtualBox Host-Only Ethernet Adapter" в диспетчере устройств).  
Команда **ping**:  
**ping 192.168.56.1**  
**Ctrl+C**









Если все сработало нормально то увидим:





![](http://startandroid.ru/images/stories/articles/A0002/A0002_320.png)













### Шаг 5 — подсоединяем Android Debug Bridge (ADB) к виртуальной ОС.





Нажимаем **Alt+F7**, чтобы вернуться к графическому интерфейсу. Нажимаем **правый CTRL** и возвращаемся к реальной ОС. Не закрываем виртуальную машину.





Создаем на рабочем столе ярлык на **adb.exe**





![](http://startandroid.ru/images/stories/articles/A0002/A0002_330.png)





Нужный нам файл находится в папке Android SDK "platform-tools".





![](http://startandroid.ru/images/stories/articles/A0002/A0002_340.png)





Дописываем команду текстом "**connect 192.168.56.2**":





![](http://startandroid.ru/images/stories/articles/A0002/A0002_360.png)





![](http://startandroid.ru/images/stories/articles/A0002/A0002_370.png)









Запускаем ярлык.





Теперь ADB соединен с виртуальным Android, а он, в свою очередь, доступен для запуска и отладки программ из Eclipse. Цель достигнута. :)





Пересоединять ADB придется в том случае, когда вы закрыли или перезагрузили виртуальную машину.





**Так-же в случае, если вы перезагрузили виртуальный Android, придется возвращаться к шагу 4, так как настройки сетевого адаптера будут сброшены**. Поэтому я рекомендую не выключать виртуальную машину, а погружать её в сон, но ярлычек потом запустить все равно придется.





![](http://startandroid.ru/images/stories/articles/A0002/A0002_380.png)





![](http://startandroid.ru/images/stories/articles/A0002/A0002_390.png)













Заходим в Eclipse и проверяем как работает





![](http://startandroid.ru/images/stories/articles/A0002/A0002_400.png)





![](http://startandroid.ru/images/stories/articles/A0002/A0002_410.png)





![](http://startandroid.ru/images/stories/articles/A0002/A0002_420.png)













![](http://startandroid.ru/images/stories/articles/A0002/A0002_430.png)





Благодарности:





**renton** с habrahabr.ru — его идея.  
[http://habrahabr.ru/post/119599/](http://habrahabr.ru/post/119599/)





 Источник [startandroid.ru](http://startandroid.ru/ru/articles/listofarticles/206-bystraja-alternativa-android-virtual-device.html)
Всем привет.





Есть много программ с которых программисты и дизайнеры берут свои идеи.





И вот одна из которых это приложение facebook для android.





С этой программы дизайнеры взяли такую вещь как sliding menu.





Давайте посмотрим, что это такое.

 <!-- more -->



![Screenshot_2013-01-17-19-47-11](http://android-helper.com.ua/images/uploads/2013/01/Screenshot_2013-01-17-19-47-11.png)




 





![Screenshot_2013-01-02-02-24-31](http://android-helper.com.ua/images/uploads/2013/01/Screenshot_2013-01-02-02-24-31.png)





 





### Задача





Сделать что то подобное.





### Реализация





Для реализации данной задачи, мы будем использовать открытую библиотеку [SlidingMenu](https://github.com/jfeinstein10/SlidingMenu).





Также как она работает можете посмотреть, скачав приложение с [маркета](https://play.google.com/store/apps/details?id=com.slidingmenu.example).





### Коды





**MainActivity.java**



	public class MainActivity extends Activity {



    @Override

    protected void onCreate(Bundle savedInstanceState) {

        super.onCreate(savedInstanceState);

        setContentView(R.layout.activity_main);



        setTitle("Attach");

        // configure the SlidingMenu

        SlidingMenu menu = new SlidingMenu(this);

        menu.setMode(SlidingMenu.LEFT);

        menu.setTouchModeAbove(SlidingMenu.TOUCHMODE_FULLSCREEN);

        menu.setShadowWidthRes(R.dimen.shadow_width);

        menu.setShadowDrawable(R.drawable.shadow);

        menu.setBehindOffsetRes(R.dimen.slidingmenu_offset);

        menu.setFadeDegree(0.35f);



        // ///////////

        menu.attachToActivity(this, SlidingMenu.SLIDING_CONTENT);

        // //////////



        menu.setMenu(R.layout.menu);

    }



    @Override

    public boolean onCreateOptionsMenu(Menu menu) {

        // Inflate the menu; this adds items to the action bar if it is present.

        getMenuInflater().inflate(R.menu.activity_main, menu);

        return true;

    }



	}


**drawable/shadow.xml**


	<?xml version="1.0" encoding="utf-8"?>

	<shape xmlns:android="http://schemas.android.com/apk/res/android" >



    <gradient

        android:centerColor="#11000000"

        android:endColor="#33000000"

        android:startColor="#00000000" />



	</shape>


**layout/menu.xml**


	<?xml version="1.0" encoding="utf-8"?>

	<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"

    android:layout_width="match_parent"

    android:layout_height="match_parent"

    android:orientation="vertical" >



    <TextView

        android:id="@+id/textView1"

        android:layout_width="wrap_content"

        android:layout_height="wrap_content"

        android:text="Menu 1"

        android:textAppearance="?android:attr/textAppearanceLarge" />



    <TextView

        android:id="@+id/textView2"

        android:layout_width="wrap_content"

        android:layout_height="wrap_content"

        android:text="Menu 2"

        android:textAppearance="?android:attr/textAppearanceLarge" />



    <TextView

        android:id="@+id/textView3"

        android:layout_width="wrap_content"

        android:layout_height="wrap_content"

        android:text="Menu 3"

        android:textAppearance="?android:attr/textAppearanceLarge" />



    <TextView

        android:id="@+id/textView4"

        android:layout_width="wrap_content"

        android:layout_height="wrap_content"

        android:text="Menu 4"

        android:textAppearance="?android:attr/textAppearanceLarge" />



	</LinearLayout>


**values/dimens.xml**



	<?xml version="1.0" encoding="utf-8"?>

	<resources>



    <dimen name="slidingmenu_offset">60dp</dimen>

    <dimen name="list_padding">10dp</dimen>

    <dimen name="shadow_width">15dp</dimen>



	</resources>


### Видео


{% youtube eHWNIS64I0Q %}






Рабочий код на странице с [кодами](http://android-helper.com.ua/codes/).
Привет друзья.





После выхода android 4. Все дизайнеры как будто сговорились и прикручивают actionbar кругом.





И заказчик говорит, что именно так должно быть и для старых версий.





И что же делать? Писать свой actionbar?


 <!-- more -->


Нам на помощь приходит очень классная и бесплатная библиотека [ActionBarSherlock](http://actionbarsherlock.com/)





Я думаю, что большая часть из вас будет ее использовать.





Но могут быть и такие которые скажут, мы не используем сторонние библиотеки.





Это вам решать, но от себя добавлю, что эту библиотеку рекомендует google.





Пришло время писать код.





### Задача





Сделать actionbar меню для всех телефонов.





### Ресурсы





ActionBarSherlock





### Примеры реализации





![feature_02](http://android-helper.com.ua/images/uploads/2013/01/feature_02.png)





 





![feature_03](http://android-helper.com.ua/images/uploads/2013/01/feature_03.png)



 





![feature_01](http://android-helper.com.ua/images/uploads/2013/01/feature_01.png)





 





 





### Реализация








  1. Подключаем проект Sherlock в eclipse. Скачать можно [тут](https://api.github.com/repos/JakeWharton/ActionBarSherlock/zipball/4.2.0).



  2. Создаем свой проект



  3. Подключаем библиотеку sherlock к вашему проекту



  4. Делаем файл меню



  5. ВАЖНО! Все активити и фрагменты должны наследоваться от SherlockActivity и SherlockFragment






### Коды





#### menu/activity_main.xml





	<menu xmlns:android="http://schemas.android.com/apk/res/android" >



    <item

        android:id="@+id/item1"

        android:icon="@android:drawable/ic_menu_agenda"

        android:orderInCategory="100"

        android:showAsAction="always|withText"

        android:title="Item 1"/>

    <item

        android:id="@+id/item2"

        android:icon="@android:drawable/ic_menu_call"

        android:orderInCategory="200"

        android:showAsAction="always|withText"

        android:title="Item 2"/>

    <item

        android:id="@+id/item3"

        android:icon="@android:drawable/ic_menu_camera"

        android:orderInCategory="300"

        android:showAsAction="ifRoom|withText"

        android:title="Item3"/>

    <item

        android:id="@+id/menu_settings"

        android:orderInCategory="400"

        android:showAsAction="never"

        android:title="@string/menu_settings"/>



	</menu>





#### MainActivity.java



	package com.ua.android_helper.testactionbar;



	import android.os.Bundle;

	import com.actionbarsherlock.app.SherlockActivity;

	import com.actionbarsherlock.view.Menu;



	public class MainActivity extends SherlockActivity {



    @Override

    protected void onCreate(Bundle savedInstanceState) {

        super.onCreate(savedInstanceState);

        setContentView(R.layout.activity_main);

    }



    @Override

    public boolean onCreateOptionsMenu(Menu menu) {

        getSupportMenuInflater().inflate(R.menu.activity_main, menu);

        return true;

    }



	}


#### AndroidManifest.xml


	<?xml version="1.0" encoding="utf-8"?>

	<manifest xmlns:android="http://schemas.android.com/apk/res/android"

    package="com.ua.android_helper.testactionbar"

    android:versionCode="1"

    android:versionName="1.0" >



    <uses-sdk

        android:minSdkVersion="8"

        android:targetSdkVersion="17" />



    <application

        android:allowBackup="true"

        android:icon="@drawable/ic_launcher"

        android:label="@string/app_name"

        android:theme="@style/Theme.Sherlock" >

        <activity

            android:name="com.ua.android_helper.testactionbar.MainActivity"

            android:label="@string/app_name" >

            <intent-filter>

                <action android:name="android.intent.action.MAIN" />



                <category android:name="android.intent.category.LAUNCHER" />

            </intent-filter>

        </activity>

    </application>



	</manifest>



**Видео**

{% youtube GOB72vWY_5s %}


Друзья всем привет.





Сегодня я бы хотел поведать вам о замечательном поведении в ActionBar.





C Android 3.0 в ActionBar добавили классное поведение для выбранных элементов.





Но давайте это посмотрим на примере.

 <!-- more -->



#### Задача





Дать возможность в ListView выбрать несколько элементов и например скопировать их названия. И эти названия вывести в диалог.





#### Результат урока





[![device-2013-01-25-092939](http://android-helper.com.ua/images/uploads/2013/01/device-2013-01-25-092939-180x300.png)](http://android-helper.com.ua/images/uploads/2013/01/device-2013-01-25-092939.png)[![device-2013-01-25-093344](http://android-helper.com.ua/images/uploads/2013/01/device-2013-01-25-093344-180x300.png)](http://android-helper.com.ua/images/uploads/2013/01/device-2013-01-25-093344.png)





#### [![device-2013-01-25-093353](http://android-helper.com.ua/images/uploads/2013/01/device-2013-01-25-093353-180x300.png)](http://android-helper.com.ua/images/uploads/2013/01/device-2013-01-25-093353.png)





####  





####  





####  





####  





####  





####  





####  





####  





####  





#### [![device-2013-01-25-093405](http://android-helper.com.ua/images/uploads/2013/01/device-2013-01-25-093405-180x300.png)](http://android-helper.com.ua/images/uploads/2013/01/device-2013-01-25-093405.png)





#### [![device-2013-01-25-093431](http://android-helper.com.ua/images/uploads/2013/01/device-2013-01-25-093431-180x300.png)](http://android-helper.com.ua/images/uploads/2013/01/device-2013-01-25-093431.png)





####  





####  





####  





####  





####  





####  





####  





####  





####  





#### Реализация





Создаем проект с минимальным значением android - 11.





Activity наследуем от ListActivity.



[java]public class MainActivity extends ListActivity {



    String[] data = { "one", "two", "three", "four", "five" };



    @Override

    protected void onCreate(Bundle savedInstanceState) {

        super.onCreate(savedInstanceState);

        prepareListView();

    }

[/java]  
  




Заполняем ListView



[java] private void prepareListView() {



        ArrayAdapter<String> adapter = new ArrayAdapter<String>(this, android.R.layout.simple_list_item_activated_1,

                data);

        getListView().setAdapter(adapter);[/java]  
  




Создаем menu для action mode



[xml]<?xml version="1.0" encoding="utf-8"?>

<menu xmlns:android="http://schemas.android.com/apk/res/android" >



	<item

		android:id="@+id/copy"

		android:icon="@android:drawable/ic_menu_save"

		android:showAsAction="always|withText"

		android:title="@string/copy">

	</item>



</menu>[/xml]  
  




Добавляем обработчики для action mode и показываем диалог



[java]private final MultiChoiceModeListener callback = new MultiChoiceModeListener() {



        private final StringBuilder message = new StringBuilder();



        @Override

        public boolean onPrepareActionMode(ActionMode mode, Menu menu) {

            return false;

        }



        @Override

        public void onDestroyActionMode(ActionMode mode) {



        }



        @Override

        public boolean onCreateActionMode(ActionMode mode, Menu menu) {

            mode.getMenuInflater().inflate(R.menu.context, menu);

            return true;

        }



        @Override

        public boolean onActionItemClicked(ActionMode mode, MenuItem item) {

            if (item.getItemId() == R.id.copy) {

                AlertDialog.Builder builder = new AlertDialog.Builder(MainActivity.this);

                builder.setTitle("Action Mode").setMessage(message.toString()).create().show();

            }

            mode.finish();

            return false;

        }



        @Override

        public void onItemCheckedStateChanged(ActionMode mode, int position, long id, boolean checked) {

            if (checked) {

                String title = data[position];

                message.append("\n" + title);

            }

        }

    };[/java]  
  




Добавляем возможность вызова action mode из ListView и множественный выбор.



[java]//

        getListView().setChoiceMode(ListView.CHOICE_MODE_MULTIPLE_MODAL);

        //

        getListView().setMultiChoiceModeListener(callback);[/java]  
  




Все готово.





Для того что бы скачать исходники вам необходимо перейти на [страницу с исходниками](http://android-helper.com.ua/codes/)
Всем привет.





Прошу простить меня, что очень долго не радовал своих читателей блога, хорошими примерами.





Вот недавно я лазил по просторах инета и нашел замечательную [статью](http://habrahabr.ru/post/166351/).





О том как можно сделать разметку html в обычном TextView.

 <!-- more -->



Автор довольно хорошо высветел эту тему. Хотел переработать для вас, но все что тут написано, действительно нужно.





Ну что ж господа. Прошу к прочтению.





Недавно мне понадобилось сделать довольно хитроумный чат в приложении под Android. Помимо собственно информации требовалось передавать пользователям дополнительную функциональность в контексте определенного сообщения: имя автора сообщения по нажатию на него должно вставляться в текстовое поле ответа, а если это сообщение о только что созданном игровом сеансе, пользователи должны иметь возможность присоединиться к игре по клику и так далее. Одним из главных требований была возможность создавать сообщение, содержащее несколько ссылок, что и задало направление исследований.  
  
**WebView**, обладая нужной функциональностью, был отвергнут по причине тяжести решения: я даже не стал создавать 100 или сколько-нибудь там экземпляров в тестовых целях, по одному на каждое сообщение, поскольку сразу было понятно, что это расточительство нормально работать не будет.





К счастью, самый обычный [**TextView**](http://developer.android.com/reference/android/widget/TextView.html) обладает неожиданно потрясающей функциональностью по разметке текста и может использоваться как в качестве отдельного элемента, так и служить целой страницей, будучи несравненно легковеснее, чем **WebView**.





Я реализовал весь, необходимый мне функционал и выяснил ещё несколько довольно интересных вещей, столкнувшись с некоторым количеством подводных камней (впрочем, не очень острых). Можно сказать, всё нижеописанное — руководство по созданию достаточно мощной справочной системы в своём приложении практически даром.





### Задачи





В данном примере мы создадим приложение с двумя **Activity**, одна из которых содержит **TextView**, исполняющий роль браузера, из которого, в частности, можно вызвать вторую **Activity**, демонстрирующую работу с параметрами вызова. Мы выясним, каким образом можно создавать страницы текста с разметкой и изображениями и связывать их ссылками. 





Содержимое страниц берётся из строк в ресурсах приложения, а изображения являются drawable-ресурсами. Небольшие изменения в коде позволят использовать другие расположения.





![](http://habrastorage.org/storage2/a04/b2e/d4b/a04b2ed4b25633dfdc13fe3927e3c859.jpg)





### Создание приложения





Любым удобным нам способом создаём обычное приложение:









**AndroidManifest.xml**



	<manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.example.markup.tutorial" android:versionCode="1" android:versionName="1.0">

 	<uses-sdk android:minSdkVersion="7" android:targetSdkVersion="15" /> 

 	<application android:icon="@drawable/ic_launcher" android:label="@string/app_name" android:theme="@style/AppTheme">

  	<activity android:name=".MainActivity" android:label="@string/title_activity_main">

   	<intent-filter>

    	<action android:name="android.intent.action.MAIN" /> 

    	<category android:name="android.intent.category.LAUNCHER" /> 

   	</intent-filter>

  	</activity>

  	<activity android:name=".AnotherActivity" android:exported="false">

   	<intent-filter>

    <data android:scheme="activity-run" android:host="AnotherActivityHost" /> 

    <action android:name="android.intent.action.VIEW" /> 

    <category android:name="android.intent.category.DEFAULT" /> 

   	</intent-filter>

  	</activity>

 	</application>

	</manifest> 
  








Немного пояснений к манифесту. Если с первой **Activity** всё понятно, вторая (**AnotherActivity**) содержит некие дополнительные описатели.





**android:exported=«false»** необходимо для того, чтобы компилятор не выдавал предупреждения о том, что мы забыли что-то прописать в экспортируемом компоненте. На мой взгляд, чисто декоративный момент, но чем меньше жёлтых треугольничков — тем спокойнее.





Раздел **intent-filter** содержит описатели того, каким образом и при каких обстоятельствах будет происходить запуск **Activity**.





 означает, что можно запустить **Activity** ссылкой вида **activity-run://AnotherActivityHost?params...**





Значения **action** и **category** необходимы системе для того чтобы обнаружить и запустить **Activity**.









**MainActivity.java**

	package com.example.markup.tutorial;

	import org.xml.sax.XMLReader;

	import android.os.Bundle;

	import android.app.Activity;

	import android.graphics.drawable.Drawable;

	import android.text.Editable;

	import android.text.Html;

	import android.text.Spannable;

	import android.text.Spanned;

	import android.text.method.LinkMovementMethod;

	import android.widget.TextView;



	public class MainActivity extends Activity {



    TextView tvContent;

    

    @Override

    public void onCreate(Bundle savedInstanceState) {

        super.onCreate(savedInstanceState);

        setContentView(R.layout.activity_main);

        

        tvContent = (TextView)findViewById(R.id.tvContent);

        tvContent.setLinksClickable(true);

        tvContent.setMovementMethod(new LinkMovementMethod());

        

        setArticle("article_main");

    }



    void setArticle(String strArticleResId) {

    	int articleResId = getResources().getIdentifier(strArticleResId, "string", getPackageName());

    	String text = getString(articleResId);

    	if (text == null) text = "Article not found";

    	

    	Spanned spannedText = Html.fromHtml(text, htmlImageGetter, htmlTagHandler);

    	Spannable reversedText = revertSpanned(spannedText);

    	

    	tvContent.setText(reversedText);

    }

    

    final Spannable revertSpanned(Spanned stext) {

        Object[] spans = stext.getSpans(0, stext.length(), Object.class);

        Spannable ret = Spannable.Factory.getInstance().newSpannable(stext.toString());

        if (spans != null && spans.length > 0) {

            for(int i = spans.length - 1; i >= 0; --i) {

                ret.setSpan(spans[i], stext.getSpanStart(spans[i]), stext.getSpanEnd(spans[i]), stext.getSpanFlags(spans[i]));

            }

        }



        return ret;

    }

    

    Html.ImageGetter htmlImageGetter = new Html.ImageGetter() {

        public Drawable getDrawable(String source) {

            int resId = getResources().getIdentifier(source, "drawable", getPackageName());

            Drawable ret = MainActivity.this.getResources().getDrawable(resId);

            ret.setBounds(0, 0, ret.getIntrinsicWidth(), ret.getIntrinsicHeight());

            return ret;

        }

    };



    Html.TagHandler htmlTagHandler = new Html.TagHandler() {

        public void handleTag(boolean opening, String tag, Editable output,	XMLReader xmlReader) {

            Object span = null;

            if (tag.startsWith("article_")) span = new ArticleSpan(MainActivity.this, tag);

            else if ("title".equalsIgnoreCase(tag)) span = new AppearanceSpan(0xffff2020, AppearanceSpan.NONE, 20, true, true, false, false);

            else if (tag.startsWith("color_")) span = new ParameterizedSpan(tag.substring(6));

            if (span != null) processSpan(opening, output, span);

        }

    };

    

    void processSpan(boolean opening, Editable output, Object span) {

        int len = output.length();

        if (opening) {

            output.setSpan(span, len, len, Spannable.SPAN_MARK_MARK);

        } else {

            Object[] objs = output.getSpans(0, len, span.getClass());

            int where = len;

            if (objs.length > 0) {

                for(int i = objs.length - 1; i >= 0; --i) {

                    if (output.getSpanFlags(objs[i]) == Spannable.SPAN_MARK_MARK) {

                        where = output.getSpanStart(objs[i]);

                        output.removeSpan(objs[i]);

                        break;

                    }

                }

            }

            

            if (where != len) {

                output.setSpan(span, where, len, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);

            }

        }

    }

    

	}   








**AnotherActivity.java**



	package com.example.markup.tutorial;



	import android.app.Activity;

	import android.app.AlertDialog;

	import android.content.DialogInterface;

	import android.net.Uri;

	import android.os.Bundle;



	public class AnotherActivity extends Activity {



    @Override

    public void onCreate(Bundle savedInstanceState) {

        super.onCreate(savedInstanceState);

    

        Uri uri = getIntent().getData();

        

        String caption = uri.getQueryParameter("caption");

        String text = uri.getQueryParameter("text");

        

        new AlertDialog.Builder(this)

        	.setTitle(caption)

        	.setMessage(text)

        	.setPositiveButton("OK", dioclOK)

        	.setCancelable(false)

        	.create().show();

    }

    

    DialogInterface.OnClickListener dioclOK = new DialogInterface.OnClickListener() {

        

        public void onClick(DialogInterface dialog, int which) {

            dialog.dismiss();

            finish();

        }

    };

    

	}  












**AppearanceSpan.java**



	package com.example.markup.tutorial;



	import android.text.TextPaint;

	import android.text.style.CharacterStyle;



	public class AppearanceSpan extends CharacterStyle {

    

    public static final int NONE = -1;

    

    final int color, bgColor, textSize;

    final boolean boldText, italicText, strikeThruText, underlineText;

    

    public AppearanceSpan(int color, int bgColor, int textSize, boolean boldText, boolean italicText, 

            boolean strikeThruText, boolean underlineText) {

        this.color = color;

        this.bgColor = bgColor;

        this.textSize = textSize;

        this.boldText = boldText;

        this.italicText = italicText;

        this.strikeThruText = strikeThruText;

        this.underlineText = underlineText;

    }

    

    @Override

    public void updateDrawState(TextPaint tp) {

        if (color != NONE) tp.setColor(color);

        if (bgColor != NONE) tp.bgColor = bgColor;

        tp.setFakeBoldText(boldText);

        tp.setStrikeThruText(strikeThruText);

        if (textSize != NONE) tp.setTextSize(textSize);

        tp.setUnderlineText(underlineText);

        tp.setTextSkewX(italicText ? -0.25f : 0);

    }



	} 
  












**ArticleSpan.java**


	package com.example.markup.tutorial;



	import android.text.style.ClickableSpan;

	import android.view.View;



	public class ArticleSpan extends ClickableSpan {



    final MainActivity activity;

    final String articleId;

    

    public ArticleSpan(MainActivity activity, String articleId) {

        super();

        this.activity = activity;

        this.articleId = articleId;

    }

    

    @Override

    public void onClick(View arg0) {

        activity.setArticle(articleId);

    }



	}
  












**ParameterizedSpan.java**


	package com.example.markup.tutorial;



	import android.graphics.Color;

	import android.text.TextPaint;

	import android.text.style.CharacterStyle;



	public class ParameterizedSpan extends CharacterStyle {



    int color = 0;

    

    public ParameterizedSpan(String param) {

        try {

            color = Color.parseColor("#" + param);

        } catch(Exception ex) { }

    }



    @Override

    public void updateDrawState(TextPaint tp) {

        tp.setColor(color);

    }



	}
  








### Подготовка ресурсов









**layout/activity_main.xml"**

	<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"

    xmlns:tools="http://schemas.android.com/tools"

    android:layout_width="fill_parent"

    android:layout_height="fill_parent" >



    <ScrollView 

        android:id="@+id/sv"

        android:layout_width="fill_parent"

        android:layout_height="fill_parent"

        >

        <TextView

            android:id="@+id/tvContent"

            android:layout_width="wrap_content"

            android:layout_height="wrap_content"

            android:text="Content" />

    </ScrollView>

	</RelativeLayout>  
  












**values/strings.xml"**


	<resources>

    <string name="app_name">MarkupTutor</string>

    <string name="hello_world">Hello world!</string>

    <string name="menu_settings">Settings</string>

    <string name="title_activity_main">MainActivity</string>

    

    <string name="article_main" formatted="false"><![CDATA[

		<title>Главная страница</title><br/>

		<br/>

		<img src="res_pushkin_little"> <article_pushkin_stih>А.С. 	Пушкин "Как пить мы станем"</article_pushkin_stih><br/>

		<img src="res_activity_little"> <a href="activity-run://	AnotherActivityHost?caption=Another%20Activity&text=Hello%20from%20markup!">Вызвать другую Activity</a><br/>

		<br/>

		<color_ff00ff00>Тест параметризированного тэга <color_ffff00ff>и вложенных спанов</color_ffff00ff>.</color_ff00ff00><br/>

		Тест анимированного GIF-а:<br/>

		<img src="res_alien_anim">

    ]]></string>

        	

    <string name="article_pushkin_stih" formatted="false"><![CDATA[

		<br/><article_main>На главную</article_main><br/><br/>

		<img src="res_pushkin" /><br/><br/>

		Сват Иван, как пить мы станем,<br/>

		Непременно уж помянем<br/>

		Трех Матрен, Луку с Петром,<br/>

		Да Пахомовну потом.<br/>

		Мы живали с ними дружно,<br/>

		Уж как хочешь - будь что будь -<br/>

		Этих надо помянуть,<br/><br/>



		Помянуть нам этих нужно.<br/>

		Поминать, так поминать,<br/>

		Начинать, так начинать,<br/>

		Лить, так лить, разлив разливом.<br/>

		Начинай-ка, сват, пора.<br/>

		Трех Матрен, Луку, Петра<br/>

		В первый раз помянем пивом,<br/>

		А Пахомовну потом<br/>

		Пирогами да вином,<br/>

		Да еще ее помянем:<br/>

		Сказки сказывать мы станем -<br/>

		Мастерица ведь была<br/>

		И откуда что брала.<br/>

		А куды разумны шутки,<br/>

		Приговорки, прибаутки,<br/>

		Небылицы, былины<br/>

		Православной старины!..<br/>

		Слушать, так душе отрадно.<br/>

		И не пил бы и не ел,<br/>

		Всё бы слушал да сидел.<br/>

		Кто придумал их так ладно?<br/>

		Стариков когда-нибудь<br/>

		(Жаль, теперь нам не досужно)<br/>

		Надо будет помянуть -<br/>

		Помянуть и этих нужно...<br/>

		Слушай, сват, начну первой,<br/>

		Сказка будет за тобой.<br/>

    ]]></string>

	</resources>
  








Строки, содержащие разметку, должны иметь аттрибут **formatted** со значением **false**, а содержимое должно передаваться в блоке **CDATA**, чтобы у компилятора не было претензий к разметке и специальным символам. В данном примере признаком статьи будет префикс **article_** в названии строки.





Также замечен странный глюк, проявляющийся в том, что если текст начинается с тега, то заканчивается он этим же тегом. Если у вас в начале статьи ссылка, советую ставить перед ней либо пробел, либо`  
`.





Изображения могут быть формата jpg, png или gif без анимации. Анимированный gif отображается статичной картинкой. Расположение стандартное для ресурсов, для дисплеев разной плотности можно подготовить свой вариант картинки. В данном примере все изображения находятся в **drawable-nodpi**





![](http://habrastorage.org/storage2/a2c/313/a58/a2c313a588ebcbd9f6d257576518d942.png)





### Как всё работает





Рассмотрим некоторые части кода подробно.

	public void onCreate(Bundle savedInstanceState) {

    super.onCreate(savedInstanceState);

    setContentView(R.layout.activity_main);

    

    tvContent = (TextView)findViewById(R.id.tvContent);

    tvContent.setLinksClickable(true);

    tvContent.setMovementMethod(new LinkMovementMethod());

    

    setArticle("article_main");

	} 
  




**TextView** используемый нами в качестве браузера, требует особой инициализации:





**tvContent.setLinksClickable(true);** указывает на то, что ссылки в данном элементе реагируют на нажатие.





**tvContent.setMovementMethod(new LinkMovementMethod());** назначает способ навигации по элементу. Использованный нами [**LinkMovementMethod**](http://developer.android.com/reference/android/text/method/LinkMovementMethod.html) интересен сам по себе и, возможно, заслуживает отдельной статьи. Я лишь скажу, что при необходимости более полного контроля можно создать его наследника, переопределенные методы которого позволят отслеживать все действия со ссылками в элементе.



	void setArticle(String strArticleResId) {

    int articleResId = getResources().getIdentifier(strArticleResId, "string", getPackageName());

    String text = getString(articleResId);

    if (text == null) text = "Article not found";

    

    Spanned spannedText = Html.fromHtml(text, htmlImageGetter, htmlTagHandler);

    Spannable reversedText = revertSpanned(spannedText);

    

    tvContent.setText(reversedText);

	} 
  




В данном методе происходит получение строки по идентификатору из строковых ресурсов, её преобразование из HTML в специальный объект **Spanned**, затем ещё одно преобразование в **Spannable** и установка в **TextView** в качестве содержимого. Всё это кажется довольно громоздким, но тому есть причины.





В **TextView**, на мой взгляд, странный порядок обработки спанов — с конца списка. При естественном расположении спанов после преобразования строки из HTML, изменения внешнего вида вложенных спанов перекрываются свойствами спанов, их содержащих. Для нормального отображения приходится буквально выворачивать маркировку наизнанку с помощью метода **revertSpanned**:



	final Spannable revertSpanned(Spanned stext) {

    Object[] spans = stext.getSpans(0, stext.length(), Object.class);

    Spannable ret = Spannable.Factory.getInstance().newSpannable(stext.toString());

    if (spans != null && spans.length > 0) {

        for(int i = spans.length - 1; i >= 0; --i) {

            ret.setSpan(spans[i], stext.getSpanStart(spans[i]), stext.getSpanEnd(spans[i]), stext.getSpanFlags(spans[i]));

        }

    }



    return ret;

	}  
  




Определение обработчика ссылок на изображения минималистично и призвано загружать только картинки из ресурсов. Поскольку мы рассматриваем вариант справочной системы, я посчитал, что этого будет достаточно. С вашего позволения, я не буду цитировать его. Если вы хотите большего, можно обратиться, например, к [данной статье](http://habrahabr.ru/post/155879/).





Более интересен нам будет **Html.TagHadler**:



	Html.TagHandler htmlTagHandler = new Html.TagHandler() {

    public void handleTag(boolean opening, String tag, Editable output,	XMLReader xmlReader) {

        Object span = null;

        if (tag.startsWith("article_")) span = new ArticleSpan(MainActivity.this, tag);

        else if ("title".equalsIgnoreCase(tag)) span = new AppearanceSpan(0xffff2020, AppearanceSpan.NONE, 20, true, true, false, false);

        else if (tag.startsWith("color_")) span = new ParameterizedSpan(tag.substring(6));

        if (span != null) processSpan(opening, output, span);

    }

	};
  




Здесь у нас происходит несколько интересных вещей.





При преобразовании из **HTML** в **Spanned** методом **Html.fromHtml**, обрабатываются тэги 





`br`, `p`, `div`, `em`, `b`,`strong`, `cite`, `dfn`, `i`, `big`, `small`, 





`font`, `blockquote`, `tt`, `a`, `u`, `sup`, `sub`, `h1...h6` и `img`.





В случае, если тэг не опознан, вызывается Html.TagHandler (если, конечно, он передан в вызов).





Мы проверяем, не является ли переданный тэг «нашим» и если это так, создаём соответствующий **Span** — элемент разметки, а затем накладываем его на текст. Я создал несколько собственных **Span**-ов, они будут рассмотрены далее. Как правило, **Span**-ы наследуются от [**android.text.style.CharacterStyle**](http://developer.android.com/reference/android/text/style/CharacterStyle.html).





К сожалению, у меня не получилось малой кровью добиться центрования отдельных строк или абзацев, а встроенной возможности для этого не существует. Также, нельзя прочесть атрибуты тэга из **xmlReader**, поскольку он реализован не полностью. По этой причине пришлось изобретать свой способ передачи параметров: значение является частью тега. В нашем примере таким образом передаётся значение цвета в тэге **color**, преобразовываемом в **ParameterizedSpan**. Получается что-то вроде``





<color_ffff0000>красный. Это достаточно ограниченный и не очень удобный способ, но иногда лучше такой, чем никакого.



	void processSpan(boolean opening, Editable output, Object span) {

        int len = output.length();

        if (opening) {

            output.setSpan(span, len, len, Spannable.SPAN_MARK_MARK);

        } else {

            Object[] objs = output.getSpans(0, len, span.getClass());

            int where = len;

            if (objs.length > 0) {

                for(int i = objs.length - 1; i >= 0; --i) {

                    if (output.getSpanFlags(objs[i]) == Spannable.SPAN_MARK_MARK) {

                        where = output.getSpanStart(objs[i]);

                        output.removeSpan(objs[i]);

                        break;

                    }

                }

            }

            

            if (where != len) {

                output.setSpan(span, where, len, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);

            }

        }

    } 
  




Этот код делает следующее: В случае, если передан открывающий **Span**, он добавляется к концу строки в текущем её виде. В случае, если **Span** закрывающий, мы находим в строке его открывающий аналог, запоминаем его положение, затем удаляем и добавляем новый, но уже с информацией о начальном положении и длине. 





Мы завершили рассмотрение класса Activity, являющегося основным модулем нашего приложения. Теперь рассмотрим вспомогательные классы.



	package com.example.markup.tutorial;



	import android.text.TextPaint;

	import android.text.style.CharacterStyle;



	public class AppearanceSpan extends CharacterStyle {

    

    public static final int NONE = -1;

    

    final int color, bgColor, textSize;

    final boolean boldText, italicText, strikeThruText, underlineText;

    

    public AppearanceSpan(int color, int bgColor, int textSize, boolean boldText, boolean italicText, 

            boolean strikeThruText, boolean underlineText) {

        this.color = color;

        this.bgColor = bgColor;

        this.textSize = textSize;

        this.boldText = boldText;

        this.italicText = italicText;

        this.strikeThruText = strikeThruText;

        this.underlineText = underlineText;

    }

    

    @Override

    public void updateDrawState(TextPaint tp) {

        if (color != NONE) tp.setColor(color);

        if (bgColor != NONE) tp.bgColor = bgColor;

        tp.setFakeBoldText(boldText);

        tp.setStrikeThruText(strikeThruText);

        if (textSize != NONE) tp.setTextSize(textSize);

        tp.setUnderlineText(underlineText);

        tp.setTextSkewX(italicText ? -0.25f : 0);

    }

	}
  




Это Span общего назначения и с его помощью можно задать большинство параметров стиля текста. Его можно использовать как базу для создания стилей текста из собственных тэгов.







	package com.example.markup.tutorial;

	import android.text.style.ClickableSpan;

	import android.view.View;



	public class ArticleSpan extends ClickableSpan {



    final MainActivity activity;

    final String articleId;

    

    public ArticleSpan(MainActivity activity, String articleId) {

        super();

        this.activity = activity;

        this.articleId = articleId;

    }

    

    @Override

    public void onClick(View arg0) {

        activity.setArticle(articleId);

    }

	}







Этот класс описывает элемент, который по нажатию на него обеспечивает переход к статье, чей идентификатор является его параметром. Здесь я применил производное от способа, описанного мной ранее: сам тэг является собственным параметром, а его класс определяется префиксом article_. Поднимемся выше, к описанию **Html.TagHandler**:








	if (tag.startsWith("article_")) span = new ArticleSpan(MainActivity.this, tag);






Обработчик тэгов, увидев тэг, начинающийся на article_, создаёт ArticleSpan, задавая ему в качестве параметра название тэга. Элемент, при нажатии на него, вызывает метод MainActivity.setArticle, после чего в TextView устанавливается новый текст.







	package com.example.markup.tutorial;


	import android.graphics.Color;

	import android.text.TextPaint;

	import android.text.style.CharacterStyle;



	public class ParameterizedSpan extends CharacterStyle {



    int color = 0;

    

    public ParameterizedSpan(String param) {

        try {

            color = Color.parseColor("#" + param);

        } catch(Exception ex) { }

    }



    @Override

    public void updateDrawState(TextPaint tp) {

        tp.setColor(color);

    }

	}




Здесь реализован элемент, получающий параметр явно и отдельно от своего имени. Претензия на своего рода стандарт именования тэгов, раз уж нельзя передавать атрибуты. 





Конечно, всё описанное является вариациями одного принципа, каждый выберёт то, что ему удобнее.





### Вызов Activity





Здесь всё очень просто. Вызов осуществляется посредством использования обычного тэга `` с заданием схемы и хоста, которые описаны в **AndroidManifest.xml** для вызываемой **Activity**.





В HTML мы видим следующее:

	<a href="activity-run://AnotherActivityHost?caption=Another%20Activity&text=Hello%20from%20markup!">Вызвать другую Activity</a> 
  




При нажатии на ссылку, происходит вызов AnotherActivity с передачей параметров в Intent. Эти параметры можно получить и использовать:

	Uri uri = getIntent().getData();
	String caption = uri.getQueryParameter("caption");
	String text = uri.getQueryParameter("text");
  




### Использованные материалы





Следующие материалы очень ускорили создание данной статьи, да и, чего уж там, сделали его вообще возможным:





[www.sherif.mobi/2011/09/html-and-activity-links-in-textview.html](http://www.sherif.mobi/2011/09/html-and-activity-links-in-textview.html)  
[stackoverflow.com/questions/3874999/alignment-in-html-fromhtml](http://stackoverflow.com/questions/3874999/alignment-in-html-fromhtml)  
[stackoverflow.com/questions/11865334/how-to-use-xmlreader-in-taghandler-handletag](http://stackoverflow.com/questions/11865334/how-to-use-xmlreader-in-taghandler-handletag)  
[stackoverflow.com/questions/4044509/android-how-to-use-the-html-taghandler](http://stackoverflow.com/questions/4044509/android-how-to-use-the-html-taghandler)  
[stackoverflow.com/questions/1792604/html-imagegetter](http://stackoverflow.com/questions/1792604/html-imagegetter)





Я очень рад, что существует на свете [StackOverflow.com](http://stackoverflow.com/).





Надеюсь статья вам пригодится и вы теперь не будете плодить много елементов.





Рабочий код на странице с [кодами](http://android-helper.com.ua/codes/).




Продолжая тему своего маркета.





Нашел еще одну интересную статью.





Хорошая новость для пользователей [Google Apps for Business](http://www.google.com/enterprise/apps/business/#utm_medium=blog&utm_source=en-na-us-entblog-playprivatechannel12042012&utm_campaign=launch), [Education](http://www.google.com/enterprise/apps/education/#utm_medium=blog&utm_source=en-na-us-entblog-playprivatechannel12042012&utm_campaign=launch) и [Government](http://www.google.com/enterprise/apps/government/#utm_medium=blog&utm_source=en-na-us-entblog-playprivatechannel12042012&utm_campaign=launch) была опубликована в[блоге Google](http://googleenterprise.blogspot.com/2012/12/a-new-way-to-distribute-your-internal.html). Отныне в Google Play можно создавать корпоративные каналы обновлений и распространять через них внутренние приложения для своих работников.  
  
![](http://habrastorage.org/storage2/cc9/d98/20b/cc9d9820bcd9d9662370983f3c2e6b97.png)  
  
  
  






##### Как это работает





  
Каждый домен Google Apps for Business теперь может иметь приватный канал в Play Store. Администраторы домена могут давать пользователем права на публикацию приложений в консоли разработчика, а также настраивать доступ к каналу в Play Store для отдельных пользователей и групп.  
  
Чтобы увидеть этот канал на девайсе, пользователям нужно войти в Play с помощью своего корпоративного аккаунта.  
  






##### Как включить





  
Администраторы Google Apps могут включить канал в панели управления:








  * В разделе **Organizations & users > Services** нужно включить **Google Play Developer Console**.



  * Для группы пользователей, которым следует разрешить публикацию, нужно:  





    * В **Settings > Mobile** разрешить обновлять **Google Play Private Channel**



    * В **Organizations & users > Services** включить для них **Google Play Developer Console**








  * Остальным пользователям нужно дать доступ к Google Play Private Channel






  
  






##### Дополнительная информация












  * Канал виден только из девайсов и пока что недоступен для веб-интерфейса



  * Каждый девелопер должен проходить обычную регистрацию в консоли разработчика (за $25)



  * Для приложений в приватном канале доступны рейтинги, отзывы, цены и таргетирование



  * Организация может иметь лишь один приватный канал






  
  
Официальная документация: [http://support.google.com/a/bin/answer.py?hl=en&answer=2494992](http://support.google.com/a/bin/answer.py?hl=en&answer=2494992)
Сегодня что то мне не спится.





Хочу побольше дать интересных тем.





Не так много разработчиков выкладывают свои приложения на маркет.


<!-- more -->


Много приложений остается закрытыми в офисной рутине.





Но вот нашел статью, как можно и в офисе организовать свой маркет. Может кому будет полезной.





В рамках работы над большим количеством android приложений появилось желание создать свой Android Market на локальном сервере (с шахматами и поэтессами).  
Свой маркет должен решать две простые задачи:








  * Распространение и обновление корпоративных приложений. У нас есть набор внутри корпоративных приложений, которые нельзя публиковать на Google Play. Сейчас пользователи оповещаются о новых версиях по емайлу, что не удобно.



  * Бета тестирование заказных приложений на большой группе коллег, с обратной связью.






  
  
И так, нам необходимо реализовать небольшое Android приложение, которое будет скачивать список доступных приложений, проверять наличие обновлений для уже установленных, устанавливать/удалять приложения.  






#### Серверная часть





  
Серверной частью приложения может быть как сервис с широким функционалом (регистрация пользователей, отчеты, разграничение доступа к приложениям), так и просто xml файл:



	<MyMarket>

    <application name="TestApp1" 

    package="com.example.testapp1"

    versionCode="1"

    versionName="1.0" 

    url="http://mobile...../android/download/TestApp1.apk"/>

		.....

	</MyMarket>





  
В моем случае серверной частью фактически выступает http шара.  
Данный xml файл в приложении трансформируется в список приложений, доступных для установки.  
  






#### Установка





  
Пользователь выбирает нужное ему приложение и устанавливает,   
Маркет скачивает apk файл на флешку устройства и инициирует установку приложения, конечно, должна быть разрешена установка из сторонних источников.  
Установить незаметно в фоне мы не можем, поэтому после выполнения данного кода:




	URL url = new URL(apkurl);

            HttpURLConnection c = (HttpURLConnection) url.openConnecвленtion();

            c.setRequestMethod("GET");

            c.setDoOutput(true);

            c.connect();



            File file = this.getExternalFilesDir("download");

            File outputFile = new File(file, "app.apk");

            FileOutputStream fos = new FileOutputStream(outputFile);

            InputStream is = c.getInputStream();



            byte[] buffer = new byte[1024];

            int len1 = 0;

            while ((len1 = is.read(buffer)) != -1) {

                fos.write(buffer, 0, len1);

            }

            fos.close();

            is.close();

            

            Intent intent = new Intent(Intent.ACTION_VIEW);

            intent.setDataAndType(Uri.fromFile(outputFile),

                    "application/vnd.android.package-archive");

            startActivity(intent);





  
Пользователь увидит стандартное окно установки приложений:  
![image](http://img-fotki.yandex.ru/get/4117/1154545.a5/0_7d3c3_bd08d241_L)  
  






#### Обновление





  
Приложение Market может по определенному интервалу проверять наличие новых версий, делается это достаточно просто, так как доступен список всех установленных приложений:




	private boolean checkNewVersion(String packageName, int versionCodeNew) {

        List<ApplicationInfo> apps = getPackageManager()

                .getInstalledApplications(0);

        for (int i = 0; i < apps.size(); i++) {

            ApplicationInfo app = apps.get(i);

            if (packageName.equals(app.packageName)) {

                PackageManager manager = getPackageManager();

                PackageInfo info;

                try {

                    info = manager.getPackageInfo(app.packageName, 0);

                    int versionCode = info.versionCode;

                    if (versionCodeNew > versionCode) {

                        Toast.makeText(this, "New Version!", Toast.LENGTH_LONG)

                                .show();

                        return true;

                    }

                } catch (NameNotFoundException e) {

                    e.printStackTrace();

                }

            }

        }

        return false;

    }



  
В случае необходимости обновления приложения, повторяем процесс Установки, приложение будет обновлено.  
  






#### Удаление





  
Удалить программу лучше из интерфейса нашего маркета, чтобы не заставлять пользователя выискивать тестируемое приложение среди всех его программ, для этого достаточно вызвать этот код:



	 Uri packageURI = Uri.parse("package:"+packageName);

        Intent intent = new Intent(Intent.ACTION_DELETE, packageURI);

        startActivity(intent);





  
![image](http://img-fotki.yandex.ru/get/4134/1154545.a5/0_7d3c5_830496a8_L)  
  






#### Обратная связь





  
Получение сообщений об ошибках, вместе с логом ошибки, очень важно для разработчика, особенно на этапе тестирования приложения, добавим функцию автоматического сбора этой информации через Маркет.  
  
Для этого в каждое приложение, распространяемое через наш Маркет добавляем следующий класс




	public class CustomExceptionHandler implements UncaughtExceptionHandler {

    private File logsFolder = null;

    public static final String ERROR_INTENT = "com.example.markettestapp1.SEND_ERROR";

    public CustomExceptionHandler(File logsFolder) {

        this.logsFolder = logsFolder;

    }

    @Override

    public void uncaughtException(Thread thread, Throwable ex) {

        final Writer result = new StringWriter();

        final PrintWriter printWriter = new PrintWriter(result);

        ex.printStackTrace(printWriter);

        String stacktrace = result.toString();

        printWriter.close();

        try {

            if (!logsFolder.exists()) {

                logsFolder.createNewFile();

            }

            BufferedWriter writer = new BufferedWriter(new FileWriter(logsFolder, true));

            writer.write(""+new Date()+"\n"+stacktrace);

            writer.close();

        } catch (IOException e) {

            e.printStackTrace();

        }

        

        Intent intent = new Intent();

        intent.setAction(ERROR_INTENT);

        intent.putExtra("packageName", Test1Application.getApplication().getPackageName());

        intent.putExtra("stacktrace", stacktrace);

        Test1Application.getInstanceApplication().sendBroadcast(intent);

        

        android.os.Process.killProcess(android.os.Process.myPid());

    }

	}


  
Как видно из кода, это хендлер, который получает ошибки (Exception), генерит строку со стеком, сохраняет ее в локальный файл и отправляет ошибку в виде броадкаст сообщения.  
  
А в Application классе включаем переадресацию всех сообщений об ошибках в этот хендлер



	public class Test1Application extends Application {

    @Override

    public void onCreate() {

        super.onCreate();

        application = this;

        Thread.setDefaultUncaughtExceptionHandler(new CustomExceptionHandler(new File(this.getApplicationContext().getExternalFilesDir(null),"exceptions.log")));

    }




  
Таким образом, если в тестируемои приложении происходит ошибка, то перед смертью пишется сообщение в лог и посылается броадкаст сообщение в маркет.,  
Перед передачей приложения заказчику, этот код удаляется (комментируется).  
  
В самом Маркете мы просто отлавливаем данное сообщение:


	public class SendErrorReceiver  extends BroadcastReceiver {

    public static final String ERROR_INTENT = "com.example.markettestapp1.SEND_ERROR";

    @Override

    public void onReceive(Context context, Intent intent) {

        Intent i = new Intent(context, SendErrorActivity.class);

        i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);

        i.putExtra("stacktrace", intent.getStringExtra("stacktrace"));

        i.putExtra("packageName", intent.getStringExtra("packageName"));

        context.startActivity(i);

    }

	}




  
AndroidManifest.xml:


	<receiver android:name="com.example.markettestapp1.SendErrorReceiver" android:enabled="true" >

            <intent-filter>

                <action android:name="com.example.markettestapp1.SEND_ERROR" >

                </action>

            </intent-filter>

        </receiver>





  
  
И дальше маркет уже может переслать это сообщение на почту разработчику, загрузить в какой нибудь веб-сервис или попросить пользователя добавить комментарий к ошибке  
![image](http://img-fotki.yandex.ru/get/4121/1154545.a5/0_7d3c4_5b504bb_L)  
  
Я надеюсь, данный пример поможет многим начинающим разработчикам, разобраться, как написать свой универсальный велосипед для бета тестирования приложений и централизованному сбору статистики ошибок.  
  
ps: В статье использован исходный код и картинки взятые из прототипа приложения.




Привет друзья.





Собирался написать статью по анимации фрагментов, но к счастью она уже написана.





Думаю вам понравится.

 <!-- more -->



Всем доброго времени суток. Этот пост хочу посвятить теме фрагментов для Android. На Хабре есть уже переводы и некоторые статьи, которые упоминают о том, как начать работать с фрагментами под Android. Например, статья [Fragments API в Android 3.0](http://habrahabr.ru/post/113196/). В ней находится описание того, что такое фрагменты и в какой версии Android они доступны, поэтому те, кто ещё не добрался до неё могут при желании ознакомиться, я же не буду пересказывать этого в своём посте. Поэтому сразу перейду к делу.   
  
  






#### Начало работы





  
Скажу только кратко, что фрагменты — это компоненты UI пользователя, которые могут использоваться с помощью класса Activity для отображение пользовательских данных, но их жизненный цикл от него не зависит. Функционал, которым наделены фрагменты имеет более широкий функционал для работы с ними, чем Activity, поэтому их использование для разработчиков имеет не малое значение, если они хотят, чтобы их приложение имело более современный по нынешним нормам интерфейс пользователя.  
  
Теперь перейдём к сути поста. Разработчиками Google фрагменты были наделены, на мой взгляд, отличной поддержкой анимации отображения самого фрагмента. Об этом и пойдёт далее речь. Я искал по Хабру посты на данную тематику, но так ничего и не нашёл, поэтому сейчас поделюсь своими знаниями.   
  






#### Создаём проект





  
Давайте создадим небольшой проект. Я создал проект под свой Samsung Nexus S, там у меня стоит версия Android 4.1.2, собственно её я и использовал (Api Level 16). Сам проект я назвал FragmentsAnimationTest.  
  
Для демонстрации нам понадобится главное активити и его лейаут, пара фрагментов, каждый также со своим лейаутом и ещё пара xml-файлов для самой анимации, о которых я расскажу позже.  
  
Приложение будет выглядеть следующим образом: на экране будет отображаться один из фрагментов, переключение между ними будет осуществляться с помощью обычной кнопки, и, соответственно, само переключение фрагментов будет сопровождаться анимационными эффектами.   
  
Сначала расположим элементы главного активити в файле activity_main.xml:







	<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"

    xmlns:tools="http://schemas.android.com/tools"

    android:layout_width="match_parent"

    android:layout_height="match_parent"

    tools:context=".MainActivity" >



    <FrameLayout

        android:id="@+id/fragCont"

        android:layout_width="wrap_content"

        android:layout_height="match_parent"

        android:layout_weight="1" >

    </FrameLayout>

    

    <Button

        android:id="@+id/btn"

        android:layout_width="wrap_content"

        android:layout_height="wrap_content"

        android:text="SWITCH FRAGMENTS" 

        android:layout_toRightOf="@id/fragCont"/>



	</RelativeLayout>





  
  
Из кода видно, что используется главный лейаут — RelativeLayout, достаточно удобный при работе с фрагментами, в него помещаются два стандартных элемента FrameLayout — собственно, он и будет являться контейнером для фрагментов и кнопка, которой будем переключать фрагменты между собой. Пока что всё должно быть предельно просто.  
  
Дальше займёмся нашими фрагментами. Создадим для них разметки и сами классы:  
fragment1.xml 




	<?xml version="1.0" encoding="utf-8"?>

	<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"

    android:layout_width="match_parent"

    android:layout_height="match_parent"

    android:orientation="vertical" 

    android:background="#5A4">

    

    <TextView 

        android:layout_width="200dp"

        android:layout_height="fill_parent"

        android:text="fragment 1"/>



	</LinearLayout>



  
  
fragment2.xml



	<?xml version="1.0" encoding="utf-8"?>

	<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"

    android:layout_width="match_parent"

    android:layout_height="match_parent"

    android:orientation="vertical" 

    android:background="#A55">

    

    <TextView 

        android:layout_width="200dp"

        android:layout_height="fill_parent"

        android:text="fragment 2"/>



	</LinearLayout>



  
  
Для обоих фрагментов код практически одинаков, отличаются только текстом, который будет отображаться в самом фрагменте для его идентификации и цветом фона, чтобы хорошо было видно анимацию.  
  
Fragment1.java



	public class Fragment1 extends Fragment {



    @Override

    public View onCreateView(LayoutInflater inflater, ViewGroup container, 

                                Bundle savedInstanceState) {

        return inflater.inflate(R.layout.fragment_1, null);

    }

	}





  
  
Fragment2.java



	public class Fragment2 extends Fragment{



    @Override

    public View onCreateView(LayoutInflater inflater, ViewGroup container, 

                                Bundle savedInstanceState) {

        return inflater.inflate(R.layout.fragment_2, null);

    }

	}




  
  
В классах также должно быть всё понятно, если знакомы с темой фрагментов. В них просто указывается какой именно леаут будет использоваться при отображении конкретного фрагмента и всё.  
  
Теперь приступим к самому вкусному. Поработаем с классом главной активити, вот её код:


	public class MainActivity extends Activity {



    private Fragment fragment2;

    private Fragment fragment1;

    private FragmentTransaction ft;



    @Override

    protected void onCreate(Bundle savedInstanceState) {

    super.onCreate(savedInstanceState);

    setContentView(R.layout.activity_main);

    

    fragment1 = new Fragment1();

    fragment2 = new Fragment2();

    ft = getFragmentManager().beginTransaction();

    ft.setCustomAnimations(R.animator.slide_in_left, R.animator.slide_in_right);

//	ft.setTransition(FragmentTransaction.TRANSIT_FRAGMENT_OPEN);

    

    ft.replace(R.id.fragCont, fragment1);

    ft.addToBackStack(null);

    

    ft.commit();

    

    Button btn = (Button) findViewById(R.id.btn);

    btn.setOnClickListener(new OnClickListener() {

        

        @Override

        public void onClick(View v) {

        ft = getFragmentManager().beginTransaction();

        ft.setCustomAnimations(R.animator.slide_in_left, R.animator.slide_in_right);

//		ft.setTransition(FragmentTransaction.TRANSIT_FRAGMENT_OPEN);

        if(fragment1.isVisible()){

            ft.replace(R.id.fragCont, fragment2);

        }else{

            ft.replace(R.id.fragCont, fragment1);

        }

        ft.commit();

        }

    });

    }

	}




  
  
Разберём что именно происходит в нашей активити. Сначала создаются оба фрагмента, которые, как уже говорилось, будут поочерёдно менять друг друга. Далее указываем строкой ft = getFragmentManager().beginTransaction() получаем FragmentTransaction, с помощью которой мы сможем взаимодействовать с нашими фрагментами, но это всё есть в статье, которую я указывал ранее. Прежде, чем перейти к разбору следующего кода, сделаю небольшое отступление.   
  
Существует две возможности создавать анимацию для отображения фрагментов: 








  * 1ый способ — это подключение стандартной анимации с помощью метода setTransition(int transit). В классе FragmentTransaction есть несколько уже предописанных анимаций.



  * 2ой способ — это именно то, что нас интересует в данной теме, реализация кастомной анимации. Осуществляется с помощью метода setCustomAnimations()






  
Теперь вернёмся к разбору нашего кода. Посмотрим на следующую строку ft.setCustomAnimations(R.animator.slide_in_left, R.animator.slide_in_right), тут происходит подключение анимации ко всем фрагментам, с которыми будет происходить работа до завершения транзакции, до строки ft.commit(). Что же именно происходит? В setCustomAnimations передаётся два параметра. Первый параметр описывает анимацию, для отображения фрагмента, который появляется, а второй — описывает анимацию для фрагмента, который сменяется, т.е. убирается с экрана устройства. Важно упомянуть, что данный метод следует вызвать до появления фрагментов, в противном случае, анимация не будет применена.  
  
Пара сток-комментариев — это для того, чтобы можно было попробовать поиграться с предописанной анимацией, достаточно их раскомментировать и закомментировать предыдущую строку — ft.setCustomAnimations(R.animator.slide_in_left, R.animator.slide_in_right), в обоих случаях, хотя это и необязательно.  
  
Давайте разберём код активити до конца и перейдём к созданию самой анимации.  
  
После установки анимации, происходит показ фрагмента, добавление его в стек и завершение транзакции для отображения всех изменений. Потом инициализируем нашу кнопку и прикрепляем к ней слушатель события нажатия кнопки, внутри которого находится код для смены фрагментов, по нажатию кнопки начинаем транзакцию, подключаем анимацию и меняем фрагмент на противоположный показываемому в настоящий момент. Код прост, поэтому глубокого объяснения не требует.  
  






#### Создаём анимацию





  
Перейдём к главной части нашей темы. Научимся создавать саму анимацию. Способ создания анимации здесь немного отличается от того, как мы привыкли это делать в ранних версиях Android. Реализация проходит следующим образом. Для на чала нужно создать папку animator в папке ресурсов приложения, это будет выглядеть так — res/animator/. Сюда мы должны положить xml-файлы, которые будут описывать как именно должна проигрываться анимация. Поместим их туда:  
slide_in_left.xml



	<?xml version="1.0" encoding="utf-8"?>

	<set xmlns:android="http://schemas.android.com/apk/res/android">

  <objectAnimator xmlns:android="http://schemas.android.com/apk/res/android"

    android:interpolator="@android:anim/accelerate_decelerate_interpolator"

    android:propertyName="y" 

    android:valueType="floatType"

    android:valueTo="0" 

    android:valueFrom="-1280"

    android:duration="1500"/>

	</set>


  
  
и slide_in_right.xml


	<?xml version="1.0" encoding="utf-8"?>

	<set xmlns:android="http://schemas.android.com/apk/res/android"

     android:ordering="together">

  

  	<objectAnimator 

      android:interpolator="@android:anim/accelerate_interpolator"

      android:propertyName="alpha"

      android:valueType="floatType"

      android:valueTo="0"

      android:duration="300"/>

    

  	<objectAnimator xmlns:android="http://schemas.android.com/apk/res/android"

    android:interpolator="@android:anim/accelerate_decelerate_interpolator"

    android:propertyName="x" 

    android:valueType="floatType"

    android:valueTo="1280" 

    android:valueFrom="0"

    android:duration="1500"/>  

  

	</set>




  
  
Теперь подробно их разберём. Элементы самих визуальных эффектов описываются в теге objectAnimator, каждый такой тег говорит об описании нового эффекта анимации. Теперь посмотрим на сами атрибуты. Первый атрибут в файле slide_in_left.xml — это interpolator, у него имеется несколько значений, о них можно более подробно узнать из документации [Property Animation](http://developer.android.com/guide/topics/graphics/prop-animation.html#object-animator). Interpolator отвечает за то, чтобы отобразить определённым способом в течении определённого времени наш фрагмент. Далее у нас следует атрибут propertyName, в нём указывается с какое именно свойство фрагмента мы будем изменять при анимации, в нашем примере первым идёт y, а valueType указывает какого типа у нас именяемый параметр. В книге Pro Android 4 аргументируется эта ситуация тем, что если посмотреть на метод setX() в классе View, то станет понятно, что он принимает значение типа float, с методом setY() дело обстоит также, отсюда и значение floatType.   
  
Далее идут не маловажные атрибуты valueFrom и valueTo, они указывают от какого до какого значания изменять значение указаннное в propertyName, в нашем первом случае это y. Если параметр valueFrom не указан, то значение берётся равное текущему. В нашем случае valueFrom равен -1280, это означает, что движение фрагмента по оси y будет начинаться со значения -1280, это значение было выбрано из-за того, что оно находится за пределами экрана устройства и перемещение будет происходить пока значение y не станет равным 0 для верхнего левого угла нашего фрагмента в течении 1500 миллисекунд. И, наконец, duration — атрибут указывает сколько именно будет длиться наш анимированный эффект в миллисекундах.  
  
И последний нюанс, который я хочу описать. Глядя в какой-либо из файлов описания анимации, можно заметить тэг set, в который помещены все эффекты анимации, он служит для объединения эффектов либо их разделения. В файле slide_in_right.xml используется атрибут ordering в теге set, в нашем случае он имеет значение together, что означает проигрывать эффекты одновременно, в противовес ему существует значение sequentially, которое требует последовательного отображения эффектов в анимации, что очень удобно в некоторых случаях.  
  
Собственно и всё. В файле slide_in_right.xml приведен пример как можно использовать другие свойства для анимирования, например alpha-канал. Надеюсь данная статья пригодится тем, кому не всё равно как будет выглядеть его приложение.  
  
Как вы сами понимаете, уважаемые хабраюзеры, скрины не смогут отобразить результат работы.  
  
Литература и источники, которые использовались при написании поста были упомянуты в ходе самой статьи.





Статья из сайта [habrahabr.ru](http://habrahabr.ru/post/162389/)
Друзья всем привет.





Поздравляю всех с Новым годом.





Но не стоит долго отдыхать. И новые статьи уже ждут вас.


<!-- more -->


Сегодня нашел хорошую статью которая упростит вам работу, по внедрению социальных сетей к себе в приложение.





При разработке игрушки для Android'а у меня появилась идея добавить в нее немного социального взаимодействия для охвата большей аудитории. Сама игрушка не располагала к тому, чтобы распространятся «вирусным» способом, поэтому я решил ограничится публикацией результатов игры в социальных сетях в случае выигрыша и при условии попадания результата в локальную таблицу рекордов, и я стал искать решение этого вопроса.  
  
  






##### Выбор социальной сети





  
Я себе поставил задачу публиковать сообщения не во всех социальных сетях сразу, а хотя бы в одной. Выбор встал между соц. сетями «ВКонтакте», «Facebook» и «Twitter». Так как хотелось распространять игру по всему миру, а не только на просторах СНГ, сеть «ВКонтакте» практически сразу была исключена из списка. Выбор между «Facebook» и «Twitter» был сделан просто, и может быть, не совсем объективно — «Facebook» мне не очень нравится, пользоваться я им не люблю из-за, на мой взгляд, крайне неудачного интерфейса, поэтому я решил использовать «Twitter», тем более, что в нем существует возможность интегрировать аккаунт с «Facebook» и дублировать туда сообщения.  
  






##### Поиск способа реализации





  
Искать способ реализовать свою идею я начал с [Twitter4j SDK](http://twitter4j.org/en/index.html). К сожалению, кроме сухой javadoc документации, представляющей собой простое справочное руководство, и отрывочных примеров, там ничего больше не обнаружилось. Также было просмотрено немало тем на stackoverflow.com, но и там ничего подходящего не нашлось (если честно, не хотелось сильно углубляться в дебри TwitterAPI, да и к тому же мои знания Java и платформы Android оставляют желать лучше).  
  






##### Есть идея, есть решение





  
Наконец блуждание в гугле навело меня на статью [Интеграция Android-приложения с Twitter](http://idev.by/android/20828/). Некоторые идеи были не совсем понятны, но код показался достаточно простым, и его автор утверждал, что его решение работает. Потратив немного времени, я адаптировал код автора для своего приложения, и стал проверять его работоспособность. Процедура авторизации проходила (хотя и показалась мне довольно непонятной для обычного, далекого от IT пользователя), но дальше дело не двигалось. Как отсылать сообщения (вернее, в какой момент), я так и не разобрался.  
Также не понравилось, что остается висеть открытый браузер, который вылезает после закрытия моего приложения. Поковырявшись денек, я оставил идею использовать TwitterAPI и стал искать более простое и приятное решение.  
  






##### Самое простое решение





  
Самое простое решение, которое меня вполне удовлетворило, было найдено, более того, оно было в некоторых аспектах даже лучше, чем предыдущее.  
Суть идеи в том, чтобы просто отсылать данные, а куда они будут реально отправлены, решает система и пользователь. Из плюсов — то, что пользователю предоставляется возможность выбрать, куда он хочет отправить сообщение — SMS/MMS, твиттер, фейсбук, в вконтакте, или что-то еще. Я решил, что пользователь наиболее активно пользуется скорее всего только одной из социальных сетей, и ему не понадобится размещать пост в нескольких сетях, к тому же это решение в данном аспекте соответствовало первому варианту. Из минусов данного решения можно отметить то, что у пользователя должно быть установлено соответствующее клиентское приложение (для твиттера в маркете, помимо официального клиента, есть много сторонних). Существование клиента для Фейсбук я не проверял, но полагаю, что оно либо есть, либо появится в довольно ближайшем будущем. Клиент для в ВКонтакте, насколько я в курсе, уже создан (где-то тут была новость о конкурсе на его разработку), и его официальное появление тоже вопрос ближайшего будущего. Также я решил, что пользователь, который достаточно активен в соц. сети для того, чтобы опубликовать там результаты игры, уже озаботился установкой клиента для нее.  
Собственно, само решение — это пять строчек кода, и мне уже стыдно, что я томил читателя своими нудными рассуждениями, вместо того, чтобы сразу опубликовать его:  
  








		// в коде моей Activity

    void shareTextInSocialMedia(String msg)

    {

    	//canShareText();

    	Intent share = new Intent(Intent.ACTION_SEND);

        share.putExtra(Intent.EXTRA_TEXT, msg);

        share.setType("text/plain");

        //startActivity(Intent.createChooser(share, "Share this via"));

        startActivityForResult(Intent.createChooser(share, "Share this via"), 0);

    }    



  
При выполнении приведенного кода возникает список приложений, способных произвести отправку (у меня это Send SMS/MMS и Post to Twitter при установленном твиттер-клиенте), пользователь выбирает нужное приложение, и продолжает работу уже в нем.   
Большой минус — мое приложение закрывается после выполнения этого кода, причем не сразу — в случае твиттер-клиента там сначала можно отредактировать сообщение, и в это время моя программа висела в фоне и играла музыку, и пропала только после нажатия кнопки «Твитнуть». Я попробовал использовать startActivityForResult вместо startActivity, но ничего не изменилось. В случае отправки SMS мое приложение тоже пропало, хотя момент я не засек так же точно. На stackoverflow.com мне сказали, что проблема в твиттер-клиенте («Ah, I see. This is a classic example of application does not respecting Android lifecycle (shame on Twitter)»). Я сначала удовлетворился тем, что от меня тут ничего не зависит, но потом проверил SMS способ, и несколько засомневался, так как он тоже не работал корректно.  
  






##### Бонус для самых упорных





  
Меня несколько напрягало то, что в случае отсутствия приложений, способных обработать отправку сообщения, пользователю будет показано противное сообщение об этом, и я захотел проверить, нужно ли показывать кнопку «Share» в своем приложении, и StackOverflow подсказал мне решение:  
  





		boolean canShareText( boolean allowSmsMms)

    {

        PackageManager manager = getPackageManager();

        List&lt;ResolveInfo&gt; list = manager.queryIntentActivities(createShareIntent(""), 0);



        if (list != null &amp;&amp; list.size() &gt; 0) 

        {

    		if (allowSmsMms) return true;

    		int handlersCount = 0;

    		for (ResolveInfo li : list)

    		{

    			if (li!=null &amp;&amp; li.activityInfo!=null &amp;&amp; li.activityInfo.packageName!=null &amp;&amp; li.activityInfo.packageName=="com.android.mms") {}

    			else

    				++handlersCount;

    		}

    		if (handlersCount&gt;0) return true;

        } 

    	return false;

    }




  
В данном коде перечисляются все доступные способы отправки сообщения, в том числе и с использованием СМС.  
Я решил не показывать кнопку «Share», если доступна отсылка только SMS/MMS, и добавил опциональную возможность проигнорировать это приложение. Имя пакета «com.android.mms» получил во время прогона на эмуляторе, так что возможно не везде будет срабатывать.





Статья из сайта [habrahabr.ru](http://habrahabr.ru/post/164187/)
Всем привет.





Сегодня набрел на Google Play Service. И мне стало интересно, что это такое.





И как его можно применить в разработке.


 <!-- more -->


Нашел очень хорошую статью на [Хабре](http://habrahabr.ru/post/153341/).





На Google I/O 2012 было объявлено о скором появлении на свет некоей «платформы Google Play Services». Платформы для разработчиков, которые жаждут интегрировать сервисы Google в свои приложения.  
  
26 сентября в [блоге на G+](https://plus.google.com/+AndroidDevelopers/posts/J1A5hc1ZnS1) было объявлено о запуске Google Play Services v.1.0  
  






#### Что это?





  
Сервисы Google Play (Google Play Services) — это платформа, предназначенная для интеграции продуктов Google, таких как Google+, в ваши Android-приложения. Платформа Google Play Services состоит из системного сервиса, работающего на устройстве, и тонкого клиента. Тонким клиентом выступает ваше приложение с подключенной клиентской библиотекой. Можно изобразить это так:  
![](http://habrastorage.org/storage2/725/647/caf/725647caf708eb37b4480dddfa7b5c7e.png)  
Google Play Services распространяется в виде обычного приложения через Google Play Store и поэтому независима от вашего оператора связи или производителя устройства. Новые девайсы имеют подержку Google Play Services «с завода». Устройства на платформе Android 2.2 (Froyo) или выше, имеющие доступ к Google Play Store получат обновления в течение ближайших нескольких дней. Это позволит вам использовать новейшие API на подавляющем большинстве устройств в экосистеме Android. Устройства с Android ниже версии 2.2 или не подключенные к Google Play Store не поддерживаются.  
  
Платформа Google Play services содержит бо́льшую часть логики взаимодействия с продуктами Google. Доступ к использованию возможностей платформы предоставляется через простую процедуру аутентификации, которая проста как для разработчика так и для пользователя. Для разработчика процедура заключается в вызове пары методов клиентской библиотеки, а остальную работу за него выполнят компоненты Google Play services. Для пользователя приложения процедура аутентификации — это несколько кликов.  
  






#### Компоненты Google Play services





  
Google Play services 1.0 включает в себя следующие компоненты и API:








  * OAuth 2.0 аутентификация в сервисах Google



  * Google+ sign-in — аутентификация с помощью аккаунта G+



  * Гугло-кнопка +1 в вашем приложении






  
Не густо, конечно, но обещают развивать и дополнять платформу новыми сервисами и API  
  
Подробности по установке, использованию и вообще есть [здесь](https://developers.google.com/android/google-play-services/).





Сейчас думаю как же его можно использовать в своих программах.





Жду предложений в комментариях.
Всем привет.





Как истинный программист, не сижу на месте, а постоянно развиваюсь.





И что бы доносить вам ценную информацию, я читаю много сайтов.





Но к сожалению, не могу все переработать сам.

<!-- more -->



Поэтому просто выставляю интересные статьи на блоге.





Речь пойдет о PhoneGap.





![](http://android-helper.com.ua/images/uploads/2012/12/завантаження.jpg)



Что это такое и для чего оно надо. Спросите вы.





Но постойте, ведь много программистов никогда не писали на java. А свои приложения хотят показать всему миру.





И тут на помощь им приходить движек PhoneGap.





На этом движке пишут приложения на HTML5 + JavaScript + CSS.





Не буду вас долго мучат. Сразу к делу.





1. Создаем проект





2. Подготавливаем проект





Из архива, который можно скачать [тут](http://phonegap.com/download), нам понадобится:








  1. Файл cordova-2.2.0.jar из lib/android копируем в libs



  2. Файл cordova-2.2.0.js из lib/android копируем в assets/www



  3. Каталог xml из lib/android копируем в res






3. Теперь меняем код главного Activity:


	package com.android_helper.phonegap1;

	import org.apache.cordova.DroidGap;

	import android.os.Bundle;

	public class MainActivity extends DroidGap {



	@Override

	public void onCreate(Bundle savedInstanceState) {

		super.onCreate(savedInstanceState);

		super.loadUrl("file:///android_asset/www/index.html");

	}

	}








Тут мы изменили имя абстрактного предка на DroidGap, убрали метод setContentView, который устанавливал "андроидную" разметку и выполнили загрузку локальной html-страницы, в которой дальше все и будет происходить. Кстати и создадим её в каталоге assets/www/index.html:


	<!DOCTYPE html>

	<html>

  	<head>

   	 <title>Device Properties Example</title>



    	<script type="text/javascript" charset="utf-8" src="cordova-2.0.0.js"></script>

    	<script type="text/javascript" charset="utf-8">



    	// Wait for Cordova to load

    	//

    	document.addEventListener("deviceready", onDeviceReady, false);



    	// Cordova is ready

    	//

   	 function onDeviceReady() {

        var element = document.getElementById('deviceProperties');



        element.innerHTML = 'Device Name: '     + device.name     + '<br />' + 

                            'Device Cordova: '  + device.cordova  + '<br />' + 

                            'Device Platform: ' + device.platform + '<br />' + 

                            'Device UUID: '     + device.uuid     + '<br />' + 

                            'Device Version: '  + device.version  + '<br />';

    	}



    	</script>

 	 </head>

  	<body>

    	<p id="deviceProperties">Loading device properties...</p>

  	</body>

	</html>





4. Добавляем разрешения (permission) в AndroidManifest.xml



		<manifest xmlns:android="http://schemas.android.com/apk/res/android"

		package="com.android_helper.phonegap1"

		android:versionCode="1"

		android:versionName="1.0" >



		<supports-screens

		android:anyDensity="true"

		android:largeScreens="true"

		android:normalScreens="true"

		android:resizeable="true"

		android:smallScreens="true" />



		<uses-sdk

		android:minSdkVersion="8"

		android:targetSdkVersion="15" />



		<uses-permission android:name="android.permission.VIBRATE" />

		<uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />

		<uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />

		<uses-permission android:name="android.permission.ACCESS_LOCATION_EXTRA_COMMANDS" />

		<uses-permission android:name="android.permission.READ_PHONE_STATE" />

		<uses-permission android:name="android.permission.INTERNET" />

		<uses-permission android:name="android.permission.RECEIVE_SMS" />

		<uses-permission android:name="android.permission.RECORD_AUDIO" />

		<uses-permission android:name="android.permission.MODIFY_AUDIO_SETTINGS" />

		<uses-permission android:name="android.permission.READ_CONTACTS" />

		<uses-permission android:name="android.permission.WRITE_CONTACTS" />

		<uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />

		<uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />

		<uses-permission android:name="android.permission.GET_ACCOUNTS" />

		<uses-permission android:name="android.permission.BROADCAST_STICKY" />



		<application

		android:icon="@drawable/ic_launcher"

		android:label="@string/app_name"

		android:theme="@style/AppTheme" >

		<activity

			android:name=".MainActivity"

			android:configChanges="orientation|keyboardHidden"

			android:label="@string/title_activity_main" >

			<intent-filter>

				<action android:name="android.intent.action.MAIN" />



				<category android:name="android.intent.category.LAUNCHER" />

			</intent-filter>

		</activity>

	</application>



	</manifest>





Рекомендую убрать те которыми не пользуетесь. Ведь при установке приложения пользователь уйдет в астрал. И подумает, что ваше приложение шпион. :)





Ну вот и все.





Запускаем и смотрим.





![](http://android-helper.com.ua/images/uploads/2012/12/Screenshot-5554-dev22-1.png)



Рабочий код на странице с [кодами](http://android-helper.com.ua/codes/).





Понравилось, нажми лайк и расскажи своим друзьям.




Всем привет.





Когда разрабатываешь хорошее приложение. Часто бывает нужно сделать красивые отделения между элементами.





Что бы долго не говорить посмотрите ниже:





![](http://android-helper.com.ua/images/uploads/2012/12/img-1024x564.jpg)


 <!-- more -->
 





Каждый программист ищет свои пути решения данной задачи.





Я же хочу показать вам как это делать с помощью обычного adapter.





Смотрим результат:



{% youtube GHpLuRLujOk %}





Приступим:





**MultipleItemsList**:

		@Override

    public void onCreate(Bundle savedInstanceState) {

        super.onCreate(savedInstanceState);

        mAdapter = new MyCustomAdapter();

        for (int i = 1; i < 50; i++) {

            mAdapter.addItem("item " + i);

            if (i % 4 == 0) {

                mAdapter.addSeparatorItem("separator " + i);

            }

        }

        setListAdapter(mAdapter);

    }




Сам адаптер **MyCustomAdapter:**

	private class MyCustomAdapter extends BaseAdapter {



        private static final int TYPE_ITEM = 0;

        private static final int TYPE_SEPARATOR = 1;

        private static final int TYPE_MAX_COUNT = TYPE_SEPARATOR + 1;



        private ArrayList<String> mData = new ArrayList<String>();

        private LayoutInflater mInflater;



        private TreeSet<Integer> mSeparatorsSet = new TreeSet<Integer>();



        public MyCustomAdapter() {

            mInflater = (LayoutInflater)getSystemService(Context.LAYOUT_INFLATER_SERVICE);

        }



        public void addItem(final String item) {

            mData.add(item);

            notifyDataSetChanged();

        }



        public void addSeparatorItem(final String item) {

            mData.add(item);

            // save separator position

            mSeparatorsSet.add(mData.size() - 1);

            notifyDataSetChanged();

        }



        @Override

        public int getItemViewType(int position) {

            return mSeparatorsSet.contains(position) ? TYPE_SEPARATOR : TYPE_ITEM;

        }



        @Override

        public int getViewTypeCount() {

            return TYPE_MAX_COUNT;

        }



        @Override

        public int getCount() {

            return mData.size();

        }



        @Override

        public String getItem(int position) {

            return mData.get(position);

        }



        @Override

        public long getItemId(int position) {

            return position;

        }



        @Override

        public View getView(int position, View convertView, ViewGroup parent) {

            ViewHolder holder = null;

            int type = getItemViewType(position);

            System.out.println("getView " + position + " " + convertView + " type = " + type);

            if (convertView == null) {

                holder = new ViewHolder();

                switch (type) {

                    case TYPE_ITEM:

                        convertView = mInflater.inflate(R.layout.item1, null);

                        holder.textView = (TextView)convertView.findViewById(R.id.text);

                        break;

                    case TYPE_SEPARATOR:

                        convertView = mInflater.inflate(R.layout.item2, null);

                        holder.textView = (TextView)convertView.findViewById(R.id.textSeparator);

                        break;

                }

                convertView.setTag(holder);

            } else {

                holder = (ViewHolder)convertView.getTag();

            }

            holder.textView.setText(mData.get(position));

            return convertView;

        }



    }



    public static class ViewHolder {

        public TextView textView;

    }


Вот и все.





Понравилось? Расскажи своим друзьям.





Рабочий код на странице с [кодами](http://android-helper.com.ua/codes/).
Всем привет.





К одной статье мне прислали комментарий.





Благодаря ему, я написал данную статью.





Как видно из названия, то речь пойдет о **WebView**


 <!-- more -->


Кода много не будет, так как вы всегда можете скачать готовый проект на нашей странице с кодами.





Рассмотрим два варианта загрузки html страницы в WebView








  1. **Локальный файл**



  2. **Веб-страница (на примере http://android-helper.com.ua/)**






#### Локальный файл





		WebView mWebView = (WebView) myView.findViewById(R.id.web);



		WebSettings settings = mWebView.getSettings();

		settings.setJavaScriptEnabled(true);

		settings.setDefaultTextEncodingName("utf-8");

		settings.setDefaultZoom(WebSettings.ZoomDensity.MEDIUM);



		mWebView.loadUrl("file:///android_asset/www/index.html");





#### Веб-страница (на примере http://android-helper.com.ua/)






		WebView mWebView = (WebView) myView.findViewById(R.id.web);



		WebSettings settings = mWebView.getSettings();

		settings.setJavaScriptEnabled(true);

		settings.setDefaultTextEncodingName("utf-8");

		settings.setDefaultZoom(WebSettings.ZoomDensity.MEDIUM);

		mWebView.loadUrl("http://android-helper.com.ua");







Напомню, что скачать полный пример вы можете на странице с [кодами](http://android-helper.com.ua/codes/).
Всем привет.





Пока я готовлюсь к вебинару. Времени на написание статей не хватает.





Именно это меня провоцирует брать готовый материал из чужих сайтов.





Сегодня речь пойдет о динамическом размещении элементов на action bar.


 <!-- more -->


В этом уроке:





- программно размещаем элементы в ActionBar  
- используем элементы из фрагментов





Недавно на форуме был вопрос о том, как во время работы программы менять содержимое ActionBar. Тема действительно интересная, и незаслуженно мною пропущенная. В этом уроке будем с ней разбираться.





Опробуем три способа работы с элементами:





1) Добавление/удаление MenuItem в объект Menu





2) Показ/скрытие группы в Menu





3) Элементы, относящиеся к фрагментам





С первыми двумя пунктами все понятно, эти механизмы мы рассматривали еще в Уроке 14.





Более интересен третий пункт. Фрагмент может реализовать в себе метод[onCreateOptionsMenu](http://developer.android.com/reference/android/app/Fragment.html#onCreateOptionsMenu(android.view.Menu, android.view.MenuInflater)) и, тем самым, создать свои элементы для ActionBar. Как только фрагмент будет добавлен на экран, эти элементы добавятся в ActionBar. А когда фрагмент с экрана уберут, элементы исчезнут.





Создадим приложение, которое реализует три этих варианта.





Добавим строки в **strings.xml**:



	<?xml version="1.0" encoding="utf-8"?>

	<resources>



    <string name="add_del">Добавить/удалить</string>

    <string name="visible">Показать/скрыть</string>

    <string name="fragment">Фрагмент</string>

    <string name="frag1_text">Fragment 1</string>

    <string name="frag2_text">Fragment 2</string>

    <string name="menu_item1">Item 1</string>

    <string name="menu_item2">Item 2</string>

    <string name="menu_item31">Item 31</string>

    <string name="menu_item32">Item 32</string>



	</resources>


Создадим два фрагмента. Начнем с layout-файлов.





**fragment1.xml**:


	<?xml version="1.0" encoding="utf-8"?>

	<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"

    android:layout_width="match_parent"

    android:layout_height="match_parent"

    android:background="#77ff0000"

    android:orientation="vertical" >



    <TextView

        android:layout_width="wrap_content"

        android:layout_height="wrap_content"

        android:text="@string/frag1_text" >

    </TextView>



	</LinearLayout>





**fragment2.xml**:


	<?xml version="1.0" encoding="utf-8"?>

	<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"

    android:layout_width="match_parent"

    android:layout_height="match_parent"

    android:background="#7700ff00"

    android:orientation="vertical" >



    <TextView

        android:layout_width="wrap_content"

        android:layout_height="wrap_content"

        android:text="@string/frag2_text" >

    </TextView>



	</LinearLayout>


Файлы с пунктами меню (они же - элементы ActionBar):





**res/menu/fragment1.xml**:



	<?xml version="1.0" encoding="utf-8"?>

	<menu xmlns:android="http://schemas.android.com/apk/res/android" >



    <item

        android:id="@+id/frag1_item"

        android:icon="@android:drawable/ic_dialog_info"

        android:showAsAction="ifRoom|withText"

        android:title="@string/menu_item31">

    </item>



	</menu>



**res/menu/fragment2.xml**:



	<?xml version="1.0" encoding="utf-8"?>

	<menu xmlns:android="http://schemas.android.com/apk/res/android" >



    <item

        android:id="@+id/frag2_item"

        android:icon="@android:drawable/ic_dialog_email"

        android:showAsAction="ifRoom|withText"

        android:title="@string/menu_item32">

    </item>



	</menu>




По одному элементу для каждого фрагмента. Эти элементы будут появляться в ActionBar при выводе фрагмента на экран.





Классы.





**Fragment1.java**:



	public class Fragment1 extends Fragment {

		public void onCreate(Bundle savedInstanceState) {

		setHasOptionsMenu(true);

		super.onCreate(savedInstanceState);

		}



	public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {

		return inflater.inflate(R.layout.fragment1, null);

	}



	public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {

		inflater.inflate(R.menu.fragment1, menu);

		super.onCreateOptionsMenu(menu, inflater);

	}



	}





**Fragment2.java**:



	public class Fragment2 extends Fragment {

	public void onCreate(Bundle savedInstanceState) {

		setHasOptionsMenu(true);

		super.onCreate(savedInstanceState);

	}



	public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {

		return inflater.inflate(R.layout.fragment2, null);

	}



	public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {

		inflater.inflate(R.menu.fragment2, menu);

		super.onCreateOptionsMenu(menu, inflater);

	}

	}



В **onCreate **с помощью [setHasOptionsMenu](http://developer.android.com/reference/android/app/Fragment.html#setHasOptionsMenu(boolean)) включаем режим вывода элементов фрагмента в ActionBar.





В **onCreateView **создаем View, в **onCreateOptionsMenu **– меню. Все как обычно.





Фрагменты готовы.





Теперь займемся Activity. Перепишем **res/layout/main.xml**:




	<?xml version="1.0" encoding="utf-8"?>

	<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"

    xmlns:tools="http://schemas.android.com/tools"

    android:id="@+id/LinearLayout1"

    android:layout_width="match_parent"

    android:layout_height="match_parent"

    android:orientation="vertical" >



    <CheckBox

        android:id="@+id/chbAddDel"

        android:layout_width="wrap_content"

        android:layout_height="wrap_content"

        android:onClick="onClick"

        android:text="@string/add_del" >

    </CheckBox>



    <CheckBox

        android:id="@+id/chbVisible"

        android:layout_width="wrap_content"

        android:layout_height="wrap_content"

        android:onClick="onClick"

        android:text="@string/visible" >

    </CheckBox>



    <Button

        android:id="@+id/btnFrag"

        android:layout_width="wrap_content"

        android:layout_height="wrap_content"

        android:onClick="onClick"

        android:text="@string/fragment" >

    </Button>



    <FrameLayout

        android:id="@+id/cont"

        android:layout_width="match_parent"

        android:layout_height="match_parent" >

    </FrameLayout>



	</LinearLayout>





Два чекбокса и кнопка. Чекбоксы отвечают за работу с элементами с помощью первого и второго способов. Кнопка будет показывать поочередно два фрагмента в контейнере cont.





**res/menu/main.xml**:


	<menu xmlns:android="http://schemas.android.com/apk/res/android" >



    <group android:id="@+id/groupVsbl" >

        <item

            android:id="@+id/item2"

            android:icon="@android:drawable/ic_menu_call"

            android:showAsAction="always|withText"

            android:title="@string/menu_item2">

        </item>

    </group>



	</menu>




Создаем группу, а в ней элемент. Эту группу будем скрывать и показывать.





**MainActivity.java**:

	
	public class MainActivity extends FragmentActivity {



	final int MENU_ID = 1;



	CheckBox chbAddDel;

	CheckBox chbVisible;



	Fragment frag1;

	Fragment frag2;

	Fragment frag;



	@Override

	public void onCreate(Bundle savedInstanceState) {

		super.onCreate(savedInstanceState);

		setContentView(R.layout.activity_main);



		chbAddDel = (CheckBox) findViewById(R.id.chbAddDel);

		chbVisible = (CheckBox) findViewById(R.id.chbVisible);



		frag = frag1 = new Fragment1();

		frag2 = new Fragment2();



	}



	@Override

	public boolean onCreateOptionsMenu(Menu menu) {

		getMenuInflater().inflate(R.menu.activity_main, menu);

		menu.setGroupVisible(R.id.groupVsbl, chbVisible.isChecked());

		if (chbAddDel.isChecked()) {

			menu.add(0, MENU_ID, 0, R.string.menu_item1).setIcon(android.R.drawable.ic_delete)

					.setShowAsAction(MenuItem.SHOW_AS_ACTION_ALWAYS | MenuItem.SHOW_AS_ACTION_WITH_TEXT);

		} else {

			menu.removeItem(MENU_ID);

		}

		return true;

	}



	public void onClick(View view) {

		switch (view.getId()) {

			case R.id.chbAddDel:

			case R.id.chbVisible:

				invalidateOptionsMenu();

				break;

			case R.id.btnFrag:

				frag = (frag == frag1) ? frag2 : frag1;

				getSupportFragmentManager().beginTransaction().replace(R.id.cont, frag).commit();

				break;

			default:

				break;

		}



	}

	}


В **onCreateOptionsMenu **настраиваем видимость группы groupVsbl в зависимости от значения чекбокса chbVisible.





В зависимости от значения чекбокса chbAddDel создаем или удаляем элемент.





В **onСlick **для чекбоксов вызываем метод [invalidateOptionsMenu](http://developer.android.com/reference/android/app/Activity.html#invalidateOptionsMenu()) - перерисовка меню/ActionBar. А по нажатию на кнопку поочередно выводим на экран Fragment1 или Fragment2.





Все сохраняем и запускаем приложение.





![](http://startandroid.ru/images/stories/lessons/L0112/L0112_010.JPG)





Жмем галку **Добавить/удалить**. Появляется элемент. Мы добавили MenuItem в Menu.





![](http://startandroid.ru/images/stories/lessons/L0112/L0112_020.JPG)





Жмем галку **Показать/скрыть**. Появляется элемент. Мы показали группу меню, в которой один пункт.





![](http://startandroid.ru/images/stories/lessons/L0112/L0112_030.JPG)





Соответственно, убирая галки - убираете элементы.





Понажимаем кнопку **Фрагмент**. Появляется элемент то одного, то другого фрагмента.





![](http://startandroid.ru/images/stories/lessons/L0112/L0112_040.JPG)





![](http://startandroid.ru/images/stories/lessons/L0112/L0112_050.JPG)





Еще, как вариант, можно играться с видимостью не всей группы, а конкретного элемента - метод [setVisible](http://developer.android.com/reference/android/view/MenuItem.html#setVisible(boolean)).





Если в ActionBar нажать на overflow-кнопку, будет вызван метод onPrepareOptionsMenu для Activity и для фрагмента, который сейчас отображен. 





Надеюсь статья вам поможет.





Полный проект вы можете скачать на [странице с кодами](http://android-helper.com.ua/codes/).
Всем привет.





Как много мы с вами видим разного рода красивых дизайнов, где с помощью пальца, можно менять не только экран но и Tabs.





Более подробно мы с вами остановимся на реализации данной задачи.


  <!-- more -->


Как вы поняли из названия статьи, мы будем использовать **PagerTabStrip**





Решил долго ничего не придумывать и записал видео как это сделать:









Теперь сам код:





**activity_main.xml**



	<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"

		xmlns:tools="http://schemas.android.com/tools"

		android:layout_width="fill_parent"

		android:layout_height="fill_parent"

		android:orientation="vertical" >



		<android.support.v4.view.ViewPager

			android:id="@+id/viewpager"

			android:layout_width="fill_parent"

			android:layout_height="fill_parent" >



			<android.support.v4.view.PagerTabStrip

				android:id="@+id/pagerTabStrip"

				android:layout_width="wrap_content"

				android:layout_height="wrap_content"

				android:layout_gravity="top"

				android:background="#a22c2e" />

		</android.support.v4.view.ViewPager>



	</RelativeLayout>


**fragment_default.xml**


	<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"

	android:layout_width="fill_parent"

	android:layout_height="fill_parent" >



	<TextView

		android:id="@+id/text"

		android:layout_width="wrap_content"

		android:layout_height="wrap_content"

		android:layout_gravity="center"

		android:text="Test" />



	</FrameLayout>



**MainActivity**



	public class MainActivity extends FragmentActivity {



		private ViewPager mViewPager;



		@Override

		public void onCreate(Bundle savedInstanceState) {

			super.onCreate(savedInstanceState);

			setContentView(R.layout.activity_main);



			mViewPager = (ViewPager) findViewById(R.id.viewpager);

			PagerTabStrip pagerTabStrip = (PagerTabStrip) findViewById(R.id.pagerTabStrip);

			// pagerTabStrip.setTextColor(color.white);

			// pagerTabStrip.setTabIndicatorColor(color.holo_red_dark);



			TitleAdapter titleAdapter = new TitleAdapter(getSupportFragmentManager());

			mViewPager.setAdapter(titleAdapter);

			mViewPager.setCurrentItem(0);

		}



		@Override

		public boolean onCreateOptionsMenu(Menu menu) {

			getMenuInflater().inflate(R.menu.activity_main, menu);

			return true;

		}

	}







**TitleAdapter**


	public class TitleAdapter extends FragmentPagerAdapter {

	private final String titles[] = new String[] { "View1", "View2", "View3" };

	private final Fragment frags[] = new Fragment[titles.length];



	public TitleAdapter(FragmentManager fm) {

		super(fm);

		frags[0] = new FragmentView1();

		frags[1] = new FragmentView2();

		frags[2] = new FragmentView3();

	}



	@Override

	public CharSequence getPageTitle(int position) {

		Log.v("TitleAdapter - getPageTitle=", titles[position]);

		return titles[position];

	}



	@Override

	public Fragment getItem(int position) {

		Log.v("TitleAdapter - getItem=", String.valueOf(position));

		return frags[position];

	}



	@Override

	public int getCount() {

		return frags.length;

	}

	}


**FragmentView1**


	public class FragmentView1 extends Fragment {

	@Override

	public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {

		View myView = inflater.inflate(R.layout.fragment_default, container, false);

		TextView text = (TextView) myView.findViewById(R.id.text);

		text.setText("Fragment View 1\n - Пример для android-helper.com.ua");

		return myView;

	}



}


**FragmentView2**


	public class FragmentView2 extends Fragment {

	@Override

	public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {

		View myView = inflater.inflate(R.layout.fragment_default, container, false);

		TextView text = (TextView) myView.findViewById(R.id.text);

		text.setText("Fragment View 2\n - Пример для android-helper.com.ua");

		return myView;

	}



	}




**FragmentView3**




	public class FragmentView2 extends Fragment {

	@Override

	public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {

		View myView = inflater.inflate(R.layout.fragment_default, container, false);

		TextView text = (TextView) myView.findViewById(R.id.text);

		text.setText("Fragment View 3\n - Пример для android-helper.com.ua");

		return myView;

	}



	}


Полный проект вы можете скачать на [странице с кодами](http://android-helper.com.ua/codes/).





Надеюсь вам понравилась статья.





Пишите ваши комментарии и подписывайтесь на обновления.
Всем привет.





Очень часто у разработчика встает вопрос - "Как же просмотреть какие запросы идут на сервер?".





Сегодня я постараюсь на него ответить.


 <!-- more -->


1. Для мониторинга трафика используйте программу [Fiddler](http://www.fiddler2.com/fiddler2/). Скачиваем и устанавливаем его.





2. Запускаем Fiddler. Заходим в Tools/Fiddler options/Connections. И ставим галочку "allow remote computers to connect". И перегружаем Fiddler.





![](http://android-helper.com.ua/images/uploads/2012/11/blog_fiddler.jpg)





3. Смотрим ваш внутренний IP адрес. Для этого открываем cmd и там пишем ipconfig





4. Для того что бы все работало. Компьютер и телефон должны быть в одной сети.





Не обязательно что бы ноутбук раздавал WiFi. У меня все работает через точку доступа.





5. Заходим в настройки WiFi. И прописываем прокси (IP вашего компьютера) и порт 8888 (такой как на картинке выше)





6. Наслаждаемся просмотром.





Короткий видео ролик, как это работает.

{% youtube Aoa38hbneSs %}


Всем привет.





Продолжаю собирать полезную информацию по программированию.





Сегодня хотел поделиться с вами работой DialogFragment.


<!-- more -->


Продолжаем рассматривать наследников Fragment. [DialogFragment](http://developer.android.com/reference/android/app/DialogFragment.html) – отличается от обычного фрагмента тем, что отображается как диалог и имеет соответствующие методы.





Построить диалог можно двумя способами: используя свой layout-файл и через AlertDialog.Builder. Нарисуем приложение, которое будет вызывать два диалога, построенных разными способами.









Создадим проект:





**Project name**: P1101_DialogFragment  
**Build Target**: Android 4.1   
**Application name**: DialogFragment  
**Package name**: ru.startandroid.develop.p1101dialogfragment  
**Create Activity**: MainActivity









Добавим строки в **strings.xml**:




	<string name="dialog_1">Dialog 1</string>

	<string name="dialog_2">Dialog 2</string>

	<string name="message_text">Text of your message</string>

	<string name="yes">Yes</string>

	<string name="no">No</string>

	<string name="maybe">Maybe</string>








Мы будем создавать два диалога, соответственно нам понадобятся два фрагмента.





Создадим layout-файл для первого фрагмента.





**dialog1.xml**:


	<?xml version="1.0" encoding="utf-8"?>

	<LinearLayout

 	xmlns:android="http://schemas.android.com/apk/res/android"

 	android:layout_width="wrap_content"

 	android:layout_height="match_parent"

 	android:orientation="vertical">

	<TextView

 	android:id="@+id/textView1"

 	android:layout_width="wrap_content"

 	android:layout_height="wrap_content"

 	android:layout_gravity="center"

 	android:layout_margin="20dp"

 	android:text="@string/message_text"

 	android:textAppearance="?android:attr/textAppearanceLarge">

	</TextView>

	<LinearLayout

 	android:layout_width="wrap_content"

 	android:layout_height="wrap_content">

	<Button

 	android:id="@+id/btnYes"

 	android:layout_width="wrap_content"

 	android:layout_height="wrap_content"

 	android:layout_margin="10dp"

 	android:text="@string/yes">

	</Button>

	<Button

 	android:id="@+id/btnNo"

 	android:layout_width="wrap_content"

 	android:layout_height="wrap_content"

 	android:layout_margin="10dp"

 	android:text="@string/no">

	</Button>

	<Button

 	android:id="@+id/btnMaybe"

 	android:layout_width="wrap_content"

 	android:layout_height="wrap_content"

 	android:layout_margin="10dp"

 	android:text="@string/maybe">

	</Button>

	</LinearLayout>

	</LinearLayout>




Так будет выглядеть наш диалог – текст сообщения и три кнопки.









Создаем класс **Dialog1.java**:

	package com.example.dialogfragments;



	import android.content.DialogInterface;

	import android.os.Bundle;

	import android.support.v4.app.DialogFragment;

	import android.util.Log;

	import android.view.LayoutInflater;

	import android.view.View;

	import android.view.View.OnClickListener;

	import android.view.ViewGroup;

	import android.widget.Button;



	public class Dialog1 extends DialogFragment implements OnClickListener {



		final String LOG_TAG = "myLogs";



		@Override

		public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {

		getDialog().setTitle("Title!");

		View v = inflater.inflate(R.layout.dialog1, null);

		v.findViewById(R.id.btnYes).setOnClickListener(this);

		v.findViewById(R.id.btnNo).setOnClickListener(this);

		v.findViewById(R.id.btnMaybe).setOnClickListener(this);

		return v;

		}



		public void onClick(View v) {

		Log.d(LOG_TAG, "Dialog 1: " + ((Button) v).getText());

		dismiss();

		}



		@Override

		public void onDismiss(DialogInterface dialog) {

		super.onDismiss(dialog);

		Log.d(LOG_TAG, "Dialog 1: onDismiss");

		}



		@Override

		public void onCancel(DialogInterface dialog) {

		super.onCancel(dialog);

		Log.d(LOG_TAG, "Dialog 1: onCancel");

		}

	}





В **onCreateView** мы получаем объект Dialog с помощью метода [getDialog](http://developer.android.com/reference/android/app/DialogFragment.html#getDialog()) и устанавливаем заголовок диалога. Далее мы создаем view из layout, находим в нем кнопки и ставим им текущий фрагмент в качестве обработчика.





В **onClick** выводим в лог текст нажатой кнопки и сами явно закрываем диалог методом [dismiss](http://developer.android.com/reference/android/app/DialogFragment.html#dismiss()).





Метод [onDismiss](http://developer.android.com/reference/android/app/DialogFragment.html#onDismiss(android.content.DialogInterface)) срабатывает, когда диалог закрывается. Пишем об этом в лог.





Метод [onCancel](http://developer.android.com/reference/android/app/DialogFragment.html#onCancel(android.content.DialogInterface)) срабатывает, когда диалог отменяют кнопкой Назад. Пишем об этом в лог.









Создаем второй фрагмент. Здесь мы будем строить диалог с помощью билдера, поэтому layout-файл не понадобится. Создаем только класс **Dialog2.java**:


	package com.example.dialogfragments;



	import android.app.AlertDialog;

	import android.app.Dialog;

	import android.content.DialogInterface;

	import android.content.DialogInterface.OnClickListener;

	import android.os.Bundle;

	import android.support.v4.app.DialogFragment;

	import android.util.Log;



	public class Dialog2 extends DialogFragment implements OnClickListener {



	final String LOG_TAG = "myLogs";



	@Override

	public Dialog onCreateDialog(Bundle savedInstanceState) {

		AlertDialog.Builder adb = new AlertDialog.Builder(getActivity()).setTitle("Title!")

				.setPositiveButton(R.string.yes, this).setNegativeButton(R.string.no, this)

				.setNeutralButton(R.string.maybe, this).setMessage(R.string.message_text);

		return adb.create();

	}



	public void onClick(DialogInterface dialog, int which) {

		int i = 0;

		switch (which) {

			case Dialog.BUTTON_POSITIVE:

				i = R.string.yes;

				break;

			case Dialog.BUTTON_NEGATIVE:

				i = R.string.no;

				break;

			case Dialog.BUTTON_NEUTRAL:

				i = R.string.maybe;

				break;

		}

		if (i > 0) {

			Log.d(LOG_TAG, "Dialog 2: " + getResources().getString(i));

		}

	}



	@Override

	public void onDismiss(DialogInterface dialog) {

		super.onDismiss(dialog);

		Log.d(LOG_TAG, "Dialog 2: onDismiss");

	}



	@Override

	public void onCancel(DialogInterface dialog) {

		super.onCancel(dialog);

		Log.d(LOG_TAG, "Dialog 2: onCancel");

	}

	}




Обычно для заполнения фрагмента содержимым мы использовали метод onCreateView. Для создания диалога с помощью билдера используется [onCreateDialog](http://developer.android.com/reference/android/app/DialogFragment.html#onCreateDialog(android.os.Bundle)). Создаем диалог с заголовком, сообщением и тремя кнопками. Обработчиком для кнопок назначаем текущий фрагмент.





В **onClick** определяем, какая кнопка была нажата и выводим соответствующий текст в лог. В случае создания диалога через билдер, диалог сам закроется по нажатию на кнопку, метод dismiss здесь не нужен.





Методы **onDismiss** и **onCancel** – это закрытие и отмена диалога, аналогично первому фрагменту.









Меняем layout-файл для MainActivity - **main.xml**:


	<?xml version="1.0" encoding="utf-8"?>

	<LinearLayout

 	xmlns:android="http://schemas.android.com/apk/res/android"

	xmlns:tools="http://schemas.android.com/tools"

	 android:id="@+id/LinearLayout1"

	 android:layout_width="match_parent"

	 android:layout_height="match_parent"

	 android:orientation="vertical">

	<Button

	 android:id="@+id/btnDlg1"

	 android:layout_width="wrap_content"

	 android:layout_height="wrap_content"

	 android:onClick="onClick"

	 android:text="@string/dialog_1">

	</Button>

	<Button

	 android:id="@+id/btnDlg2"

	 android:layout_width="wrap_content"

	 android:layout_height="wrap_content"

	 android:onClick="onClick"

	 android:text="@string/dialog_2">

	</Button>

	</LinearLayout>







Здесь только две кнопки.









Кодим **MainActivity.java**:



	package com.example.dialogfragments;



	import android.os.Bundle;

	import android.support.v4.app.DialogFragment;

	import android.support.v4.app.FragmentActivity;

	import android.view.View;



	public class MainActivity extends FragmentActivity {



	DialogFragment dlg1;

	DialogFragment dlg2;



	@Override

	public void onCreate(Bundle savedInstanceState) {

		super.onCreate(savedInstanceState);

		setContentView(R.layout.activity_main);

		dlg1 = new Dialog1();

		dlg2 = new Dialog2();

	}



	public void onClick(View v) {

		switch (v.getId()) {

			case R.id.btnDlg1:

				dlg1.show(getSupportFragmentManager(), "dlg1");

				break;

			case R.id.btnDlg2:

				dlg2.show(getSupportFragmentManager(), "dlg2");

				break;

			default:

				break;

		}



	}

	}




Создаем диалоги и запускаем их методом [show](http://developer.android.com/reference/android/app/DialogFragment.html#show(android.app.FragmentManager, java.lang.String)), который на вход требует FragmentManager и строку-тэг. Транзакция и коммит происходят внутри этого метода, нам об этом думать не надо.





Все сохраняем и запускаем приложение.





![](http://startandroid.ru/images/stories/lessons/L0110/L0110_010.JPG)









Жмем **Dialog1**





![](http://startandroid.ru/images/stories/lessons/L0110/L0110_020.JPG)





Отобразился наш простенький диалог.





Жмем какую-нибудь кнопку, например, **Yes **- диалог закрылся. Смотрим логи:





_Dialog 1: Yes  
Dialog 1: onDismiss_





Все верно.









Снова запустим первый диалог и нажмем клавишу **Назад **(**Back**). Смотрим лог:





_Dialog__ 1: __onCancel__  
Dialog 1: onDismiss_





Сработал onCancel – диалог был отменен, и onDismiss – диалог закрылся.





Если мы будем поворачивать экран, то каждый раз будет отрабатывать onDismiss, но диалог снова будет отображен после поворота.









Запустим второй диалог – нажмем кнопку **Dialog 2**.





![](http://startandroid.ru/images/stories/lessons/L0110/L0110_030.JPG)





Отобразился стандартный сконструированный нами диалог. Жмем, например, **No **– диалог закрылся. В логах:





_Dialog 2: No  
Dialog 2: onDismiss_









Снова запустим второй диалог и нажмем **Назад**. В логах:





_Dialog__ 2: __onCancel__  
Dialog 2: onDismiss_





Все так же, как и в первом случае.









Еще несколько слов по теме.





Если вы не хотите, чтобы ваш диалог можно было закрыть кнопкой, используйте для вашего диалог-фрагмента метод [setCancelable](http://developer.android.com/reference/android/app/DialogFragment.html#setCancelable(boolean)) с параметром false.





Есть еще один вариант вызова диалога. Это метод [show](http://developer.android.com/reference/android/app/DialogFragment.html#show(android.app.FragmentTransaction, java.lang.String)), но на вход он уже принимает не FragmentManager, а FragmentTransaction. В этом случае система также сама вызовет commit внутри show, но мы можем предварительно поместить в созданную нами транзакцию какие-либо еще операции или отправить ее в BackStack.





Вы можете использовать диалог-фрагменты, как обычные фрагменты и отображать их на Activity, а не в виде диалога. Но при этом будьте аккуратнее с использованием **getDialog**. Я так понял, что он возвращает null в этом случае.





Если **AlertDialog.Builder** вам незнаком, то посмотрите Урок 60 и несколько следующих за ним. Там достаточно подробно описано, как создавать различные диалоги.





Статья из сайта [startandroid.ru](http://startandroid.ru/uroki/vse-uroki-spiskom/180-urok-110-android-3-fragments-dialogfragment-dialog.html)





Полный проект вы можете скачать на [странице с кодами](http://android-helper.com.ua/codes/).





Пишите ваши комментарии.
Сегодня просматривая свои записи, нашел интересную статью.





В этой статье автор описывает базовые компоненты android.





Думаю, что она будет интересна не только новичкам но и бывалым программерам, которые просто хотят освежить свои знания.





Тогда прошу к прочтению.


 <!-- more -->


Маленькая схема:





![](http://android-helper.com.ua/images/uploads/2012/10/f3ea651c-e042-4c34-b2fc-964b4cd7ae0f.png)








* Приложения для Android состоят из одного или нескольких компонентов: Activities (Деятельности), Services (Службы), Content Providers (Поставщики данных), а также Broadcast Receivers (Получатели широковещательных сообщений).  
  
* Каждый компонент выполняет свою роль в приложении и может быть активирован отдельно от других (причём активирован может быть даже сторонним приложением).  
  
* В AndroidManifest.xml (файл манифеста) должны быть объявлены все компоненты приложения и системные требования, такие как необходимая минимальная версия Android или определённая аппаратная конфигурация.  
  
* Необходимые для приложения ресурсы (изображения, файлы разметки, строки и т.д.) должны содержать альтернативные варианты для различных конфигураций устройств (например, строки на разных языков или различные разметки и изображения для возможных размеров экрана).  
  
  
Данный текст является переводом (хотя и немного вольным) статьи из [официальной документации по Android](http://developer.android.com/guide/topics/fundamentals.html).  
  
Примечание: некоторые слова в тексте оставлены по-английски, потому что, эти термины совпадают с названиями классов с помощью которых они реализуются и их перевод только усложняет понимание (в скобках написан их буквальный перевод).  
  
  
**Основы**  
Android-приложения написаны на языке программирования Java. Инструмент Android SDK (Software Development Kit — комплект разработки программного обеспечения) компилирует код вместе со всеми данными и файлами ресурсов в пакет Android - архивный файл с расширением .apk. Этот файл позволяет установить приложение на любом устройстве под управлением системы Android.  
  
После установки на устройстве, каждое приложение живёт в своей собственной изолированной программной среде:








  * Операционная система Android является многопользовательской Linux-системой, в которой каждое приложение это отдельный пользователь.



  * По умолчанию, система присваивает каждому приложению уникальный идентификатор пользователя userid (который используется только системой). Система устанавливает разрешения для всех файлов приложения таким образом, чтобы только определённый пользователь (с определённым userid) мог получить к ним доступ.



  * Каждый процесс имеет свою собственную виртуальную машину, так что код приложения запускается изолированно от других приложений.



  * По умолчанию каждое приложение выполняется в отдельном процессе Linux. Android начинает процесс, когда одному из компонентов приложения необходимо запуститься, а затем завершает процесс, когда он больше не нужен или когда системе требуется память для других приложений.






Таким образом, система Android реализует принцип наименьших привилегий. То есть, каждое приложение по умолчанию имеет доступ только к компонентам, которые необходимы для его работы и не более того. Однако, существуют способы обмена данными между приложениями и получения доступа к системным сервисам:








  * Возможно раздать двум приложениям одинаковые идентификаторы пользователей (userid), в этом случае они могут получить доступ к файлам друг друга. Для экономии системных ресурсов приложения с тем же идентификатором также могут быть запущены в одном процессе и использовать одну виртуальную машину. Такие приложения должны быть подписаны на один и тот же сертификат.



  * Приложение может запросить разрешение на доступ к системным данным, таким как контакты пользователя, SMS сообщения, карточка хранения (SD), камера, Bluetooth и многое другое. Все запросы доступа должны быть разрешены пользователем во время установки.






**Компоненты приложений **  
Компоненты — кирпичики, из которых состоит любое приложение. Каждый компонент предоставляет отдельную точку входа в приложение для системы, хотя не каждая такая точка является актуальной для пользователя. Компоненты могут зависеть друг от друга, но каждый из них это отдельная сущность, которая играет особую роль и помогает определить общее поведение приложения.   
  
Существуют четыре типа компонентов приложения. Каждый из них служит различным целям и имеет свой жизненный цикл, который определяет, как компонент создаётся и уничтожается.   
  
_**Activity (Деятельность)**_  
Activity представляет собой один экран с пользовательским интерфейсом. Например, приложение электронной почты, может иметь одну Activity, которая показывает список новых сообщений электронной почты, другую для создания нового сообщения, и ещё одну для чтения письма. Хотя все они работают вместе в рамках одного приложения, каждая из них независима от других. Таким образом, другие приложения могут вызвать любую из этих Activity (если почтовое приложение позволяет это). Например, приложение камеры может открыть Activity в которой создаётся новое сообщение, чтобы пользователь мог отправить фотографии по почте.   
  
_**Service (Служба)**_  
Service это компонент, который работает в фоновом режиме и не имеет пользовательского интерфейса. Службы используются для обработки длительных операций или для выполнения удалённых процессов. Например, Service может воспроизводить музыку в фоновом режиме или получать данные по сети, не блокируя взаимодействие пользователя с работающим приложением. Service могут запустить другие компоненты, например Activity, и затем взаимодействовать с ней.  
  
_**Content provider (Поставщик данных)**_  
Content provider управляет данными приложения. Данные можно хранить в файловой системе, базе данных SQLite, в Интернете или любом другом доступном для приложения месте хранения. Через Content providers другие приложения могут запрашивать или даже изменить данные (если на это есть права доступа). Например, в операционной системе Android существует Content provider, который управляет списком контактов пользователя. Таким образом, любое приложение, с соответствующими разрешениями могут запрашивать информацию о конкретном человеке для чтения или записи. Content provider также можно использовать для чтения и записи данных, которые доступны только для одного приложения.   
  
_**Broadcast receivers (Получатель широковещательных сообщений)**_  
Broadcast receiver - компонент, который позволяет принимать широковещательные сообщения операционной системы. Такими сообщениями являются, например, объявления о том, что экран выключился, батарея разряжена или был сделан фотоснимок. Такие сообщения также могут посылаться пользовательскими приложениями, например, уведомления о том, что некоторые данные были загружены и готовы к использованию. Хотя Broadcast receiver не имеют пользовательского интерфейса, он может создавать уведомления в строке состояния. Однако, чаще всего Broadcast receiver это просто "шлюз" для других компонентов, например, он может запускать Service для обработки определённых событий.   
  
Уникальной особенностью системы Android является то, что любое приложение может запустить компоненты другого приложения. Если необходимо дать пользователю возможность сделать фотографию, то не обязательно это реализовывать, можно вызвать уже существующее приложение. После завершения оно вернёт созданную фотографию в ваше приложение для дальнейшего использования. Для пользователя это будет выглядеть как одно приложение.   
  
Для запуска любого компонента операционная система начинает новый процесс (если его ещё не было) и инициализирует классы, необходимые для компонента. Например, если в вашем приложении запускается Activity для работы с камеры (принадлежащая стороннему приложению), то она запускается в отдельном процессе, который принадлежит этому стороннему приложению, а не в процессе вашего приложения. Поэтому, в отличие от приложений на большинство других систем, приложений Android не имеют единую точку входа (нет функции main()).   
  
Так как система запускает каждое приложение в отдельном процессе с правами доступа к файлам, которые ограничивают доступ для других приложений, ваше приложение не может непосредственно вызвать компонент из стороннего приложения. Однако, операционная система Android это может, поэтому для активации такого компонента, необходимо отправить сообщение операционной системе о своём намерении начать конкретный компонент и она его активирует.  
  
**Активация компонентов**  
Три из четырёх типов компонентов — Activity (деятельность), Service (сервис), а также Broadcast receivers (получатель широковещательных сообщений) — активируются с помощью асинхронного сообщения Intent (намерение). Intent связывает отдельные компоненты друг с другом во время выполнения, будь то компонент принадлежащий вашему приложению или другой.   
  
Intent (намерение) создаётся с помощью класса Intent, который описывает запрос на активацию конкретного компонента или конкретного типа компонента, соответственно Intent может быть явным или неявным.   
  
Для Activity и Service, Intent(намерение) определяет действие, которое надо выполнить (например, "Просмотреть" или "Отправить" что-то), и может указать URI (Uniform Resource Identifier — унифицированный идентификатор ресурса) данных необходимых для выполнения. Например, Intent может передать запрос Activity показать изображение или открыть веб-страницу.   
Для broadcast receivers Intent просто определяет транслируемые сообщения (например, широковещательное сообщения о том, что аккумулятор разряжен содержит только строковую константу обозначающую "батарея разряжена").   
Последний компонент - Content provider не активируется с помощью Intent. Хотя он и может вызывается, если Content provider запрашивает данные из ContentResolver.   
  
Методы для активации каждого типа компонентов:








  * Для запуска Activity используются методы startActivity(Intent intent) или startActivityForResult(Intent intent) (если необходимо вернуть результат).



  * Для запуска Service вызывается метод startService (Intent service).



  * Для запуска Broadcast reciever — sendBroadcast(Intent intent), sendOrderedBroadcast(Intent intent, String receiverPermission), или sendStickyBroadcast(Intent intent).



  * Для формирования запроса для Content Provider используется метод query ()






**Файл манифеста **  
Перед запуском любого компонента операционная система Android читает файл манифеста приложения AndroidManifest.xml, чтобы убедиться, что запускаемый компонент существует. В этом файле должны быть объявлены все компоненты приложения, которые находятся в корневой папке приложения.  
  
Кроме этого манифест-файл выполняет другие функции:








  * Определяет пользовательские разрешения, такие как доступ в Интернет или чтение контактов.



  * Объявление минимального API уровня (версии Android), необходимого для приложения.



  * Объявление аппаратных и программных требований, такие как камера, Bluetooth, или мультитач экран.



  * API библиотек с которыми приложение будет связываться, например библиотеки Google Maps.






Но все же основная задача манифеста сообщить системе о компонентах приложения. Например, можно объявить Activity (деятельность) следующим образом:







	<?xml version="1.0" encoding="utf-8"?>  
	<manifest ... >  
		<application android:icon="@drawable/app_icon.png" ... >  
			<activity android:name="com.example.project.ExampleActivity"  
			android:label="@string/example_label" ... >  
			</activity>  
		</application>  
	</manifest>  








В элементе <application> атрибут Android:icon указывает на ресурсы для иконки приложения.  
  
В элементе <activity> атрибут Android:name определяет полный путь на имя класса Activity (деятельности), а атрибут Android:label задаёт заголовок приложения.   
  
Для определения компонентов используются:  
<activity> для Activity (деятельности)  
<service> для Service (сервисы)  
<receiver> для Broadcast reciever (получатели широковещательных сообщений)  
<provider> для Content providers (поставщики данных)  
  
Activity (деятельность), Service (сервис) и Content provider (поставщики данных), которые существуют в исходниках, но не заявлены в манифесте не видны системе и, следовательно, не смогут запуститься. Однако, Broadcast provider (получатель широковещательных сообщений) может создаваться динамически в коде (как объекты BroadcastReceiver) и регистрироваться с помощью вызова registerReceiver ().   
  
**Объявление возможностей компонента**  
Как уже говорилось в разделе «Активация компонентов», для вызова Activity (деятельность), Service (сервис) и Broadcast receiver (получатель широковещательных сообщений) можно использовать класс Intent. Сделать это можно явно, задав конкретное имя компонента, или не явно, а этом случае описывается только тип действия, который нужно выполнить (и, возможно, данные, необходимые для него). Система сама находит компонент устройства, который может выполнить действия и запускает его. Если найдено несколько подходящих компонентов, то пользователь выбирает, какой из них использовать.   
  
Система определяет компоненты, которые могут реагировать на намерение путём сравнения полученного Intent (намерения), с Intent filters (фильтр намерений), определённых в файлах манифеста других приложений.   
  
При объявлении компонента в файле манифеста, можно дополнительно включить фильтр намерений, которые заявляют возможности компонента, чтобы он мог реагировать на запросы из других приложений. Для объявления фильтра намерения используется элемент <intent-filter>.   
  
Например, приложение электронной почты с Activity (деятельностью) для создания новых сообщений может объявить Intent filter (фильтр намерения) в своём файле манифеста запускаться на запрос "send" (отправить). Activity (деятельность) в стороннем приложении создаёт Intent (намерение) с типом действия "send" (ACTION_SEND), которое система сопоставит с приложением электронной почты и запустит нужную Activity (деятельность).  
  
**Объявление требований приложений **  
Существует большое количество устройств, работающий под управлением системы Android, однако, не все они обеспечивают одинаковые функции и возможности. Чтобы не позволить установить приложение на устройство, в котором отсутствуют необходимые функции, необходимо объявить аппаратные и программные требования в файле манифеста. Большинство из этих заявлений существуют исключительно для ознакомления и система не читает их, однако внешние сервисы, таких как Android Market используют их, чтобы обеспечить фильтрацию для пользователей, которые ищут приложения для своего устройства.   
  
Например, если приложение требует камеру и использует API, введённые в Android версии 2.1 (API уровень 7), надо записать эти требования в файл манифеста. Таким образом, устройства, которые не имеют камеру или с версией Android ниже, чем 2.1 не смогут установить приложение из Android Market.   
  
Однако, приложение может использовать камеру, но но это требование не является критичным для его работы. В этом случае приложение должно выполнять проверку во время выполнения, чтобы отключить функции, использующие камеру.   
  
При проектировании и разработке приложения, необходимо учитывать:   
  
_**Размер экрана и плотность**_  
Android определяет две характеристики экрана для устройства: размер экрана (физические размеры экрана) и плотность (плотность пикселей на экране, или dpi (dots per inch - точек на дюйм). Для упрощения Android обобщает их в отдельных группы  
  
Размер: small (маленький), normal (средний), large (большой), and extra large (очень большой).   
Плотность: low density (низкая), medium density (средняя), high density (высокая), and extra high density (очень высокая).   
  
По умолчанию, приложение совместимо со всеми размерами экрана, так как система Android делает необходимые изменения пользовательского интерфейса и изображений. Однако, лучше создать специализированные макеты и изображения для определённых размеров и плотностей и объявить в манифесте, какие именно размеры экрана приложение поддерживает в элементе <supports-screens>.  
  
_**Средства ввода **_  
Устройства могут иметь различные средства для ввода, такие как аппаратная клавиатура, трекбол или джойстик. Если приложение требует определённое оборудование для ввода, то необходимо объявить это в манифесте в элементе <uses-configuration>. Однако, в большинстве случаев приложения поддерживают любое средство ввода.  
  
_**Аппаратные требования**_  
Не все аппаратные или программные функции, таких как камера, датчик освещённости, Bluetooth или сенсорный экран, могут существовать на конкретном устройстве, поэтому необходимо декларировать любые функции, используемые приложения в элементе .   
  
_**Версия платформы **_  
Устройства работают на разных версиях платформы Android. Каждая последующая версия часто включает в себя дополнительные интерфейсы API, которые не доступны в предыдущей версии. Для того, чтобы указать, какой набор API-интерфейсов доступен, каждой версии платформы соответствует API уровень (например, Android 1.0 — 1 уровень API, Android 2.3 — 9 уровень). Если в приложении используются API, которые были добавлены к платформе после определённой версии, необходимо объявить минимальный уровень API с помощью элемента <uses-sdk>.  
  
**Ресурсы приложения **  
Приложения Android состоят не только из исходного кода, но также из ресурсов для визуального представления, такие как изображения или звуковые файлы. Для приложения необходимо определить меню, стили, цвета и разметку пользовательского интерфейса в файлах XML. Использование ресурсов даёт возможность изменять некоторые части приложения без модификации исходного кода, а также позволяет оптимизировать приложение для различных устройств (с различным языком интерфейса или размером экрана).   
  
Для каждого ресурса, включённого в проект Android, SDK определяет уникальный идентификатор (целое число), которое можно использовать для ссылки на ресурс из кода или из других ресурсов определённых в XML. Например, если приложение содержит изображение с именем logo.png (сохранённое в директории res/drawable), SDK сгенерирует идентификатор ресурса R.drawable.logo, которое можно использовать для ссылки на изображение.   
  
Главным достоинством отдельного хранения исходного кода и ресурсов является возможность создать разные ресурсы для разных аппаратных конфигураций. Например, строки интерфейса для разных языков можно определять в различных xml файлах (они хранятся например в директории res/values-fr/ для французского языка). В зависимости от выбранного пользователем языка система Android подставляет нужные строки в интерфейс.   
  
Android поддерживает множество классификаторов для альтернативных ресурсов. Классификатор это короткая строка в название директории ресурсов для определения когда эти ресурсы должны быть использованы. Часто создаются различные схемы интерфейса для разных размеров и ориентаций экранов устройства. Например, при портретной ориентации кнопки удобнее разместить по вертикали, а для альбомной ориентации - по горизонтали. Чтобы изменить расположение в зависимости от ориентации, можно определить две различные схемы и добавить соответствующие классификаторы к имени каталога каждого макета. Тогда, система автоматически применяет соответствующий макет в зависимости от текущей ориентации устройства.
Добрый день друзья.





По просьбе одного из участников нашего сообщества. Был поднят вопрос:





Как можно достучаться до элементов на табах.





Сегодня я вам покажу на эту тему видео и дам комментарии.


<!-- more -->


Смотрим видео.


{% youtube waUgWu8PV1w %}






#### bottom_selector.xml



	<?xml version="1.0" encoding="utf-8"?>

	<selector xmlns:android="http://schemas.android.com/apk/res/android">



		<item android:drawable="@android:drawable/ic_lock_silent_mode_off" android:state_selected="true"/>

		<item android:drawable="@android:drawable/ic_lock_silent_mode_off" android:state_focused="true"/>

		<item android:drawable="@android:drawable/ic_lock_silent_mode_off" android:state_pressed="true"/>

		<item android:drawable="@android:drawable/ic_lock_silent_mode"/>

	</selector>


	



#### text_colors_selector.xml



	<?xml version="1.0" encoding="utf-8"?>

	<selector xmlns:android="http://schemas.android.com/apk/res/android">



		<item android:state_selected="true" android:color="@android:color/white"/>

		<item android:state_focused="true" android:color="@android:color/white"/>

		<item android:state_pressed="true" android:color="@android:color/white"/>

		<item android:color="@android:color/darker_gray"/>



	</selector>

	



#### tab_host_layout.xml


	<?xml version="1.0" encoding="utf-8"?>

	<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"

		android:layout_width="fill_parent"

		android:layout_height="fill_parent"

		android:background="@android:color/black" >



	<ImageView

		android:id="@+id/tab_image"

		android:layout_width="fill_parent"

		android:layout_height="fill_parent"

		android:layout_above="@+id/tab_text"

		android:cropToPadding="true"

		android:scaleType="center"

		android:src="@android:drawable/ic_menu_add" />



	<TextView

		android:id="@+id/tab_text"

		android:layout_width="fill_parent"

		android:layout_height="wrap_content"

		android:layout_alignParentBottom="true"

		android:layout_marginBottom="5dp"

		android:gravity="center_horizontal"

		android:text="Text"

		android:textColor="@color/text_colors_selector"

		android:textSize="13sp" />



	<TextView

		android:id="@+id/tab_unread_message"

		android:layout_width="wrap_content"

		android:layout_height="wrap_content"

		android:layout_alignParentRight="true"

		android:layout_marginRight="10dp"

		android:layout_marginTop="2dp"

		android:gravity="center"

		android:text="5"

		android:textColor="@android:color/white"

		android:textSize="14sp"

		android:textStyle="bold" />



	</RelativeLayout>
	



#### MainActivity.java


1. Комментируем и добавляем построение табов



		// mTabsAdapter.addTab(mTabHost.newTabSpec("simple").setIndicator("Android"), AndroidFragment.class, null);

		// mTabsAdapter.addTab(mTabHost.newTabSpec("contacts").setIndicator("IOs"), IOsFragment.class, null);

		// mTabsAdapter.addTab(mTabHost.newTabSpec("custom").setIndicator("Windows"), WindowsFragment.class, null);

		// mTabsAdapter.addTab(mTabHost.newTabSpec("throttle").setIndicator("DOS"), DOSFragment.class, null);



		mTabsAdapter.addTab(setupTab(new TextView(this), "Android", R.drawable.bottom_selector, 0),

				AndroidFragment.class, null);

		mTabsAdapter

				.addTab(setupTab(new TextView(this), "IOs", R.drawable.bottom_selector, 0), IOsFragment.class, null);

		mTabsAdapter.addTab(setupTab(new TextView(this), "Windows", R.drawable.bottom_selector, 0),

				WindowsFragment.class, null);

		mTabsAdapter

				.addTab(setupTab(new TextView(this), "DOS", R.drawable.bottom_selector, 0), DOSFragment.class, null);

	



2. Добавляем 2 функции сразу после onCreate





		private TabSpec setupTab(final View view, final String tag, final int imageRes, final int notificationItem) {

		View tabview = createTabView(mTabHost.getContext(), tag, imageRes, notificationItem);

		TabSpec setContent = mTabHost.newTabSpec(tag).setIndicator(tabview).setContent(new TabContentFactory()                         {

			@Override

			public View createTabContent(final String tag) {

				return view;

			}

		});

		// mTabHost.addTab(setContent);

		return setContent;

		}



		private static View createTabView(final Context context, final String text, final int imageRes,

			final int notificationItem) {

		View view = LayoutInflater.from(context).inflate(R.layout.tab_host_layout, null);

		TextView tv = (TextView) view.findViewById(R.id.tab_text);

		tv.setText(text);

		ImageView iv = (ImageView) view.findViewById(R.id.tab_image);

		iv.setImageResource(imageRes);

		tv = (TextView) view.findViewById(R.id.tab_unread_message);

		tv.setText(String.valueOf(notificationItem));

		if (notificationItem == 0) {

			tv.setVisibility(View.GONE);

		} else {

			tv.setVisibility(View.VISIBLE);

		}

		return view;

		}






3. Добавляем функцию нотификации после метода onPageScrollStateChanged

4. Делаем нотификацию

		public void updateNotification(final int notificationItem, final int position) {

			View view = mTabHost.getTabWidget().getChildAt(position);

			TextView tv = (TextView) view.findViewById(R.id.tab_unread_message);

			tv.setText(String.valueOf(notificationItem));

			if (notificationItem == 0) {

				tv.setVisibility(View.GONE);

			} else {

				tv.setVisibility(View.VISIBLE);

			}

		}





P.S. Забыл на видео сказать, что нужно еще модифицировать activity_main.xml





#### activity_main.xml





	<?xml version="1.0" encoding="utf-8"?>

	<TabHost xmlns:android="http://schemas.android.com/apk/res/android"

	android:id="@android:id/tabhost"

	android:layout_width="match_parent"

	android:layout_height="match_parent" >



	<LinearLayout

		android:layout_width="match_parent"

		android:layout_height="match_parent"

		android:orientation="vertical" >



		<FrameLayout

			android:id="@android:id/tabcontent"

			android:layout_width="0dp"

			android:layout_height="0dp"

			android:layout_weight="0" />



		<android.support.v4.view.ViewPager

			android:id="@+id/pager"

			android:layout_width="match_parent"

			android:layout_height="0dp"

			android:layout_weight="1" />



		<TabWidget

			android:id="@android:id/tabs"

			android:layout_width="match_parent"

			android:layout_height="53dp"

			android:layout_weight="0"

			android:orientation="horizontal" />

	</LinearLayout>



	</TabHost>




Если вам понравилась статья, пишите свои комментарии.





Поделись этой статьей с другом.
Нашел довольно интересную статью по работе с mp3 файлами на стороне android.





Думаю это будет интересно как для профи так и для новичка.





Прошу к прочтению.


<!-- more -->


В данной статье описан процесс получения всей основной информации о аудиотреках в устройстве с Android, основы работы с плейлистами и проигрывания аудиофайлов.





**Общие принципы работы с провайдерами данных**





Источники данных ( Content Providers, Провайдеры данных ) в Android предоставляют интерфейс общего доступа к любому источнику данных путем отделения уровня доступа к данным от уровня приложения. Источники данных предлагают стандартный API, с помощью которого приложения могут обмениваться своими данными между собой, и использовать различные системные базы данных.





Типичный запрос к провайдеру данных выглядит следующим образом. Сначала запрашивается системный объект класса ContentResolver, который позволяет подключаться к провайдерам данных. Затем необходимо настроить параметры запроса и вызвать метод ContentResolver.query, в который передаются параметры запроса и который в случае успешного выполнения возвращает объект класса Cursor, предоставляющий интерфейс для работы с данными, возвращаемые в результате запроса к базе данных.




    
    
    
    [java]String[] projection = new String[] {
    
    People._ID,
    
    People.NAME,
    
    People.NUMBER,
    
    };
    
    
    
    Uri mContactsUri = People.CONTENT_URI;
    
    ContentResolver resolver = appContext.getContentResolver();
    
    
    
    Cursor managedCursor = resolver.query( mContactsUri,
    
              projection,.
    
              null, 
    
              null,
    
              People.NAME + " ASC"); 
    
    
    
    for( int i=0;i&lt;managedCursor.getCount();i++)
    
    {
    
          managedCursor.moveToPosition(i);
    
          String nameOfContact =  managedCursor.getString(1);
    
          ….    
    
    }
    
    [/java]
    
    





Подробнее о работе с провайдерами данных можно посмотреть на сайте разработчиков -[http://developer.android.com/guide/topics/providers/content-providers.html](http://developer.android.com/guide/topics/providers/content-providers.html).





**Провайдер данных MediaStore.Audio**





Провайдер данных MediaStore представляет собой централизованную базу данных мультимедиа, размещенных в памяти устройства или на сменном носителе ( SD карте ), включая аудио-, видеофайлы и изображения. Данные в MediaStore записываются автоматически при сканировании системой внутренней или сменной памяти, при этом рассылаются сообщения ACTION_MEDIA_SCANNER_STARTED и ACTION_MEDIA_SCANNER_FINISHED. Любая программа может уведомить сканер о наличии нового файла вызовом




    
    
    
    [java]sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE, newFilePath));[/java]





Примечание: чтобы запретить сканеру обрабатывать определенный каталог на диске, поместите туда пустой файл с именем .nomedia.





При сканировании анализируются ID теги и другая информация, которая становится доступна в пользовательских приложениях. Доступ к данным аудиофайлов осуществляется через провайдер MediaStore.Audio, который также дает возможность работать с плейлистами ( списками воспроизведения ). 





В примерах этой статьи будет использоваться вызов myquery, который утилизирует получение курсора по URI провайдера данных и других параметров запроса.




    
    [java]public static Cursor myquery(Context context, Uri uri, String[] projection,
    
                 String selection, String[] selectionArgs, String sortOrder, int limit) {
    
                 try {
    
                       ContentResolver resolver = context.getContentResolver();
    
                       if (resolver == null) {
    
                            return null;
    
                       }
    
                        if (limit &gt; 0) {
    
                            uri = uri.buildUpon().appendQueryParameter("limit", "" + limit).build();
    
                         }
    
                      return resolver.query(uri, projection, selection, selectionArgs, sortOrder);
    
                    } catch (UnsupportedOperationException ex) {
    
                                return null;
    
                     }
    
                 
    
                  }[/java]





**Простое перечисление всей музыки в телефоне**




    
    [java]String[] projection = { MediaStore.Audio.Media._ID,             // 0
    
                              MediaStore.Audio.Media.ARTIST,          // 1
    
                              MediaStore.Audio.Media.TITLE,           // 2
    
                              MediaStore.Audio.Media.ALBUM_ID,  // 3
    
                              MediaStore.Audio.Media.ALBUM,           // 4
    
                              MediaStore.Audio.Media.DATA,            // 5
    
                              MediaStore.Audio.Media.DISPLAY_NAME,    // 6
    
                              MediaStore.Audio.Media.DURATION,
    
                                            MediaStore.Audio.Media.TITLE_KEY
    
            };      // 7
    
    
    
    String selection = MediaStore.Audio.Media.IS_MUSIC + " != 0 ";
    
    Cursor musicListSDCardCursor = myquery(
    
                               this,
    
                               MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,
    
                               projection, selection , null, null,0);
    
    Cursor musicListInternalMemoryCursor = myquery(
    
                               this,
    
                               MediaStore.Audio.Media.INTERNAL_CONTENT_URI,
    
                               projection, selection , null, null,0);
    
    [/java]





**Списки альбомов**





Получение списка альбомов:




    
    [java]String[] projection = {
    
                 MediaStore.Audio.Albums.ALBUM,            // 0
    
                 MediaStore.Audio.Albums.NUMBER_OF_SONGS,  // 1
    
                 MediaStore.Audio.Albums.LAST_YEAR,       // 2
    
                               MediaStore.Audio.Albums.ARTIST,           // 3
    
                               MediaStore.Audio.Albums._ID               // 4
    
                                            };
    
    
    
    
    
      Cursor albumsListSDCardCursor = myquery(
    
                               this,
    
                               MediaStore.Audio.Albums.EXTERNAL_CONTENT_URI,
    
                               projection, null , null, null,0);
    
    
    
      Cursor albumsListInternalMemoryCursor = myquery(
    
                               this,
    
                               MediaStore.Audio.Albums.INTERNAL_CONTENT_URI,
    
                               projection, null , null, null,0);
    
    [/java]





Получение списка дорожек, входящих в данный альбом:




    
    [java]// String albumId содержит выбранный MediaStore.Audio.Albums._ID  
    
    
    
    String[] projection = { MediaStore.Audio.Media._ID,             // 0
    
                              MediaStore.Audio.Media.ARTIST,          // 1
    
                              MediaStore.Audio.Media.TITLE,           // 2
    
                              MediaStore.Audio.Media.ALBUM_ID,  // 3
    
                              MediaStore.Audio.Media.ALBUM,           // 4
    
                              MediaStore.Audio.Media.DATA,            // 5
    
                              MediaStore.Audio.Media.DISPLAY_NAME,    // 6
    
                              MediaStore.Audio.Media.DURATION,
    
                                            MediaStore.Audio.Media.TITLE_KEY
    
            };      // 7
    
    
    
           String selection = MediaStore.Audio.Media.IS_MUSIC + " != 0 AND "+
    
                   MediaStore.Audio.Media.ALBUM_ID +"=?";
    
           String[] args = new String[] {albumId};
    
    
    
    Cursor musicListSDCardCursor = myquery(
    
                               this,
    
                               MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,
    
                               projection, selection , args, null,0);
    
    Cursor musicListInternalMemoryCursor = myquery(
    
                               this,
    
                               MediaStore.Audio.Media.INTERNAL_CONTENT_URI,
    
                               projection, selection , args, null,0);
    
    [/java]





**Списки исполнителей**





Получение списка всех исполнителей:




    
    [java]String[] projection = {
    
                MediaStore.Audio.Artists.ARTIST,            // 0
    
                MediaStore.Audio.Artists.NUMBER_OF_ALBUMS,  // 1
    
                MediaStore.Audio.Artists.NUMBER_OF_TRACKS,
    
                              MediaStore.Audio.Artists._ID
    
                                            };
    
    
    
    
    
      Cursor artistListSDCardCursor = myquery(
    
                               this,
    
                               MediaStore.Audio.Artists.EXTERNAL_CONTENT_URI,
    
                               projection, null , null, null,0);
    
    
    
      Cursor artistListInternalMemoryCursor = myquery(
    
                               this,
    
                               MediaStore.Audio.Artists.INTERNAL_CONTENT_URI,
    
                               projection, null , null, null,0);
    
    [/java]





Получение списка композиций данного исполнителя:




    
    [java]// String artistId содержит выбранный MediaStore.Audio.Artists._ID  
    
    String[] projection = {
    
                  String[] projection = { MediaStore.Audio.Media._ID,             // 0
    
                              MediaStore.Audio.Media.ARTIST,          // 1
    
                              MediaStore.Audio.Media.TITLE,           // 2
    
                              MediaStore.Audio.Media.ALBUM_ID,  // 3
    
                              MediaStore.Audio.Media.ALBUM,           // 4
    
                              MediaStore.Audio.Media.DATA,            // 5
    
                              MediaStore.Audio.Media.DISPLAY_NAME,    // 6
    
                              MediaStore.Audio.Media.DURATION,
    
                                            MediaStore.Audio.Media.TITLE_KEY
    
            };      // 7
    
    
    
           String selection = MediaStore.Audio.Media.IS_MUSIC + " != 0 AND "+
    
                   MediaStore.Audio.Media.ARTIST_ID +"=?";
    
           String[] args = new String[] {artistId};
    
    
    
          Cursor musicListSDCardCursor = myquery(
    
                               this,
    
                               MediaStore.Audio.Artists.EXTERNAL_CONTENT_URI,
    
                               projection, null , null, null,0);
    
    
    
          Cursor musicListInternalMemoryCursor = myquery(
    
                               this,
    
                               MediaStore.Audio.Artists.INTERNAL_CONTENT_URI,
    
                               projection, null , null, null,0);
    
    [/java]





**Списки жанров**





Получение списка всех жанров:




    
    [java]String[] projection = { MediaStore.Audio.Genres._ID,          // 0
    
                  MediaStore.Audio.Genres.NAME          // 1
    
                                                        };
    
        Cursor genresListSDCardCursor = myquery(
    
                               this,
    
                               MediaStore.Audio.Genres.EXTERNAL_CONTENT_URI,
    
                               projection, null , null, MediaStore.Audio.Genres.NAME, 0);
    
    
    
        Cursor genresListInternalMemoryCursor = myquery(
    
                               this,
    
                               MediaStore.Audio.Genres.INTERNAL_CONTENT_URI,
    
                               projection, null , null, MediaStore.Audio.Genres.NAME, 0);[/java]





Получение списка композиций выбранного жанра:




    
    [java]// String genreId содержит выбранный MediaStore.Audio.Genres._ID
    
     String[] projection = { MediaStore.Audio.Genres.Members._ID,             // 0
    
                              MediaStore.Audio.Genres.Members.ARTIST,          // 1
    
                              MediaStore.Audio.Genres.Members.TITLE,           // 2
    
                              MediaStore.Audio.Genres.Members.ALBUM_ID,  // 3
    
                              MediaStore.Audio.Genres.Members.ALBUM,           // 4
    
                              MediaStore.Audio.Genres.Members.DATA,            // 5
    
                              MediaStore.Audio.Genres.Members.DISPLAY_NAME,    // 6
    
                              MediaStore.Audio.Genres.Members.DURATION,
    
                                            MediaStore.Audio.Media.TITLE_KEY
    
                       };      // 7
    
    
    
            String selection = MediaStore.Audio.Genres.Members.IS_MUSIC + " != 0";
    
    
    
      Cursor musicListSDCardCursor = myquery(
    
                               this,
    
                               MediaStore.Audio.Genres.Members.getContentUri("external", Long.valueOf(s)),
    
                               projection, selection , null, null,0);
    
    
    
      Cursor musicListInternalMemoryCursor = myquery(
    
                               this,
    
                               MediaStore.Audio.Genres.Members.getContentUri("internal", Long.valueOf(s)),
    
                               projection, selection , null, null,0);
    
    
    
    [/java]





**Работа с плейлистами**





Получение списка всех плейлистов в устройстве:




    
    [java]String[] projection = { MediaStore.Audio.Playlists._ID,             // 0
    
                                 MediaStore.Audio.Playlists.NAME          // 1
    
                                                        };
    
    
    
                    
    
    
    
    Cursor playListSDCardCursor = myquery(
    
                               this,
    
                               MediaStore.Audio.Playlists.EXTERNAL_CONTENT_URI,
    
                               projection, null , null, MediaStore.Audio.Playlists.NAME,0);
    
    
    
    Cursor playListInternalMemoryCursor = myquery(
    
                               this,
    
                               MediaStore.Audio.Playlists.INTERNAL_CONTENT_URI,
    
                               projection, null , null, MediaStore.Audio.Playlists.NAME,0);[/java]





Создание нового плейлиста:




    
    [java]ContentValues cv = new ContentValues();
    
    cv.put(MediaStore.Audio.Playlists.NAME, "Новый плейлист");
    
    Uri uri = getContentResolver().insert(MediaStore.Audio.Playlists.getContentUri("external"), cv);[/java]





Добавление композиции в плейлист:




    
    [java]// long playlistId - MediaStore.Audio.Playlists._ID выбранного плейлиста
    
    // int audioId - MediaStore.Audio.Media._ID композиции
    
            ContentResolver resolver = getContentResolver();
    
            String[] cols = new String[] {
    
                    "count(*)"
    
            };
    
            Uri uri = MediaStore.Audio.Playlists.Members.getContentUri("external", playlistId);
    
            Cursor cur = resolver.query(uri, cols, null, null, null);
    
            cur.moveToFirst();
    
            final int base = cur.getInt(0);
    
            cur.close();
    
            ContentValues values = new ContentValues();
    
            values.put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, Integer.valueOf(base + 1));
    
            values.put(MediaStore.Audio.Playlists.Members.AUDIO_ID, audioId);
    
            resolver.insert(uri, values);[/java]





Перечисление всех композиций плейлиста:




    
    [java]// String playlistId - MediaStore.Audio.Playlists._ID выбранного плейлиста
    
    
    
    String[] projection = {         MediaStore.Audio.Media._ID,             // 0
    
                              MediaStore.Audio.Media.ARTIST,          // 1
    
                              MediaStore.Audio.Media.TITLE,           // 2
    
                              MediaStore.Audio.Media.ALBUM_ID,  // 3
    
                              MediaStore.Audio.Media.ALBUM,           // 4
    
                              MediaStore.Audio.Media.DATA,            // 5
    
                              MediaStore.Audio.Media.DISPLAY_NAME,    // 6
    
                              MediaStore.Audio.Media.DURATION,
    
                                            MediaStore.Audio.Media.TITLE_KEY
    
            };     
    
    
    
           
    
     Cursor musicListSDCardCursor = myquery(
    
                               this,
    
                               MediaStore.Audio.Playlists.Members.getContentUri("external", Long.valueOf(playlistId)),
    
                               projection, null , null, null,0);
    
    
    
      Cursor musicListInternalMemoryCursor = myquery(
    
                               this,
    
                               MediaStore.Audio.Playlists.Members.getContentUri("internal", Long.valueOf(playlistId)),
    
                               projection, null , null, null,0);
    
    [/java]





**Проигрывание аудиотрека**





Чтобы открыть mp3 файл в одном из плееров, установленных в системе, можно использовать Intents таким образом:




    
    [java]Intent it = new Intent(Intent.ACTION_VIEW);
    
     Uri uri = Uri.parse( "file:///sdcard/mymusic/happysong.mp3");
    
     it.setDataAndType(uri, "audio/mp3");
    
     startActivity(it);[/java]





Для проигрывания mp3 файлов из приложения можно использовать объект класса MediaPlayer. Класс MediaPlayer из Android SDK работает на основе модели автомата состояний ( конечного автомата, state machine ) и используется для воспроизведения аудио и видео роликов. 





После создания объекта класса MediaPlayer устанавливается путь к файлу аудиоролика на диске и вызывается метод MediaPlayer.prepare(), который инициализирует MediaPlayer и приводит его в состояние готовности к воспроизведению аудиофайла. 





После успешной инициализации MediaPlayer приложение может вызывать его методы start(), stop() и pause() для управления воспроизведением. 




    
    [java]// Общий пример воспроизведения mp3 с использованием класса MediaPlayer
    
    
    
         MediaPlayer mediaPlayer = new  MediaPlayer();
    
    
    
         
    
        try {
    
              mediaPlayer.setDataSource("/sdcard/mytracks/happysong.mp3");
    
              mediaPlayer.prepare();
    
              mediaPlayer.start();
    
    
    
            } catch (IllegalArgumentException iae) {
    
                  // TODO Auto-generated catch block
    
                  iae.printStackTrace();
    
     
    
            } catch (IllegalStateException ise) {
    
                 // TODO Auto-generated catch block
    
                 ise.printStackTrace();
    
    
    
            } catch (IOException ioe) {
    
                 // TODO Auto-generated catch block
    
                 ioe.printStackTrace();
    
            } catch (Exception e) {
    
                 // TODO Auto-generated catch block
    
                 e.printStackTrace();
    
            }
    
    
    
    [/java]





Подробнее об использовании класса MediaPlayer можно посмотреть на сайте разработчиков [http://developer.android.com/reference/android/media/MediaPlayer.html](http://developer.android.com/reference/android/media/MediaPlayer.html).





**Пример - проигрывание случайной дорожки**





Программа открывает в проигрывателе случайно выбранный mp3 файл.




    
    [java]package org.me.androidrandomplay;
    
    
    
    import android.app.Activity;
    
    import android.os.Bundle;
    
    import android.content.*;
    
    import android.database.Cursor;
    
    import android.net.Uri;
    
    import  android.provider.MediaStore;
    
    import android.widget.Toast;
    
    
    
    public class AndroidRandomPlay extends Activity {
    
    
    
        /** Called when the activity is first created. */
    
        @Override
    
        public void onCreate(Bundle icicle) {
    
            super.onCreate(icicle);
    
    
    
    
    
            String[] projection = { 
    
                                    MediaStore.Audio.Media._ID,
    
                                    MediaStore.Audio.Media.DATA
    
                                  };  
    
    
    
            String selection = MediaStore.Audio.Media.IS_MUSIC + " != 0 ";
    
            Cursor musicListSDCardCursor = myquery(
    
                                       this,
    
                                       MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,
    
                                       projection, selection , null, null,0);
    
            Cursor musicListInternalMemoryCursor = myquery(
    
                                       this,
    
                                       MediaStore.Audio.Media.INTERNAL_CONTENT_URI,
    
                                       projection, selection , null, null,0);
    
    
    
            java.util.Vector&lt;String&gt; paths = new java.util.Vector();
    
    
    
            if( musicListSDCardCursor!= null )
    
            {
    
                for(int i=0;i&lt;musicListSDCardCursor.getCount();i++)
    
                {
    
                    musicListSDCardCursor.moveToPosition(i);
    
                    String p = musicListSDCardCursor.getString(1);
    
                    if(p.endsWith("mp3"))
    
                            paths.addElement(p);
    
    
    
                }
    
                musicListSDCardCursor.close();
    
            }
    
    
    
             if( musicListInternalMemoryCursor!= null )
    
            {
    
                for(int i=0;i&lt;musicListInternalMemoryCursor.getCount();i++)
    
                {
    
                    musicListInternalMemoryCursor.moveToPosition(i);
    
                    String p = musicListInternalMemoryCursor.getString(1);
    
                    if(p.endsWith("mp3"))
    
                            paths.addElement(p);
    
    
    
                }
    
                musicListInternalMemoryCursor.close();
    
            }
    
    
    
            if( paths.isEmpty() ) 
    
            {
    
                Toast.makeText( this, "no media found", Toast.LENGTH_LONG).show();   
    
                return;
    
            }
    
    
    
            java.util.Random r = new  java.util.Random();
    
            int pos = r.nextInt(paths.size()-1);
    
            if( paths.size() == 1 ) pos = 0;
    
    
    
            String url  = paths.elementAt(pos);
    
    
    
            if( url.length() == 0 ) return;
    
    
    
            Toast.makeText( this, url, Toast.LENGTH_LONG).show();
    
    
    
            try{
    
    
    
                Intent it = new Intent(Intent.ACTION_VIEW);
    
                Uri uri = Uri.parse( "file://"+url);
    
                it.setDataAndType(uri, "audio/mp3");
    
                startActivity(it);
    
          
    
            }catch (Exception e)
    
            {
    
                Toast.makeText( this, e.toString(), Toast.LENGTH_LONG).show();
    
            }
    
        }
    
    
    
        public static Cursor myquery(Context context, Uri uri, String[] projection,
    
                 String selection, String[] selectionArgs, String sortOrder, int limit) {
    
                 try {
    
                       ContentResolver resolver = context.getContentResolver();
    
                       if (resolver == null) {
    
                            return null;
    
                       }
    
                        if (limit &gt; 0) {
    
                            uri = uri.buildUpon().appendQueryParameter("limit", "" + limit).build();
    
                         }
    
                      return resolver.query(uri, projection, selection, selectionArgs, sortOrder);
    
                    } catch (UnsupportedOperationException ex) {
    
                                return null;
    
                     }
    
                  }
    
    
    
    }[/java]
Многие меня спрашивают.





Что когда нужно вызывать в Activity. И когда вызываются разные методы.





И мне попалась интересная статья.





Лично для себя я читал официальную статью. Аналогов на русской тогда не было.





И так прошу к прочтению.


<!-- more -->


### Теория





При работе приложения, мы **создаем** новые **Activity** и **закрываем** старые, **сворачиваем** приложение, снова **открываем** и т.д. Activity умеет обрабатывать все эти движения. Это необходимо, например, для освобождения ресурсов или сохранения данных. В [хелпе](http://developer.android.com/guide/topics/fundamentals/activities.html#Lifecycle) достаточно подробно это описано.





Созданное при работе приложения **Activity **может быть в одном из **трех состояний**:





**Resumed**- Activity видно на экране, оно находится в фокусе, пользователь может с ним взаимодействовать. Это состояние также иногда называют Running.  
**Paused**- Activity не в фокусе, пользователь не может с ним взаимодействовать, но его видно (оно перекрыто другим Activity, которое занимает не весь экран или полупрозрачно).  
**Stopped**- Activity не видно (полностью перекрывается другим Activity), соответственно оно не в фокусе и пользователь не может с ним взаимодействовать.





Когда Activity переходит из одного **состояния** в другое, система вызывает различные его **методы**, которые мы можем заполнять своим кодом. Схематично это можно изобразить так:





![](http://android-helper.com.ua/images/uploads/2012/10/20111005_L0023_L_StatesSchema.jpg)





Для упрощения понимания я дал краткое описание состояний в скобках под названиями. А крестом обозначил отсутствие Activity.





Итак, мы имеем следующие методы Activity, которые вызывает система:





**onCreate**() – вызывается при первом создании Activity  
**onStart**() – вызывается перед тем, как Activity будет видно пользователю  
**onResume**() – вызывается перед тем как будет доступно для активности пользователя (взаимодействие)





**onPause**() – вызывается перед тем, как будет показано другое Activity  
**onStop**() – вызывается когда Activity становится не видно пользователю  
**onDestroy**() – вызывается перед тем, как Activity будет уничтожено





Т.е. эти методы **НЕ** вызывают смену состояния. Наоборот, смена состояния Activity является триггером, который вызывает эти методы. Тем самым нас уведомляют о смене, и мы можем реагировать соответственно. Посмотрим на практике, когда и в каком порядке вызываются эти методы.





###  





### Практика





В этом уроке нам надо будет эмулировать событие смены ориентации экрана. Но эмулятор с Android 2.3 делает это криво, поэтому в проекте будем использовать версию 2.2. Для этого надо [создать](http://startandroid.ru/uroki/vse-uroki-spiskom/12-urok-3-sozdanie-avd-pervoe-prilozhenie-struktura-android-proekta.html) новое AVD по версии 2.2 





![](http://android-helper.com.ua/images/uploads/2012/10/20111005_L0023_L_AVD22.jpg)




Создадим проект (обратите внимание, используем Android 2.2.):





**Project name**: P0231_OneActivityState  
**Build Target**: Android 2.2  
**Application name**: OneActivityState  
**Package name**: ru.startandroid.develop.p0231oneactivitystate  
**Create Activity**: MainActivity





Layout не меняем, нам он сейчас не важен.



	import android.app.Activity;

	import android.os.Bundle;

	import android.util.Log;



	public class MainActivity extends Activity {

  

  	final String TAG = "States";

  

    /** Called when the activity is first created. */

    @Override

    public void onCreate(Bundle savedInstanceState) {

        super.onCreate(savedInstanceState);

        setContentView(R.layout.main);

        Log.d(TAG, "MainActivity: onCreate()");

    }

    

  	@Override

  	protected void onStart() {

    	super.onStart();

   		Log.d(TAG, "MainActivity: onStart()");

  	}



  	@Override

  	protected void onResume() {

    	super.onResume();

    	Log.d(TAG, "MainActivity: onResume()");

  	}



  	@Override

  	protected void onPause() {

    	super.onPause();

    	Log.d(TAG, "MainActivity: onPause()");

  	}



  	@Override

  	protected void onStop() {

    	super.onStop();

    	Log.d(TAG, "MainActivity: onStop()");

  	}

    

  	@Override

  	protected void onDestroy() {

   		super.onDestroy();

    	Log.d(TAG, "MainActivity: onDestroy()");

  	}

	}







Добавим все остальные **методы** из схемы, и в каждый добавим запись в **лог**.





В каментах подсказали важное замечание! При реализации этих методов обязательно вызывайте соответствующие методы супер-класса и обязательно перед вашим кодом. См. код выше. Каждый метод содержит вызов метода супер-класса и свой код расположен после этих вызовов.





Все сохраним и запустим приложение. После того, как запустилось, смотрим лог:





_MainActivity: onCreate()  
MainActivity: onStart()  
MainActivity: onResume()_





Activity создалось, прошло два состояния (Stopped, Paused) и теперь находится в третьем состоянии - Resumed. Т.е. оно создалось (onCreate), отобразилось (onStart) и получило возможность взаимодействовать с пользователем (onResume).





Теперь нажмем кнопку Back на эмуляторе. Activity закрылось. Смотрим лог:





_MainActivity: onPause()  
MainActivity: onStop()  
MainActivity: onDestroy()_





Activity проделывает путь, обратный созданию. Сначала теряет фокус (onPaused), затем исчезает с экрана (onStop), затем полностью уничтожается (onDestroy).





###  





### Смена ориентации экрана





Посмотрим, как ведет себя Activity, когда происходит смена ориентации экрана. Запустите снова приложение (либо найдите его в списке приложений в системе на эмуляторе, либо снова нажмите CTRL+F11 в Eclipse ). В логах снова отобразились три метода, вызванные при создании. Теперь в эмуляторе нажмите CTRL+F12, ориентация сменилась. Кажется, что ничего особенного не произошло, но смотрим логи и видим:





_MainActivity: onPause()  
MainActivity: onStop()  
MainActivity: onDestroy()  
MainActivity: onCreate()  
MainActivity: onStart()  
MainActivity: onResume()_





Activity полностью уничтожается и снова создается. При этом обычно выполняются процедуры сохранения и восстановления данных, чтобы не потерялись данные, и приложение сохранило свой вид. Про то, как это делается, мы будем говорить в последующих уроках.





Также есть еще метод **onRestart**. Он вызывается перед методом **onStart**, если Activity не создается с нуля, а восстанавливается из состояния **Stoped**. Его мы рассмотрим в следующем уроке.





Обычно в учебниках эта тема дается по-другому. Но мне это шаблонное объяснение кажется недостаточно понятным, поэтому я написал свое. Как всегда, надеюсь, что у меня получилось раскрыть тему )





Советую вам после этого урока прочитать хелп, ссылку на который я дал в самом начале урока. Там все очень хорошо написано. И знания лучше усвоятся. Пока что, главное – это понять в какой момент, какой метод вызывается. А уже дальше мы будем разбираться, как это можно использовать и что там кодить.





Статья взята из сайта [startandroid.ru](http://startandroid.ru/)
Добрый день друзья.





Продолжаю собирать важную информацию по программированию под android.





Сегодня речь пойдет о SOAP и REST запросах.


 <!-- more -->


Одной из задач, часто решаемых разработчиками мобильного софта, является получение данных от удаленного **web сервиса**. Этот процесс включает в себя несколько этапов: отправка запрос web-сервису, получение ответа и парсинг ответа с целью получения данных. В Android нет встроенного SOAP клиента, однако существует несколько довольно неплохих сторонних библиотек. Мы не будем пользоваться чужими поделками, а разработаем собственный клиент на базе Android API.  
  
_**SOAP **(Simple Object Access Protocol) это основанный на XML протокол, предназначенный для обмена данными между распределенными приложениями.  **REST **(Representational State Transfer)- архитектура позволяющая строить распределенные, масштабируемые приложения. Основная задача сервера в этой архитектуре предоставить клиентам доступ к ресурсам по их идентификаторам (URI). Под доступом подразумевается как получение информации, так и ее изменение. SOAP и REST строятся поверх существующих web протоколов, например HTTP. Я не буду здесь вдаваться в детали, если Вы не знакомы с темой, рекомендую посмотреть вот эту [статью](http://habrahabr.ru/blogs/webdev/131343/)._  
  






### Формат запроса для SOAP сервису





Прежде чем переходить к написанию кода, давайте посмотрим на структуру SOAP.





![](http://android-helper.com.ua/images/uploads/2012/10/soap_structure.png)





Обычный** SOAP запрос** выглядит так:




	POST /InStock HTTP/1.1

	Host: www.example.org

	Content-Type: application/soap+xml; charset=utf-8

	Content-Length: length

	SOAPAction: "http://www.w3schools.com/GetItems"

 

	<?xml version="1.0"?>

	<soap:Envelope

	xmlns:soap="http://www.w3.org/2001/12/soap-envelope"

	soap:encodingStyle="http://www.w3.org/2001/12/soap-encoding">

	<soap:Header>

  	<m:Trans xmlns:m="http://www.w3schools.com/transaction/"

  	soap:mustUnderstand="1">234

	  </m:Trans>

	</soap:Header>

	<soap:Body>

  	<m:GetPrice xmlns:m="http://www.w3schools.com/prices">

    	<m:Item>Apples</m:Item>

	  </m:GetPrice>

	</soap:Body></soap:Envelope>




То есть SOAP запрос/ответ передается как пакет (SOAP Envelope), состоящий из заголовка (SOAP Header) и тела (SOAP Body).**SOAP Header** - вспомогательный  компонент, содержащий конфиденциальную информацию для приложения, например параметры  аутентификации. **SOAP Body** - это сообщение с полезной информацией. Заголовок может также содержать** SOAP Action**, который определяет функцию, запрашиваемую сервисом.  
  






### Отправка запроса SOAP-сервису





Чтобы вызвать SOAP-сервис вы должны сделать две вещи:  
**Во-первых**, вручную сконструировать SOAP пакет, например вот так:




	String envelope="<?xml version=\"1.0\" encoding=\"utf-8\"?>"+

	"<soap:Envelope xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\"xmlns:soap=\"http://schemas.xmlsoap.org/soap/envelope/\">"+

  	"<soap:Body>"+

    "<GetItems xmlns=\"http://tempuri.org/\">"+

      "<startDate>%s</ startDate>"+

      "<getAll>%s</getAll>"+

    "</Items>"+

  	"</soap:Body>"+

	"</soap:Envelope>";




где %s метка формата. С помощью метода String.format на ее место  будет подставляться конкретное значение.


	String requestEnvelope=String.format(envelope, "10-5-2011","true");



**Во-вторых**, вызвать web-сервис, например так:

	String CallWebService(String url,

    String soapAction,

   	String envelope)  {

  	final DefaultHttpClient httpClient=new DefaultHttpClient();

	  // параметры запроса

	  HttpParams params = httpClient.getParams();

     HttpConnectionParams.setConnectionTimeout(params, 10000);

     HttpConnectionParams.setSoTimeout(params, 15000);

     // устанавливаем параметры

  	HttpProtocolParams.setUseExpectContinue(httpClient.getParams(), true);

 

  	// С помощью метода POST отправляем конверт

  	HttpPost httppost = new HttpPost(url);

  	// и заголовки

     httppost.setHeader("soapaction", soapAction);

     httppost.setHeader("Content-Type", "text/xml; charset=utf-8");

 

     String responseString="";

     try {

 

      // выполняем запрос

   	HttpEntity entity = new StringEntity(envelope);

   	httppost.setEntity(entity);

 

   	// Заголоаок запроса

   	ResponseHandler<string> rh=new ResponseHandler<string>() {

    // вызывается, когда клиент пришлет ответ

    public String handleResponse(HttpResponse response)

      throws ClientProtocolException, IOException {

 

     // получаем ответ

     HttpEntity entity = response.getEntity();

 

     // читаем его в массив

           StringBuffer out = new StringBuffer();

           byte[] b = EntityUtils.toByteArray(entity);

 

           // write the response byte array to a string buffer

           out.append(new String(b, 0, b.length));

           return out.toString();

    }

   	};

 

   	responseString=httpClient.execute(httppost, rh); 

 

  	}

     catch (Exception e) {

      Log.v("exception", e.toString());

  	}

 

     // закрываем соединение

  	httpClient.getConnectionManager().shutdown();

  	return responseString;

 		}




После вызова этой функции Вы получите ответ, который будет выглядеть как-то так:


	<?xml version="1.0" encoding="utf-8"?>

	<soap:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">

  	<soap:Body>

    	<GetItemsResponse xmlns="http://tempuri.org/">

     	 <GetItemsResult>



        <Items>

          <Item>

            <name>string</name>

            <description>string</ description >

          </iPhoneCategory>

          <iPhoneCategory>

            <name>string</name>

            <description>string</ description >

          </ Item >

        </Items>

      	</GetItemsResult>

    	</ GetItemsResponse >

  	</soap:Body>

	</soap:Envelope>


Этот ответ нужно разобрать XML парсером и извлечь нужные данные.  
  






### Отправка запроса REST-сервису





Расбота с REST-сервисом намного проще. Вы должны вызвать сервис, передав ему URL с параметрами, например вот так:  
  
	http://example.com/resources/getitems  
  
Пример вызова REST сервиса:


	String callWebErvice(String serviceURL){

        // http get client

            HttpClient client=new DefaultHttpClient();

            HttpGet getRequest=new HttpGet();

 

            try {

                // создаем a URI объект

                getRequest.setURI(new URI(serviceURL));

            } catch (URISyntaxException e) {

                Log.e("URISyntaxException", e.toString());

            }

 

            // Создаем BufferedReader дял чтения ответа

            BufferedReader in=null;

            // и HttpResponse для получения ответа

            HttpResponse response=null;

            try {

                // выполняем запрос

                response = client.execute(getRequest);

            } catch (ClientProtocolException e) {

                Log.e("ClientProtocolException", e.toString());

            } catch (IOException e) {

                Log.e("IO exception", e.toString());

            }

            try {

                in=new BufferedReader(new InputStreamReader(response.getEntity().getContent()));

            } catch (IllegalStateException e) {

                Log.e("IllegalStateException", e.toString());

            } catch (IOException e) {

                Log.e("IO exception", e.toString());

            }

            StringBuffer buff=new StringBuffer("");

            String line="";

            try {

                while((line=in.readLine())!=null)

                {

                    buff.append(line);

                }

            } catch (IOException e) {

                Log.e("IO exception", e.toString());

                return e.getMessage();

            }

 

            try {

                in.close();

            } catch (IOException e) {

                Log.e("IO exception", e.toString());

            }

            // возвращаем ответ в виде строки текста

            return buff.toString();

    }




Соединение с web-сервисом по протоколу Secure Sockets Layer (SSL)  
  
HttpClinet не поддерживает SSL соединения, поэтому если Вам необходимо работать с защищенным web-сервисом, то используйте  javax.net.ssl.HttpsURLConnection. Ниже приведен пример, иллюстрирующий работу с SSL SOAP web-сервисом.


	String CallWebService(String url,

             String soapAction,

            String envelope) throws IOException  {

        URL address=new URL(url);

        URLConnection connection=address.openConnection();

        HttpsURLConnection post=(HttpsURLConnection)connection;

        post.setDoInput(true);

        post.setDoOutput(true);

        post.setRequestMethod("POST");

        post.setRequestProperty("SOAPAction", soapAction);

        post.setRequestProperty( "Content-type", "text/xml; charset=utf-8" );

        post.setRequestProperty( "Content-Length", String.valueOf(envelope.length()));

        post.setReadTimeout(4000);

 

        OutputStream outStream=post.getOutputStream();

        Writer out=new OutputStreamWriter(outStream);

        out.write(envelope);

        out.flush();

        out.close();

 

        InputStream inStream = post.getInputStream();

        BufferedInputStream in = new BufferedInputStream(inStream,4);

        StringBuffer buffer=new StringBuffer();

        // читаем за раз 4 байта

        byte[] buffArray=new byte[4];

        int c=0;

            while((c=in.read(buffArray))!=-1){

                for(int i=0;i<c;i++)

                    buffer.append((char)buffArray[i]);

            }

 

            return buffer.toString();

    }


Итак, мы отправили запрос web-сервису и получили ответ в виде строки. Настало время использовать парсер.  
  






### Использование парсера в Android





В зависимости от реализации сервиса в ответ на наш запрос может прийти ответ в формате XML, SOAP или JSON.  
  






#### Программирование XML парсера в Android





Рассмотрим конкретный пример. Допустим, нам пришел XML ответ, содержащий имя, фамилию и возраст пользователя:


	<?xml version="1.0"?>

	<person>

    <firstname>Jack</firstname>

    <lastname>smith</lastname>

    <age>28</age>

	</person>





С помощью этих параметров нужно создать объект класса Person:




	public class Person{

        public String firstName;

        public String lastName;

        public int age;

    }


### Использование DOM Parser





В библиотека **org.w3c.dom** можно найти классы, с помощью которых можно разобрать xml, создав документ и сравнив каждый узел с шаблоном. Приведенная ниже функция использует DOM парсер:



	void parseByDOM(String response) throws 	ParserConfigurationException, SAXException, IOException{

        Person person=new Person();

        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();

        DocumentBuilder db = dbf.newDocumentBuilder();

        Document doc = db.parse(new InputSource(new StringReader(response)));

        // нормализируем документ

        doc.getDocumentElement().normalize();

        // получаем корневой узел

        NodeList nodeList = doc.getElementsByTagName("person");

        Node node=nodeList.item(0);

        // узел имеет три дочерних узла

        for (int i = 0; i < node.getChildNodes().getLength(); i++) {

        Node temp=node.getChildNodes().item(i);

        if(temp.getNodeName().equalsIgnoreCase("firstname")){

            person.firstName=temp.getTextContent();

        }

        else if(temp.getNodeName().equalsIgnoreCase("lastname")){

            person.lastName=temp.getTextContent();

        }

        else if(temp.getNodeName().equalsIgnoreCase("age")){

            person.age=Integer.parseInt(temp.getTextContent());

        }

 

        }

 

        Log.e("person", person.firstName+ " "+person.lastName+" "+String.valueOf(person.age));

    }




Показаный метод работает, однако для его использования нужно знать структуру разбираемого xml и порядок перечисления узлов. Более гибок в этом плане SAX парсер.  
 





###  Использование SAX Parser





SAX Parser находится в пакете **org.xml.sax**. В процессе разбора документа SAX генерирует события, для которых программист должен написать обработчики. Создадим класс-потомок основе класса **DefaultHandler **и переопределим следующие методы:  
 








  * **startDocument()**: Этот метод вызывается при открытии XML документа.



  * **startElement(String uri, String localName, String qName, Attributes attributes)**: вызывается, когда парсер встречает XML-узел.



  * **endElement(String uri, String localName, String Name)**: вызывается, когда парсер считал закрывающий тег.



  * **characters(char[] ch, int start, int length)**: этот метод вызывается, когда парсер считывает данные из узла.






Напишем класс для парсинга нашего примера





	public class PersonParser extends DefaultHandler

	{

 

    // arraylist для сохранения объектов persons

    ArrayList persons;

    // вспомогательный объект

    Person tempPerson;

    // буфер

    StringBuilder builder;

 

    /**

     * Инициализируем arraylist

     * @throws SAXException

     */

    @Override

    public void startDocument() throws SAXException {

        pesons=new ArrayList();

 

    }

 

    /**

     * Инициализируем вспомогательный объект и буфер 

     * @param uri

     * @param localName

     * @param qName

     * @param attributes

     * @throws SAXException

     */

    @Override

    public void startElement(String uri, String localName, String qName,

            Attributes attributes) throws SAXException {

 

        if(localName.equalsIgnoreCase.equals("person")){

            tempPerson=new Person();

            builder=new StringBuilder();

        }

 

    }

    /**

     * Завершение чтения тега person и

     * добавление данных в arraylist

     * @param uri

     * @param localName

     * @param qName

     * @throws SAXException

     */

    @Override

    public void endElement(String uri, String localName, String qName)

            throws SAXException {

        // закончилось чтение person, добавим собранные данные в массив

        if(localName.toLowerCase().equals("person"))

        {

            this.persons.add(tempPerson);

        }

        // закончилось чтение  "firstname", добавим эти данные во вспомогательный объект

        else if(localName.toLowerCase().equals("firstname")){

            tempPerson.firstName=builder.toString();

        }

        // закончилось чтение  "lastname", добавим эти данные во вспомогательный объект

        else if(localName.toLowerCase().equals("lastname")){

            tempPerson.lastName=builder.toString();

        }

        // закончилось чтение  "age", добавим эти данные во вспомогательный объект

        else if(localName.toLowerCase().equals("age")){

            tempPerson.age=Integer.parseInt(builder.toString());

        }

    }

 

    /**

     * Считываем данные из каждого тега

     * @param ch

     * @param start

     * @param length

     * @throws SAXException

     */

    @Override

    public void characters(char[] ch, int start, int length)

            throws SAXException {

        // читаем символы в буфер

        String tempString=new String(ch, start, length);

         builder.append(tempString);

    }

	}



Код довольно прост. Парсер проходится по всем узлам, и в зависимости от считанного тега, вы выполняете то или иное действие. Используем этот класс:


	public ArrayList getPersons(final String response) throws 

	ParserConfigurationException, SAXException, IOException

    {

        BufferedReader br=new BufferedReader(new StringReader(response));

        InputSource is=new InputSource(br);

        PersonParser parser=new PersonParser();

        SAXParserFactory factory=SAXParserFactory.newInstance();

           SAXParser sp=factory.newSAXParser();

           XMLReader reader=sp.getXMLReader();

           reader.setContentHandler(parser);

           reader.parse(is);

           ArrayList persons=parser.persons;

 

        return persons;

 

    }




### Программирование JSON парсера в Android





Некоторые сервисы могут вернуть ответ не в виде XML, а как JSON массив:



	"persons"

	[

	{

		"person"{

			"firstName": "John",

     	"lastName": "Smith",

    	"age": 25

		}

	}

	{

		"person"{

			"firstName": "Catherine",

     	"lastName": "Jones",

     	"age": 35

		}

	}

	]





Здесь мы видим JSON массив persons, содержащий несколько JSON объектов person. На самом деле, работать с JSON намного проще, чем с XML:

	public ArrayList<Person> getMessage(String response){

        JSONObject jsonResponse;

        ArrayList<Person> arrPersons=new ArrayList<Person>;

        try {

            // получаем ответ

            jsonResponse = new JSONObject(response);

            // получаем массив

            JSONArray persons=jsonResponse.optJSONArray("persons");

            // проходимся по массиву и извлекаем персоны

            for(int i=0;i<persons.length();i++){

                // получаем объект person

                JSONObject person=persons.getJSONObject(i);

                // получаем firstname

                String firstname=person.optString("firstname");

                // получаем lastname

                String lastname=person.optString("lastname");

                // получаем age

                int age=person.optInt("age");

 

                // создаем объект и добавляем его в массив

                Person p=new Person();

                p.firstName=firstname;

                p.lastName=lastname;

                p.age=age;

                arrPersons.add(p);

            }

 

        } catch (JSONException e) {

 

            e.printStackTrace();

        }

 

        return arrPersons;

    }    



Обратите внимание, здесь мы использовали методы optJSONArray, optString, optInt вместо getString, getInt, поскольку opt-методы эти методы возвращают пустую строку или 0, если какой-то элемент не найден, в то время как get-методы генерируют исключения.





Источник статьи [mobilab.ru](http://www.mobilab.ru/androiddev/androidwebserviceclient.html)
Столкнулся с необходимостью распознавать речь на android устройстве.





Долго собирал крупицы информации, пока не нашел хорошею и полною статью





Прошу к прочтению.


<!-- more -->


Последнее время большой интерес у пользователей вызывает возможность распознавания речи в телефонах. Огромная заслуга в популяризации этого направления принадлежит компании Aple, однако Google также располагает подобными технологиями. Собственно этой теме и будет посвящена данная статья. Мы разработаем приложение, которое будет распознавать речь пользователя и воспроизводить результат с помощью голосового движка "Text To Speech" (TTS). Отметим, что распознавание происходит на серверах Google, поэтому для работы приложению необходимо разрешить использовать коммуникационные возможности. Кроме того, распознавание речи не работает на эмуляторе. Тестировать программу необходимо на реальном устройстве.





На самом деле работать с распознаванием и синтезом речи в Android очень просто. Все сложные вычисления скрыты от нас в довольно элегантную библиотеку с простым API. Вы сможете осилить этот урок, даже если имеете весьма поверхностные знания о программировании для Android.





Давайте создадим новый проект в Eclipse. Для наших нужд понадобится версия SDK не меньше 8. Опишем в общих чертах создаваемую программу. При запуске приложения пользователю будет показана кнопка, после нажатия на которую пользователю будет предложено надиктовать фразу. Затем будет осуществлено распознавание и будет показан список возможных вариантов. Поскольку технологии распознавания речи далеки от совершенства, программа не может ручаться за точность результата, именно поэтому будет предложено несколько вариантов. После того, как пользователь выберет один из них, будет запущен генератор голоса, который воспроизведет выбранную фразу. 





Нам понадобится несколько текстовых строк, объявим их в фале "res/values/strings.xml"





	<resources>

    <string name="intro">Press the button to speak!</string>

    <string name="app_name">SpeechRepeat</string>

    <string name="speech">Speak now!</string>

    <string name="word_intro">Suggested words&#8230;</string>

	</resources>







Откроем файл "res/layout/main.xml" и зададим шаблон дизайна приложения. Для этого переключимся из графического в XML редактор и изменим содержимое файла





	<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"

    android:layout_width="fill_parent"

    android:layout_height="fill_parent"

    android:orientation="vertical"

    android:background="#ff330066"

    android:paddingBottom="5dp" >

 

	</LinearLayout>







Добавим в Linear Layout элемент Text View






	<TextView android:layout_width="fill_parent"

    android:layout_height="wrap_content"

    android:text="@string/intro"

    android:padding="5dp"

    android:textStyle="bold"

    android:textSize="16dp"

    android:gravity="center"

    android:textColor="#ffffff33" />







обратите внимание, TextView ссылается на строку intro, которую мы задали в файле strings.xml. 





После Text View добавим кнопку





	<Button android:id="@+id/speech_btn"

    android:layout_width="match_parent"

    android:layout_height="wrap_content"

    android:text="@string/speech" />








Пользователь будет нажимать эту кнопку, чтобы начать говорить. Кнопка имеет параметр id, через который ее можно вызвать из Java кода. После нажатия на кнопку пользователю показывается сообщение. Нам также понадобится TextView для вывода слов с предложениями






	<TextView android:layout_width="fill_parent"

    android:layout_height="wrap_content"

    android:padding="5dp"

    android:text="@string/word_intro"

    android:textStyle="italic" />






TextView будет использовать строковый ресурс. Нам также понадобится список для вариантов слов







	<ListView android:id="@+id/word_list"

    android:layout_width="fill_parent"

    android:layout_height="0dip"

    android:layout_weight="1"

    android:paddingLeft="10dp"

    android:paddingTop="3dp"

    android:paddingRight="10dp"

    android:paddingBottom="3dp"

    android:layout_marginLeft="20dp"

    android:layout_marginRight="20dp"

    android:layout_marginTop="5dp"

    android:layout_marginBottom="5dp"

    android:background="@drawable/words_bg" />







ListView будет заполняться данными в процессе работы программы, поэтому для доступа к этому компоненту также требуется ID. Обратите также внимание на наличие ресурса drawable. Вы должны сохранить файл words_bg.xml в папке res




	<shape xmlns:android="http://schemas.android.com/apk/res/android"

    android:dither="true">

    <gradient

    android:startColor="#ff000000"

    android:endColor="#ff000000"

    android:centerColor="#00000000"

    android:angle="180" />

    <corners android:radius="10dp" />

    <stroke

    android:width="2dp"

    android:color="#66ffffff" />

	</shape> 







Ничего особенного. Вы можете настроить дизайн ListView по своему усмотрению. Нам осталось задать еще один элемент пользовательского интерфейса - шаблон для элемента ListView. Создайте новый файл res/layout/word.xml со следующим содержанием





	<TextView xmlns:android="http://schemas.android.com/apk/res/android"

    android:layout_width="fill_parent"

    android:layout_height="fill_parent"

    android:gravity="center"

    android:padding="5dp"

    android:textColor="#ffffffff"

    android:textSize="16dp" >

	</TextView>







Таким образом, каждый элемент списка представляет собой просто Text View.





Если Вы все сделали правильно, то при запуске должно получиться следующее





![](http://android-helper.com.ua/images/uploads/2012/10/speechsample1.jpg)




### Программируем распознавание речи в Android





После того, как шаблон будущего приложения создан, можно перейти к кодированию. Откройте java файл главной Activity и добавьте в начало файла





	import java.util.ArrayList;

	import java.util.List;

	import java.util.Locale;

 

	import android.app.Activity;

	import android.content.Intent;

	import android.content.pm.PackageManager;

	import android.content.pm.ResolveInfo;

	import android.os.Bundle;

	import android.speech.RecognizerIntent;

	import android.speech.tts.TextToSpeech.OnInitListener;

	import android.speech.tts.TextToSpeech;

	import android.util.Log;

	import android.view.View;

	import android.view.View.OnClickListener;

	import android.widget.AdapterView;

	import android.widget.AdapterView.OnItemClickListener;

	import android.widget.ArrayAdapter;

	import android.widget.Button;

	import android.widget.ListView;

	import android.widget.Toast;

	import android.widget.TextView;






Изменим немного декларацию главного класса






	public class SpeechRepeatActivity extends Activity implements OnClickListener, OnInitListener {





OnInitListener необходим для работы TTS движка. Внутри класса добавим объявления переменных перед методом onCreate







	//переменная для проверки возможности

	//распознавания голоса в телефоне

	private static final int VR_REQUEST = 999;

 

	//ListView для отображения распознанных слов

	private ListView wordList;

 

	//Log для вывода вспомогательной информации

	private final String LOG_TAG = "SpeechRepeatActivity";

	//***здесь можно использовать собственный тег***

 

	//переменные для работы TTS 

 

	//переменная для проверки данных для TTS 

	private int MY_DATA_CHECK_CODE = 0;

 

	//Text To Speech интерфейс

	private TextToSpeech repeatTTS;



Внутри метода onCreate автоматически сгенерирован код, вызывающий метод родительского класса и устанавливающий главный контекст вывода.




	//вызов суперкласса

	super.onCreate(savedInstanceState);

	//установка контекста вывода

	setContentView(R.layout.main);








Cоздадим переменные для работы с кнопкой и списком распознанных слов



	Button speechBtn = (Button) findViewById(R.id.speech_btn);

	wordList = (ListView) findViewById(R.id.word_list);








Далее необходимо проверить поддерживается ли возможность распознавания голоса телефоном


	//проверяем, поддерживается ли распознование речи

	PackageManager packManager = getPackageManager();

	List<ResolveInfo> intActivities = packManager.queryIntentActivities(new 

        Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH), 0);

	if (intActivities.size() != 0) {

    // распознавание поддерживается, будем отслеживать событие щелчка по кнопке

    speechBtn.setOnClickListener(this);

	}

	else

	{

    // распознавание не работает. Заблокируем 

    // кнопку и выведем соответствующее 

    // предупреждение.

    speechBtn.setEnabled(false);

    Toast.makeText(this, "Oops - Speech recognition not supported!", Toast.LENGTH_LONG).show();

	}








Мы запрашиваем среду, поддерживается ли Recognizer Intent. Если поддерживается, мы говорим приложению, что нужно отслеживать щелчок пользователя по кнопке. Если интент не поддерживается, мы блокируем кнопку и выводим соответствующее сообщение пользователю.





Напишем код, обрабатывающий нажатие на кнопку. Внутри класса после метода OnCreate добавим метод OnClick.






	public void onClick(View v) {

    if (v.getId() == R.id.speech_btn) {

        // отслеживаем результат

        listenToSpeech();

    }

	}







Как видите, при нажатии на кнопку мы вызываем метод listenToSpeech().



	private void listenToSpeech() {

 

    //запускаем интент, распознающий речь и передаем ему требуемые данные

    Intent listenIntent = new Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH);

    //указываем пакет

 	listenIntent.putExtra(RecognizerIntent.EXTRA_CALLING_PACKAGE, 

           getClass().getPackage().getName());

    //В процессе распознования выводим сообщение

    listenIntent.putExtra(RecognizerIntent.EXTRA_PROMPT, "Say a word!");

    //устанавливаем модель речи

    	listenIntent.putExtra(RecognizerIntent.EXTRA_LANGUAGE_MODEL, 

            RecognizerIntent.LANGUAGE_MODEL_FREE_FORM);

    //указываем число результатов, которые могут быть получены

    listenIntent.putExtra(RecognizerIntent.EXTRA_MAX_RESULTS, 10);

 

    //начинаем прослушивание

    startActivityForResult(listenIntent, VR_REQUEST);

	}





Большая часть приведенного кода стандартна для программ, использующих распознавание голоса. Обратите внимание на параметр EXTRA_PROMPT. Он задает строку-приглашение для пользователя. Параметр EXTRA_MAX_RESULTS определяет максимальное число вариантов распознавания. В конце концов, мы вызываем startActivityForResult. Результат его работы будет передан в метод onActivityResult.





На следующем скриншоте показан экран в момент распознавания речи.





![](http://android-helper.com.ua/images/uploads/2012/10/speechsample2.jpg)





Определим метод onActivityResult



	@Override

	protected void onActivityResult(int requestCode, int resultCode, Intent data) {

    //проверяем результат распознавания речи

    if (requestCode == VR_REQUEST && resultCode == RESULT_OK)

    {

        //Добавляем распознанные слова в список результатов

        ArrayList<String> suggestedWords = 

                 data.getStringArrayListExtra(RecognizerIntent.EXTRA_RESULTS);

        //Передаем список возможных слов через ArrayAdapter компоненту ListView  

        wordList.setAdapter(new ArrayAdapter<String> (this, R.layout.word, suggestedWords));

    }

 

    //tss код здесь

 

    //вызываем метод родительского класса

    super.onActivityResult(requestCode, resultCode, data);

	}





Обратите внимание, при проверке результата мы сравниваем переменную requestCode с константой VR_REQUEST, которую использовали ранее при вызове метода startActivityForResult. Таким образом, мы рассматриваем только результаты от нашего запроса. В метод возвращается 10 вариантов распознанных слов, которые мы записываем в список ArrayList. Этот список мы используем в ArrayAdapter компонента List View. 





Если приложение справилось с задачей и смогло что-то распознать, вы увидите похожий н показанный на левом скриншоте результат. Если приложению не удалось распознать фразу, будет показано сообщение, как на правом скриншоте





![](http://android-helper.com.ua/images/uploads/2012/10/speechsample3.jpg)
![](http://android-helper.com.ua/images/uploads/2012/10/speechsample4.jpg)



Вот, собственно и все. Распознавание голоса в Android - довольно простая задача. Мы вызываем интент RecognizerIntent с требуемыми нами параметрами. Результат  возвращается в onActivityResult.





### Генерация речи в Android





Перейдем ко второй части нашего приложения, связанного с генерацией речи. Мы хотим, чтобы телефон проговаривал фразу из списка результатов. Мы должны определить строку, на которую щелкнул пользователь. Вернемся к методу onCreate и добавим в конец этого метода код




	//засекаем щелчок пользователя по слову из списка

	wordList.setOnItemClickListener(new OnItemClickListener() {

 

    //метод вызывается в ответ на щелчок по слову

    public void onItemClick(AdapterView<?> parent, View view, int position, long id)

    {

        //записываем в переменную TextView строки

        TextView wordView = (TextView)view;

        //получаем строку с текстом

        String wordChosen = (String) wordView.getText();

        //выводим ее в лог для отладки

        Log.v(LOG_TAG, "chosen: "+wordChosen);

        //выводим Toast сообщение

        Toast.makeText(SpeechRepeatActivity.this, "You said: "+wordChosen, 

                Toast.LENGTH_SHORT).show();

    }

	});





Мы используем метод setOnItemClickListener чтобы установить отслеживание щелчков для каждой строки. Внутри нового объекта OnItemClickListener мы описали метод onItemClick, который вызывается в ответ на щелчок по строке списка. Выбранная строка передается, как View в этот метод. Поскольку при проектировании шаблона приложения мы указали, что наш список состоит из TextView, мы преобразуем полученное значение в объект TextView и достаем из него строковое значение. Мы записываем это слово в лог и показываем пользователю Toast сообщение.





Если Вас не интересует процесс генерации речи, Вы можете остановиться и протестировать приложение. 





Для генерации речи необходимо настроить движок TTS. Добавим код в конец метода onCreate



	//подготовка движка TTS для проговаривания слов

	Intent checkTTSIntent = new Intent(); 

	//проверка наличия TTS 

	checkTTSIntent.setAction(TextToSpeech.Engine.ACTION_CHECK_TTS_DATA); 

	//запуск checkTTSIntent интента

	startActivityForResult(checkTTSIntent, MY_DATA_CHECK_CODE); 





Как и в случае распознавания, результат интента возвращается в метод onActivityResult. В этом методе перед строкой super.onActivityResult(requestCode, resultCode, data); добавьте





	//returned from TTS data check

	if (requestCode == MY_DATA_CHECK_CODE)

	{ 

    //все необходимые приложения установлены, создаем TTS 

    if (resultCode == TextToSpeech.Engine.CHECK_VOICE_DATA_PASS) 

        repeatTTS = new TextToSpeech(this, this); 

    //движок не установлен, предположим пользователю установить его

    else

    { 

        //интент, перебрасывающий пользователя на страницу TSS в Google Play

        Intent installTTSIntent = new Intent(); 

        installTTSIntent.setAction(TextToSpeech.Engine.ACTION_INSTALL_TTS_DATA); 

        startActivity(installTTSIntent); 

    } 

	}






Таким образом, мы проверяем наличие TTS движка, и если он не установлен - предлагаем пользователю установить соответствующую программу. 





Чтобы завершить настройку TTS, добавим метод onInit, который вызывается при успешной инициализации TTS.







	public void onInit(int initStatus) {

    if (initStatus == TextToSpeech.SUCCESS)  

        repeatTTS.setLanguage(Locale.UK); //Язык

	}







Здесь мы устанавливаем язык генератора речи.





Для того, чтобы заставить движок проговорить строку, нужно вызвать метод repeatTTS.speak. Вернемся к методу onCreate. Внутри метода onItemClick после строки Toast.makeText(SpeechRepeatActivity.this, "You said: "+wordChosen, Toast.LENGTH_SHORT).show(); добавьте следующий код






	repeatTTS.speak("You said: "+wordChosen, TextToSpeech.QUEUE_FLUSH, null);




Таким образом, одновременно с Toast сообщением пользователь услышит сгенерированную речь. Отметим еще раз, что эмулятор не поддерживает распознавание речи, поэтому тестировать программу необходимо на телефоне.





Полный проект вы можете скачать на [странице с кодами](http://android-helper.com.ua/codes/).





Статья взята из сайта [mobilab.ru](http://www.mobilab.ru/androiddev/androidspeechrecognition.html)
Добрый день друзья.





Много уже работал с базами данных.





Но ни как не мог подготовить статью на эту тему.





Сегодня я ее нашел хорошею статью. И покажу ее вам.

<!-- more -->



По умолчанию в Android используется база данных SQLite - это довольно популярная, легкая и быстрая реляционная база данных. Если для вас SQL – это пустой звук, то, скорее всего, вы мало что поймете из этой статьи. Предполагается, что читатель знаком с SQL, знает что такое запросы выборки, триггеры и представления. Если это не так - почитайте какое-нибудь введение в SQL, а потом возвращайтесь сюда.  
  
База данных SQLite  имеет некоторые особенности, о которых нужно помнить:








  * Не поддерживается проверка типов данных. Это значит, что Вы случайно сможете записать данные не того типа, например поместить строку в колонку, предназначенную для целых чисел.



  * Не поддерживается ссылочная целостность:  нет поддержки FOREIGN KEY и конструкций JOIN.



  * Полная поддержка Unicode отключена по умолчанию.






  
Давайте создадим простую базу данных, содержащую информацию о работниках. База содержит две таблицы:  Employees - для хранения данных о сотрудниках и Dept - о департаментах. И представление ViewEmps, связывающее работников с департаментами.





![](http://android-helper.com.ua/images/uploads/2012/10/android_db_sql.jpg)




## Создание SQLite базы данных в Android проекте





По умолчанию, Android не содержит удобных СУБД для создания и работы с базами данных (есть sqlite3.exe - консоль для работы с базой данных), поэтому давайте создадим базу и все необходимые таблицы непосредственно из кода.   
  
Во-первых, мы напишем класс, который будет управлять всеми операциями с базой данных: созданием базы, созданием таблиц, вставкой и удалением записей. Давайте создадим класс потомок от **SQLiteOpenHelper**. Нам нужно переопределить два метода:








  * onCreate(SQLiteDatabase db) - вызывается при создании базы данных. Здесь мы можем создать таблицы, определить в них колонки, создать виды и триггеры.



  * onUpgrade(SQLiteDatabse db, int oldVersion, int newVersion) - вызывается, при внесении изменений в базу, например при создании и удалении таблиц






  
Внутри нашего класса определим переменные





	public class DatabaseHelper extends SQLiteOpenHelper {

 

 	static final String dbName="demoDB";

 	static final String employeeTable="Employees";

 	static final String colID="EmployeeID";

 	static final String colName="EmployeeName";

 	static final String colAge="Age";

 	static final String colDept="Dept";

 

 	static final String deptTable="Dept";

 	static final String colDeptID="DeptID";

 	static final String colDeptName="DeptName";

 

 	static final String viewEmps="ViewEmps";

 

 	// и создадим конструктор

 

	public DatabaseHelper(Context context) {

  	super(context, dbName, null,33);

		}

	}


Как видите, здесь мы просто вызываем конструктор суперкласса, который имеет четыре параметра:








  * **Context **- контекст, связанный с базой данных.



  * **dataBaseName **- имя базы данных.



  * **CursorFactory** - можно использовать класс, созданный на основе класса Cursor. Это позволяет проводить некоторые дополнительные проверки и операции с результатами запросов. Если сюда подставить ссылку на наш класс, он будет использоваться вместо стандартного курсора. Мы не будем работать с  **CursorFactory**, поэтому передадим значение null.



  * **Version**- версия базы данных. Смысл этого параметра будет раскрыт ниже






## Создание базы данных





Давайте переопределим метод **onCreate**


	public void onCreate(SQLiteDatabase db) {

  	// TODO Auto-generated method stub

 

  	db.execSQL("CREATE TABLE "+deptTable+" ("+

        colDeptID+ " INTEGER PRIMARY KEY , "+

        colDeptName+ " TEXT)");

 

  	db.execSQL("CREATE TABLE "+employeeTable+

        " ("+colID+" INTEGER PRIMARY KEY AUTOINCREMENT, "+

        colName+" TEXT, "+colAge+" Integer, "+colDept+

        " INTEGER NOT NULL ,FOREIGN KEY ("+colDept+")

        REFERENCES "+deptTable+" ("+colDeptID+"));");

 

 	 db.execSQL("CREATE TRIGGER fk_empdept_deptid " +

    " BEFORE INSERT "+

    " ON "+employeeTable+

 

    " FOR EACH ROW BEGIN"+

    " SELECT CASE WHEN ((SELECT "+colDeptID+" FROM "+

    deptTable+" WHERE "+colDeptID+"=new."+colDept+" ) IS NULL)"+

    " THEN RAISE (ABORT,'Foreign Key Violation') END;"+

    "  END;");

 

  	db.execSQL("CREATE VIEW "+viewEmps+

    " AS SELECT "+employeeTable+"."+colID+" AS _id,"+

    " "+employeeTable+"."+colName+","+

    " "+employeeTable+"."+colAge+","+

    " "+deptTable+"."+colDeptName+""+

    " FROM "+employeeTable+" JOIN "+deptTable+

    " ON "+employeeTable+"."+colDept+" ="+deptTable+"."+colDeptID

    );

 	 //Inserts pre-defined departments

  	InsertDepts(db);

 	}


Внутри метода мы с помощью SQL запросов создаем таблицы, триггеры и представления. Запросы вызываются для базы db с помощью метода **execSQL**.  
   
Метод **onCreate  **вызывается при создании базы данных, как только база создана, мы добавляем туда таблицы с необходимым набором полей. Вызов метода происходит, когда база данных не существует на диске, то есть для данного конкретного устройства этот метод будет вызван всего один раз, сколько бы мы потом не запускали нашу программу.  
 





##  Изменение базы данных





   
Иногда возникает необходимость внести изменения в базу данных: поменять схему, добавить новые таблицы или поменять типы столбцов таблиц. Все это можно сделать внутри метода **onUpdate(SQLiteDatabase db,int old Version,int newVerison)** .




	public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {

  	// TODO Auto-generated method stub

 

  	db.execSQL("DROP TABLE IF EXISTS "+employeeTable);

  	db.execSQL("DROP TABLE IF EXISTS "+deptTable);

 

  	db.execSQL("DROP TRIGGER IF EXISTS dept_id_trigger");

  	db.execSQL("DROP TRIGGER IF EXISTS dept_id_trigger22");

  	db.execSQL("DROP TRIGGER IF EXISTS fk_empdept_deptid");

  	db.execSQL("DROP VIEW IF EXISTS "+viewEmps);

  	onCreate(db);

 	}




Этот метод вызывается, когда изменяется номер, указанный в конструкторе класса. Помните то загадочное число 33, внутри конструктора **DatabaseHelper**? Если Вам вдруг понадобится внести изменение в свою базу, просто поменяйте номер в конструкторе. То есть, если вы измените конструктор


	public DatabaseHelper(Context context) {

  	super(context, dbName, null,34);

 	}




приложение поймет, что вы хотите изменить свою базу и вызовет метод onUpgrade. Обычно внутри этого метода удаляются таблицы и создаются заново с другим набором полей.   
 





##  Управление внешними ключами





Давайте создадим триггер, который будет следить при добавлении нового сотрудника за тем, чтобы указанный в описании сотрудника департамент присутствовал в таблице Dept.   
   
 SQL команда, создающая такой триггер, выглядит следующим образом:





	CREATE TRIGGER fk_empdept_deptid Before INSERT ON Employees

	FOR EACH ROW BEGIN

    SELECT CASE WHEN ((SELECT DeptID FROM Dept WHERE DeptID =new.Dept ) IS NULL)

    THEN RAISE (ABORT,'Foreign Key Violation') END;

    END

 

Добавим в метод onCreate вызов метода execSQL с соответствующим запросом:

	db.execSQL("CREATE TRIGGER fk_empdept_deptid " +

    " BEFORE INSERT "+

    " ON "+employeeTable+

 

    " FOR EACH ROW BEGIN"+

    " SELECT CASE WHEN ((SELECT "+colDeptID+" FROM "+deptTable+

    " WHERE "+colDeptID+"=new."+colDept+" ) IS NULL)"+

    " THEN RAISE (ABORT,'Foreign Key Violation') END;"+

    "  END;");


# Выполнение SQL команд в Android





 Как уже было отмечено выше, Вы можете выполнить любую SQL команду с помощью метода **db.execSQL(String statement)**.   
 





##  Добавление записи в таблицу





 Можно добавить новую запись в таблицу с помощью SQL команды **INSERT**, а можно воспользоваться методом **db.insert**:



	SQLiteDatabase db=this.getWritableDatabase();

	ContentValues cv=new ContentValues();

  	cv.put(colDeptID, 1);

  	cv.put(colDeptName, "Sales");

  	db.insert(deptTable, colDeptID, cv);

 		
	cv.put(colDeptID, 2);

  	cv.put(colDeptName, "IT");

  	db.insert(deptTable, colDeptID, cv);

  	db.close();



Обратите внимание, для соединения с базой данных мы вызвали метод **this.getWritableDatabase()**. Класс **ContentValues** позволяет создать карту с параметрами ключ-значение. Эта карта затем используется методом **insert**, который фактически добавляет запись в таблицу. Метод **ContentValues.put** создает пару ключ-значение. Еще одно замечание, хорошим тоном считается закрывать базу данных вызовом метода  **close()** после завершения выполнения группы команд.  
  






## Изменение значений в таблице





Изменить значение в какой-либо записи можно с помощью SQL команды **UPDATE **или с помощью метода  **db.update**:


	public int UpdateEmp(Employee emp)

  	{

   	SQLiteDatabase db=this.getWritableDatabase();

   	ContentValues cv=new ContentValues();

   	cv.put(colName, emp.getName());

   	cv.put(colAge, emp.getAge());

   	cv.put(colDept, emp.getDept());

   	return db.update(employeeTable, cv, colID+"=?", new String []{String.valueOf(emp.getID())});

  	}


Метод update имеет следующие параметры: 








  * **String Table**: название таблицы в которой мы хотим что-то изменить.



  * **ContentValues cv**: пара ключ-значение с новой информацией.



  * **String where**: строка-шаблон, определяющая условие  WHERE, которое проверяется для каждой строки таблицы. Ксли условие истинно, то в этой строке обновляется информация в соответствии с параметром cv.



  * **String[] args**: массив с аргументами, которые подставляются в строку-шаблон where.






## Удаление строк





Удалить строку в таблице можно с помощью SQL команды **DELETE**, а также с помощью метода **db.delete**. Этот метод имеет аналогичный  **update **набор параметров (за исключением cv).



	public void DeleteEmp(Employee emp)

  	{

   	SQLiteDatabase db=this.getWritableDatabase();

   	db.delete(employeeTable,colID+"=?", new String [] {String.valueOf(emp.getID())});

   	db.close();

  	}



## Выполнение SQL запросов





 Для выполнения запросов в Android используются два метода: **db.rawQuery** и **db.query**. Давайте сделаем запрос к базе, с целью получения списка всех департаментов:




	Cursor getAllDepts()

  	{

   	SQLiteDatabase db=this.getReadableDatabase();

   	Cursor cur=db.rawQuery("SELECT "+colDeptID+" as _id, "+

   	colDeptName+" from "+deptTable,new String [] {});

 

   	return cur;

  	}





 Метод **rawQuery** имеет два параметра:








  * **String query**: Строка с SQL запросом SELECT.



  * **String[] selection args**: массив аргументов where, если он используется в SELECT запросе.






  
**Замечания!** В качестве результата этого запроса возвращается объект **Cursor**. Если в качестве ключевого поля в таблице используется колонка с именем, отличным от** _id**, Вам необходимо использовать alias в форме "SELECT [Column Name] as _id". Дело в том, что объект **Cursor** всегда считает, что ключевое поле имеет имя **_id**, и если это не так, генерируется исключение.  
  
Другим способом выполнения запроса к базе является вызов метода **db.query**. Давайте напишем метод, который выдает всех сотрудников, работающих в каком-то конкретном департаменте:



	public Cursor getEmpByDept(String Dept)

  	{

   	SQLiteDatabase db=this.getReadableDatabase();

   	String [] columns=new String[]{"_id",colName,colAge,colDeptName};

   	Cursor c=db.query(viewEmps, columns, colDeptName+"=?", new String[]{Dept}, null, null, null);

   	return c;

  	}


Метод **db.query** имеет следующий набор параметров:








  * **String Table Name**: Имя таблицы, из которой осуществляется выборка.



  * **String [ ] columns**: список столбцов, которые войдут в результат.



  * **String WHERE clause**: шаблон where-условия или null.



  * **String [ ] selection args**: массив с аргументами where-условия.



  * **String Group by**: условие группировки.



  * **String Having**: условие HAVING.



  * **String Order By by**: порядок сортировки.






##  Управление объектом Cursor





В результате выполнения запросов нам возвращается объект **Cursor**, содержащий таблицу с результатами запроса. **Cursor**предполагает последовательную работу со строками результата. В каждый момент времени активна одна строка, на которую ссылается указатель. Ниже перечислены методы, которые используются для работы с этим объектом:








  * **boolean moveToNext()**- перемещает указатель на одну запись вперед. Возвращает false, если достигнут конец таблицы результата.



  * **boolean moveToFirst()**- перемещает указатель на первую строку. Возвращает false, если таблица-результат не содержит строк.



  * **boolean moveToPosition(int position)** - перемещает указатель на конкретную строку в таблице результатов. Если строки с таким номером нет - возвращает false.



  * **boolean moveToPrevious()**- перемещает указатель на одну запись назад. Возвращает false, если достигнуто начало таблицы результата.



  * **boolean moveToLast()**- перемещает указатель на последнюю строку. Возвращает false, если таблица-результат не содержит строк.



  * **int  getColumnIndex(String column)** - возвращает ссылку на колонку column в текущей строке. Для получения значения по ссылке используются методы **Cursor.getInt(int ColumnIndex), getShort,getString,getDouble, getBlob**. 






  
Для определение текущей позиции указателя можно воспользоваться методами:**boolean isAfterLast(), isBeforeFirst, isFirst, isLast и isNull(columnIndex)**. Их назначение без труда можно понять из названий.  
  
Если в результате выполнения запроса вы получили только одну строку, то извлечь из нее значения столбцов можно следующим образом:





	public int GetDeptID(String Dept)

  	{

  	SQLiteDatabase db=this.getReadableDatabase();

   	Cursor c=db.query(deptTable, new String[]{colDeptID+" as _id",colDeptName},colDeptName+"=?",

   	new String[]{Dept}, null, null, null);

   	c.moveToFirst();

   	return c.getInt(c.getColumnIndex("_id"));

  	}




В результате выполнения этого метода, мы получим значение колонки _id текущей строки.  После использования курсора его хорошо бы закрыть с помощью метода **close()**.  
   
 Вот собственно и все. Теперь вы вполне сможете использовать базы данных в своих Android проектах.





Если вам понравилась статья, пишите комментарии и рассказывайте друзьям.
Добрый день друзья.





Я продолжаю сбор интересной информации.





И сегодня я нашел статью о работе с ListFragment.





Прошу к прочтению.

<!-- more -->



Вернемся к фрагментам. В Android есть несколько полезных классов – наследников класса Fragment. Мы рассмотрим несколько из них. Начнем с [ListFragment](http://developer.android.com/reference/android/app/ListFragment.html). В принципе, это просто Fragment, в котором есть методы, упрощающие доступ к ListView и некоторым его операциям.





Тут можно провести аналогию - для Activity есть класс наследник [ListActivity](http://developer.android.com/reference/android/app/ListActivity.html). Когда мы только знакомились со списками, я не стал рассматривать этот класс, чтобы не вносить путаницы в непростую тему. Но в учебниках и хелпе о нем обычно говорят. Думаю, многие уже сталкивались с ним и примерно знают, что это такое. Если да, то ListFragment будет совсем прост для понимания.





Напишем приложение и рассмотрим основные возможности ListFragment.





Создадим класс фрагмента, наследующий не android.app.Fragment как обычно, а android.app.ListFragment.





**MainList.java**:

	import android.app.ListFragment;



	public class MainList extends ListFragment {



	}







Класс так и оставляем пока пустым. И пока что не будем создавать Layout-файл для этого фрагмента. Дело в том, что ListFragment по умолчанию уже содержит ListView и мы вполне можем обойтись им. Адаптер мы пока также никакой не создаем, посмотрим чего получится.





Редактируем layout для MainActivity





**main.xml**:


	<?xml version="1.0" encoding="utf-8"?>

	<LinearLayout

 	xmlns:android="http://schemas.android.com/apk/res/android"

 	xmlns:tools="http://schemas.android.com/tools"

 	android:id="@+id/LinearLayout1"

 	android:layout_width="match_parent"

 	android:layout_height="match_parent"

 	android:orientation="vertical">

	<fragment android:name="ru.startandroid.develop.p1091listfragment.MainList"

	android:layout_width="match_parent"

 	android:layout_height="match_parent">

	</fragment>

	</LinearLayout>







Здесь только компонент fragment, использующий наш класс.





Все сохраняем, запускаем приложение.





![](http://android-helper.com.ua/images/uploads/2012/10/L0109_010.jpg)




ListFragment показывает нам, что он ждет данных. 





Ок, давайте дадим ему данные. Перепишем **MainList.java**:



	import android.app.ListFragment;

	import android.os.Bundle;

	import android.widget.ArrayAdapter;



	public class MainList extends ListFragment {



  	String data[] = new String[] { "one", "two", "three", "four" };



  	@Override

  	public void onActivityCreated(Bundle savedInstanceState) {

    super.onActivityCreated(savedInstanceState);

    ArrayAdapter<String> adapter = new ArrayAdapter<String>(getActivity(),

        android.R.layout.simple_list_item_1, data);

    setListAdapter(adapter);

  	}



	}








Мы создаем адаптер и используем метод [setListAdapter](http://developer.android.com/reference/android/app/ListFragment.html#setListAdapter(android.widget.ListAdapter)), чтобы передать его списку. Обратите внимание - мы даже не создаем или не находим (findViewById) список (ListView), он уже есть где-то внутри фрагмента и метод setListAdapter сам знает, как до него добраться. В принципе, это и есть основная фишка ListFragment - нам не надо работать с ListView.





Все сохраним, запустим приложение.





![](http://android-helper.com.ua/images/uploads/2012/10/L0109_0201.jpg)



Данные появились.





Еще раз обращаю ваше внимание на то, что мы вообще не создавали никаких layout с ListView. ListFragment работает с каким-то своим, встроенным списком. 





Если же вас чем-то не устраивает этот дефолтный список, можно использовать свой layout-файл для фрагмента.





В **strings.xml** добавим строки


	<string name="number_list">Список чисел</string>

	<string name="empty">Нет данных</string>








И создадим layout файл **fragment.xml**:



	<?xml version="1.0" encoding="utf-8"?>

	<LinearLayout

 	xmlns:android="http://schemas.android.com/apk/res/android"

 		android:layout_width="match_parent"

 		android:layout_height="match_parent"

 		android:orientation="vertical">

		<TextView

 			android:layout_width="wrap_content"

 			android:layout_height="wrap_content"

 			android:text="@string/number_list">

		</TextView>

	<ListView

		 android:id="@id/android:list"

		 android:layout_width="match_parent"

		 android:layout_height="match_parent">

	</ListView>

	<TextView

		 android:id="@id/android:empty"

		 android:layout_width="match_parent"

		 android:layout_height="match_parent"

		 android:gravity="center"

		 android:text="@string/empty">

	</TextView>

	</LinearLayout>








Первый TextView – просто заголовок списка. Далее идет ListView. Его ID обязательно должен быть равен **@id/android:list**. Чтобы ListFragment сам его нашел и мог с ним работать. Второй TextView – будет показан, если нет данных для списка. Его ID обязательно должен быть равен **@id/android:empty**.





Допишем в **MainList.java** метод создания View.





	@Override

 	public View onCreateView(LayoutInflater inflater, ViewGroup container,

      Bundle savedInstanceState) {

    return inflater.inflate(R.layout.fragment, null);

 	 }







Фрагмент будет отображать компоненты из layout-файла, который мы только что создавали.





Все сохраняем и запускаем.





![](http://android-helper.com.ua/images/uploads/2012/10/L0109_030.jpg)





Видим заголовок и данные. Наш layout был использован.





Если не дать списку данные, то приложение будет выглядеть так





![](http://android-helper.com.ua/images/uploads/2012/10/L0109_040.jpg)





Отобразился наш второй TextView с ID = @id/android:empty. Причем, это вовсе не обязательно должен быть TextView. Главное тут именно этот ID. Компонент с этим ID будет показан вместо ListView, если нет данных.





Чтобы включать одиночный и множественный выбор, необходимо провести все те же действия, которые мы рассматривали в Уроке 43: передать в адаптер соответствующий layout-файл и включить соответствующий режим выбора для списка. В этом же 43-м Уроке можно посмотреть, как определять, какие пункты списка выбраны. Чтобы в ListFragment получить доступ к списку – используйте метод [getListView](http://developer.android.com/reference/android/app/ListFragment.html#getListView()).





Результаты включения режима выбора будут такие:





одиночный выбор





![](http://android-helper.com.ua/images/uploads/2012/10/L0109_050.jpg)





множественный выбор





![](http://android-helper.com.ua/images/uploads/2012/10/L0109_060.jpg)




Еще, как вариант, можно в адаптер передавать layout-файл **android.R.layout.simple_list_item_activated_1**.





В этом случае результаты будут такие:





![](http://android-helper.com.ua/images/uploads/2012/10/L0109_070.jpg)




![](http://android-helper.com.ua/images/uploads/2012/10/L0109_080.jpg)





Это хорошо подходит для случая, когда у вас на экране слева фрагмент-список, а справа фрагмент-содержимое и вы всегда видите какой именно пункт из списка сейчас просматриваете.





Чуть не забыл про самое главное )  Ловить нажатия можно в методе [onListItemClick](http://developer.android.com/reference/android/app/ListFragment.html#onListItemClick(android.widget.ListView, android.view.View, int, long)). 





Если добавим в MainList.java его реализацию:





	public void onListItemClick(ListView l, View v, int position, long id) {

    super.onListItemClick(l, v, position, id);

    Toast.makeText(getActivity(), "position = " + position, Toast.LENGTH_SHORT).show();

 	 }








то при нажатии на пункт списка, увидим результат:





![](http://android-helper.com.ua/images/uploads/2012/10/L0109_090.jpg)





Статья взята из сайта [startandroid.ru](http://startandroid.ru/uroki/vse-uroki-spiskom/179-urok-109-android-3-fragments-listfragment-spisok.html)





Если вам понравилась статья, пишите ваши комментарии.





Если у вас есть интересные примеры решения, пишите мне и я буду их публиковать на блоге.





Полный проект вы можете скачать на [странице с кодами](http://android-helper.com.ua/codes/).
Добрый день друзья.





Нашел сегодня интересную статью. Которая еще более детально описывает работу с actionbar.





Прошу к прочтению.


<!-- more -->


На прошлом уроке мы рассмотрели добавление элементов ActionBar. Пользователю эти элементы удобно использовать для совершения каких-либо операций в приложении. Например, в почтовой программе это может быть удаление письма, пересылка, ответ и т.д.





Теперь рассмотрим, как добавить элементы для навигации по приложению. Есть два типа элементов для навигации: табы и выпадающий список. Создадим простое приложение и реализуем в нем сначала один, затем второй способ.





Создадим проект:





**Project name**: P1081_ActionBarNavigation  
**Build Target**: Android 4.1   
**Application name**: ActionBarItems  
**Package name**: ru.startandroid.develop.p1081actionbarnavigation  
**Create Activity**: MainActivity





Никакие строки не добавляем, основной layout не трогаем.





### Табы





Кодим **MainActivity.java**:



	import android.app.ActionBar;

	import android.app.ActionBar.Tab;

	import android.app.Activity;

	import android.app.FragmentTransaction;

	import android.os.Bundle;

	import android.util.Log;



	public class MainActivity extends Activity implements ActionBar.TabListener {



  	final String LOG_TAG = "myLogs";



  	@Override

  	public void onCreate(Bundle savedInstanceState) {

    super.onCreate(savedInstanceState);

    setContentView(R.layout.main);



    ActionBar bar = getActionBar();



    bar.setNavigationMode(ActionBar.NAVIGATION_MODE_TABS);



    Tab tab = bar.newTab();

    tab.setText("tab1");

    tab.setTabListener(this);

    bar.addTab(tab);



    tab = bar.newTab();

    tab.setText("tab2");

    tab.setTabListener(this);

    bar.addTab(tab);



  	}



  	@Override

  	public void onTabReselected(Tab tab, FragmentTransaction ft) 	{

    Log.d(LOG_TAG, "reselected tab: " + tab.getText());

  	}



  	@Override

  	public void onTabSelected(Tab tab, FragmentTransaction ft) {

    Log.d(LOG_TAG, "selected tab: " + tab.getText());

  	}



  	@Override

  	public void onTabUnselected(Tab tab, FragmentTransaction ft) 	{

    Log.d(LOG_TAG, "unselected tab: " + tab.getText());

  	}

	}







Смотрим, что нам нужно, чтобы включить табы.





В **onCreate** мы получаем доступ к ActionBar и устанавливаем для него режим навигации в [NAVIGATION_MODE_TABS](http://developer.android.com/reference/android/app/ActionBar.html#NAVIGATION_MODE_TABS). Далее идет добавление табов. Тут все несложно – создаем, пишем текст, присваиваем обработчика, добавляем в ActionBar.





Обработчиком для табов мы сделали MainActivity, оно реализует методы интерфейса [ActionBar.TabListener](http://developer.android.com/reference/android/app/ActionBar.TabListener.html):





[onTabReselected](http://developer.android.com/reference/android/app/ActionBar.TabListener.html) – выбран уже выбранный таб





[onTabSelected](http://developer.android.com/reference/android/app/ActionBar.TabListener.html)– таб выбран





[onTabUnselected](http://developer.android.com/reference/android/app/ActionBar.TabListener.html)– таб более не выбран





В эти методы поместим запись в лог и посмотрим, как оно все там работает.





Все сохраняем и запускаем приложение.





Видим табы





![](http://android-helper.com.ua/images/uploads/2012/10/L0108_010.jpg)





Сейчас выбран первый таб и лог сразу об этом сообщает:





	_selected tab: tab1_





Нажмем на второй таб,





![](http://android-helper.com.ua/images/uploads/2012/10/L0108_020.jpg)




смотрим логи:





	_unselected tab: tab1  
	__selected tab: tab_2





Первый таб «развыбран», а второй выбран.





Еще раз нажмем на второй таб:





	_reselected tab: tab2_





Второй таб перевыбран. Все логично и понятно.





Я, чтобы не перегружать урок, не стал реализовывать какие-либо операции по навигации в приложении. А, вообще, подразумевается, что в методах обработчика мы кодим операции с фрагментами. Нам даже любезно предоставляют объект **FragmentTransaction** для этих целей. При этом хелп предупреждает, что в этих методах нам не надо самим вызывать метод **commit**, а также мы не можем добавлять транзакцию в **BackStack**.





### Выпадающий список





Теперь посмотрим, как работает навигация с выпадающим списком.





Перепишем **MainActivity.java**:





	import android.app.ActionBar;

	import android.app.Activity;

	import android.os.Bundle;

	import android.util.Log;

	import android.widget.ArrayAdapter;



	public class MainActivity extends Activity implements

    ActionBar.OnNavigationListener {



  	String[] data = new String[] { "one", "two", "three" };



  	final String LOG_TAG = "myLogs";



  	@Override

  	public void onCreate(Bundle savedInstanceState) {

    super.onCreate(savedInstanceState);

    setContentView(R.layout.main);



    ActionBar bar = getActionBar();

    bar.setNavigationMode(ActionBar.NAVIGATION_MODE_LIST);



    ArrayAdapter<String> adapter = new ArrayAdapter<String>(this,

        android.R.layout.simple_spinner_item, data);

    adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);

    bar.setListNavigationCallbacks(adapter, this);

  	}



  	@Override

  	public boolean onNavigationItemSelected(int itemPosition, long itemId) {

    Log.d(LOG_TAG, "selected: position = " + itemPosition + ", id = "

        + itemId + ", " + data[itemPosition]);

    return false;

  	}

	}







В **onCreate** получаем ActionBar и включаем ему режим навигации [NAVIGATION_MODE_LIST](http://developer.android.com/reference/android/app/ActionBar.html#NAVIGATION_MODE_LIST). Для выпадающего списка необходимо создать адаптер, реализующий SpinnerAdapter. Пусть это будет ArrayAdapter. При создании используем массив из трех строк. Далее вызываем метод [setListNavigationCallbacks](http://developer.android.com/reference/android/app/ActionBar.html#setListNavigationCallbacks(android.widget.SpinnerAdapter, android.app.ActionBar.OnNavigationListener)), в который передаем адаптер и обработчик.





Обработчиком у нас снова является Activity, реализует метод [onNavigationItemSelected](http://developer.android.com/reference/android/app/ActionBar.OnNavigationListener.html#onNavigationItemSelected(int, long)) интерфейса [ActionBar.OnNavigationListener](http://developer.android.com/reference/android/app/ActionBar.OnNavigationListener.html). Этот метод дает нам позицию и id выбранного из списка элемента. Выводим в лог эту инфу и соответствующий элемент массива.





В манифесте я прописал для MainActivity атрибут темы: android:theme="@android:style/Theme.Holo.Light". Иначе был темный текст на темном фоне.





Все сохраняем и запускаем.





![](http://android-helper.com.ua/images/uploads/2012/10/L0108_030.jpg)





Первый элемент сразу выбран. В логах видим:





	_selected: position = 0, id = 0, one_





Выберем какой-нить другой элемент из списка





![](http://android-helper.com.ua/images/uploads/2012/10/L0108_040.jpg)




В логах:





	_selected: position = 2, id = 2, three_





Снова все логично и понятно.





Для обоих видов навигации мы всегда можем получить текущий выбранный элемент с помощью метода [getSelectedNavigationIndex](http://developer.android.com/reference/android/app/ActionBar.html#getSelectedNavigationIndex()). А для навигации с табами есть также метод [getSelectedTab](http://developer.android.com/reference/android/app/ActionBar.html#getSelectedTab()), возвращающий текущий выбранный таб.





Разумеется, что вместе с навигацией мы можем добавлять в ActionBar и обычные элементы, которые были рассмотрены на прошлом уроке.





![](http://android-helper.com.ua/images/uploads/2012/10/L0108_050.jpg)





При этом, если места будет недостаточно, то ActionBar разделит все свои элементы на две полосы.





![](http://android-helper.com.ua/images/uploads/2012/10/L0108_060.jpg)





Начиная с четвертой версии Андроид, можно использовать атрибут **uiOptions** для Activity или Application в манифесте. Если присвоить ему значение**splitActionBarWhenNarrow**, то результат при нехватке места получится такой:





![](http://android-helper.com.ua/images/uploads/2012/10/L0108_070.jpg)




Элементы ушли вниз. Правда, при этом почему-то перестает работать withText в showAsAction.





Статья взята из сайта [startandroid.ru](http://startandroid.ru/uroki/vse-uroki-spiskom/178-urok-108-android-3-actionbar-navigatsija-taby-i-vypadajuschij-spisok.html)





Если вам понравилась статья, оставляйте свои комментарии. И не забывайте рассказать друзьям о нас.
Нашел неплохую [статью](http://findevelop.blogspot.com/2011/10/bitmapdrawable.html) как изменить размер в BitmapDrawable.





Недавно мне понадобилось получить из внешнего потока (InputStream) картинку и вывести ее на экран, но картинка была в одном размере и ее нужно было под разные экраны и условия уменьшить или увеличить.  
  

<!-- more -->

Для начала получим из потока Drawable. Например с assets каталога:







	Drawable drawable = 	Drawable.createFromStream(act.getAssets().open(fileName), null);







И для того, чтобы изменить размер, я использую следующий метод:




	public static Drawable resizeDrawable(Drawable drawable, int newWidth, int newHeight) {

    Bitmap bitmap = ((BitmapDrawable) drawable).getBitmap();

    int width = bitmap.getWidth();

    int height = bitmap.getHeight();

    float scaleWidth = ((float) newWidth) / width;

    float scaleHeight = ((float) newHeight) / height;

    Matrix matrix = new Matrix();

    matrix.postScale(scaleWidth, scaleHeight);

    Bitmap resizedBitmap = Bitmap.createBitmap(bitmap, 0, 0,

        width, height, matrix, true);

    return new BitmapDrawable(resizedBitmap);

  	}






Этот метод я запостил скорей чтобы не забыть, потому как в проекте он уже не нужен, и дабы помочь ищущему. Но я думаю есть другие варианты решения, если кто наткнулся на пост и знает, то плиз в комментарии.
Добрый день.





Сегодня нашел статью, как можно закачать файлы с сервера.





Оригинал статьи [тут](http://findevelop.blogspot.com/2012/01/android_19.html).


 <!-- more -->


Хорошо сделанное Android-приложение (кроме всего прочего) не заставляет клиента угадывать что в данный момент происходит "по ту сторону экрана". Приятное и аккуратное приложение показывает при всех продолжительных операциях прогресс-бар, который реализует, как правило, с помощью класса AsyncTask. Давайте посмотрим как правильно использовать этот замечательный инструмент на примере загрузки файла из сети:





	import java.io.File;

	import java.io.FileOutputStream;

	import java.io.IOException;

	import java.io.InputStream;

	import java.net.HttpURLConnection;

	import java.net.MalformedURLException;

	import java.net.URL;

	import android.app.Act	ivity;

	import android.app.ProgressDialog;

	import android.os.AsyncTask;

	import android.os.Bundle;

	import android.view.View;

	import android.view.ViewGroup.LayoutParams;

	import android.widget.Button;

	import android.widget.TextView;

	public class BackFLoaderActivity extends Activity {

 

 	@Override

 	public void onCreate(Bundle savedInstanceState) {

  	super.onCreate(savedInstanceState);

  	Button load = new Button(this);

  	load.setText("Load file");

  	load.setOnClickListener(new View.OnClickListener() {

   	@Override

   	public void onClick(View v) {

    	downloadFile("http://anjedi.com/api_lib/2.2_level8.jar");

   	}

  	});

  	setContentView(load, new LayoutParams(LayoutParams.WRAP_CONTENT,

   	LayoutParams.WRAP_CONTENT));

 	}

 



 	private void downloadFile(String url) {

  	final ProgressDialog progressDialog = new ProgressDialog(this);

 

  	new AsyncTask<String, Integer, File>() {

   	private Exception m_error = null;

 

   	@Override

   	protected void onPreExecute() {

    progressDialog.setMessage("Downloading ...");

    progressDialog.setCancelable(false);

    progressDialog.setMax(100);

    progressDialog

      .setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);

 

    progressDialog.show();

   	}

 

   	@Override

   	protected File doInBackground(String... params) {

    URL url;

    HttpURLConnection urlConnection;

    InputStream inputStream;

    int totalSize;

    int downloadedSize;

    byte[] buffer;

    int bufferLength;

 

    File file = null;

    FileOutputStream fos = null;

 

    try {

     url = new URL(params[0]);

     urlConnection = (HttpURLConnection) url.openConnection();

 

     urlConnection.setRequestMethod("GET");

     urlConnection.setDoOutput(true);

     urlConnection.connect();

 

     file = File.createTempFile("Mustachify", "download");

     fos = new FileOutputStream(file);

     inputStream = urlConnection.getInputStream();

 

     totalSize = urlConnection.getContentLength();

     downloadedSize = 0;

 

     buffer = new byte[1024];

     bufferLength = 0;

 

     // читаем со входа и пишем в выход, 

     // с каждой итерацией публикуем прогресс

     while ((bufferLength = inputStream.read(buffer)) > 0) {

      fos.write(buffer, 0, bufferLength);

      downloadedSize += bufferLength;

      publishProgress(downloadedSize, totalSize);

     }

 

     fos.close();

     inputStream.close();

 

     return file;

    } catch (MalformedURLException e) {

     e.printStackTrace();

     m_error = e;

    } catch (IOException e) {

     e.printStackTrace();

     m_error = e;

    }

 

    return null;

   	}

 

   	// обновляем progressDialog

   	protected void onProgressUpdate(Integer... values) {

    progressDialog

      .setProgress((int) ((values[0] / (float) values[1]) * 100));

   	};

 

   	@Override

   	protected void onPostExecute(File file) {

    // отображаем сообщение, если возникла ошибка

    if (m_error != null) {

     m_error.printStackTrace();

     return;

    }

    // закрываем прогресс и удаляем временный файл

    progressDialog.hide();

    file.delete();

   	}

  	}.execute(url);

 		}

	}






В этом маленьком приложении при нажатии на кнопку запускается загрузка файла, при этом пользователь наблюдает прогресс-бар. Не забудьте добавить в манифест запрос разрешений на доступ к интернет и файловой системе.  
Основой примера является метод, который я взял [отсюда](http://twigstechtips.blogspot.com/2011/10/android-download-file-with-progress.html) (и поправил пару ошибок).     
Этот метод принимает url файла, который нужно загрузить, загружает файл, отображая при этом горизонатальный прогресс-бар. При этом прогресс-бар реально показывает какая часть файла в данный момент загружена. По окончании загрузки файл удаляется.  
  
**Разберём работу метода подробнее:**  
  
Главная часть метода - создание AcyncTask-а и переопределение его методов.  
В методе _onPreExecute_ мы запускаем progressDialog, установив предварительно текст сообщения и максимальное значение прогресса: 100%.   
В методе _doInBackground_ - выполняем собственно загрузку файла. Файл читаем  из_urlConnection_ порциями по 1024 байт, каждый раз прибавляя размер полученной порции к общему счётчику. Счётчик и общий размер файла передаём при каждой итерации в метод _publishProgress_, благодаря чему в методе _onProgressUpdate_ мы получаем эти данные и обновляем текущий статус progressDialog-а.   
И, наконец, в методе _onPostExecute_ мы прячем диалог и удаляем временный файл.   
Особенностью использования AsyncTask-a является способ, как он объявляется и как в него передаются параметры. Типы, которыми параметризуется экземпляр AsyncTask-a определяю по порядку: тип входящего значения, тип параметра, опреляющего прогресс опреации и тип результата фоновой операции (то что возвращает _doInBackground_ и принимает _onPostExecute_). Кроме того конструктор и чаcть методов AsyncTask-а принимает _varargs, _т.е. произвольное число параметров, что весьма удобно в некоторых случаях.
Привет всем.





Сегодня изучил для себя новую тему- работу с ActionBar.





Это новый патерн который программисты могут использовать с 3 версии android.





Изучал я этот патерн по одной статье.


<!-- more -->


Оригинал [тут.](http://startandroid.ru/uroki/vse-uroki-spiskom/177-urok-107-android-3-actionbar-razmeschenie-elementov.html)





Поскольку статья, заслуживает внимания как новичков так и гуру, я ее продублирую у себя на сайте.





Еще одно нововведение третьего Андроида – [Action Bar](http://developer.android.com/guide/topics/ui/actionbar.html). Это панель в верхней части приложения.





В этом уроке попробуем размещать там свои элементы с иконками и посмотрим, как с ними взаимодействовать. Тут нам все уже будет знакомо, т.к. используется механизм, который раньше строил меню.  Т.е. мы в методе [onCreateOptionsMenu](http://developer.android.com/reference/android/app/Activity.html#onCreateOptionsMenu(android.view.Menu)) получаем на вход объект Menu и (программно или с помощью XML) наполняем его элементами.





Для элементов будем указывать id, текст, иконку и режим показа.





В **strings.xml** добавим строки:




	<string name="item1">Item1</string>

	<string name="item2">Item2</string>

	<string name="item3">Item3</string>

	<string name="item4">Item4</string>







В файл **res\menu\main.xml** напишем следующий текст:





	<?xml version="1.0" encoding="utf-8"?>

	<menu

 xmlns:android="http://schemas.android.com/apk/res/android">

	<item

 android:id="@+id/item1"

 android:showAsAction="always"

 android:title="@string/item1">

	</item>

	<item

 		android:id="@+id/item2"

 		android:icon="@android:drawable/ic_menu_call"

 		android:showAsAction="ifRoom"

 		android:title="@string/item2">

	</item>

	<item

 		android:id="@+id/item3"

 		android:icon="@android:drawable/ic_menu_info_details"

 		android:showAsAction="ifRoom|withText"

 		android:title="@string/item3">

	</item>

	<item

 		android:id="@+id/item4"

 		android:icon="@android:drawable/ic_menu_view"

 		android:showAsAction="never"

 		android:title="@string/item4">

	</item>

	</menu>






С **id**, **title** и **icon**, думаю все понятно – это идентификатор, текст и иконка элемента. Иконки системные, выбранные случайно.





Нам тут больше интересен атрибут **showAsAction**, это режим показа элемента. Он может принимать значения:





**never**– не показывать элемент





**ifRoom**– показывать, если есть место





**always**– всегда показывать





К этим значениям может быть добавлено еще одно – **withText**. Актуально для элементов с указанной иконкой. В этом случае для элемента будет показана не только иконка, но и текст из **title**. 





Кодим **MainActivity.java**:

	package ru.startandroid.develop.p1071actionbaritems;



	import android.app.Activity;

	import android.os.Bundle;

	import android.view.Menu;



	public class MainActivity extends Activity {



  @Override

  public void onCreate(Bundle savedInstanceState) {

    super.onCreate(savedInstanceState);

    setContentView(R.layout.main);

  }



  @Override

  public boolean onCreateOptionsMenu(Menu menu) {

    getMenuInflater().inflate(R.menu.main, menu);

    return true;

  }



	}







Думаю, комментарии тут особо не нужны. Все знакомое. Заполненный нами ранее xml-файл используется для создания элементов Menu. 





Все сохраняем, запускаем приложение.





Отобразился **item1 **и **item2**.





![](http://android-helper.com.ua/images/uploads/2012/09/L0107_010.jpg)



Для **item1** мы не указывали иконку, поэтому видим только текст. А в **showAsAction **мы указали **always**, т.е. система будет пытаться отобразить элемент, даже если не хватает места на ActionBar.





Для **item2** мы указали иконку ic_menu_call, ее и видим в ActionBar. В **showAsAction **мы указали **ifRoom**, т.е. отображать, если есть свободное место. Место есть – элемент виден.





Жмем на эмуляторе menu и видим два оставшихся элемента. Они не отобразились в ActionBar и теперь доступны только так.





![](http://android-helper.com.ua/images/uploads/2012/09/L0107_020.jpg)





**item3** не отобразился, т.к. ему не хватило места. Мы для него указывали **showAsAction** = **ifRoom**, т.е. отображать, если есть где. Для **item2** место нашлось, а вот **item3**не влез.





**item4** не отобразился, т.к. мы указали **showAsAction**= **never**.





Давайте увеличим место в ActionBar и посмотрим, что изменится. Для этого просто повернем экран в горизонтальную ориентацию – CTRL+F12.





![](http://android-helper.com.ua/images/uploads/2012/09/L0107_030.jpg)





Для **item1** и **item2** ничего не изменилось. А вот для **item3** теперь появилось местечко, и он вылез. Если для **item2** отображена только иконка, то для **item3** мы видим и текст. Это сказывается **withText** в атрибуте **showAsAction**.





**item4** не виден несмотря на то, что есть куча места свободного. Причина - **never** в атрибуте **showAsAction**. Чтоб добраться до него, жмем menu.





![](http://android-helper.com.ua/images/uploads/2012/09/L0107_040.jpg)




### overflow menu





Если запустить это же приложение на планшете, то увидим чуть другой интерфейс ActionBar:





![](http://android-helper.com.ua/images/uploads/2012/09/L0107_050.jpg)




Справа появляется кнопка, нажатие на которую аналогично нажатию на menu. Судя по всему, эта кнопка видна только на тех устройствах, на которых нет кнопки menu.





### Как узнать текст элемента, если видна только иконка





Если для элемента показана только иконка, то долгим нажатием на нее можно добиться показа текста. Попробуем на item2:





![](http://android-helper.com.ua/images/uploads/2012/09/L0107_060.jpg)




На AVD с 4.1 это работает. На планшете с 3.2 – почему-то нет.





### Как отключить ActionBar





Для этого в коде можно прописать:





Либо выбрать для **Activity** тему, содержащую текст _NoActionBar_.





![](http://android-helper.com.ua/images/uploads/2012/09/L0107_070.jpg)




### Где обрабатывать нажатия на элементы





Там же, где и при работе с меню – метод [onOptionsItemSelected](http://developer.android.com/reference/android/app/Activity.html#onOptionsItemSelected(android.view.MenuItem)). Все аналогично.





### О кнопке Home





В левой части ActionBar находится кнопка **Home**. По умолчанию для нее используется иконка приложения или Activity. Мы можем поставить сюда свою иконку, не трогая текущие. Для этого используется атрибут android:logo у Activity или Application.





В третьем Андроиде кнопка Home кликабельна по умолчанию. В четвертом же ее надо явно задействовать методом [setHomeButtonEnabled](http://developer.android.com/reference/android/app/ActionBar.html#setHomeButtonEnabled(boolean)).





Поймать нажатие кнопки **Home** можно также в onOptionsItemSelected. Она имеет id = **android.R.id.home**.





Насколько я понял по хелпу, назначение этой кнопки – перейти в коренное Activity программы, т.е. действительно кнопка «Домой». Также хелп говорит об еще одной логической возможности использования – как кнопка «Вверх». Т.е. не в корневое Activity, а на один логический уровень вверх. Например, из чтения письма переходим к списку писем. А для того, чтобы пользователь знал, что он попадет не Домой, а Вверх предлагается вещать на кнопку стрелочку методом [setDisplayHomeAsUpEnabled](http://developer.android.com/reference/android/app/ActionBar.html#setDisplayHomeAsUpEnabled(boolean)).





В итоге выглядит это примерно так





![](http://android-helper.com.ua/images/uploads/2012/09/L0107_080.jpg)





На кнопке появилась стрелка.





Надо понимать, что эта стрелка – это просто изображение для пользователя, чтобы он знал, какое поведение ожидать от нажатия. А кодить весь процесс перехода Вверх надо самим. Как впрочем и процесс перехода Домой.









Напоследок еще несколько полезных методов для ActionBar:





[setTitle](http://developer.android.com/reference/android/app/ActionBar.html#setTitle(java.lang.CharSequence)) – установить свой текст около кнопки Home





[setDisplayShowTitleEnabled ](http://developer.android.com/reference/android/app/ActionBar.html#setDisplayShowTitleEnabled(boolean))– скрыть/показать текст около кнопки Home





[setDisplayShowHomeEnabled](http://developer.android.com/reference/android/app/ActionBar.html#setDisplayShowHomeEnabled(boolean)) – скрыть/показать кнопку Home









Если вам понравилась статья, или вы бы хотели что бы описали что то конкретно. Пишите, мы с радостью вам поможем.
Сегодня нашел интересую статью, как можно строить диаграммы в Android.





Оригинал статьи вы можете найти [тут](http://www.mobilab.ru/androiddev/achartengineforandroid.html).





Я же в свою очередь продублирую ее у себя на блоге, так как считаю, что она заслуживает внимания.


<!-- more -->


При разработке бизнес приложений программисты часто сталкиваются с необходимостью строить большое количество различных диаграмм и графиков. Конечно, все можно делать с нуля, вручную отрисовывая все необходимое, но зачем так мучатся, если есть неплохое бесплатное решение? Сегодня я хочу рассказать Вам об open source библиотеке AChartEngine, позволяющей создавать красивые графики и диаграммы для ваших отчетов. Приятно, что библиотека распространяется под весьма мягкой лицензией Apache Version 2, так что Вы вполне можете использовать **AChartEngine **в своих коммерческих проектах.     
  
[На сайте разработчика](http://www.achartengine.org/index.html) помимо самой библиотеки можно найти подробную документацию, офермленную в стиле Javadoc pages, примеры использования библиотеки, а также ее исходный код. В разделе Demo приводится несколько диаграмм и графиков, построенных средствами AChartEngine.





![](http://android-helper.com.ua/images/uploads/2012/09/AChartEngine.jpg)





Для построения диаграммы нужно выполнить несколько довольно простых шагов








  1. Перед использованием библиотеки вам нужно подключить ее к своему проекту в Eclipse. Для этого создайте где-нибудь папку для библиотеки и поместите туда jar файл. Теперь добавьте этот jar в свой project build path. После этого добавьте строку <activity android:name="org.achartengine.GraphicalActivity"/> в файл манифеста вашего проекта.



  2. Создайте и инициализируйте три массива. В первом будут содержаться цвета, во втором - подписи, в третьем - значения. 



  3. Создайте объект CategorySeries и загрузите в него массивы строк с подписями и значения. При построении диаграмм будут использоваться именно эти данные.



  4. Создайте объект DefaultRenderer. CategorySeries и DefaultRenderer определены в библиотеке AChartEngine.



  5. Для каждого цвета в диаграмме создайте SimpleSeriesRenderer и установите его в этот цвет. Затем каждый SimpleSeriesRenderer добавьте в DefaultRenderer. Таким образом, имеем один Render на каждый Series. К слову, Render может включать другой Render, таким образом можно создавать подкатегории.



  6. Создайте объект PieChartIntent и передайте ему CategorySeries и DefaultRenderer.



  7. С помощью PieChartIntent можно показать диаграмму, как отдельную деятельность.






  
Ниже приводится исходный код, в котором реализованы все описанные выше шаги.





	package com.example.bars;

 

	import org.achartengine.ChartFactory;

	import org.achartengine.chart.PieChart;

	import org.achartengine.model.CategorySeries;

	import org.achartengine.renderer.DefaultRenderer;

	import org.achartengine.renderer.SimpleSeriesRenderer;

	import android.content.Context;

	import android.content.Intent;

	import android.graphics.Color;

	import android.app.Activity;

	import android.os.Bundle;

 

	public class MainActivity extends Activity {

 

    @Override

    public void onCreate(Bundle savedInstanceState) {

       super.onCreate(savedInstanceState);

          Intent intent = buildIntent();

        startActivity(intent);          // шаг 7

    }

 

    public Intent buildIntent() {

        int[] values = new int[] { 5, 15, 25, 50, 75 };        // шаг 2

        String[] bars = new String[] {"Francesca's",  "King of Clubs", 

                                 "Zen Lounge", "Tied House", "Molly Magees"};

        int[] colors = new int[] { Color.BLUE, Color.GREEN, Color.MAGENTA, 

                                   Color.YELLOW, Color.CYAN };

 

        CategorySeries series = new CategorySeries("Pie Chart");  // шаг 3

        DefaultRenderer dr = new DefaultRenderer();   // шаг 4

 

        for (int v=0; v<5; v++){    // шаг 5

            series.add(bars[v], values[v]);

            SimpleSeriesRenderer r = new SimpleSeriesRenderer();

            r.setColor(colors[v]);

            dr.addSeriesRenderer(r);

        }

        dr.setZoomButtonsVisible(true);

        dr.setZoomEnabled(true);

        dr.setChartTitleTextSize(20);

        return ChartFactory.getPieChartIntent(    // шаг 6

                              this, series, dr, "Pie of bars");

    }

 

	}






Мы построили диаграмму PieChartIntent, однако подобным образом можно построить и другие виды графиков. Мне библиотека показалась довольно удобной и понятной. Ее можно использовать, если необходимо быстро разработать какое-нибудь бизнес-приложение со строгим дизайном.







Если вам понравилось, пишите комментарии и подписывайтесь на наши обновления.


Добрый день друзья.





Сегодня я вам расскажу о таком android элементе как AutoCompleteTextView.





Для чего же нужен этот элемент. А нужен он для того что бы во время ввода выдавался соответствующий список возможных вариантов.





Давайте теперь рассмотрим как с этим работать.


<!-- more -->


К примеру нам нужно автозаполнение для списка месяцев года.





![](http://android-helper.com.ua/images/uploads/2012/09/ExAutoCompleteTextView.png)





Для этого подготовим нужный нам массив строк (/res/values/myvalues.xml):






	<?xml version="1.0" encoding="UTF-8"?>

	<resources>

	<array name="month">

       <item>January</item>

       <item>February</item>

       <item>March</item>

       <item>April</item>

       <item>May</item>

       <item>June</item>

       <item>July</item>

       <item>August</item>

       <item>September</item>

       <item>October</item>

       <item>November</item>

       <item>December</item>

	</array>

	</resources>







В главной активити напишем следуюющее:



	import android.app.Activity;

	import android.os.Bundle;

	import android.text.Editable;

	import android.text.TextWatcher;

	import android.widget.ArrayAdapter;

	import android.widget.AutoCompleteTextView;

 

	public class ExAutoCompleteTextView extends Activity implements TextWatcher {

  

 	AutoCompleteTextView autoCompleteTextView;

  

   	/** Called when the activity is first created. */

   	@Override

   	public void onCreate(Bundle savedInstanceState) {

       super.onCreate(savedInstanceState);

       setContentView(R.layout.main); 

       autoCompleteTextView = (AutoCompleteTextView)findViewById(R.id.input);

       String[] month = getResources().getStringArray(R.array.month);

       autoCompleteTextView.addTextChangedListener(this); 

       autoCompleteTextView.setAdapter(new ArrayAdapter<String>(this, android.R.layout.simple_dropdown_item_1line, month)); 

   	}

 

 		@Override

 		public void afterTextChanged(Editable arg0) {

  	// TODO Auto-generated method stub

   

 		}

 

 		@Override

 		public void beforeTextChanged(CharSequence arg0, int arg1, int arg2, int arg3) {

  	// TODO Auto-generated method stub

   

 		}

 

		@Override

 		public void onTextChanged(CharSequence arg0, int arg1, int arg2, int arg3) {

  	// TODO Auto-generated method stub

   

 		}

	}








Ну и сама раскладка main.xml:



	<?xml version="1.0" encoding="utf-8"?>

	<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"

   	android:orientation="vertical"

   	android:layout_width="fill_parent"

   	android:layout_height="fill_parent"

   	>

	<TextView

   	android:layout_width="fill_parent"

   	android:layout_height="wrap_content"

   	android:text="@string/hello"

   	/>

	<AutoCompleteTextView

   	android:id="@+id/input"

   	android:layout_width="fill_parent"

   	android:layout_height="wrap_content"

   	android:completionThreshold="1"

   	/>

	</LinearLayout>








Вот и все.





Жду ваших комментариев и прошу подписаться на моем блоге.
Всем привет.





С вами снова я. И сегодня мы поговорим, как показывать HTML код в TextView.





Если все готовы. Тогда приступим.


<!-- more -->


Вам необходимо вызвать функцию:







	TextView txtView = new TextView(this);

	Spanned s = Html.fromHtml("Android - это супер <font color=\"red\">android-helper.com.ua</font>");

	txtView.setText(s);









Вот полный код:






	public class TestActivity extends Activity {

 

    @Override

    public void onCreate(Bundle savedInstanceState) {

        super.onCreate(savedInstanceState);

        TextView txtView = new TextView(this);

        Spanned s = Html.fromHtml("Android - это супер <font color=\"red\">android-helper.com.ua</font>");

        txtView.setText(s);

 

        setContentView(txtView);

    }

	}







Все готово. Теперь можете наслаждаться.





Но нужно помнить, что так можно отформатировать не все HTML теги.





Вот список тегов, которые поддерживает класс **Html**.








  * a href="...",



  * b,



  * big,



  * blockquote,



  * br,



  * cite,



  * dfn,



  * div align="...",



  * em,



  * font size="..." color="..." face="...",



  * h1-h6,



  * i,



  * img src="...",



  * p,



  * small,



  * strike,



  * strong,



  * sub,



  * sup,



  * tt,



  * u



Недавно столкнулся с задачей - сделать приложение для android 4 с его интерфейсом.





Все было супер, пока я не запустил на android 2.3. И там увидел, что таких стилей нету.





Покопав просторы интернета. Я нашел такую [статью](http://findevelop.blogspot.com/2012/06/android-android-4.html#more)





Но так как я на своем блоге собираю всю полезную информацию. Я ее продублирую у себя на блоге.





Прошу к прочтению:

 <!-- more -->



![](http://android-helper.com.ua/images/uploads/2012/09/holo.jpg)




Ничто так не портит настроение программиста, как необходимость заниматься вместо программирования чем-то другим. Например, дизайном. Но приложение без дизайна в наше время  обречено на забвение избалованных пользователей. Как же быть? А давайте нашим формам и кнопочкам "выдадим" стандартный стиль Android Ice Cream Sandwich. Пусть наши пользователи, которые пока ещё не обновились до последней версии Android наслаждаются стильным дизайном и проникаются к нашему приложению тёплыми чувствами. В этом добром деле нам поможет библиотека [HoloEverywhere](https://github.com/ChristopheVersieux/HoloEverywhere). Использовать всю библиотеку мы не будем, нам хватит и одной темы, например моей любимой HoloEverywhereDark. А прикрутим к проекту мы её ручками, попутно изучив механизм "стилизации" Android-приложений.   
  
**Стили - это просто**  
  
В res/values/ нашего проекта создаём файл styles.xml, где мы будем описывать стили для всех контролов в нашей теме. Описывать - это громко сказано: мы просто скопируем аналогичный файл из библиотеки HoloEverywhere, удалив лишние стили. Картинки для HoloEverywhereDark копируем в свои каталоги drawable-mdpi, drawable-hdpi и drawable-xhdpi. Название всех нужных файлов заканчивается на "dark".   
Кроме картинок нам понадобятся xml-файлы описания ресурсов, напрмер цветов. Их складываем в каталог drawable. Больше нам из библиотеки HoloEverywhere ничего не понадобится.  
Посмотрим подробнее в наш styles.xml. Например:



	<style name="ButtonHoloDark" parent="android:style/Widget.Button">

 	<item name="android:background">@drawable/btn_default_holo_dark</item>

 	<item name="android:textColor">#ffffff</item>

	</style>








В этом фрагменте мы видим описание стиля кнопки с именем ButtonHoloDark. Тег style имеет обязательный атрибут name и необязательный parent. Именно parent позволяет нам реализовать иерархию стилей элементов интерфейса Android-приложений. В данном случае мы наследуем стиль стандартной кнопки и переопределяем в нашем новом стиле два item-а: цвет фона и цвет текста. Цвет можно задавать как комбинацией rgb (как в html), так и ссылкой на xml-ресурс. В данном случае для фона кнопки это файл btn_default_holo_dark.xml в каталоге drawable. Посмотрим в него и поймём почему используется xml-ресурс вместо обычного описания цвета:




	<selector xmlns:android="http://schemas.android.com/apk/res/android">

    <item android:drawable="@drawable/btn_default_normal_holo_dark" android:state_enabled="true" android:state_window_focused="false"/>

    <item android:drawable="@drawable/btn_default_disabled_holo_dark" android:state_enabled="false" android:state_window_focused="false"/>

    <item android:drawable="@drawable/btn_default_pressed_holo_dark" android:state_pressed="true"/>

    <item android:drawable="@drawable/btn_default_focused_holo_dark" android:state_enabled="true" android:state_focused="true"/>

    <item android:drawable="@drawable/btn_default_normal_holo_dark" android:state_enabled="true"/>

    <item android:drawable="@drawable/btn_default_disabled_focused_holo_dark" android:state_focused="true"/>

    <item android:drawable="@drawable/btn_default_disabled_holo_dark"/>

	</selector>






Тут описано несколько цветов, которые назначаются фону кнопки в зависимости от её состояния. Эти цвета уже не xml-ресурсы а обычные изображения (некоторые в формате nine-patch, оптимизированном для "растягивания").  
И так мы дошли до подножия "пирамиды стилей". А что же наверху?  
Мы, безусловно можем назначить готовый стиль кнопке в нашем xml-layout или в коде. Но зачем этот утомительный процесс? Назначить стиль всем элементам интерфейса в приложении можно одной инструкцией в AndroidManifest.xml:





	android:theme="@style/Theme.HoloEverywhereDark"






в теге application.  
Так мы устанавливаем "тему", которая описывается в том же styles.xml.  
Отличие от обычного описания стиля только в том, что стиль кнопки определяет в item-ах её свойства, а item-ами темы является сама кнопка и другие элементы интерфейса. Например:






	<style name="Theme.HoloEverywhereDark" parent="android:Theme.NoTitleBar">

       ...

       <item name="android:buttonStyle">@style/ButtonHoloDark</item>

       ...

	</style>







Вот тут мы и связываем тему с стилем отдельного элемента, который мы видели вначале. Как видите, использовать стили в приложении для Android ничуть не сложнее, чем в web-страницах. 





Надеюсь вам понравилась статья.





Если это так, тогда ваши комментарии будут кстати. :)
Добрый день друзья.





Очень много программистов сейчас сталкиваются с много язычными приложениями.





Я решил поделится опытом работы с такими приложениями.


<!-- more -->


Есть 2 подхода разработки таких приложений.








  1. Язык приложения зависит от языка системы



  2. Возможность менять язык в самом приложении






Ну что приступим.





### Язык приложения зависит от языка системы





В android для реализации данного подхода, используется следующая структура вложения папок.





![](http://android-helper.com.ua/images/uploads/2012/09/m1.png)





Тут все просто, создаем папку с расширением ru (Для России), fr - Франции и так далее.





Больше информации вы можете получить [тут](http://developer.android.com/intl/ru/training/basics/supporting-devices/languages.html).







strings.xml - с папки values





	<resources>



    <string name="app_name">multilanguage</string>

    <string name="hello_world">Hello world!</string>

    <string name="menu_settings">Settings</string>

    <string name="title_activity_main">MainActivity</string>



	</resources>










strings.xml - с папки values-ru









	<resources>



    <string name="app_name">multilanguage</string>

    <string name="hello_world">Привет Мир!</string>

    <string name="menu_settings">Настройки</string>

    <string name="title_activity_main">Главное активити</string>



	</resources>







### Возможность менять язык в самом приложении





Вот тут более интересней тема.





Для того что бы приложение на лету поменяло язык нужно сделать следующее.





Создаем файл который наследуется от Application.





	package com.example.multilanguage;



	import java.util.Locale;



	import android.app.Application;

	import android.content.res.Configuration;



	public class MyApp extends Application {



	private Locale locale = null;



	@Override

	public void onConfigurationChanged(Configuration newConfig) {

		super.onConfigurationChanged(newConfig);

		if (locale != null) {

			newConfig.locale = locale;

			Locale.setDefault(locale);

			getBaseContext().getResources().updateConfiguration(newConfig,

					getBaseContext().getResources().getDisplayMetrics());

		}

	}



	@Override

	public void onCreate() {

		super.onCreate();



		Configuration config = getBaseContext().getResources().getConfiguration();



		String lang = "ru";

		if (!"".equals(lang) && !config.locale.getLanguage().equals(lang)) {

			locale = new Locale(lang);

			Locale.setDefault(locale);

			config.locale = locale;

			getBaseContext().getResources().updateConfiguration(config,

					getBaseContext().getResources().getDisplayMetrics());

		}

	}



	}





Вот и все.





Теперь если вам нужно изменить язык при нажатии на кнопку вызываете просто:






	Configuration config = getBaseContext().getResources().getConfiguration();



		String lang = "ru";

		if (!"".equals(lang) && !config.locale.getLanguage().equals(lang)) {

			locale = new Locale(lang);

			Locale.setDefault(locale);

			config.locale = locale;

			getBaseContext().getResources().updateConfiguration(config,

					getBaseContext().getResources().getDisplayMetrics());

		}







Если вам понравилась статья пишите комментарии и рассказывайте друзьям.





Коды вы можете скачать [тут](http://android-helper.com.ua/forms)
При разработке приложения порой бывает необходимо выполнять какие-то действия в будущем. Например, вы хотите создать будильник или периодически отправлять данные на свой сайт в строго определенное время. Для решения подобных задач в Android используется класс**AlarmManager**, который позволяет выполнять код в требуемый момент времени, даже если ваше приложение не запущено. То-есть AlarmManager - аналог corn в Linux или планировщика задач Windows. Вы говорите, что такой-то кусок кода должен выполниться тогда-то и AlarmManager обеспечивает запуск кода. В англоязычный литературе таймер, который выполняет код в требуемый момент времени обозначается термином**alarm**. Давайте в рамках данной статьи называть этот таймер**будильником**, чтобы отделить это понятие от таймера.



 <!-- more -->

## Несколько слов о классе AlarmManager





Фактически класс AlarmManager обеспечивает доступ к сервису планировки задач Android. Для получения объекта этого класса нужно вызвать метод **Context.getSystemService(Context.ALARM_SERVICE)**. **AlarmManager** регистрирует в системе интент и когда наступает обозначенное время, AlarmManager запускает этот интент. Если момент вызова приложение закрыто, то оно будет вновь запущено. AlarmManager нужно использовать только в случае, если код должен быть выполнен даже при закрытом приложении, во всех других случаях рекомендуется использовать класс **Handler**.  
  
Класс AlarmManager довольно прост. В нашем распоряжении шесть методов:  
  









  * **void cancel(PendingIntent operation)** - отменяет установленный таймер для переданного в качестве параметра интента.



  * **void set (int type, long triggerAtMillis, PendingIntent operation)** - устанавливает будильник, который сработает один раз.



  * **void setInexactRepeating (int type, long triggerAtMillis, long intervalMillis, PendingIntent operation)** - установка будильника с неточным повторением.



  * **setRepeating(int type, long triggerAtMillis, long intervalMillis, PendingIntent operation)**- установка будильника с точным повторением.



  * **setTime(long millis)** - установка системного времени.



  * **setTimeZone(String timeZone)** - установка временной зоны, выбранной по-умолчанию.






  
Здесь **PendingIntent**- класс, который представляет интент и связанное с его выполнением действие. Передавая PendingIntent другому приложению Вы тем самым даете ему право запускать кусок кода из своей программы.  
  
В качестве типа будильника (параметр **type**) может быть передано одно из значений ELAPSED_REALTIME, ELAPSED_REALTIME_WAKEUP, RTC и RTC_WAKEUP. ELAPSED_REALTIME и ELAPSED_REALTIME_WAKEUP - время задается с момента загрузки устройства, а RTC и RTC_WAKEUP - системное время в UTC. Для ELAPSED_REALTIME и RTC если устройство находится в спящем режиме в момент срабатывания будильника, то связанный с ним интент будет вызван позже, когда пользователь выведет устройство из спящего режима. Для ELAPSED_REALTIME_WAKEUP и RTC_WAKEUP если устройство находится в спящем режиме, оно немедленно пробуждается и вызывается интент.





## Программируем приложение-будильник для Android





Давайте в качестве примера разработаем приложение - будильник. При запуске программы пользователю будет показано окно с тремя кнопками. С их помощью пользователь сможет: установить будильник, который срабатывает один раз; будильник, который будет срабатывать периодически; а также удалить ранее установленные будильники. 





![](http://android-helper.com.ua/images/uploads/2012/09/device-2012-09-10-172549.png)



Создадим новый проект в макет шаблона добавим три кнопки





	<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"

    xmlns:tools="http://schemas.android.com/tools"

    android:layout_width="match_parent"

    android:layout_height="match_parent"

    android:orientation="vertical" >



    <Button

        android:id="@+id/btStart"

        android:layout_width="match_parent"

        android:layout_height="wrap_content"

        android:onClick="startRepeatingTimer"

        android:padding="@dimen/padding_medium"

        android:text="Start"

        tools:context=".WidgetAlarmManagerActivity" />



    <Button

        android:id="@+id/btCancel"

        android:layout_width="match_parent"

        android:layout_height="wrap_content"

        android:onClick="cancelRepeatingTimer"

        android:padding="@dimen/padding_medium"

        android:text="Cancel"

        tools:context=".WidgetAlarmManagerActivity" />



    <Button

        android:id="@+id/btOneTime"

        android:layout_width="match_parent"

        android:layout_height="wrap_content"

        android:onClick="onetimeTimer"

        android:padding="@dimen/padding_medium"

        android:text="One Time"

        tools:context=".WidgetAlarmManagerActivity" />



	</LinearLayout>



Кнопка **btStart** устанавливает повторяющийся будильник, кнопка **btCancel**- отменяет его. Кнопка **btOneTime**- создает не повторяющийся будильник. Прямо в шаблоне мы указали методы, которые будут вызываться при нажатии на кнопки: startRepeatingTimer, cancelRepeatingTimer и onetimeTimer соответственно. Код этих методов будут приведен в классе Activity.  
   
Для работы с **AlarmManager** напишем отдельный класс. В качестве базового класса используем BroadcastReciever. Наш класс будет управлять зарегистрированным с помощью AlarmManager интентом. Мы переопределим метод **onReceive()**, который будет вызываться после получения интента. Внутри метод onReceive() мы должны попытаться получить связанные с интентом параметры. В своей программе мы будем использовать один параметр ONE_TIME, который позволяет определить, относится ли интент к однократно срабатывающему будильнику или нет. После того, как значение ONE_TIME получено, пользователю показывается соответствующее сообщение.   
   
Также в этом классе определим методы setAlarm(), cancelAlarm() и onetimeTimer(). Конечно эти методы можно было определить и в другом месте, мы включили их в данный класс из соображения простоты примера.








  * Метод setAlarm() устанавливает повторяющийся будильник с помощью метода setRepeating(). Этому методу требуется четыре параметра: тип будильника, время запуска (устанавливаем текущий момент), интервал в миллисекундах, интент, который будет вызываться при срабатывании будильника.



  * Метод cancelAlarm() отменяет зарегистрированный ранее будильник с помощью вызова метода cancel(), которому перезается в качестве параметра интент. При совпадении этого параметра с зарегистрированным ранее интентом, произойдет удаление будильника.



  * Метод onetimeTimer() создает будильник, который срабатывает один раз. Делается с помощью метода set(), которому передается три параметра: тип будильника, время запуска, вызываемый интент.


		package com.example.alarm;

		import java.text.Format;

		import java.text.SimpleDateFormat;

		import java.util.Date;

		import android.app.AlarmManager;

		import android.app.PendingIntent;

		import android.content.BroadcastReceiver;

		import android.content.Context;

		import android.content.Intent;

		import android.os.Bundle;

		import android.os.PowerManager;

		import android.widget.Toast;

		public class AlarmManagerBroadcastReceiver extends BroadcastReceiver {



		final public static String ONE_TIME = "onetime";



		@Override

		public void onReceive(Context context, Intent intent) {

		PowerManager pm = (PowerManager) context.getSystemService(Context.POWER_SERVICE);

		PowerManager.WakeLock wl = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "YOUR TAG");

		// Осуществляем блокировку

		wl.acquire();



		// Здесь можно делать обработку.

		Bundle extras = intent.getExtras();

		StringBuilder msgStr = new StringBuilder();



		if (extras != null && extras.getBoolean(ONE_TIME, Boolean.FALSE)) {

			// проверяем параметр ONE_TIME, если это одиночный будильник,

			// выводим соответствующее сообщение.

			msgStr.append("Одноразовый будильник: ");

		}

		Format formatter = new SimpleDateFormat("hh:mm:ss a");

		msgStr.append(formatter.format(new Date()));



		Toast.makeText(context, msgStr, Toast.LENGTH_LONG).show();



		// Разблокируем поток.

		wl.release();

		}



		public void SetAlarm(Context context) {

		AlarmManager am = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);

		Intent intent = new Intent(context, AlarmManagerBroadcastReceiver.class);

		intent.putExtra(ONE_TIME, Boolean.FALSE); // Задаем параметр интента

		PendingIntent pi = PendingIntent.getBroadcast(context, 0, intent, 0);

		// Устанавливаем интервал срабатывания в 5 секунд.

		am.setRepeating(AlarmManager.RTC_WAKEUP, System.currentTimeMillis(), 1000 * 5, pi);

		}



		public void CancelAlarm(Context context) {

		Intent intent = new Intent(context, AlarmManagerBroadcastReceiver.class);

		PendingIntent sender = PendingIntent.getBroadcast(context, 0, intent, 0);

		AlarmManager alarmManager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);

		alarmManager.cancel(sender); // Отменяем будильник, связанный с интентом данного класса

		}



		public void setOnetimeTimer(Context context) {

		AlarmManager am = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);

		Intent intent = new Intent(context, AlarmManagerBroadcastReceiver.class);

		intent.putExtra(ONE_TIME, Boolean.TRUE); // Задаем параметр интента

		PendingIntent pi = PendingIntent.getBroadcast(context, 0, intent, 0);

		am.set(AlarmManager.RTC_WAKEUP, System.currentTimeMillis(), pi);

		}

		}







Ниже приводится файл манифеста. Обратите внимание, для корректной работы программе необходимо дать разрешение**WAKE_LOCK**, поскольку мы используем блокировку потока в методе onReceive(). Также тут мы регистрируем AlarmManagerBroadcastReceiver, как получатель широковещательных сообщений


	<manifest xmlns:android="http://schemas.android.com/apk/res/android"

    package="com.example.alarm"

    android:versionCode="1"

    android:versionName="1.0" >



    <uses-sdk

        android:minSdkVersion="8"

        android:targetSdkVersion="15" />



    <uses-permission android:name="android.permission.WAKE_LOCK" />



    <application

        android:icon="@drawable/ic_launcher"

        android:label="@string/app_name"

        android:theme="@style/AppTheme" >

        <activity

            android:name=".MainActivity"

            android:label="@string/title_activity_main" >

            <intent-filter>

                <action android:name="android.intent.action.MAIN" />



                <category android:name="android.intent.category.LAUNCHER" />

            </intent-filter>

        </activity>



        <receiver android:name="AlarmManagerBroadcastReceiver" >

        </receiver>

    </application>



	</manifest>






Теперь давайте напишем класс, в котором реализуем обработчики кнопок. Здесь мы создадим экземпляр описанного выше класса AlarmManagerBroadcastReciever и будем вызывать методы setAlarm(), cancelAlarm() и setOnetime(). 




	package com.example.alarm;



	import android.app.Activity;

	import android.content.Context;

	import android.os.Bundle;

	import android.view.Menu;

	import android.view.View;

	import android.widget.Toast;



	public class MainActivity extends Activity {



	private AlarmManagerBroadcastReceiver alarm;



	@Override

	public void onCreate(Bundle savedInstanceState) {

		super.onCreate(savedInstanceState);

		setContentView(R.layout.activity_main);

		alarm = new AlarmManagerBroadcastReceiver();

	}



	@Override

	protected void onStart() {

		super.onStart();

	}



	public void startRepeatingTimer(View view) {

		Context context = this.getApplicationContext();

		if (alarm != null) {

			alarm.SetAlarm(context);

		} else {

			Toast.makeText(context, "Alarm is null", Toast.LENGTH_SHORT).show();

		}

	}



	public void cancelRepeatingTimer(View view) {

		Context context = this.getApplicationContext();

		if (alarm != null) {

			alarm.CancelAlarm(context);

		} else {

			Toast.makeText(context, "Alarm is null", Toast.LENGTH_SHORT).show();

		}

	}



	public void onetimeTimer(View view) {

		Context context = this.getApplicationContext();

		if (alarm != null) {

			alarm.setOnetimeTimer(context);

		} else {

			Toast.makeText(context, "Alarm is null", Toast.LENGTH_SHORT).show();

		}

	}



	@Override

	public boolean onCreateOptionsMenu(Menu menu) {

		getMenuInflater().inflate(R.menu.activity_main, menu);

		return true;

	}



	}





При надатии на кнопки будут установлен будильник.





Комментируем и подписываемся на обновления.





Коды вы можете скачать [тут](http://android-helper.com.ua/forms)
Добрый день.




Сегодня речь пойдет о Service, IntentService и Foreground.




Попробуем сегодня разобрать, что это такое и как оно работает.




Я решил не выдумывать велосипед, и взял уже готовую [статью](http://startandroid.ru/uroki/vse-uroki-spiskom/165-urok-100-service-intentservice-foreground-avtozagruzka-servisa.html).




Прошу к прочтению.

<!-- more -->


В этом уроке:




- изучаем IntentService  
- включаем режим Foreground для сервиса  
- помещаем сервис в автозагрузку




Строили мы, строили, и, наконец, построили. Урок номер 100, с чем всех нас и поздравляю )




В этом уроке рассмотрим еще несколько полезных вещей про сервисы. Выносить каждую из них в отдельный урок я не стал, вполне можно в одном все рассмотреть. Проекты здесь тоже создавать не будем, чтобы урок не получился слишком громоздким. Я просто приведу некоторые куски кода и скрины для наглядности своих рассуждений. А если у вас будет желание, вы по этим наработкам сами можете создать проекты-примеры.




 **IntentService**




 Это подкласс обычного Service. Он используется, если вам в сервисе надо выполнять какие-то тяжелые задачи, и вы не хотите сами возиться с асинхронностью. Принцип работы этого вида сервиса прост. Он создает новый поток для своей работы. Затем берет все Intent пришедшие ему в onStartCommand и отправляет их на обработку в этот поток. Как именно обрабатываются Intent – зависит от нас, т.к. мы сами кодим это в методе onHandleIntent.




Т.е. приложение сыпет в сервис вызовами startService, в которых передает Intent-ы. [IntentService ](http://developer.android.com/reference/android/app/IntentService.html)принимает эти вызовы в onStartCommand, берет Intent-ы и отправляет их в очередь на обработку. И далее они поочередно обрабатываются в отдельном процессе методом [onHandleIntent](http://developer.android.com/reference/android/app/IntentService.html#onHandleIntent(android.content.Intent)). Когда последний Intent из очереди обработан, процесс сам завершает свою работу.




Пример




В приложении делаем три вызова:


	Intent intent = new Intent(this, MyService.class);
	startService(intent.putExtra("time", 3).putExtra("label", "Call 1"));
	startService(intent.putExtra("time", 1).putExtra("label", "Call 2"));
	startService(intent.putExtra("time", 4).putExtra("label", "Call 3"));






Где **time **– это время паузы, которую будем делать в сервисе, а **label **– просто метка, чтобы отличать вызовы.




Код сервиса:


	package com.example.service;

	import java.util.concurrent.TimeUnit;

	import android.app.IntentService;
	import android.content.Intent;
	import android.util.Log;

	public class MyService extends IntentService {

	final String LOG_TAG = "myLogs";

	public MyService() {
		super("myname");
	}

	@Override
	public void onCreate() {
		super.onCreate();
		Log.d(LOG_TAG, "onCreate");
	}

	@Override
	protected void onHandleIntent(final Intent intent) {
		int tm = intent.getIntExtra("time", 0);
		String label = intent.getStringExtra("label");
		Log.d(LOG_TAG, "onHandleIntent start " + label);
		try {
			TimeUnit.SECONDS.sleep(tm);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		Log.d(LOG_TAG, "onHandleIntent end " + label);
	}

	@Override
	public void onDestroy() {
		super.onDestroy();
		Log.d(LOG_TAG, "onDestroy");
	}

	}


Здесь необходим конструктор, в котором вызываем конструктор супер-класса и указываем какое-нить имя. Оно будет использовано для наименования потока.




В методе onHandleIntent кодим обработку Intent-ов. Достаем из них time и label, запускаем паузу на time секунд и выводим в лог label в начале и в конце.




В итоге, при запуске в логах видим:




	11:07:37.880: D/myLogs(4137): onCreate  
	11:07:37.880: D/myLogs(4137): onHandleIntent start Call 1  
	11:07:40.880: D/myLogs(4137): onHandleIntent end Call 1  
	11:07:40.880: D/myLogs(4137): onHandleIntent start Call 2  
	11:07:41.880: D/myLogs(4137): onHandleIntent end Call 2  
	11:07:41.880: D/myLogs(4137): onHandleIntent start Call 3  
	11:07:45.890: D/myLogs(4137): onHandleIntent end Call 3  
	11:07:45.890: D/myLogs(4137): onDestroy_




Сервис создался, вызовы выполнились по очереди и сервис завершил работу. От нас понадобилось только накодить обработку.




### **Foreground**




Вы можете сказать системе, что ваш сервис очень важен для пользователя и его нельзя грохать при нехватке памяти. Это актуально, например, для музыкального плеера. В статус-бар при этом будет помещено уведомление.




Делается это методом [startForeground(int id, Notification notification)](http://developer.android.com/reference/android/app/Service.html#startForeground(int, android.app.Notification)).




На вход он принимает те же параметры, что и NotificationManager.notify – ID и Notification.




Т.е. вы создаете уведомление, назначаете ему ID и передаете это в startForeground. Сервис переходит в режим [IDDQD](http://lurkmore.to/IDDQD) :), а в статус-баре появилось уведомление.




![](http://android-helper.com.ua/images/uploads/2012/09/L0100_010.jpg)



Оно появилось в разделе для постоянных уведомлений (Ongoing). 




Метод [stopForeground (boolean removeNotification)](http://developer.android.com/reference/android/app/Service.html#stopForeground(boolean))  - возвращает сервису способность быть убитым системой в случае острой нехватки памяти. А на вход он принимает boolean-значение – удалять уведомление из статус-бара или нет.




Уведомление также пропадет, когда сервис будет остановлен.




Эти методы работают, начиная с Android 2.0.  Пример реализации для более ранних версий есть в [хелпе](http://developer.android.com/reference/android/app/Service.html#startForeground(int, android.app.Notification)).




Напомню, что уведомления мы научились создавать на прошлом уроке.




### **Автозагрузка**




Сервисы для получения погоды или почты имеет смысл помещать в автозагрузку. Для этого нам надо создать [BroadcastReceiver](http://developer.android.com/reference/android/content/BroadcastReceiver.html), настроить его IntentFilter на Action =**android.intent.action.BOOT_COMPLETED**, и добавить права **android.permission.RECEIVE_BOOT_COMPLETED**. Этот BroadcastReceiver будет вызван системой при старте системы и в нем мы кодим запуск сервиса.




Допустим, есть проект с сервисом MyService.




Создаем в проекте класс **MyBroadReceiv**


	package com.example.service;

	import android.content.BroadcastReceiver;
	import android.content.Context;
	import android.content.Intent;
	import android.util.Log;

	public class MyBroadReceiv extends BroadcastReceiver {

	final String LOG_TAG = "myLogs";

	@Override
	public void onReceive(final Context context, final Intent intent) {
		Log.d(LOG_TAG, "onReceive " + intent.getAction());
		context.startService(new Intent(context, MyService.class));
	}
	}


В манифесте добавляем его как **Receiver **и настраиваем фильтр

![](http://android-helper.com.ua/images/uploads/2012/09/L0100_020.jpg)




 




Добавляем права на получение сообщения о загрузке




![](http://android-helper.com.ua/images/uploads/2012/09/L0100_030.jpg)


Инсталлим проект на AVD. Закрываем AVD. Запускаем через меню в Eclipse: Window > AVD Manager. Находим там наш эмулятор и запускаем вручную.




Когда он запустился, смотрим логи




	_onReceive android.intent.action.BOOT_COMPLETED  
	MyService onCreate  
	MyService onStartCommand_




Сработал BroadcastReceiver и запустил сервис.







Если после запуска AVD логи не отображаются, то откройте DDMS и во вкладке Devices явно выберите ваш AVD.




Надеюсь вам понравилась статья.




Ожидаю ваших комментариев.




Коды вы можете скачать [тут](http://android-helper.com.ua/forms)
Добрый день друзья.





Продолжая собирать у себя на сайте различного рода ценную информацию.





Я решил продолжить описание работы с fragments.





И как всегда на помощь мне пришла статья одного известного сайта.


<!-- more -->


Оригинал статьи [тут](http://startandroid.ru/uroki/vse-uroki-spiskom/175-urok-105-android-3-fragments-dinamicheskaja-rabota.html).





Прошу к прочтению.





В этом уроке:





- динамически работаем с фрагментами





Размещать статические фрагменты мы уже умеем. Но, ясно дело, что гораздо интереснее работать с ними динамически. Система позволяет нам добавлять, удалять и заменять фрагменты друг другом. При этом мы можем сохранять все эти манипуляции в BackStack и кнопкой Назад отменять. В общем, все удобно и красиво.





Создадим простое приложение с двумя  фрагментами, которое будет уметь:





- добавлять первый фрагмент  
- удалять первый фрагмент  
- заменять первый фрагмент вторым фрагментом  
- переключать режим сохранения в BackStack операций с фрагментами





В **strings.xml** добавим строки:


		<string name="frag1_text">Fragment 1</string>

    <string name="frag2_text">Fragment 2</string>

    <string name="add">Add</string>

    <string name="remove">Remove</string>

    <string name="replace">Replace</string>

    <string name="stack">add to Back Stack</string>







Создаем фрагменты. Как мы помним из прошлого урока, для этого нам нужны будут layout-файлы и классы, наследующие android.app.Fragment





 **fragment1.xml**:




	<?xml version="1.0" encoding="utf-8"?>

	<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"

    android:layout_width="match_parent"

    android:layout_height="match_parent"

    android:background="#77ff0000"

    android:orientation="vertical" >



    <TextView

        android:layout_width="wrap_content"

        android:layout_height="wrap_content"

        android:text="@string/frag1_text" >

    </TextView>



	</LinearLayout>







**fragment2.xml:**






	<?xml version="1.0" encoding="utf-8"?>

	<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"

    android:layout_width="match_parent"

    android:layout_height="match_parent"

    android:background="#7700ff00"

    android:orientation="vertical" >



    <TextView

        android:layout_width="wrap_content"

        android:layout_height="wrap_content"

        android:text="@string/frag2_text" >

    </TextView>



	</LinearLayout>






**Fragment1.java**:






	package com.example.fragmetns2;



	import android.os.Bundle;

	import android.support.v4.app.Fragment;

	import android.view.LayoutInflater;

	import android.view.View;

	import android.view.ViewGroup;

	public class Fragment1 extends Fragment {



	@Override

	public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {

		return inflater.inflate(R.layout.fragment1, null);

	}

	}









**Fragment2.java**:


	package com.example.fragmetns2;


	import android.os.Bundle;

	import android.support.v4.app.Fragment;

	import android.view.LayoutInflater;

	import android.view.View;

	import android.view.ViewGroup;



	public class Fragment2 extends Fragment {



	@Override

	public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {

		return inflater.inflate(R.layout.fragment2, null);

	}

	}


Все почти аналогично прошлому уроку, только убрали вызовы кучи lifecycle методов с логами.









Рисуем основное Activity.





**activity_main.xml**:



	<?xml version="1.0" encoding="utf-8"?>

	<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"

    xmlns:tools="http://schemas.android.com/tools"

    android:id="@+id/LinearLayout1"

    android:layout_width="match_parent"

    android:layout_height="match_parent"

    android:orientation="vertical" >



    <LinearLayout

        android:layout_width="wrap_content"

        android:layout_height="wrap_content"

        android:orientation="vertical" >



        <Button

            android:id="@+id/btnAdd"

            android:layout_width="wrap_content"

            android:layout_height="wrap_content"

            android:onClick="onClick"

            android:text="@string/add" >

        </Button>



        <Button

            android:id="@+id/btnRemove"

            android:layout_width="wrap_content"

            android:layout_height="wrap_content"

            android:onClick="onClick"

            android:text="@string/remove" >

        </Button>



        <Button

            android:id="@+id/btnReplace"

            android:layout_width="wrap_content"

            android:layout_height="wrap_content"

            android:onClick="onClick"

            android:text="@string/replace" >

        </Button>



        <CheckBox

            android:id="@+id/chbStack"

            android:layout_width="wrap_content"

            android:layout_height="wrap_content"

            android:text="@string/stack" >

        </CheckBox>

    </LinearLayout>



    <FrameLayout

        android:id="@+id/frgmCont"

        android:layout_width="match_parent"

        android:layout_height="match_parent" >

    </FrameLayout>



	</LinearLayout>






Три кнопки для добавления, удаления и замены фрагментов. Чекбокс для включения использования BackStack. И FrameLayout – это контейнер, в котором будет происходить вся работа с фрагментами. Он должен быть типа ViewGroup. А элементы Fragment, которые мы использовали на прошлом уроке для размещения фрагментов, нам не нужны для динамической работы. 





 **MainActivity.java**:


	package com.example.fragmetns2;



	import android.os.Bundle;

	import android.support.v4.app.FragmentActivity;

	import android.support.v4.app.FragmentTransaction;

	import android.view.View;

	import android.widget.CheckBox;



	public class MainActivity extends FragmentActivity {



	Fragment1 frag1;

	Fragment2 frag2;

	FragmentTransaction fTrans;

	CheckBox chbStack;



	@Override

	public void onCreate(Bundle savedInstanceState) {

		super.onCreate(savedInstanceState);

		setContentView(R.layout.activity_main);



		frag1 = new Fragment1();

		frag2 = new Fragment2();



		chbStack = (CheckBox) findViewById(R.id.chbStack);

	}



	public void onClick(View v) {

		fTrans = getSupportFragmentManager().beginTransaction();

		switch (v.getId()) {

			case R.id.btnAdd:

				fTrans.add(R.id.frgmCont, frag1);

				break;

			case R.id.btnRemove:

				fTrans.remove(frag1);

				break;

			case R.id.btnReplace:

				fTrans.replace(R.id.frgmCont, frag2);

			default:

				break;

		}

		if (chbStack.isChecked()) {

			fTrans.addToBackStack(null);

		}

		fTrans.commit();

	}

	}






В **onCreate** создаем пару фрагментов и находим чекбокс.





В **onClick** мы получаем менеджер фрагментов с помощью метода [getFragmentManager](http://developer.android.com/reference/android/app/Activity.html#getFragmentManager()). Этот объект является основным для работы с фрагментами. Далее, чтобы добавить/удалить/заменить фрагмент, нам необходимо использовать транзакции. Они аналогичны транзакциям в БД, где мы открываем транзакцию, производим операции с БД, выполняем commit. Здесь мы открываем транзакцию, производим операции с фрагментами (добавляем, удаляем, заменяем), выполняем commit.





Итак, мы получили FragmentManager и открыли транзакцию методом [beginTransaction](http://developer.android.com/reference/android/app/FragmentManager.html#beginTransaction()). Далее определяем, какая кнопка была нажата:





если **Add**, то вызываем метод [add](http://developer.android.com/reference/android/app/FragmentTransaction.html#add(int, android.app.Fragment)), в который передаем id контейнера (тот самый FrameLayout из main.xml) и объект фрагмента. В итоге, в контейнер будет помещен Fragment1





если **Remove**, то вызываем метод [remove](http://developer.android.com/reference/android/app/FragmentTransaction.html#remove(android.app.Fragment)), в который передаем объект фрагмента, который хотим убрать. В итоге, фрагмент удалится с экрана.





если **Replace**, то вызываем метод [replace](http://developer.android.com/reference/android/app/FragmentTransaction.html#replace(int, android.app.Fragment)), в который передаем id контейнера и объект фрагмента. В итоге, из контейнера удалится его текущий фрагмент (если он там есть) и добавится фрагмент, указанный нами.





Далее проверяем чекбокс. Если он включен, то добавляем транзакцию в BackStack. Для этого используем метод [addToBackStack](http://developer.android.com/reference/android/app/FragmentTransaction.html#addToBackStack(java.lang.String)). На вход можно подать строку-тэг. Я передаю null.





Ну и вызываем [commit](http://developer.android.com/reference/android/app/FragmentTransaction.html#commit()), транзакция завершена.





Давайте смотреть, что получилось. Все сохраняем, запускаем приложение.





![](http://android-helper.com.ua/images/uploads/2012/09/L0105_010.jpg)




Жмем **Add**





![](http://android-helper.com.ua/images/uploads/2012/09/L0105_020.jpg)





появился первый фрагмент.









Жмем **Remove**





![](http://android-helper.com.ua/images/uploads/2012/09/L0105_030.jpg)




фрагмент удалился.









Еще раз добавим первый фрагмент – жмем **Add**. И жмем **Replace**





![](http://android-helper.com.ua/images/uploads/2012/09/L0105_040.jpg)




первый фрагмент заменился вторым.





Жмем кнопку **Назад**. Приложение закрылось, т.к. все эти операции с фрагментами не сохранялись в BackStack. Давайте используем эту возможность.





Снова запускаем приложение и включаем чекбокс** add to Back Stack**





![](http://android-helper.com.ua/images/uploads/2012/09/L0105_050.jpg)



Выполняем те же операции: **Add**, **Remove**, **Add**, **Replace**. У нас добавится первый фрагмент, удалится первый фрагмент, добавится первый фрагмент, заменится вторым. В итоге мы снова видим второй фрагмент. Теперь жмем несколько раз кнопку **Назад **и наблюдаем, как выполняются операции, обратные тем, что мы делали. Когда транзакции, сохраненные в стеке закончатся, кнопка Назад закроет приложение.





Т.е. все достаточно просто и понятно. Скажу еще про пару интересных моментов.





Я в этом примере выполнял всего одну операцию в каждой транзакции. Но, разумеется, их может быть больше.





Когда мы удаляем фрагмент и не добавляем транзакцию в BackStack, то фрагмент уничтожается. Если же транзакция добавляется в BackStack, то, при удалении, фрагмент не уничтожается (onDestroy не вызывается), а останавливается (onStop).









В качестве самостоятельной работы: попробуйте немного изменить приложение и добавлять в один контейнер сразу два фрагмента. Возможно, результат вас удивит ) 





Надеюсь что вам понравилась статья.





Жду ваших комментариев.





Коды вы можете скачать [тут](http://android-helper.com.ua/forms)







От себя хочу также добавить, что коды которые я предоставляю, работают до 1.6 версии.


Добрый день друзья.





Сегодня я покажу вам как можно звонить из своего приложения.





Прошу к прочтению.


 <!-- more -->


Создадим activity_main.xml:


	<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"

    xmlns:tools="http://schemas.android.com/tools"

    android:layout_width="match_parent"

    android:layout_height="match_parent" >



    <EditText

        android:id="@+id/editText1"

        android:layout_width="wrap_content"

        android:layout_height="wrap_content"

        android:layout_alignParentLeft="true"

        android:ems="10"

        android:inputType="numberSigned" >



        <requestFocus />

    </EditText>



    <Button

        android:id="@+id/button1"

        android:layout_width="wrap_content"

        android:layout_height="wrap_content"

        android:layout_alignParentTop="true"

        android:layout_toRightOf="@+id/editText1"

        android:text="Звонок" />



	</RelativeLayout>








Создаем MainActivity.java:


	package com.example.call_to_phone;



	import android.app.Activity;

	import android.content.Intent;

	import android.net.Uri;

	import android.os.Bundle;

	import android.view.Menu;

	import android.view.View;

	import android.view.View.OnClickListener;

	import android.widget.Button;

	import android.widget.EditText;



	public class MainActivity extends Activity implements OnClickListener {



	private EditText callNumber;



	@Override

	public void onCreate(Bundle savedInstanceState) {

		super.onCreate(savedInstanceState);

		setContentView(R.layout.activity_main);

		callNumber = (EditText) findViewById(R.id.editText1);

		Button callButton = (Button) findViewById(R.id.button1);

		callButton.setOnClickListener(this);



	}



	@Override

	public boolean onCreateOptionsMenu(Menu menu) {

		getMenuInflater().inflate(R.menu.activity_main, menu);

		return true;

	}



	@Override

	public void onClick(View arg0) {

		if (callNumber != null) {

			String number = String.format("tel:%s", callNumber.getText().toString());

			startActivity(new Intent(Intent.ACTION_CALL, Uri.parse(number)));

		}

	}

	}








Как вы видите при нажатии на кнопку мы сразу начинаем звонок.





Для вызова нужно писать:



	String number = String.format("tel:%s", callNumber.getText().toString());

	startActivity(new Intent(Intent.ACTION_CALL, Uri.parse(number)));







Как видите все очень быстро из без проблем.





Прошу оценить статью и дать пару комментариев.





Коды вы можете скачать [тут](http://android-helper.com.ua/forms)
Продолжим описание android программирования.





Все вы наверное видели красивые widget у себя на рабочем столе телефона.





Вы угадали, сегодня речь пойдет именно о них.





Ну что поехали.


 <!-- more -->


Оригинал статьи [тут](http://www.mobilab.ru/articles/109/).





С начала этого года (прим. автора с 2007 года) команда разработчиков **Android** упорно работала над созданием нового релиза, который получил название**Android 1.5**. В его состав входит **AppWidget framework**, предназначенный для создания виджетов, которые пользователь может размещать на своем домашнем экране. Виджеты могут импортировать и отображать в удобной для пользователя форме информацию из Ваших Android приложений. Например, можно создать виджет, который будет отображать список невыполненных дел или давать информацию об играющей в фоновом режиме музыке.





![](http://android-helper.com.ua/images/uploads/2012/09/Awidget.png)





Когда пользователь перетаскивает виждет на домашний экран, он фактически резервирует место, на котором будет отображаться контент из Вашего приложения. Кроме того, пользователь может взаимодействовать с Вашим приложением через виджет, например, приостанавливать проигрывание музыки. Если у Вас есть сервис, работающий в фоновом режиме, Вы можете обновлять виджет по собственному графику, или использовать стандартный механизм из **AppWidget framework**.





Виджет представляет собой BroadcastReceiver скрещенный с XML описанием параметров виждета. **AppWidget framework**связывается с Вашим виджетом через радиовещание, когда требуется обновление. Обновления строятся и посылаются с помощью RemoteViews, включающий контент, для отображения на домашней странице.





Вы без особого труда можете создать виджет для своего приложения. Давайте создадим виджет для Android приложения "Слово дня" ([исходники](http://code.google.com/p/wiktionary-android/source/browse/#svn/trunk/SimpleWiktionary)). Я не буду рассматривать здесь это приложение, а сосредоточусь на самом виджете.





Прежде всего нужно создать XML описание виджета, указав там область домашнего экрана, которую Вы хотели бы зарезервировать для своего виджета, начальный слой для отображения, а также частоту обновления информации. Домашний экран **Android** разбит на ячейки, так что указанные вами размеры округляются до размеров ячеек. Это может сбить с толку. Возможно вам поможет вот эта формула





Минимальный размер в dip=(Число ячеек * 74dip)-2dip





В нашем примере мы хотим создать виджет, который будет занимать 2 ячейки в ширину и 1 в высоту. Это значит, что минимальный размер должен составлять 146dip x 72dip. Мы хотим, чтобы информация обновлялась раз в день, то есть через каждые 86,400,000 миллисекунд. XML metadata имеет вид:






	<appwidget-provider

    xmlns:android="http://schemas.android.com/apk/res/android"

    android:minWidth="146dip"

    android:minHeight="72dip"

    android:initialLayout="@layout/widget_message"

    android:updatePeriodMillis="86400000"

    />




Теперь давайте сопоставим эти XML данные и BroadcastReceiver в AndroidManifest:




	<!-- Broadcast Receiver that will process AppWidget updates -->

	<receiver android:name=".WordWidget" android:label="@string/widget_name">

    <intent-filter>

        <action android:name="android.appwidget.action.APPWIDGET_UPDATE" />

    </intent-filter>

    <meta-data android:name="android.appwidget.provider" android:resource="@xml/widget_word" />

	</receiver>



	<!-- Service to perform web API queries -->

	<service android:name=".WordWidget$UpdateService" />







Давайте напишем код для BroadcastReceiver, который будет управлять **AppWidget** запросами. Чтобы помочь виджету управлять различными радиовещательными событиями, разработчики написали класс **AppWidgetProvider**. Важно отметить, что мы запустим фоновый сервис, чтобы выполнять обновления. Это связано с тем, что BroadcastReceivers - потомок Application Not Responding (ANR) таймера, который может предложить пользователю закрыть приложение, если запрос выполняется слишком долго. Выполнение веб запроса может занимать несколько секунд, поэтому мы используем именно сервисы, чтобы избежать ANR таймаутов.



	/**

	 * Определяем простой виджет, который отображает слово дня. Для обновлений

	 * мы порождаем фоновой сервис {@link Service} для выполнения API запросов.

	 */

	public class WordWidget extends AppWidgetProvider {

    @Override

    public void onUpdate(Context context, AppWidgetManager appWidgetManager,

        int[] appWidgetIds) {

        // Чтобы предотвратить любые ANR таймацты, мы выполняем обновление в сервисе.

        context.startService(new Intent(context, UpdateService.class));

    }

 

    public static class UpdateService extends Service {

        @Override

        public void onStart(Intent intent, int startId) {

            // Выполняем сегодняшнее обновление виджета.

            RemoteViews updateViews = buildUpdate(this);

 

            // Помещаем обновление этого выджета на домашний экран

            ComponentName thisWidget = new ComponentName(this, WordWidget.class);

            AppWidgetManager manager = AppWidgetManager.getInstance(this);

            manager.updateAppWidget(thisWidget, updateViews);

        }

 

        /**

                     * Строим обновление виджета, чтобы показать текущее слово.

                     * Заблокируем пока не получим online ответ.

         */

        public RemoteViews buildUpdate(Context context) {

            // Берем название месяца из ресурсов

            Resources res = context.getResources();

            String[] monthNames = res.getStringArray(R.array.month_names);

 

            // ищем текущий месяц и день

            Time today = new Time();

            today.setToNow();

 

            // Заголовок страницы в вмде "Wiktionary:Word of the day/March 21"

            String pageName = res.getString(R.string.template_wotd_title,

                monthNames[today.month], today.monthDay);

            RemoteViews updateViews = null;

            String pageContent = "";

 

            try {

                // Пытаемся послать запрос Wiktionary API для получения слова дня

                SimpleWikiHelper.prepareUserAgent(context);

                pageContent = SimpleWikiHelper.getPageContent(pageName, false);

            } catch (ApiException e) {

                Log.e("WordWidget", "Couldn't contact API", e);

            } catch (ParseException e) {

                Log.e("WordWidget", "Couldn't parse API response", e);

            }

 

            // Используем регулярное выражение для парсинга слов и их описания

            Pattern pattern = Pattern.compile(SimpleWikiHelper.WORD_OF_DAY_REGEX);

            Matcher matcher = pattern.matcher(pageContent);

            if (matcher.find()) {

                // Выполняем обновление контента виджета

                updateViews = new RemoteViews(context.getPackageName(), R.layout.widget_word);

 

                String wordTitle = matcher.group(1);

                updateViews.setTextViewText(R.id.word_title, wordTitle);

                updateViews.setTextViewText(R.id.word_type, matcher.group(2));

                updateViews.setTextViewText(R.id.definition, matcher.group(3).trim());

 

                // Когда пользователь кликает на виджет, запускается страница Wiktionary.

                String definePage = res.getString(R.string.template_define_url,

                        Uri.encode(wordTitle));

                Intent defineIntent = new Intent(Intent.ACTION_VIEW, Uri.parse(definePage));

                PendingIntent pendingIntent = PendingIntent.getActivity(context,

                        0 /* no requestCode */, defineIntent, 0 /* no flags */);

                updateViews.setOnClickPendingIntent(R.id.widget, pendingIntent);

 

            } else {

                // Слово дня не найдено, показываем ошибку

                updateViews = new RemoteViews(context.getPackageName(), R.layout.widget_message);

                CharSequence errorMessage = context.getText(R.string.widget_error);

                updateViews.setTextViewText(R.id.message, errorMessage);

            }

            return updateViews;

        }

 

        @Override

        public IBinder onBind(Intent intent) {

            // Мы не хотим привязываться к этому сервису

            return null;

        }

    }

	}

 


Все. Мы написали виджет для приложения Wiktionary "Слово дня". Когда требуется обновление, мы с помощью online API получаем новые данные. **AppWidget framework** автоматически запрашивает у нас обновления, например в момент добавления виджета на экран или согласно своему расписанию - раз в день.





Вообще виджеты стоит создавать для отображения не очень часто обновляемых данных (не чаще чем раз в час). Старайтесь обновлять информацию как можно реже и предусмотрите возможность ручного обновления.





Созданные таким образом виджеты можно размещать на любом домашнем экране, поддерживающим **AppWidget framework**.





Спасибо вам, за то что вы с нами.





Ожидаем ваших комментариев.







Коды вы можете скачать [тут](http://android-helper.com.ua/forms)
Добрый день друзья.





Я продолжаю собирать информацию по android программированию у себя на сайте.





Сегодня я нашел достойную статью. Которую следует прочесть как экспертам так и начинающим.





Речь сегодня пойдет о Push-notification.


<!-- more -->


Оригинал статьи [тут](http://startandroid.ru/uroki/vse-uroki-spiskom/164-urok-99-service-uvedomlenija-notifications.html).





Читаем, комментируем.









В принципе, **уведомления **– отдельная от **сервисов **тема. Но чаще всего уведомления используются именно в сервисах, поэтому я решил дать эту тему сейчас.





В андроид (версии < 3) есть строка вверху экрана. Называется она статус-бар. Туда обычно в виде иконок сваливаются различные уведомления для пользователя (новые письма, смс и прочие). Пользователь открывает статус бар – видит там чуть более подробную инфу о событии. Дальше он может либо стереть это уведомление, либо нажать на него и перейти непосредственно к событию.





В этом уроке научимся все это проделывать. Для начала разберем уведомление на логические составляющие, чтобы проще было понять как его создавать и отправлять.





**Первая часть** – то, что видно в статус-баре, когда уведомление только приходит – иконка и текст. Текст потом исчезает и остается только иконка.





**Вторая часть** – то, что мы видим, когда открываем статус бар (тянем вниз). Там уже полноценный View с иконкой и двумя текстами, т.е. более подробная информация о событии.





**Третья часть** – то, что произойдет, если мы нажмем на View из второй части. Тут обычно идет вызов Activity, где мы можем просмотреть полную информацию и обработать событие.





Кроме этого есть еще несколько возможностей, по которым совсем кратко пробежимся в конце урока.





Создадим приложение и сервис. Сервис, как будто загружает файл и посылает уведомление, по нажатию на которое будет открываться приложение и отображать имя файла.









**activity_main.xml**:


	<?xml version="1.0" encoding="utf-8"?>

	<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"

    android:layout_width="fill_parent"

    android:layout_height="fill_parent"

    android:orientation="vertical" >



    <Button

        android:id="@+id/btnStart"

        android:layout_width="wrap_content"

        android:layout_height="wrap_content"

        android:onClick="onClickStart"

        android:text="Start" >

    </Button>



    <Button

        android:id="@+id/btnStop"

        android:layout_width="wrap_content"

        android:layout_height="wrap_content"

        android:onClick="onClickStop"

        android:text="Stop" >

    </Button>



    <TextView

        android:id="@+id/tv"

        android:layout_width="fill_parent"

        android:layout_height="wrap_content"

        android:text="" >

    </TextView>



	</LinearLayout>


Кнопки для старт/стопа сервиса и TextView для отображения результата





Создаем сервис **MyService**.java и прописываем его в манифесте. В манифесте же настроим сервис так, чтобы он работал в отдельном процессе. Для этого надо в его атрибуте process написать двоеточие и какое-нить слово. В итоге у вас должен получится следующий файл манифест:



	<manifest xmlns:android="http://schemas.android.com/apk/res/android"

    package="com.example.push_notification"

    android:versionCode="1"

    android:versionName="1.0" >



    <uses-sdk

        android:minSdkVersion="8"

        android:targetSdkVersion="15" />



    <application

        android:icon="@drawable/ic_launcher"

        android:label="@string/app_name"

        android:theme="@style/AppTheme" >

        <activity

            android:name=".MainActivity"

            android:label="@string/title_activity_main" >

            <intent-filter>

                <action android:name="android.intent.action.MAIN" />



                <category android:name="android.intent.category.LAUNCHER" />

            </intent-filter>

        </activity>



        <service

            android:name="MyService"

            android:process=":myservice" >

        </service>

    </application>



	</manifest>








Система эту строку добавит к package сервиса и, тем самым, получит название нового процесса, в котором и запустит сервис





 ![](http://android-helper.com.ua/images/uploads/2012/09/L0099_020.jpg)




**MainActivity.java**:



	package com.example.push_notification;



	import android.app.Activity;

	import android.content.Intent;

	import android.os.Bundle;

	import android.text.TextUtils;

	import android.view.View;

	import android.widget.TextView;



	public class MainActivity extends Activity {



	public final static String FILE_NAME = "filename";



	/** Called when the activity is first created. */

	@Override

	public void onCreate(Bundle savedInstanceState) {

		super.onCreate(savedInstanceState);

		setContentView(R.layout.activity_main);



		TextView tv = (TextView) findViewById(R.id.tv);



		Intent intent = getIntent();



		String fileName = intent.getStringExtra(FILE_NAME);

		if (!TextUtils.isEmpty(fileName)) {

			tv.setText(fileName);

		}

	}



	public void onClickStart(View v) {

		startService(new Intent(this, MyService.class));

	}



	public void onClickStop(View v) {

		stopService(new Intent(this, MyService.class));

	}



	}








В onCreate мы вытаскиваем из intent и кладем в TextView текст. Этот текст мы будем отправлять из сервиса через уведомление.



**onClickStart** и **onClickStop** – это обработчики кнопок. Стартуют и останавливают сервис.







**MyService.java**:




	package com.example.push_notification;



	import java.util.concurrent.TimeUnit;

	import android.app.Notification;

	import android.app.NotificationManager;

	import android.app.PendingIntent;

	import android.app.Service;

	import android.content.Intent;

	import android.os.IBinder;



	public class MyService extends Service {



	NotificationManager nm;



	@Override

	public void onCreate() {

		super.onCreate();

		nm = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);

	}



	@Override

	public int onStartCommand(Intent intent, int flags, int startId) {

		try {

			TimeUnit.SECONDS.sleep(5);

		} catch (InterruptedException e) {

			e.printStackTrace();

		}

		sendNotif();

		return super.onStartCommand(intent, flags, startId);

	}



	void sendNotif() {

		// 1-я часть

		Notification notif = new Notification(R.drawable.ic_launcher, "Text in status bar", System.currentTimeMillis());



		// 3-я часть

		Intent intent = new Intent(this, MainActivity.class);

		intent.putExtra(MainActivity.FILE_NAME, "somefile");

		PendingIntent pIntent = PendingIntent.getActivity(this, 0, intent, 0);



		// 2-я часть

		notif.setLatestEventInfo(this, "Notification's title", "Notification's text", pIntent);



		// ставим флаг, чтобы уведомление пропало после нажатия

		notif.flags |= Notification.FLAG_AUTO_CANCEL;

		notif.number = 3;



		// отправляем

		nm.notify(1, notif);

	}



	@Override

	public IBinder onBind(Intent arg0) {

		return null;

	}

	}







В **onCreate **получаем менеджер уведомлений – [NotificationManager](http://developer.android.com/reference/android/app/NotificationManager.html). Он нам понадобится, чтобы отправить уведомление.





В **onStartCommand **запускаем паузу на 5 секунд (эмулируем закачку файла) и после этого отправляем уведомление. Именно из-за этой паузы мы и используем другой процесс, чтобы не тормозило основное приложение.





В **sendNotif **мы создаем и отправляем уведомление. Правда, немного в иной последовательности, что я описывал выше. Сначала первая часть, потом третья, потом вторая.





Первая часть – создаем [Notification](http://developer.android.com/reference/android/app/Notification.html). В конструкторе указываем иконку и текст, которые будут видны в статус-баре. Также мы здесь указываем время. Обычно это текущее время. Но можно указать и прошлое и будущее. По этому времени уведомления будут отсортированы в статус-баре и в его раскрытой части.





Третья часть – создаем Intent, который мы бы использовали для вызова нашего Activity. Туда помещаем имя загруженного файла. Activity его достанет и поместит в TextView. Далее мы оборачиваем этот Intent в PendingIntent, с помощью метода [getActivity](http://developer.android.com/reference/android/app/PendingIntent.html#getActivity(android.content.Context, int, android.content.Intent, int)). На вход ему передаем контекст и Intent. Второй параметр не используется (так написано в хелпе). А четвертый – это флаги, влияющие на поведение PendingIntent. Они не относятся к теме урока, мы их не используем.





Теперь этот созданный PendingIntent содержит информацию о том, что надо вызывать Activity, а также объект Intent, который для этой цели надо использовать. Это будет использовано при нажатии на уведомлении.





Вторая часть – вызываем метод [setLatestEventInfo](http://developer.android.com/reference/android/app/Notification.html#setLatestEventInfo(android.content.Context, java.lang.CharSequence, java.lang.CharSequence, android.app.PendingIntent)). Передаем на вход контекст, текст-заголовок, подробный текст и PendingIntent. Теперь, когда мы откроем статус-бар, мы увидим два этих текста (заголовок и подробный). А, когда нажмем на уведомление, система использует PendingIntent для запуска Activity.





Далее мы для созданного уведомления ставим флаг [FLAG_AUTO_CANCEL](http://developer.android.com/reference/android/app/Notification.html#FLAG_AUTO_CANCEL), чтобы оно исчезло из статус-бара после нажатия. По умолчанию оно не исчезает и продолжает висеть.





Далее вызываем метод [notify](http://developer.android.com/reference/android/app/NotificationManager.html#notify(int, android.app.Notification)) для менеджера уведомлений и передаем туда ID и созданное уведомление. ID используется, если мы хотим изменить или удалить уведомление.





Все сохраним, запустим.





![](http://android-helper.com.ua/images/uploads/2012/09/device-2012-09-05-163359.png)




Жмем **Start **и сразу закрываем приложение кнопкой **Назад**.





Проходит 5 сек и появляется уведомление (первая часть)





![](http://android-helper.com.ua/images/uploads/2012/09/device-2012-09-05-163430.png)







Жмем на уведомление.





Открывается наше приложение (третья часть) и в TextView появляется текст, переданный из сервиса.





![](http://android-helper.com.ua/images/uploads/2012/09/device-2012-09-05-163441.png)




Теперь вкратце пробежимся по остальным интересным возможностям уведомлений.





### Обновление старого или новое уведомление





Если вы создадите новое уведомление и отправите его (notify) с тем же ID, что и у уже существующего уведомления, то новое заменит старое. Таким образом, вы можете уведомления обновлять.





Если же надо показать новое уведомление, то используйте другой ID.





### Удаление





Чтобы убрать уведомление из статус-бара, используется метод [cancel](http://developer.android.com/reference/android/app/NotificationManager.html#cancel(int)) у менеджера уведомлений. На вход подается ID. Либо используйте метод [cancelAll](http://developer.android.com/reference/android/app/NotificationManager.html#cancelAll()), чтобы удалить все уведомления.





### Звук





Если хотите, чтобы уведомление появилось со стандартным звуком, добавьте флаг [Notification.DEFAULT_SOUND](http://developer.android.com/reference/android/app/Notification.html#DEFAULT_SOUND) в поле уведомления [defaults](http://developer.android.com/reference/android/app/Notification.html#defaults).





А для использования своих звуков используется поле [sound](http://developer.android.com/reference/android/app/Notification.html#sound).





Чтобы проиграть файл с **SD**:





_notif.sound = Uri.parse("file:///sdcard/notification/ringer.mp3");_





Чтобы использовать какую-либо из стандартных мелодий, используем **Content Provider**:





_notif.sound = Uri.withAppendedPath(Audio.Media.INTERNAL_CONTENT_URI, "6");_





Подробнее [здесь](http://developer.android.com/guide/topics/ui/notifiers/notifications.html#Sound).





### Вибра





Если хотите, чтобы уведомление появилось со стандартной виброй, добавьте флаг [Notification.DEFAULT_VIBRATE](http://developer.android.com/reference/android/app/Notification.html#DEFAULT_VIBRATE) в поле уведомления defaults.





А для использования своей комбинации вибры используется поле [vibrate](http://developer.android.com/reference/android/app/Notification.html#vibrate). В это поле помещается массив long-чисел. Первое – длительность паузы (в миллисекундах) перед началом вибрирования, второе – длительность вибрирования, третье – длительность паузы, четвертое – длительность вибрирования … и т.д. Т.е. создаете свою комбинацию пауз и вибрирования. И мобила при получении уведомления вам ее провибрирует.





Подробнее [здесь](http://developer.android.com/guide/topics/ui/notifiers/notifications.html#Vibration).





Для работы вибры необходимо прописать права [VIBRATE](http://developer.android.com/reference/android/Manifest.permission.html#VIBRATE) в манифесте.





### Индикатор





Если хотите, чтобы уведомление появилось с миганием индикатора, добавьте флаг [Notification.DEFAULT_LIGHTS](http://developer.android.com/reference/android/app/Notification.html#DEFAULT_LIGHTS) в поле уведомления defaults.





А для использования своей комбинации мигания индикатора используются поля





[ledARGB](http://developer.android.com/reference/android/app/Notification.html#ledARGB) – здесь задается цвет





[ledOnMS](http://developer.android.com/reference/android/app/Notification.html#ledOnMS) – время «горения»





[ledOffMS](http://developer.android.com/reference/android/app/Notification.html#ledOffMS) – время «не горения»





И в поле [flags](http://developer.android.com/reference/android/app/Notification.html#flags) надо добавить флаг [Notification.FLAG_SHOW_LIGHTS](http://developer.android.com/reference/android/app/Notification.html#FLAG_SHOW_LIGHTS).





В итоге индикатор будет мигать с заданными значениями и с заданным цветом. В хелпе написано, что не все девайсы поддерживают разные цвета. Поэтому выбранный вами цвет не гарантируется.





Подробнее [здесь](http://developer.android.com/guide/topics/ui/notifiers/notifications.html#Lights).





### Число





У Notification есть поле [number](http://developer.android.com/reference/android/app/Notification.html#number). Вы можете поместить туда число больше нуля и оно отобразится на уведомлении.





Например, при notif.number = 3 уведомление будет выглядеть так:





![](http://android-helper.com.ua/images/uploads/2012/09/L0099_070-300x210.jpg)





### Флаги





Добавляются в поле flags





[FLAG_INSISTENT](http://developer.android.com/reference/android/app/Notification.html#FLAG_INSISTENT) – звук уведомления будет повторяться, пока не откроют статус-бар





[FLAG_ONGOING_EVENT](http://developer.android.com/reference/android/app/Notification.html#FLAG_ONGOING_EVENT) – уведомление появляется не в обычной секции, а в ongoing (постоянные). Уведомления из этой секции не удаляются при нажатии кнопки очистки уведомлений.





[![](http://android-helper.com.ua/images/uploads/2012/09/L0099_080-300x210.jpg)](http://android-helper.com.ua/images/uploads/2012/09/L0099_080.jpg)





[FLAG_NO_CLEAR ](http://developer.android.com/reference/android/app/Notification.html#FLAG_NO_CLEAR)– уведомление не удалится при очистке всех уведомлений





Не очень понимаю, в чем разница между ongoing и тем, что уведомление не удалится после нажатия на кнопку очистки всех уведомлений. Но флаги такие есть, и я о них упомянул.





Надеюсь вам статья понравилась.





Ожидаю ваших комментариев!





Коды вы можете скачать [тут](http://android-helper.com.ua/forms)
Добрый день друзья.





В предыдущих записях я писал как можно отправлять сообщения с помощью встроенной системы.





Сегодня же я решил поделится опытом отправки и приема сообщений без участия стандартных программ.





Приступим.


<!-- more -->


### Отправка сообщений





## 1. Дадим права отправки сообщений



	<uses-permission android:name="android.permission.SEND_SMS"></uses-permission>


## 2. Базовая функция отправки сообщений


	SmsManager sms = SmsManager.getDefault();

	sms.sendTextMessage("1-212-555-1212", null, "Привет, Android-helper.com.ua", null, null);








## 3. Опишем Activity для отправки.





Хочу отметить, что для получения статуса сообщение мы создадим BroadcastReceiver и зарегистрируем его.




	import android.app.Activity;

	import android.app.PendingIntent;

	import android.content.BroadcastReceiver;

	import android.content.Context;

	import android.content.Intent;

	import android.content.IntentFilter;

	import android.os.Bundle;

	import android.telephony.SmsManager;

	import android.util.Log;

	import android.view.View;

	import android.view.View.OnClickListener;

	import android.widget.Button;

	import android.widget.Toast;

	public class SMSFun extends Activity {

	// Button to trigger sending the SMS

	Button aButton;

	// PendingIntent to tell the SMS app to notify us

	PendingIntent sentPI;

	// The intent action we are using

    String SENT = "SMS_SENT";

    // The BroadcastReceiver that we use to listen for the notification back

    BroadcastReceiver br;

    @Override

	public void onCreate(Bundle savedInstanceState) {

        super.onCreate(savedInstanceState);

        setContentView(R.layout.main);

        // Create the Pending Intent

	sentPI = PendingIntent.getBroadcast(this, 0,

                new Intent(SENT), 0);

	aButton = (Button) this.findViewById(R.id.Button01);

        aButton.setOnClickListener(new OnClickListener() {

	public void onClick(View v) {

	SmsManager sms = SmsManager.getDefault();

	// send the message, passing in the pending intent, sentPI

        sms.sendTextMessage("1-212-555-1212", null, "Привет android-helper.com.ua", sentPI, null);  

        registerReceiver(br, new IntentFilter(SENT));       

	}});  

          

        // In order to receive the results via the pending intent we need

	// to register a new BroadcastReceiver and pay attention to the various

	// values we could get back

	br = new BroadcastReceiver(){

                @Override

	public void onReceive(Context ctx, Intent intent) {

                    switch (getResultCode())

                    {

                        case Activity.RESULT_OK:

                            Toast.makeText(getBaseContext(), "SMS sent", 

                                    Toast.LENGTH_SHORT).show();

                            break;

                        case SmsManager.RESULT_ERROR_GENERIC_FAILURE:

                            Toast.makeText(getBaseContext(), "SMS: Generic failure", 

                                    Toast.LENGTH_SHORT).show();

                            break;

                        case SmsManager.RESULT_ERROR_NO_SERVICE:

                            Toast.makeText(getBaseContext(), "SMS: No service", 

                                    Toast.LENGTH_SHORT).show();

                            break;

                        case SmsManager.RESULT_ERROR_NULL_PDU:

                            Toast.makeText(getBaseContext(), "SMS: Null PDU", 

                                    Toast.LENGTH_SHORT).show();

                            break;

                        case SmsManager.RESULT_ERROR_RADIO_OFF:

                            Toast.makeText(getBaseContext(), "SMS: Radio off", 

                                    Toast.LENGTH_SHORT).show();

                            break;

                    }

                    unregisterReceiver(br);

                }

            };    }

	}








###  Получение сообщений 





## 1. Права доступа







	<uses-permission android:name="android.permission.RECEIVE_SMS"></uses-permission>








## 2. Для того что бы получать сообщения, нужно создать BroadcastReceiver







	<receiver android:name=".SMSFunReceive">

     <intent-filter>

                <action android:name=

                   "android.provider.Telephony.SMS_RECEIVED" />

     </intent-filter>

	</receiver>

**Java**

	import android.content.BroadcastReceiver;

	import android.content.Context;

	import android.content.Intent;

	import android.os.Bundle;

	import android.telephony.SmsMessage;

	import android.util.Log;

	// This will run when an SMS message comes in.

	// We can see if we want to do something based upon the message

	// Perhaps launch an activity

	public class SMSFunReceive extends BroadcastReceiver 

	{

	@Override

	public void onReceive(Context ctx, Intent intent) 

	{

	Bundle bundle = intent.getExtras();        

	Object[] pdus = (Object[]) bundle.get("pdus");

	SmsMessage[] messages = new SmsMessage[pdus.length];

        

	for (int i = 0; i < messages.length; i++)
	{

	messages[i] = SmsMessage.createFromPdu((byte[])pdus[i]);

        

	Log.v("SMSFun","Body: " + messages[i].getDisplayMessageBody());

	Log.v("SMSFun","Address: " + messages[i].getDisplayOriginatingAddress());

	//If say we wanted to do something based on who sent it

	if (messages[i].getDisplayOriginatingAddress().contains("2125551212"))

         {

	// we could launch an activity and pass the data

	Intent newintent = new Intent(ctx, SecretMessage.class);
	newintent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);         // Pass in data

	newintent.putExtra("address", messages[i].getDisplayOriginatingAddress());

	newintent.putExtra("message", messages[i].getDisplayMessageBody());

	ctx.startActivity(newintent);         

	}

	}

	}

	}








## 5. Финальный аккорд. Создадим Activity для отображения сообщения.


	import android.app.Activity;

	import android.os.Bundle;

	import android.widget.TextView;

	public class SecretMessage extends Activity {

    public void onCreate(Bundle savedInstanceState) {

        super.onCreate(savedInstanceState);

        setContentView(R.layout.secret);

        // Get the extra data

        Bundle extras = getIntent().getExtras(); 

        String address = extras.getString("address");

        String message = extras.getString("message");

        

        TextView addresstv = (TextView) findViewById(R.id.addresstv);

        TextView messagetv = (TextView) findViewById(R.id.messagetv);

        

        messagetv.setText(message);

        addresstv.setText(address);

    }

	}



**xml**

	<?xml version="1.0" encoding="utf-8"?>

	<LinearLayout 
		xmlns:android="http://schemas.android.com/apk/res/android" 
		android:layout_width="wrap_content" 
		android:layout_height="wrap_content">

		<TextView 
			android:layout_height="wrap_content" 
			android:id="@+id/addresstv" 
			android:text="address" 
			android:layout_width="fill_parent"
			android:layout_gravity="fill_horizontal" />

		<TextView 
			android:layout_height="wrap_content" 
			android:id="@+id/messagetv" 
			android:text="message" 
			android:layout_width="fill_parent" 
			android:layout_gravity="fill_horizontal" />

	</LinearLayout>

Если понравилась статья, нажми рассказать друзьям.


Полный код программы [тут](http://android-helper.com.ua/forms).


Добрый день всем.





В предыдущем посте я писал о возможности отправки писем с вашего приложения.





Сегодня я бы хотел написать, как же можно отправлять SMS с вашего приложения.


 <!-- more -->


Вот код:


	Intent smsIntent = new Intent(Intent.ACTION_VIEW);

	smsIntent.setType("vnd.android-dir/mms-sms");

	smsIntent.putExtra("address", "12125551212,121212121212"); // C версии 2.2 можно отправлять множеству получателей

	smsIntent.putExtra("sms_body","Body of Message");

	startActivity(smsIntent);



Несколько дней наз столкнулся с задачей отправки почты с приложения.





И как оказалось и тут google позаботился о нас.


 <!-- more -->


Пример кода:







	Intent it = new Intent(Intent.ACTION_SEND);   

	it.putExtra(Intent.EXTRA_EMAIL, "me@abc.com");   

	it.putExtra(Intent.EXTRA_TEXT, "The email body text");   

	it.setType("text/plain");   

	context.startActivity(Intent.createChooser(it, "Choose Email Client")); 










После этого будет вызван диалог выбора почтового клиента.


Добрый день друзья.





Как и обещал выкладываю информацию о Fragments.





Пошарил немного по Интернету и нашел увлекательную статью на [Habrahabr.ru](http://habrahabr.ru/post/113196/)





Поэтому было решено вставить ее сюда полностью + со своей доработкой


<!-- more -->


_В Android 3.0 введена новая концепция фрагментов, которая служит для упрощения работы с интерфейсом под разные размеры экранов. Данный топик является переводом статьи с android-developers.blogspot.com. В ней рассмотрены преимущества фрагментов, а также приведен простой, но законченный пример приложения, работающего по этому принципу._





Важная цель Android 3.0 — упростить написание программ, которые должны масштабироваться в зависимости от размеров экрана. Для этого в платформе Android уже доступны следующие средства:








  * С самого начала, UI-фреймворк был спроектирован для использования layout managers, которые позволяют описывать интерфейс так, чтобы он «подгонялся» к размерам. Примером этого является ListView, высота которого изменяется в зависимости от размера экрана, который варьируется между соотношениями QVGA, HVGA, and WVGA.



  * В Android 1.6 была введена новая концепция плотности экрана, позволяющая приложениям легче масштабировать размеры между разными разрешениями, в то время как экраны имеют почти один и тот же физический размер. Разработчики незамедлительно начали использовать эту особенность, когда были введены телефоны с высоким разрешением, такие как Droid.



  * Также в Android 1.6 разработчикам стали доступны размеры экрана, при помощи их классификации: «small» для соотношения QVGA, «normal» для HVGA и WVGA, и «large» для более больших экранов. Разработчики могут использовать систему ресурсов для выбора между различными layout'ами, в зависимости от размера экрана






Комбинация layout managers и выбора различных ресурсов представляет долгий путь для создания масштабируемого интерфейса. В итоге многие приложения для хэндсетов не используют специальный интерфейс для планшетов, работающих под Honeycomb.





#### Введение во фрагменты





В Android 3.0 введена поддержка новых классов, которые помогают приложениям масштабировать их интерфейс, называемых фрагментами (Fragment). Фрагмент — это независимый компонент со своим интерфейсом и жизненным циклом; он может быть неоднократно использован в разных частях пользовательского интерфейса, в зависимости от нужного UI потока для определенного устройства или экрана.





В некотором смысле можно рассматривать фрагмент как мини-Activity, хотя он не может запускаться независимо и должен размещаться внутри Activity. На самом деле введение Fragment API дало нам возможность решать многие проблемы, с которыми сталкивались разработчики, при работе с Activity, так как полезность фрагмента простирается далеко за пределы обычных настроек для разных разрешений экрана:








  * Activity, вложенные через ActivityGroup были хорошей идеей, однако с ними было не так просто работать, так как Activity изначально разработан как независимый компонент. Fragment API — намного лучшее решение для этого, его стоит рассматривать как замену для вложенных Activity.



  * Сохранение данных для экземпляров Activity может быть выполнено через Activity.onRetainNonConfigurationInstance(), но это неуклюже само по себе и не очевидно. Фрагменты заменяют этот механизм, позволяя сохранять целый экземпляр фрагмента простой установкой флага.



  * Одна из конкретизаций фрагмента — DialogFragment, она упрощает отображение диалога, который управляется как часть жизненного цикла Activity. Он заменяет API Activity, используемые для управления диалогами.



  * Еще одна конкретизация фрагмента — ListFragment, она упрощает отображение списка данных. ListFragment похож на ListActivity (с несколькими дополнительными особенностями), его использование упростит отображение данных в списке.



  * Информация по всем фрагментам, прикрепленным к Activity, сохраняется фреймворком в сохраненное состояние той же Activity и восстанавливается при рестарте. Таким образом уменьшается количество сохраняемых состояний.



  * У фреймворка есть встроенная поддержка для управления стеком фрагментов, она упрощает поддержку поведения кнопки BACK внутри Activity, причем это поведение интегрируется с существующим стеком Activities.






#### Приступая к работе





Вот простой, но полный пример реализации множественных потоков UI, с помощью фрагментов. Начнем с проектирования ландшафтного layout'a, содержащего список элементов слева и данные по ним справа. Так выглядит нужный нам layout:





![](http://android-helper.com.ua/images/uploads/2012/07/device-fragment-land_new.png)




Код для Activity не особенно интересен, он просто вызывает setContentView() со следующим макетом:







	<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"

    android:layout_width="match_parent"

    android:layout_height="match_parent"

    android:orientation="horizontal" >



    <fragment

        android:id="@+id/titles"

        android:layout_width="0px"

        android:layout_height="match_parent"

        android:layout_weight="1"

        class="com.example.androidhelper.fragments.TitlesFragment" />



    <FrameLayout

        android:id="@+id/details"

        android:layout_width="0px"

        android:layout_height="match_parent"

        android:layout_weight="1" />



	</LinearLayout>


Вы можете заметить первую особенность: тег

	<fragment>

позволяет устанавливать фрагмент в вашу иерархию интерфейса. Вышеописанный фрагмент наследует свойства ListFragment, который отображает данные по элементу в текущем месте, или в отдельном Activity, в зависимости от layout'a. Обратите внимание на то, как сохраняются изменения в состоянии фрагмента.

	public class TitlesFragment extends ListFragment {

	boolean mDualPane;

	int mCurCheckPosition = 0;



	@Override

	public void onActivityCreated(Bundle savedState) {

		super.onActivityCreated(savedState);



		// Populate list with our static array of titles.

		setListAdapter(new ArrayAdapter<String>(getActivity(), R.layout.list_item, Shakespeare.TITLES));



		// Check to see if we have a frame in which to embed the details

		// fragment directly in the containing UI.

		View detailsFrame = getActivity().findViewById(R.id.details);

		mDualPane = detailsFrame != null && detailsFrame.getVisibility() == View.VISIBLE;



		if (savedState != null) {

			// Restore last state for checked position.

			mCurCheckPosition = savedState.getInt("curChoice", 0);

		}



		if (mDualPane) {

			// In dual-pane mode, list view highlights selected item.

			getListView().setChoiceMode(ListView.CHOICE_MODE_SINGLE);

			// Make sure our UI is in the correct state.

			showDetails(mCurCheckPosition);

		}

	}



	@Override

	public void onSaveInstanceState(Bundle outState) {

		super.onSaveInstanceState(outState);

		outState.putInt("curChoice", mCurCheckPosition);

	}



	@Override

	public void onListItemClick(ListView l, View v, int pos, long id) {

		showDetails(pos);

	}



	/**

	 * Helper function to show the details of a selected item, either by displaying a fragment in-place in the current

	 * UI, or starting a whole new activity in which it is displayed.

	 */

	void showDetails(int index) {

		mCurCheckPosition = index;



		if (mDualPane) {

			// We can display everything in-place with fragments.

			// Have the list highlight this item and show the data.

			getListView().setItemChecked(index, true);



			// Check what fragment is shown, replace if needed.

			DetailsFragment details = (DetailsFragment) getFragmentManager().findFragmentById(R.id.details);

			if (details == null || details.getShownIndex() != index) {

				// Make new fragment to show this selection.

				details = DetailsFragment.newInstance(index);



				// Execute a transaction, replacing any existing

				// fragment with this one inside the frame.

				FragmentTransaction ft = getFragmentManager().beginTransaction();

				ft.replace(R.id.details, details);

				ft.setTransition(FragmentTransaction.TRANSIT_FRAGMENT_FADE);

				ft.commit();

			}



		} else {

			// Otherwise we need to launch a new activity to display

			// the dialog fragment with selected text.

			Intent intent = new Intent();

			intent.setClass(getActivity(), DetailsActivity.class);

			intent.putExtra("index", index);

			startActivity(intent);

		}

	}

	}


Также необходимо реализовать DetailsFragment, который будет отображать данные по элементу в обычном TextView.

	public class DetailsFragment extends Fragment {

	/**

	 * Create a new instance of DetailsFragment, initialized to show the text at 'index'.

	 */

	public static DetailsFragment newInstance(int index) {

		DetailsFragment f = new DetailsFragment();



		// Supply index input as an argument.

		Bundle args = new Bundle();

		args.putInt("index", index);

		f.setArguments(args);



		return f;

	}



	public int getShownIndex() {

		return getArguments().getInt("index", 0);

	}



	@Override

	public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {

		if (container == null) {

			// Currently in a layout without a container, so no

			// reason to create our view.

			return null;

		}



		ScrollView scroller = new ScrollView(getActivity());

		TextView text = new TextView(getActivity());

		int padding = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 4, getActivity().getResources()

				.getDisplayMetrics());

		text.setPadding(padding, padding, padding, padding);

		scroller.addView(text);

		text.setText(Shakespeare.DIALOGUE[getShownIndex()]);

		return scroller;

	}

	}

Настало время для добавления еще одного потока UI в наше приложение. Когда экран находится в портретном режиме, то недостаточно места для отображения двух фрагментов бок о бок. То есть мы хотим, чтобы отображался только список:





![](http://android-helper.com.ua/images/uploads/2012/07/device-fragment-port1_new.png)





Напишем новый layout для портретной ориентации:


	<?xml version="1.0" encoding="utf-8"?>

	<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"

    android:layout_width="match_parent"

    android:layout_height="match_parent" >



    <fragment

        android:id="@+id/titles"

        android:layout_width="match_parent"

        android:layout_height="match_parent"

        class="com.example.androidhelper.fragments.TitlesFragment" />



	</FrameLayout>



Теперь у нас нет контейнера для отображения данных для TitlesFragment, отображается только список. При нажатии на элемент списка теперь нужно вызывать отдельное Activity, в котором и будут отображаться данные:





![](http://android-helper.com.ua/images/uploads/2012/07/device-fragment-port2_new.png)





Теперь, всё что от нас требуется — использовать уже готовый DetailsFragment:
	
	public class DetailsActivity extends FragmentActivity {



	@Override

	protected void onCreate(Bundle savedInstanceState) {

		super.onCreate(savedInstanceState);



		if (getResources().getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPE) {

			// If the screen is now in landscape mode, we can show the

			// dialog in-line so we don't need this activity.

			finish();

			return;

		}



		if (savedInstanceState == null) {

			// During initial setup, plug in the details fragment.

			DetailsFragment details = new DetailsFragment();

			details.setArguments(getIntent().getExtras());

			getSupportFragmentManager().beginTransaction().add(android.R.id.content, details).commit();

		}

	}



	}



Соединив Activity, мы получаем полностью работающий пример приложения, использующего радикальное изменение UI потока, основанное на том, какая конфигурация используется в данный момент. Также приложение автоматически подгоняется под требования размеров экрана при смене конфигурации.





Этот пример иллюстрирует всего лишь один способ использования фрагментов для подгонки вашего UI. В зависимости от дизайна, вы можете предпочесть другие. Например, вы можете поместить всё ваше приложение в одно Activity, в котором будет изменяться структура фрагментов.





Как обычно, больше информации можно найти в документации по SDK. Также можно найти примеры в ApiDemos.





#### Фрагментация для всех





Fragment API будет полезен для разработчиков, начинающих работать с приложениями, ориентированными на планшеты, которые спроектированы под Android 3.0, во многих случаях, связанных с большим экраном. Также использование фрагментов должно сделать проще настройку UI для приложений под новые устройства на Android, например, телевизоры.





Однако, сейчас Fragment API будет наиболее востребован для улучшения интерфейса существующих приложений для телефонов под планшеты.





Также планируется сделать статическую библиотеку для использования Fragment API (_Ура!!!_), чтобы использовать вышеописанный метод на ранних версиях Android. На самом деле, весь код в примере использует как раз статическую библиотеку классов, причем выполняется на Android 2.3 (можете сравнить с примерами в Android 3.0 SDK, они почти не отличаются). Наша цель — сделать эти API как можно более похожими, чтобы вы могли начать работать с ними сейчас, независимо от того, когда вы перейдете на Android 3.0.





Пока нет точной даты, когда библиотека будет доступна, но она точно будет скоро. Пока вы можете начать работать с фрагментами на Android 3.0.





#### Дополнения





Это была первая статья которая описывала фрагменты. На данный момент выпущена библиотека с обратной совместимостью (см. мои предыдущие посты) до версии андроид 1.6.





Для подключения фрагментов в приложения с обратной совместимостью вам нужно сделать следующее:





Наследоватся не от Activity, а от FragmentActivity. Это самое главное требование.





Пример как всегда вы сможете скачать [тут](http://android-helper.com.ua/forms/).
Добрый день друзья.





В предыдущих статьях я писал о использовании [Swipe](http://android-helper.com.ua/%D1%81%D0%BB%D0%B0%D0%B9%D0%B4%D0%B8%D0%BD%D0%B3-%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%BE%D0%B2-%D1%81-%D0%BF%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%D1%8E-viewpager/) и своих [Tabs](http://android-helper.com.ua/%D0%BA%D0%B0%D0%BA-%D1%81%D0%B4%D0%B5%D0%BB%D0%B0%D1%82%D1%8C-%D1%81%D0%B2%D0%BE%D0%B8-tabs-%D0%B2-android/)





Тогда у меня возник вопрос, как же их можно объединить. 





![](http://android-helper.com.ua/images/uploads/2012/07/device-2012-07-17-084758.png)


<!-- more -->


### 1. Подготовка проекта





Перед тем как приступить к реализации этой задачи, нам нужно подключить библиотеку обратной совместимости.





Как это сделать, вы можете прочесть [тут](http://android-helper.com.ua/%D1%81%D0%BB%D0%B0%D0%B9%D0%B4%D0%B8%D0%BD%D0%B3-%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%BE%D0%B2-%D1%81-%D0%BF%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%D1%8E-viewpager/) (предварительная настройка).





### 2. Подготовка ресурсов





Откройте файл main.xml и пропишите туда следующий код:

	<?xml version="1.0" encoding="utf-8"?>

	<TabHost xmlns:android="http://schemas.android.com/apk/res/android"

	android:id="@android:id/tabhost"

	android:layout_width="match_parent"

	android:layout_height="match_parent" >



		<LinearLayout

		android:layout_width="match_parent"

		android:layout_height="match_parent"

		android:orientation="vertical" >



		<FrameLayout

			android:id="@android:id/tabcontent"

			android:layout_width="0dp"

			android:layout_height="0dp"

			android:layout_weight="0" />



		<android.support.v4.view.ViewPager

			android:id="@+id/pager"

			android:layout_width="match_parent"

			android:layout_height="0dp"

			android:layout_weight="1" />



		<TabWidget

			android:id="@android:id/tabs"

			android:layout_width="match_parent"

			android:layout_height="wrap_content"

			android:layout_weight="0"

			android:orientation="horizontal" />

	</LinearLayout>



	</TabHost>


### 3. Подготовка Activity





Для реализации данного примера мы будем наследоваться не от Activity, а от **FragmentActivity** (о фрагментах мы поговорим в следующей статье):



	public class MainActivity extends FragmentActivity 
  




В метод onCreate пишем следующее:



	private TabHost mTabHost;

	private ViewPager mViewPager;

	private TabsAdapter mTabsAdapter;



	@Override

	public void onCreate(final Bundle savedInstanceState) {

		super.onCreate(savedInstanceState);

		setContentView(R.layout.activity_main);

		mTabHost = (TabHost) findViewById(android.R.id.tabhost);

		mTabHost.setup();



		mViewPager = (ViewPager) findViewById(R.id.pager);



		mTabsAdapter = new TabsAdapter(this, mTabHost, mViewPager);



		mTabsAdapter.addTab(mTabHost.newTabSpec("simple").setIndicator("Android"), AndroidFragment.class, null);

		mTabsAdapter.addTab(mTabHost.newTabSpec("contacts").setIndicator("IOs"), IOsFragment.class, null);

		mTabsAdapter.addTab(mTabHost.newTabSpec("custom").setIndicator("Windows"), WindowsFragment.class, null);

		mTabsAdapter.addTab(mTabHost.newTabSpec("throttle").setIndicator("DOS"), DOSFragment.class, null);



		if (savedInstanceState != null) {

			mTabHost.setCurrentTabByTag(savedInstanceState.getString("tab"));

		}

	}


  




### 4. Реализация Adapter





Вот тут начинается самое интересное.





Создаем adapter который у нас будет унаследован от **FragmentPagerAdapter**, а также для обработки нажатий на Tabs мы подпишемся на обработчик событий **TabHost.OnTabChangeListener** и для скролинга страниц также подписываемся на **ViewPager.OnPageChangeListener**





Полный код вы можете увидеть ниже:



	public static class TabsAdapter extends FragmentPagerAdapter implements TabHost.OnTabChangeListener,

			ViewPager.OnPageChangeListener {

		private final Context mContext;

		private final TabHost mTabHost;

		private final ViewPager mViewPager;

		private final ArrayList<TabInfo> mTabs = new ArrayList<TabInfo>();



		static final class TabInfo {

			private final String tag;

			private final Class<?> clss;

			private final Bundle args;



			TabInfo(final String _tag, final Class<?> _class, final Bundle _args) {

				tag = _tag;

				clss = _class;

				args = _args;

			}

		}



		static class DummyTabFactory implements TabHost.TabContentFactory {

			private final Context mContext;



			public DummyTabFactory(final Context context) {

				mContext = context;

			}



			@Override

			public View createTabContent(final String tag) {

				View v = new View(mContext);

				v.setMinimumWidth(0);

				v.setMinimumHeight(0);

				return v;

			}

		}



		public TabsAdapter(final FragmentActivity activity, final TabHost tabHost, final ViewPager pager) {

			super(activity.getSupportFragmentManager());

			mContext = activity;

			mTabHost = tabHost;

			mViewPager = pager;

			mTabHost.setOnTabChangedListener(this);

			mViewPager.setAdapter(this);

			mViewPager.setOnPageChangeListener(this);

		}



		public void addTab(final TabHost.TabSpec tabSpec, final Class<?> clss, final Bundle args) {

			tabSpec.setContent(new DummyTabFactory(mContext));

			String tag = tabSpec.getTag();



			TabInfo info = new TabInfo(tag, clss, args);

			mTabs.add(info);

			mTabHost.addTab(tabSpec);

			notifyDataSetChanged();

		}



		@Override

		public int getCount() {

			return mTabs.size();

		}



		@Override

		public Fragment getItem(final int position) {

			TabInfo info = mTabs.get(position);

			return Fragment.instantiate(mContext, info.clss.getName(), info.args);

		}



		@Override

		public void onTabChanged(final String tabId) {

			int position = mTabHost.getCurrentTab();

			mViewPager.setCurrentItem(position);

		}



		@Override

		public void onPageScrolled(final int position, final float positionOffset, final int positionOffsetPixels) {

		}



		@Override

		public void onPageSelected(final int position) {

			// Unfortunately when TabHost changes the current tab, it kindly

			// also takes care of putting focus on it when not in touch mode.

			// The jerk.

			// This hack tries to prevent this from pulling focus out of our

			// ViewPager.

			TabWidget widget = mTabHost.getTabWidget();

			int oldFocusability = widget.getDescendantFocusability();

			widget.setDescendantFocusability(ViewGroup.FOCUS_BLOCK_DESCENDANTS);

			mTabHost.setCurrentTab(position);

			widget.setDescendantFocusability(oldFocusability);

		}



		@Override

		public void onPageScrollStateChanged(final int state) {

		}

	}
 
  




### 5. Финальная стадия





Из пункта 2 видно что у нас есть 4 новых фрагмента. Так давайте их создадим.





**AndroidFragment**:




	import android.os.Bundle;

	import android.support.v4.app.Fragment;

	import android.view.LayoutInflater;

	import android.view.View;

	import android.view.ViewGroup;



	public class AndroidFragment extends Fragment {



	@Override

	public View onCreateView(final LayoutInflater inflater, final ViewGroup container, final Bundle savedInstanceState) {

		View view = inflater.inflate(R.layout.android_fragment, container, false);

		return view;

	}



	}




**IOsFragment**:



	public class IOsFragment extends Fragment {



	@Override

	public View onCreateView(final LayoutInflater inflater, final ViewGroup container, final Bundle savedInstanceState) {

		View view = inflater.inflate(R.layout.ios_fragment, container, false);

		return view;

	}



	}

  




**WindowsFragment:**



	public class WindowsFragment extends Fragment {



	@Override

	public View onCreateView(final LayoutInflater inflater, final ViewGroup container, final Bundle savedInstanceState) {

		View view = inflater.inflate(R.layout.windows_fragment, container, false);

		return view;

	}



	}

 
  




**DOSFragment:**



	public class DOSFragment extends Fragment {



	@Override

	public View onCreateView(final LayoutInflater inflater, final ViewGroup container, final Bundle savedInstanceState) {

		View view = inflater.inflate(R.layout.dos_fragment, container, false);

		return view;

	}



	}
  
  




Теперь нам нужно создать еще 4 xml файла которые мы используем в фрагментах





**android_fragment.xml**




	<?xml version="1.0" encoding="utf-8"?>
	
	<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"

	android:layout_width="match_parent"

	android:layout_height="match_parent"

	android:orientation="vertical" >



	<TextView

		android:id="@+id/textView1"

		android:layout_width="wrap_content"

		android:layout_height="wrap_content"

		android:text="Android" />



	</LinearLayout>

  
  




**dos_fragment.xml**



	<?xml version="1.0" encoding="utf-8"?>

	<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"

	android:layout_width="match_parent"

	android:layout_height="match_parent"

	android:orientation="vertical" >



	<TextView

		android:id="@+id/textView1"

		android:layout_width="wrap_content"

		android:layout_height="wrap_content"

		android:text="DOS" />



	</LinearLayout>


  




**ios_fragment.xml**




	<?xml version="1.0" encoding="utf-8"?>

	<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"

	android:layout_width="match_parent"

	android:layout_height="match_parent"

	android:orientation="vertical" >



	<TextView

		android:id="@+id/textView1"

		android:layout_width="wrap_content"

		android:layout_height="wrap_content"

		android:text="IOs" />



	</LinearLayout>
  
  




**windows_fragment.xml**



	<?xml version="1.0" encoding="utf-8"?>

	<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"

	android:layout_width="match_parent"

	android:layout_height="match_parent"

	android:orientation="vertical" >



	<TextView

		android:id="@+id/textView1"

		android:layout_width="wrap_content"

		android:layout_height="wrap_content"

		android:text="Windows" />



	</LinearLayout>

  




Ну вот и все. 





Коды можно скачать [тут](http://android-helper.com.ua/forms/).
Добрый день друзья.





Сегодня я бы хотел поделится с вами информацией о создании и использовании своих Tabs.





![](http://android-helper.com.ua/images/uploads/2012/07/custom_tabs_view.png)




<!-- more -->
  






### 1. Создадим layout





  






Самое первое что нужно сделать, это открыть main.xml и добавить туда TabHost и TabWidget







	<?xml version="1.0" encoding="utf-8"?>

	<TabHost xmlns:android="http://schemas.android.com/apk/res/android"

	android:id="@android:id/tabhost" android:layout_width="fill_parent"

	android:layout_height="fill_parent">

	<LinearLayout android:orientation="vertical"

		android:layout_width="fill_parent" android:layout_height="fill_parent">

		<TabWidget android:id="@android:id/tabs"

			android:layout_width="fill_parent" android:layout_height="wrap_content" />

		<FrameLayout android:id="@android:id/tabcontent"

			android:layout_width="fill_parent" android:layout_height="fill_parent">

		</FrameLayout>

	</LinearLayout>

	</TabHost>








### 2. Пишем код в Activity





  






У нас есть main.xml , теперь нам нужно добавить код для привязки нашего activity с нашим файлом







	setContentView(R.layout.main);

	mTabHost = (TabHost) findViewById(android.R.id.tabhost);









Ну вот после этого мы можем добавлять tabs на наше activty







	@Override

	public void onCreate(Bundle savedInstanceState) {

	super.onCreate(savedInstanceState);

	setContentView(R.layout.main);

	mTabHost = (TabHost) findViewById(android.R.id.tabhost);

	setupTab(new TextView(this), "Tab 1");

	setupTab(new TextView(this), "Tab 2");

	setupTab(new TextView(this), "Tab 3");

	}

	private void setupTab(final View view, final String tag) {

	View tabview = createTabView(mTabHost.getContext(), tag);

        TabSpec setContent = mTabHost.newTabSpec(tag).setIndicator(tabview).setContent(new TabContentFactory() {

		public View createTabContent(String tag) {return view;}

	});

	mTabHost.addTab(setContent);

	}



	private static View createTabView(final Context context, final String text) {

	View view = LayoutInflater.from(context).inflate(R.layout.tabs_bg, null);

	TextView tv = (TextView) view.findViewById(R.id.tabsText);

	tv.setText(text);

	return view;

	}








### 3. Создаем свой tabs layout





Создадим новый xml файл и назовем его tabs_bg.xml. Этот файл как раз и будет служить заполнением нашего tab.





На него можно добавлять любые элементы.








	<?xml version="1.0" encoding="utf-8"?>

	<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"

	android:id="@+id/tabsLayout" android:layout_width="fill_parent"

	android:layout_height="fill_parent"

	android:padding="10dip" android:gravity="center" android:orientation="vertical">



	<TextView android:id="@+id/tabsText" android:layout_width="wrap_content"

		android:layout_height="wrap_content" android:text="Title"

		android:textSize="15dip" />

	</LinearLayout>








### 4. Меняем вид и поведение





Создадим еще несколько файлов tab_text_selector.xml и tab_bg_selector.xml (их нужно создать в папке layout), а также tab_bg_selected.xml и tab_bg_unselected.xml (эти 2 файла создаем в папке drawable). Эти файлы служат для того что при изменении статуса tab с активного на неактивный соответственно меняется его внешний вид.





**tab_bg_selected.xml:**







	<?xml version="1.0" encoding="utf-8"?>

	<shape xmlns:android="http://schemas.android.com/apk/res/android"

	android:shape="rectangle">

	<gradient android:startColor="#A8A8A8" android:centerColor="#7F7F7F"

		android:endColor="#696969" android:angle="-90" />

	</shape>







**tab_bg_unselected.xml:**







	<?xml version="1.0" encoding="utf-8"?>

	<shape xmlns:android="http://schemas.android.com/apk/res/android"

	android:shape="rectangle">

	<gradient android:startColor="#5C5C5C" android:centerColor="#424242"

		android:endColor="#222222" android:angle="-90" />

	</shape>







 **tab_text_selector.xml:**







	<?xml version="1.0" encoding="utf-8"?>

	<selector xmlns:android="http://schemas.android.com/apk/res/android">

    <item android:state_selected="true" android:color="@android:color/white" />

    <item android:state_focused="true" android:color="@android:color/white" />

    <item android:state_pressed="true" android:color="@android:color/white" />

    <item android:color="#f8f8f8" />

	</selector>








**tab_bg_selector.xml:**







	<?xml version="1.0" encoding="utf-8"?>

	<selector xmlns:android="http://schemas.android.com/apk/res/android">

    <!--  Active tab -->

	<item android:state_selected="true" android:state_focused="false"

		android:state_pressed="false" android:drawable="@drawable/tab_bg_selected" />

	<!--  Inactive tab -->

	<item android:state_selected="false" android:state_focused="false"

		android:state_pressed="false" android:drawable="@drawable/tab_bg_unselected" />

	<!--  Pressed tab -->

	<item android:state_pressed="true" android:drawable="@android:color/transparent" />

	<!--  Selected tab (using d-pad) -->

	<item android:state_focused="true" android:state_selected="true"

		android:state_pressed="false" android:drawable="@android:color/transparent" />

	</selector>







И теперь поменяем внешний вид нашего tabs_bg.xml









	<?xml version="1.0" encoding="utf-8"?>

	<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"

	android:id="@+id/tabsLayout" android:layout_width="fill_parent"

	android:layout_height="fill_parent" android:background="@drawable/tab_bg_selector"

	android:padding="10dip" android:gravity="center" android:orientation="vertical">



	<TextView android:id="@+id/tabsText" android:layout_width="wrap_content"

		android:layout_height="wrap_content" android:text="Title"

		android:textSize="15dip" android:textColor="@drawable/tab_text_selector" />

	</LinearLayout>









### 5. Заключительная стадия 





  






В заключительной стадии нам нужно добавить разделитель между tabs.





Этот код нужно добавить пере вызовом функции setupTab.








	mTabHost.getTabWidget().setDividerDrawable(R.drawable.tab_divider);









Ну вот и все.





В следующей статье я продолжу тему своих tabs. И с нее вы сможете узнать как скомпоновать tabs и swipe экранов.




Сегодня мы продолжим цикл изучения ScrollView.





Из прошлых уроков вы узнали, что в ScrollView можно  добавить текст.





Сегодня же мы добавим кнопки :).


<!-- more -->


main.xml:








    <?xml version="1.0" encoding="utf-8"?>

    <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"

        android:id="@+id/LinearLayout01"

        android:layout_width="fill_parent"

        android:layout_height="fill_parent" >



        <ScrollView

            android:id="@+id/ScrollView01"

            android:layout_width="fill_parent"

            android:layout_height="110px" >



            <LinearLayout

                android:id="@+id/LinearLayout02"

                android:layout_width="wrap_content"

                android:layout_height="30px"

                android:orientation="vertical" >



                <Button

                    android:id="@+id/Button01"

                    android:layout_width="wrap_content"

                    android:layout_height="wrap_content"

                    android:text="1" />



                <Button

                    android:id="@+id/Button02"

                    android:layout_width="wrap_content"

                    android:layout_height="wrap_content"

                    android:text="2" />



                <Button

                    android:id="@+id/Button03"

                    android:layout_width="wrap_content"

                    android:layout_height="wrap_content"

                    android:text="3" />

            </LinearLayout>

        </ScrollView>



    </LinearLayout>








Результат:





 [![](http://android-helper.com.ua/images/uploads/2012/05/device-2012-05-29-105334.png)](http://android-helper.com.ua/images/uploads/2012/05/device-2012-05-29-105334.png)
Сегодня мы поговорим о ListView.





Этот елемент служит для того что бы показывать разного рода елементы в списке с возможностью прокрутки.





Меньше слов, больше кода.



<!-- more -->

main.xml:









	<?xml version="1.0" encoding="utf-8"?>

	<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"

    	android:id="@+id/LinearLayout01"

    	android:layout_width="fill_parent"

    	android:layout_height="fill_parent" >



    <ListView

        android:id="@+id/ListView01"

        android:layout_width="wrap_content"

        android:layout_height="wrap_content" />



	</LinearLayout>

	







Java код:









	package com.in.androidhelper;



	import android.app.Activity;

	import android.os.Bundle;

	import android.widget.ArrayAdapter;

	import android.widget.ListView;



	public class Example1Activity extends Activity {

		private ListView lv1;

		private final String lv_arr[] = { "Android", "iPhone", "BlackBerry", "Android Helper :)" };



		@Override

		public void onCreate(Bundle icicle) {

			super.onCreate(icicle);

			setContentView(R.layout.main);

			lv1 = (ListView) findViewById(R.id.ListView01);

			// С использованием setAdpater mетода в listview вы добавляете строки в

			// список

			lv1.setAdapter(new ArrayAdapter<String>(this, android.R.layout.simple_list_item_1, lv_arr));

		}

	}









Скриншоты:





![](http://android-helper.com.ua/images/uploads/2012/05/device-2012-05-23-191439.png)Добрый день друзья.





Сегодня мы поговорим о таком android елементе как ScrollView.





И не только поговорим, я вам покажу как можно большой текст двигать в маленьком окне.


<!-- more -->


Откроем файл main.xml





И заменим:








	<TextView

        android:layout_width="fill_parent"

        android:layout_height="wrap_content"

        android:text="Привет Android" />









на:








	<ScrollView

        android:id="@+id/ScrollView01"

        android:layout_width="fill_parent"

        android:layout_height="70px" >



        <TextView

            android:id="@+id/TEXT_VIEW"

            android:layout_width="wrap_content"

            android:layout_height="wrap_content"

            android:text="Второе задание мы с вами успешно прошли.

	Если у вас есть вопросы вы всегда можете задать их на сайте либо в соц. сетях.

	Подписывайтесь на рассылку и получайте только самое свежее.

	Планируется проведение тренинга по Android. Если вы хотите повысить свои знания тогда вам к нам  .

	Все вопросы задавайте в соц. сетях."

            android:textSize="17sp" />

    </ScrollView>









И вот что у нас получилось:





![](http://android-helper.com.ua/images/uploads/2012/05/device-2012-05-23-182038.png)
![](http://android-helper.com.ua/images/uploads/2012/05/device-2012-05-23-182049.png)
Добрый день уважаемые читатели.





Сегодня мы с вами напишем первое приложение для Android.


<!-- more -->


1. Первое что нужно сделать, это выкачать последний Android SDK.





У себя я использую версию 2.2 и 4.0.3. (Скачать вы их можете с SDK Android Manager)





![](http://android-helper.com.ua/images/uploads/2012/05/AndroidSDK.jpg)





2. Указать в Eclipse где у вас android sdk





Window - Preference





![](http://android-helper.com.ua/images/uploads/2012/05/android1.jpg)





 





После того как все это сделано, мы можем приступить к созданию своего первого приложения.





New - Android Project.





Дальше все по скринам.





![](http://android-helper.com.ua/images/uploads/2012/05/android2.jpg)




![](http://android-helper.com.ua/images/uploads/2012/05/android3.jpg)




![](http://android-helper.com.ua/images/uploads/2012/05/android4.jpg)





После нажатия на Finish, у вас должно получиться следующее дерево вашего проекта:





![](http://android-helper.com.ua/images/uploads/2012/05/android5.jpg)



Открыв файл Example1Activity.java вы увидите следующий код.






	package com.in.androidhelper;



	import android.app.Activity;

	import android.os.Bundle;



	public class Example1Activity extends Activity {

 	/** Called when the activity is first created. */

	@Override

	public void onCreate(Bundle savedInstanceState) {

    	super.onCreate(savedInstanceState);

    	setContentView(R.layout.main);</p>

   	}

	}






Но у нас с вами задача написать "Привет Android".  
Для этого откройте файл main.xml  
И измените текст текстового поля.  
Должно получиться так:






	<?xml version="1.0" encoding="utf-8"?>

	<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"

		android:layout_width="fill_parent"

		android:layout_height="fill_parent"

		android:orientation="vertical" >



		<TextView

			android:layout_width="fill_parent"

			android:layout_height="wrap_content"

			android:text="Привет Android" />



	</LinearLayout>







Первое задание мы с вами успешно прошли.





Если у вас есть вопросы вы всегда можете задать их на сайте либо в соц. сетях.





Подписывайтесь на рассылку и получайте только самое свежее.





Планируется проведение тренинга по Android. Если вы хотите повысить свои знания тогда вам к нам :).





Все вопросы задавайте в соц. сетях.




Добрый день друзья.





Сегодня у нас стартует рубрика программирования для начинающих.





Освоив эту рубрику, вы станете не только понимать Android, но и быть неким гуру в разработке.



 <!-- more -->

 





Перед началом программирования, нужно подготовить ваш компьютер.












  1. Устанавливаем [Java](http://www.oracle.com/technetwork/java/javase/downloads/jdk-6u32-downloads-1594644.html)



  2. Установим [Android SDK](http://developer.android.com/sdk/index.html)



  3. Скачаем [Eclipse](http://eclipse.org/downloads/) (рекомендую Classic)



  4. Установим [Android плагин для Eclipse (ADT)](http://developer.android.com/sdk/eclipse-adt.html#downloading)



  5. Подключим ваше устройство, [устанавливаем драйвера](http://developer.android.com/sdk/win-usb.html). Если драйверов нету, тогда добавляйте его как ADT Interface (Android устройство)



  6. Научимся пользоваться эмулятором










 





Если есть вопросы, задавайте их в соц. сетях или в Twitter.





 





После завершения этих задач, можно будет приступить к написанию вашей первой программы.




</li>&ndash;&gt;-->
    <!--&lt;!&ndash;&ndash;&gt;-->
    <!--&lt;!&ndash;<li>Памятка разработчикуДрузья всем привет.

Я очень рад, что некоторые из ребят в коучинге пишут замечательные топики!

Вот с какой проблемой мы столкнулись в коучинге и как ее решали!

<!-- more -->


В процессе коучинга, создавая своё первое приложение - калькулятор, научился использовать кастомные шрифты. Спешу безвозмездно поделиться своим опытом!

**Какие шрифты подходят?**

Можно использовать шрифты TrueType (TTF)

**Куда положить шрифт?**

В корневой директории (на одном уровне с директориями java и res и файлом AndroidManifest.xml) создать папку assets, а внутри неё можно создать отдельную папку для шрифтов fonts
В эту папку бросить свой файл со шрифтом Custom.ttf

**Как Android узнает, где находятся кастомные шрифты?**

В файле **<project_name>.iml** в разделе configuration необходимо добавить строчку

	<configuration>
	...
	<option name="ASSETS_FOLDER_RELATIVE_PATH" value="/src/	main/assets" />
	</configuration>

а в файле **res/values/strings.xml** - строчку

	<string name="digit_keyboard_font">fonts/Custom.ttf</string>

**Как назначить шрифт своим View-элементам?**

Теперь в коде, в методе onCreate можно использовать свой шрифт. Обратите внимание на код, в котором скрывается первая секретная фишка!

	Typeface keys = Typeface.createFromAsset(getAssets(), 	getString(R.string.digit_keyboard_font));
	TextView key = (TextView)findViewById(R.id.button_about_ok);
	key.setTypeface(keys);


Как видите, таким способом можно применить шрифт к надписям на кнопках и других **View**, которые можно явно привести типу **TextView**.


Ещё одна супер-полезная и очень секретная фишка
Допустим, требуется применить шрифт к группе элементов, которые располагаются в layout-файле внутри корневого элемента типа **ViewGroup** с присвоенным ему уникальным **id**


	<LinearLayout
    android:id="@+id/digit_keyboard_layout"
    android:layout_width="wrap_content"
    android:layout_height="match_parent"
    android:layout_gravity="center_horizontal"
    android:orientation="vertical">

    <TableLayout
        android:id="@+id/table1"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content">

        <TableRow
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_weight="3">

            <Button
                android:id="@+id/button_one"
                style="@style/calc_button_style"
                android:layout_width="@dimen/button_width"
                android:text="@string/one"
                android:layout_alignParentStart="false"
                android:layout_alignParentEnd="false"
                android:layout_weight="1"/>

            <Button
                android:id="@+id/button_two"
                style="@style/calc_button_style"
                android:layout_width="@dimen/button_width"
                android:text="@string/two"
                android:layout_weight="1"/>

            <Button
                android:id="@+id/button_three"
                android:text="@string/three"
                style="@style/calc_button_style"
                android:layout_width="@dimen/button_width"
                android:layout_weight="1"
                />
        </TableRow>
    </TableLayout>
	</LinearLayout>


Используйте в коде приложения вот такой метод


	// Sets the font on all TextViews in the ViewGroup.
    public void setFont(ViewGroup group, Typeface font) {
        int count = group.getChildCount();
        View v;
        for(int i = 0; i < count; i++) {
            v = group.getChildAt(i);
            if(v instanceof TextView) {
                ((TextView)v).setTypeface(font);
            } else if(v instanceof ViewGroup) {
                setFont((ViewGroup) v, font);
            }
        }
    }

Метод рекурсивно вызывает сам себя пока не доберётся до нужного элемента в любой сложной xml-структуре **layout**. 

Вызывая этот метод устанавливаем шрифт группе элементов.

	Typeface keys = Typeface.createFromAsset(getAssets(), 	getString(R.string.digit_keyboard_font));
	ViewGroup keyboardArea = (ViewGroup)findViewById(R.id.digit_keyboard_layout);
	setFont(keyboardArea, keys);

У кого есть какие то наработки или идеи, пишите в комментариях. Мы обязательно добавим статью на блог!

Жду ваших комментариев!### Как зарутить ganymotion?

Всем привет.

Один из участников моего коучинга, задал мне [вопрос на форуме](http://forum.android-helper.com.ua/viewtopic.php?f=15&t=9). Один из ответов был использовать Ganymotion в его разработке. На что он ответил, что не может добраться к базе данных.

Я реально проверил это. И знаете, что оно так и есть. Было принято решение получить доступ к базе любой ценой. И это свершилось.

Сегодня я хотел бы поделится своим опытом - **"Как получить доступ к базе данных в Ganymotion?"**

Готовы? Тогда вперед.

<!-- more -->

#### Подготовка

1. [Установка Ganymotion](http://android-helper.com.ua/android-studio-genymotion/)
2. Выбираем из списка нужный емулятор
3. [Скачиваем root файл](https://drive.google.com/file/d/0B-p1r5SNN4adTGgyajV6ckNtV00/edit?usp=sharing).
4. Открываем **terminal** - Mac (**cmd** - Windows)

#### Root

Заходим в папку где у вас скачан файл (см. выше)

И в terminal пишем следующее!

	adb devices
	adb root
	adb connect <IP вашего устройства см. adb devices вместе с портом>
	adb remount
	adb push su /system/xbin/
	adb push su /system/bin
	adb shell chmod 6755 /system/bin/su
	adb shell chmod 6755 /system/xbin/su

Все ваш емулятор теперь имеет права root.

#### Видео урок

{% youtube rsBGF9_Un8o %}


1. Ставьте лайк
2. Пишите комментарии
3. Рассказывайте друзьямДобрый день друзья.
Сегодня наша статья будет полезна не только гуру android программирования, но и тем кто только стал на этот не легкий тернистый путь.

Сегодня мы поговорим о том как с помощь Intent намерений можно выполнять самые различные операции.

Ну что поехали?

<!-- more -->

**Открыть браузер**

	Uri uri = Uri.parse("http://www.google.com");
	Intent it  = new Intent(Intent.ACTION_VIEW,uri);
	startActivity(it);

**Открыть карту с координатами**

	Uri uri = Uri.parse("geo:38.899533,-77.036476");
	Intent it = new Intent(Intent.Action_VIEW,uri);
	startActivity(it); 

**Показать путь**

	Uri uri = Uri.parse("http://maps.google.com/maps?f=d&saddr=startLat%20startLng&daddr=endLat%20endLng&hl=en");
	Intent it = new Intent(Intent.ACTION_VIEW,URI);
	startActivity(it);

**Позвонить с программы**

	Uri uri = Uri.parse("tel:xxxxxx");
	Intent it = new Intent(Intent.ACTION_DIAL, uri);  
	startActivity(it);  

	Uri uri = Uri.parse("tel.xxxxxx");
	Intent it =new Intent(Intent.ACTION_CALL,uri);

Не забудьте добавить разрешение в манифесте.

	<uses-permission id="android.permission.CALL_PHONE" />

**Отправка сообщения с помощью встроенной программы**

	Intent it = new Intent(Intent.ACTION_VIEW);   
	it.putExtra("sms_body", "The SMS text");   
	it.setType("vnd.android-dir/mms-sms");   
	startActivity(it);  

**Отправка сообщения на номер телефона**

	Uri uri = Uri.parse("smsto:0800000123");   
	Intent it = new Intent(Intent.ACTION_SENDTO, uri);   
	it.putExtra("sms_body", "The SMS text");   
	startActivity(it);  

**Отправка MMS**

	Uri uri = Uri.parse("content://media/external/images/media/23");   
	Intent it = new Intent(Intent.ACTION_SEND);   
	it.putExtra("sms_body", "some text");   
	it.putExtra(Intent.EXTRA_STREAM, uri);   
	it.setType("image/png");   
	startActivity(it); 

**Отправка почты**
 
	Uri uri = Uri.parse("mailto:xxx@abc.com");
	Intent it = new Intent(Intent.ACTION_SENDTO, uri);
	startActivity(it);

	Intent it = new Intent(Intent.ACTION_SEND);   
	it.putExtra(Intent.EXTRA_EMAIL, "me@abc.com");   
	it.putExtra(Intent.EXTRA_TEXT, "The email body text");   
	it.setType("text/plain");   
	startActivity(Intent.createChooser(it, "Choose Email Client"));  

	Intent it=new Intent(Intent.ACTION_SEND);     
	String[] tos={"me@abc.com"};     
	String[] ccs={"you@abc.com"};     
	it.putExtra(Intent.EXTRA_EMAIL, tos);     
	it.putExtra(Intent.EXTRA_CC, ccs);     
	it.putExtra(Intent.EXTRA_TEXT, "The email body text");     
	it.putExtra(Intent.EXTRA_SUBJECT, "The email subject text");     
	it.setType("message/rfc822");     
	startActivity(Intent.createChooser(it, "Choose Email Client"));   


**Добавление файлов**

	Intent it = new Intent(Intent.ACTION_SEND);   
	it.putExtra(Intent.EXTRA_SUBJECT, "The email subject text");   
	it.putExtra(Intent.EXTRA_STREAM, "file:///sdcard/mysong.mp3");   
	sendIntent.setType("audio/mp3");   
	startActivity(Intent.createChooser(it, "Choose Email Client"));

**Проигрывание музыки**

	Intent it = new Intent(Intent.ACTION_VIEW);
	Uri uri = Uri.parse("file:///sdcard/song.mp3");
	it.setDataAndType(uri, "audio/mp3");
	startActivity(it);

	Uri uri = Uri.withAppendedPath(MediaStore.Audio.Media.INTERNAL_CONTENT_URI, "1");   
	Intent it = new Intent(Intent.ACTION_VIEW, uri);   
	startActivity(it);  

**Удаление программы**

	Uri uri = Uri.fromParts("package", strPackageName, null);   
	Intent it = new Intent(Intent.ACTION_DELETE, uri);   
	startActivity(it);

	Uri uninstallUri = Uri.fromParts("package", "xxx", null);
	returnIt = new Intent(Intent.ACTION_DELETE, uninstallUri);

**Установка программы**

	Uri installUri = Uri.fromParts("package", "xxx", null);
	returnIt = new Intent(Intent.ACTION_PACKAGE_ADDED, installUri);

**Поиск на маркете**

	Uri uri = Uri.parse("market://search?q=pname:pkg_name");  
	Intent it = new Intent(Intent.ACTION_VIEW, uri);  
	startActivity(it);  


**Показать детали программы**

	Uri uri = Uri.parse("market://details?id=app_id");  
	Intent it = new Intent(Intent.ACTION_VIEW, uri);  
	startActivity(it);  

**Поиск в Google**

	Intent intent = new Intent();
	intent.setAction(Intent.ACTION_WEB_SEARCH);
	intent.putExtra(SearchManager.QUERY,"searchString")
	startActivity(intent);


Ну вот и все, расскажи своим друзьям. Нажимай лайки и пиши свои комментарии.### Genymotion





Вероятно название **Genymotion** вам ни о чем не говорит. Но уверяю вас это не надолго. Как только вы его испробуете из памяти уже не сотрете. В nutshell, Genymotion это полностью готовый модуль заменяющий стандартный эмулятор Android (который стал бесполезным из-за недостаточной производительности на последних последних версиях Android) который можно скачать на официальном сайте [genymotion.com](http://www.genymotion.com/). Решение основано на **Virtual Box** соответственно является виртуальным а не эмулируемым устройством.



![Genymotion](https://lh3.googleusercontent.com/-wk22pXuAJXA/UeeXbDsp0LI/AAAAAAAAIyI/8TFeBRdx5Yk/w871-h191-no/genymotion.png)  
  
Genymotion

<!-- more -->

Я не являюсь экспертом ни в виртуализации ни в эмуляции, но похоже, что эмуляция уже не актуальна. На теперешнее время **iOS** предлагает симулятор (приложения компилируются под целевую архитектуру) и последние **Windows Phone SDK** укомплектовано Windows Phone эмулятором который по сути является виртуальной машиной. Мне кажется, что виртуализация лучший вариант для решения проблем производительности, как следствие эмуляции, и «различий бинарников» от которых страдает симуляция.





Если вы уже испробовали Genymotion, вы знаете об основных отличиях стандартного эмулятора от реального устройства и Genymotion: скорость! с очень быстрый и превращает процесс разработки под Android в удовольствие. Genymotion освобождает от необходимости постоянно отрываться от рабочей станции к реальному девайсу для тестирования. Благодаря этой софтине все происходит на вашей машине. Для того, чтобы продемонстрировать, насколько быстр Genymotion, я запустил небольшой проект с несколькими тестами на двух устройствах (Nexus 4) и экземпляр Genymotion работающем на моем MacBook. Результаты говорят сами за себя, тесты на Genymotion прошли по крайней мере в 10 раз быстрее, чем на Nexus 4:



![Tests](https://lh3.googleusercontent.com/-Vp3Bq5WCeT0/UeeXbFc9pqI/AAAAAAAAIyM/eb6bNTx0d1U/w902-h361-no/tests.png)  
  
Tests



Впервые я попробовал Genymotion кода он еще был известным по имени AndroVM. На тот момент этот продукт имел большой потенциал, но был сыроват и сложен в настройке, что перекрывало все пути к средам разработки под Android. Последняя версия софта которую продемонстрировал Genymobile (компания которая стоит за Genymotion) вытолкнула Genymotion на новый уровень. После нового неплохого демо от команды Genymotion на Droidcon France, я решил еще раз попробовать часок его потестить и пришел к выводу что его рационально использовать в ежедневной разработке. Теперь свой личный девайс использую либо лишь для последней фазы тестирования, либо как обычный телефон. Скорость основное преимущество Genymotion, но есть еще:








  * 



протестированные и доверительные ROM’ы: Команда очень старается чтобы обеспечить CTS-compliant своих ROM’ов. Недавно они заявили что прошли 99.4% AOSP CTS. Можно ожидать что в ближайшее будет обеспечена полная совместимость.







  * 



аппаратное управление: Вы можете эмулировать много различных фич, например управление GPS сенсором. Вам всего лишь нужно указать на маркером на карте точку и он подхватит соответствующие координаты. ![GPS test](https://lh4.googleusercontent.com/-nTA9xWhMFUo/UeeXbZS7H3I/AAAAAAAAIyE/J1ZUuSD7Fv0/w838-h549-no/gps_control_center.png)







  * 



поддержка сервиса **Google Play**: Некоторые ROM’ы были укомплектованы приложениями от Google, у вас будет доступ к тем самым фичам что и у настоящего апарата. Соответственно, вы можете устанавливать и тестировать те же фреймворки, такие как **Google Play Services**. Это позволит вам тестировать приложения даже если они используют **Google Maps Android API v2** или последнее локационное API (через провайдер локации).







  * 



полная интеграция с **Android Studio & Eclipse**: Genymotion представляет простой UI для начала/создания нового виртуального устройства в мгновении. Также можете использовать плагины.







  * 



независимость от среды: доступен под Windows, Mac OS X or Linux







  * 



поддержка консоли: Genymotion предоставляет возможность написать модификации скрипта для состояний сенсора.










Давайте уточним, наличие быстрой виртуальной машины никак не значит что вы не должны тестировать на реальных устройствах. Это хорошая возможность быстро на кидать и отшлифовать прототип. Как не крути, лучшим способом удостоверится, что все работает плавно на реальных устройствах на них и провеять. У Genymotion все еще есть некоторые незначительные баг/недостающие фичи (это все еще Бета). Но его скорость, простота интеграции в среду разработки делают его мощным инструментом в арсенале разработчика.
В этой статье я расскажу как как установить среду разработки Android используя Android Studio и Genymotion. При переходе от Eclispe/ADT к Android Studio я исследовал альтернативные конфигурации для улучшения сборочной среды. Нашел неплохой эмулятор Genymotion. Интересный, довольно быстрый и очень простой.





**Что нам нужно?**




<!-- more -->



  * [Android Studio](http://android-helper.com.ua/android-studio/)



  * [Oracle VM VirtualBox](https://www.virtualbox.org/wiki/Downloads)



  * [Genymotion Android emulator](http://www.genymotion.com/)



  * [Genymotion Android studio plugin](http://www.genymotion.com/)






**Установка Oracle VM VirtualBox** Если вы используете Windows в загруженном вами пакете будет все необходимое, в противном случае вам нужно будет скачать и установить ее самостоятельно. Процесс простой и прямолинейный но эти действия необходимо выполнить иначе Android Emulator не запуститься.





**Установка Genymotion Android device emulator** Первое что нужно это сделать создать аккаунт, чтобы иметь возможность скачать эмулятор. Вы можете выбирать среди платформ, в моем случае это Mac OS X. Когда вы его скачали и установили у вас должно получиться что-то такое:



![Genymotion Android device emulator](https://lh4.googleusercontent.com/-XTLtY_Lu-uo/UdZ1ohxTDpI/AAAAAAAAIxU/UHNpDYatWSE/w878-h549-no/emulator1.png)  
  
Genymotion Android device emulator



У вас может быть доступно множество эмуляторов. Вы выбираете и грузите его с сети. Как результат у вас готовый эмулятор.



![Genymotion Android device emulator](https://lh3.googleusercontent.com/-bSICk3KwvT0/UdZ1oresDZI/AAAAAAAAIxE/VXQYFWzmdBs/w878-h549-no/emulator2.png)  
  
Genymotion Android device emulator



**Установка Android Studio Plugin** Чтобы интегрировать средство разработки с эмулятором вам необходимо установить плагин для Android Studio. Зайдите в Preferences там Plugin, выбираем нужный нам. Добавляем плагин который мы уже скачали и видим:



![Genymotion Android Studio Plugin](https://lh3.googleusercontent.com/-7ESa9bvI8oY/UdZ1ouyWdyI/AAAAAAAAIxQ/cod9TPdH1Qc/w878-h549-no/emulator3.png)  
  
Genymotion Android Studio Plugin



**Результат**





Теперь вы можете запустить Android проект и вы увидите:



![Genymotion Android Studio Plugin](https://lh4.googleusercontent.com/-pu_27RpWvZI/UdZ1pYXK1xI/AAAAAAAAIxM/qk4W1XYDUw4/w878-h549-no/emulator4_1.png)  
  
Genymotion Android Studio Plugin



Эмулятор полностью интегрирован в вашу среду разработки . Первый раз когда вы запустите эмулятор вы можете увидеть диалог который спросит путь к Android SDK:



![Genymotion Android Studio Plugin](https://lh3.googleusercontent.com/-kJdXolrj9RQ/UdZ1pOHCHFI/AAAAAAAAIxI/L8cSs1wTSNk/w878-h549-no/emulator4.png)  
  
Genymotion Android Studio Plugin



Как-только все настроено можно запускать свой проект. ![Genymotion Android Studio Plugin](https://lh4.googleusercontent.com/-vvfjkEI4RRw/UdZ1ph1p7II/AAAAAAAAIxc/n31dDQvUqj4/w878-h549-no/emulator5.png)





**Видео**



{% youtube 63T-8YRlFmE %}





Надеюсь статья была для вас полезной. Если да нажимайте рассказать друзьям :)
Друзья всем привет.





Сегодня речь пойдет о замечательной среде разработки Android Studio.





Когда мы транслировали в прямом эфире [I\O 2013](http://android-helper.com.ua/google-io-2013/), многие из вас увидели хорошую программу для разработки и даже было несколько слов о ней сказано.





Сегодня я постараюсь сделать небольшой обзор того, почему же она вызвала такой фурор.


<!-- more -->


### Видео





Ну что глянем сначала видео?





{% youtube uWnhrW-Gu0U %}



### Краткое описание








  1. Когда я первый раз ее запустил, то увидел, что основы этой студии идут от очень хорошего продукта для разработки Intellij.






![Android studio - Начало](http://android-helper.com.ua/images/uploads/2013/05/as1.jpg)





2. Структура проекта отличается от той которую использует Eclipse.



![Android studio - Структура](http://android-helper.com.ua/images/uploads/2013/05/as3.jpg)
Android studio - Структура



### А теперь начинаются самое интересное.








  1. 



Начнем с малого. Каждый из вас думал какой цвет ему использовать в своей программе. Придумал выбрал в редакторе, вставил в код и потом на другой день просто забыл или это синий или голубоватый. Я думаю так бывало с каждым. Но эту проблему решили. ![Android studio - Цвета](http://android-helper.com.ua/images/uploads/2013/05/as2.jpg)







  2. 



Следующим по очереди идет java код. К примеру я покажу **MainActivity.java**. И дам каждому пункту описание. ![Android studio - MainActivity](http://android-helper.com.ua/images/uploads/2013/05/as4.jpg)






    1. Теперь если мы пишем для **ImageView** _setImageResource(R.drawable.bla-bla)_, то у нас слева будет показан ресурс который мы используем.



    2. Теперь не нужно переходить в **strings.xml**, что бы посмотреть какая строка у вас будет в конкретном **TextView**. Студия сама покажет вам строку. А также может показать для какого языка она не переведена.



    3. Что я заметил, так это светло-желтый цвет выделения одного из запросов. Мне стало интересно почему. Когда я навел на него мышку, то увидел, что мне подсказывает возможный **NullPointerException**. И это очень порадовало. Так как много багов потом появляется просто из-за того, что ты забыл поставить проверку.






  3. 



Еще одним замечательным свойством, есть просмотр того, что вы сделали в вашем дизайне. Это значит, что теперь с помощью одной команды вы сможете увидеть ваш layout на всех устройствах. Очень удобно. ![Android studio - Просмотр на устройсвах](http://android-helper.com.ua/images/uploads/2013/05/as5.jpg)







  4. 



Еще одним бесспорным моментом является то, что теперь сборка ваших проектов работает намного быстрее.







  5. 



Intellij всегда брала тем, что у нее очень много полезных советов для правильного и главное быстрого написания кода.







  6. Но есть и несколько недостатков. Но это все исправляют и они не существенны.






### Завершение





Надеюсь вам понравилась статья. Если кто то, что нарыл нового в студии, то пишите, буду обновлять статью.
Всем привет.





За этих 2 дня мы посомтрели очень много полезной информации.





Сегодня же стартует не менее важная презентация.


<!-- more -->




**Google I/O Pitch Night**





Что вы можете тут взять для себя?





Как делать стартапы и правильно их презентовать.





Ну что смотрим?


{% youtube 9yZ6KpZ6y44 %}

Срочно!





Все трансляции в одном месте!<!-- more -->





**Google I/O 2013: Day 2 Android Sessions**





**Google I/O 2013 Technical Sessions 2**





**Google I/O 2013 Chrome Sessions**




{% youtube hXPAXKb-LQE %}Всем привет.





Сегодня стартует очень популярная конференция **Google I/O 2013**.





И наш сайт ведет онлайн трансляцию.



 <!-- more -->

Что будет и сама трансляция








  * на ней будет представлена новая версия операционной системы Android 4.3



  * новые планшеты семейства Nexus



  * умные очки Google Glass






**Онлайн трансляция:**


{% youtube 9pmPa_KxsAM %}






Расскажите друзьям.
Очень познавательная статья.





Читать всем разработчикам!





Перед любым начинающим Android-разработчиком рано или поздно встает вопрос о том, где и как удобнее запускать и отлаживать свои программы.













Самый верный способ — через Android Debug Bridge на реальном Android-устройстве. Но если, по каким то причинам, этот способ не подходит, то остается два варианта — воспользоваться штатным эмулятором Android Virtual Device (AVD) из Android SDK, или установить Android на виртуальную машину.  Про второй вариант я и хочу рассказать в этой статье. Android на виртуальной машине серьезно превосходит AVD по быстродействию и времени загрузки, но есть и недостатки — сложнее эмулировать телефонию (возможно, при помощи дополнительных программ), пока не разобрался как смонтировать SD-карту.







 <!-- more -->





**Итак! Нам понадобится**:





1. Готовая к работе среда разработки и Android SDK Tools - см. StartAndroid.ru урок 2.  
[http://startandroid.ru/uroki/vse-uroki-spiskom/9-urok-2-ustanovka-i-nastrojka-sredy-razrabotki.html](http://startandroid.ru/uroki/vse-uroki-spiskom/9-urok-2-ustanovka-i-nastrojka-sredy-razrabotki.html)





2. VirtualBox последней версии.  
[https://www.virtualbox.org/](https://www.virtualbox.org/).





3. Образ Android. Выбираем любую версию с сайта проекта Android-x86.  
[http://code.google.com/p/android-x86/](http://code.google.com/p/android-x86/)









### Шаг 1 — устанавливаем Virtual Box.





![](http://startandroid.ru/images/stories/articles/A0002/A0002_050.png)





![](http://startandroid.ru/images/stories/articles/A0002/A0002_060.png)





![](http://startandroid.ru/images/stories/articles/A0002/A0002_070.png)





![](http://startandroid.ru/images/stories/articles/A0002/A0002_080.png)





![](http://startandroid.ru/images/stories/articles/A0002/A0002_090.png)





![](http://startandroid.ru/images/stories/articles/A0002/A0002_100.png)













### Шаг 2 — Создаем виртуальную машину с Android.





![](http://startandroid.ru/images/stories/articles/A0002/A0002_110.png)





![](http://startandroid.ru/images/stories/articles/A0002/A0002_120.png)





![](http://startandroid.ru/images/stories/articles/A0002/A0002_130.png)





![](http://startandroid.ru/images/stories/articles/A0002/A0002_140.png)





![](http://startandroid.ru/images/stories/articles/A0002/A0002_150.png)





![](http://startandroid.ru/images/stories/articles/A0002/A0002_160.png)





![](http://startandroid.ru/images/stories/articles/A0002/A0002_170.png)













### Шаг 3 — настройка виртуальной машины и её запуск.





![](http://startandroid.ru/images/stories/articles/A0002/A0002_180.png)





![](http://startandroid.ru/images/stories/articles/A0002/A0002_190.png)





![](http://startandroid.ru/images/stories/articles/A0002/A0002_200.png)





![](http://startandroid.ru/images/stories/articles/A0002/A0002_210.png)





![](http://startandroid.ru/images/stories/articles/A0002/A0002_220.png)





Система не может найти диск для загрузки и останавливается. Монтируем скачанный образ Android.





![](http://startandroid.ru/images/stories/articles/A0002/A0002_230.png)





![](http://startandroid.ru/images/stories/articles/A0002/A0002_240.png)









Выбрать можно любой, но я советую работать с версией для EEEPC, например  
[android-x86-3.2-RC2-eeepc.iso](http://code.google.com/p/android-x86/downloads/detail?name=android-x86-3.2-RC2-eeepc.iso&can=4&q=). В других может возникнуть проблема — из под Android не будет виден виртуальный сетевой адаптер.





Перегружаем машину.





![](http://startandroid.ru/images/stories/articles/A0002/A0002_250.png)





![](http://startandroid.ru/images/stories/articles/A0002/A0002_260.png)





![](http://startandroid.ru/images/stories/articles/A0002/A0002_270.png)





Нажимаем ENTER и ждет загрузки Android.





![](http://startandroid.ru/images/stories/articles/A0002/A0002_280.png)





Закрываем обучающие подсказки. И выключаем функцию интеграции мыши, которая некорректно работает с нашей ОС, скрывая курсор.





![](http://startandroid.ru/images/stories/articles/A0002/A0002_290.png)













### Шаг 4 — настройка сети в виртуальном Android.





Щелкаем внутри окна и оказываемся в пространстве виртуальной машины.   
(чтобы вернуть курсор нужно нажать **правый CTRL**)





![](http://startandroid.ru/images/stories/articles/A0002/A0002_300.png)









Нажимаем **Alt+F1** и оказываемся в консоли.





![](http://startandroid.ru/images/stories/articles/A0002/A0002_310.png)









Присваиваем адрес сетевому адаптеру командой **ifconfig**:  
**ifconfig eth0 192.168.56.2 netmask 255.255.255.0**









Проверяем или переходим к следующему шагу. Основной комп пингуется по адресу 192.168.56.1 ("VirtualBox Host-Only Ethernet Adapter" в диспетчере устройств).  
Команда **ping**:  
**ping 192.168.56.1**  
**Ctrl+C**









Если все сработало нормально то увидим:





![](http://startandroid.ru/images/stories/articles/A0002/A0002_320.png)













### Шаг 5 — подсоединяем Android Debug Bridge (ADB) к виртуальной ОС.





Нажимаем **Alt+F7**, чтобы вернуться к графическому интерфейсу. Нажимаем **правый CTRL** и возвращаемся к реальной ОС. Не закрываем виртуальную машину.





Создаем на рабочем столе ярлык на **adb.exe**





![](http://startandroid.ru/images/stories/articles/A0002/A0002_330.png)





Нужный нам файл находится в папке Android SDK "platform-tools".





![](http://startandroid.ru/images/stories/articles/A0002/A0002_340.png)





Дописываем команду текстом "**connect 192.168.56.2**":





![](http://startandroid.ru/images/stories/articles/A0002/A0002_360.png)





![](http://startandroid.ru/images/stories/articles/A0002/A0002_370.png)









Запускаем ярлык.





Теперь ADB соединен с виртуальным Android, а он, в свою очередь, доступен для запуска и отладки программ из Eclipse. Цель достигнута. :)





Пересоединять ADB придется в том случае, когда вы закрыли или перезагрузили виртуальную машину.





**Так-же в случае, если вы перезагрузили виртуальный Android, придется возвращаться к шагу 4, так как настройки сетевого адаптера будут сброшены**. Поэтому я рекомендую не выключать виртуальную машину, а погружать её в сон, но ярлычек потом запустить все равно придется.





![](http://startandroid.ru/images/stories/articles/A0002/A0002_380.png)





![](http://startandroid.ru/images/stories/articles/A0002/A0002_390.png)













Заходим в Eclipse и проверяем как работает





![](http://startandroid.ru/images/stories/articles/A0002/A0002_400.png)





![](http://startandroid.ru/images/stories/articles/A0002/A0002_410.png)





![](http://startandroid.ru/images/stories/articles/A0002/A0002_420.png)













![](http://startandroid.ru/images/stories/articles/A0002/A0002_430.png)





Благодарности:





**renton** с habrahabr.ru — его идея.  
[http://habrahabr.ru/post/119599/](http://habrahabr.ru/post/119599/)





 Источник [startandroid.ru](http://startandroid.ru/ru/articles/listofarticles/206-bystraja-alternativa-android-virtual-device.html)
Всем привет.





Есть много программ с которых программисты и дизайнеры берут свои идеи.





И вот одна из которых это приложение facebook для android.





С этой программы дизайнеры взяли такую вещь как sliding menu.





Давайте посмотрим, что это такое.

 <!-- more -->



![Screenshot_2013-01-17-19-47-11](http://android-helper.com.ua/images/uploads/2013/01/Screenshot_2013-01-17-19-47-11.png)




 





![Screenshot_2013-01-02-02-24-31](http://android-helper.com.ua/images/uploads/2013/01/Screenshot_2013-01-02-02-24-31.png)





 





### Задача





Сделать что то подобное.





### Реализация





Для реализации данной задачи, мы будем использовать открытую библиотеку [SlidingMenu](https://github.com/jfeinstein10/SlidingMenu).





Также как она работает можете посмотреть, скачав приложение с [маркета](https://play.google.com/store/apps/details?id=com.slidingmenu.example).





### Коды





**MainActivity.java**



	public class MainActivity extends Activity {



    @Override

    protected void onCreate(Bundle savedInstanceState) {

        super.onCreate(savedInstanceState);

        setContentView(R.layout.activity_main);



        setTitle("Attach");

        // configure the SlidingMenu

        SlidingMenu menu = new SlidingMenu(this);

        menu.setMode(SlidingMenu.LEFT);

        menu.setTouchModeAbove(SlidingMenu.TOUCHMODE_FULLSCREEN);

        menu.setShadowWidthRes(R.dimen.shadow_width);

        menu.setShadowDrawable(R.drawable.shadow);

        menu.setBehindOffsetRes(R.dimen.slidingmenu_offset);

        menu.setFadeDegree(0.35f);



        // ///////////

        menu.attachToActivity(this, SlidingMenu.SLIDING_CONTENT);

        // //////////



        menu.setMenu(R.layout.menu);

    }



    @Override

    public boolean onCreateOptionsMenu(Menu menu) {

        // Inflate the menu; this adds items to the action bar if it is present.

        getMenuInflater().inflate(R.menu.activity_main, menu);

        return true;

    }



	}


**drawable/shadow.xml**


	<?xml version="1.0" encoding="utf-8"?>

	<shape xmlns:android="http://schemas.android.com/apk/res/android" >



    <gradient

        android:centerColor="#11000000"

        android:endColor="#33000000"

        android:startColor="#00000000" />



	</shape>


**layout/menu.xml**


	<?xml version="1.0" encoding="utf-8"?>

	<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"

    android:layout_width="match_parent"

    android:layout_height="match_parent"

    android:orientation="vertical" >



    <TextView

        android:id="@+id/textView1"

        android:layout_width="wrap_content"

        android:layout_height="wrap_content"

        android:text="Menu 1"

        android:textAppearance="?android:attr/textAppearanceLarge" />



    <TextView

        android:id="@+id/textView2"

        android:layout_width="wrap_content"

        android:layout_height="wrap_content"

        android:text="Menu 2"

        android:textAppearance="?android:attr/textAppearanceLarge" />



    <TextView

        android:id="@+id/textView3"

        android:layout_width="wrap_content"

        android:layout_height="wrap_content"

        android:text="Menu 3"

        android:textAppearance="?android:attr/textAppearanceLarge" />



    <TextView

        android:id="@+id/textView4"

        android:layout_width="wrap_content"

        android:layout_height="wrap_content"

        android:text="Menu 4"

        android:textAppearance="?android:attr/textAppearanceLarge" />



	</LinearLayout>


**values/dimens.xml**



	<?xml version="1.0" encoding="utf-8"?>

	<resources>



    <dimen name="slidingmenu_offset">60dp</dimen>

    <dimen name="list_padding">10dp</dimen>

    <dimen name="shadow_width">15dp</dimen>



	</resources>


### Видео


{% youtube eHWNIS64I0Q %}






Рабочий код на странице с [кодами](http://android-helper.com.ua/codes/).
Привет друзья.





После выхода android 4. Все дизайнеры как будто сговорились и прикручивают actionbar кругом.





И заказчик говорит, что именно так должно быть и для старых версий.





И что же делать? Писать свой actionbar?


 <!-- more -->


Нам на помощь приходит очень классная и бесплатная библиотека [ActionBarSherlock](http://actionbarsherlock.com/)





Я думаю, что большая часть из вас будет ее использовать.





Но могут быть и такие которые скажут, мы не используем сторонние библиотеки.





Это вам решать, но от себя добавлю, что эту библиотеку рекомендует google.





Пришло время писать код.





### Задача





Сделать actionbar меню для всех телефонов.





### Ресурсы





ActionBarSherlock





### Примеры реализации





![feature_02](http://android-helper.com.ua/images/uploads/2013/01/feature_02.png)





 





![feature_03](http://android-helper.com.ua/images/uploads/2013/01/feature_03.png)



 





![feature_01](http://android-helper.com.ua/images/uploads/2013/01/feature_01.png)





 





 





### Реализация








  1. Подключаем проект Sherlock в eclipse. Скачать можно [тут](https://api.github.com/repos/JakeWharton/ActionBarSherlock/zipball/4.2.0).



  2. Создаем свой проект



  3. Подключаем библиотеку sherlock к вашему проекту



  4. Делаем файл меню



  5. ВАЖНО! Все активити и фрагменты должны наследоваться от SherlockActivity и SherlockFragment






### Коды





#### menu/activity_main.xml





	<menu xmlns:android="http://schemas.android.com/apk/res/android" >



    <item

        android:id="@+id/item1"

        android:icon="@android:drawable/ic_menu_agenda"

        android:orderInCategory="100"

        android:showAsAction="always|withText"

        android:title="Item 1"/>

    <item

        android:id="@+id/item2"

        android:icon="@android:drawable/ic_menu_call"

        android:orderInCategory="200"

        android:showAsAction="always|withText"

        android:title="Item 2"/>

    <item

        android:id="@+id/item3"

        android:icon="@android:drawable/ic_menu_camera"

        android:orderInCategory="300"

        android:showAsAction="ifRoom|withText"

        android:title="Item3"/>

    <item

        android:id="@+id/menu_settings"

        android:orderInCategory="400"

        android:showAsAction="never"

        android:title="@string/menu_settings"/>



	</menu>





#### MainActivity.java



	package com.ua.android_helper.testactionbar;



	import android.os.Bundle;

	import com.actionbarsherlock.app.SherlockActivity;

	import com.actionbarsherlock.view.Menu;



	public class MainActivity extends SherlockActivity {



    @Override

    protected void onCreate(Bundle savedInstanceState) {

        super.onCreate(savedInstanceState);

        setContentView(R.layout.activity_main);

    }



    @Override

    public boolean onCreateOptionsMenu(Menu menu) {

        getSupportMenuInflater().inflate(R.menu.activity_main, menu);

        return true;

    }



	}


#### AndroidManifest.xml


	<?xml version="1.0" encoding="utf-8"?>

	<manifest xmlns:android="http://schemas.android.com/apk/res/android"

    package="com.ua.android_helper.testactionbar"

    android:versionCode="1"

    android:versionName="1.0" >



    <uses-sdk

        android:minSdkVersion="8"

        android:targetSdkVersion="17" />



    <application

        android:allowBackup="true"

        android:icon="@drawable/ic_launcher"

        android:label="@string/app_name"

        android:theme="@style/Theme.Sherlock" >

        <activity

            android:name="com.ua.android_helper.testactionbar.MainActivity"

            android:label="@string/app_name" >

            <intent-filter>

                <action android:name="android.intent.action.MAIN" />



                <category android:name="android.intent.category.LAUNCHER" />

            </intent-filter>

        </activity>

    </application>



	</manifest>



**Видео**

{% youtube GOB72vWY_5s %}


Продолжая тему своего маркета.





Нашел еще одну интересную статью.





Хорошая новость для пользователей [Google Apps for Business](http://www.google.com/enterprise/apps/business/#utm_medium=blog&utm_source=en-na-us-entblog-playprivatechannel12042012&utm_campaign=launch), [Education](http://www.google.com/enterprise/apps/education/#utm_medium=blog&utm_source=en-na-us-entblog-playprivatechannel12042012&utm_campaign=launch) и [Government](http://www.google.com/enterprise/apps/government/#utm_medium=blog&utm_source=en-na-us-entblog-playprivatechannel12042012&utm_campaign=launch) была опубликована в[блоге Google](http://googleenterprise.blogspot.com/2012/12/a-new-way-to-distribute-your-internal.html). Отныне в Google Play можно создавать корпоративные каналы обновлений и распространять через них внутренние приложения для своих работников.  
  
![](http://habrastorage.org/storage2/cc9/d98/20b/cc9d9820bcd9d9662370983f3c2e6b97.png)  
  
  
  






##### Как это работает





  
Каждый домен Google Apps for Business теперь может иметь приватный канал в Play Store. Администраторы домена могут давать пользователем права на публикацию приложений в консоли разработчика, а также настраивать доступ к каналу в Play Store для отдельных пользователей и групп.  
  
Чтобы увидеть этот канал на девайсе, пользователям нужно войти в Play с помощью своего корпоративного аккаунта.  
  






##### Как включить





  
Администраторы Google Apps могут включить канал в панели управления:








  * В разделе **Organizations & users > Services** нужно включить **Google Play Developer Console**.



  * Для группы пользователей, которым следует разрешить публикацию, нужно:  





    * В **Settings > Mobile** разрешить обновлять **Google Play Private Channel**



    * В **Organizations & users > Services** включить для них **Google Play Developer Console**








  * Остальным пользователям нужно дать доступ к Google Play Private Channel






  
  






##### Дополнительная информация












  * Канал виден только из девайсов и пока что недоступен для веб-интерфейса



  * Каждый девелопер должен проходить обычную регистрацию в консоли разработчика (за $25)



  * Для приложений в приватном канале доступны рейтинги, отзывы, цены и таргетирование



  * Организация может иметь лишь один приватный канал






  
  
Официальная документация: [http://support.google.com/a/bin/answer.py?hl=en&answer=2494992](http://support.google.com/a/bin/answer.py?hl=en&answer=2494992)
Привет всем.





Сейчас готовлю вебинар и нашел статью, которой хотел поделится со своими читателями.





Прошу к прочтению:


  <!-- more -->


Android – мобильная операционная система, разработанная специально для смартфонов, планшетов и нетбуков. Операционная система Android основана на модифицированном ядре Linux. Первыми разработками занималась компания Android Inc, которая позже была куплена Google. После приобретения компании и всех прав, было инициировано создание альянса Open Handset Alliance (OHA). Впоследствии, Google и другие участники Open Headset Alliance начали свою полноценно сотрудничество для совместной разработки этой новой операционной системы. У Android имеется очень большое сообщество разносторонних разработчиков, которые расширяют функциональность и производительность устройств.









![](http://androidzon.ru/uploads/posts/2012-05/1335970797_google-android.jpg)









Система Android от компании Google имеет свой собственный официальный магазин по продаже мобильных приложений и игр который был открыт 22 октября 2008 года. Изначально он назывался Android Market, однако в марте месяце 2012 года компания Google решила переименовать Android Market в Google Play. На сегодняшний день он включает в себя как платные приложения, так и бесплатные. Так как система Android является полностью открытой, все пользователи имеют возможность загружать приложения не только с официального, но и с других ресурсов.  
  
Большинство приложений для вышеупомянутой системы пишется на языке Java, управляющие устройством через специаьно разработанные Google библиотеки.  
  
Официально об операционной системе Android стало известно 5 ноября 2007 года, когда было официально объявлено основание Open Headset Alliance – консорциум, состоящий из 80 компаний. Большая часть кода Android была выпущена с использованием лицензией Apache.  
  
Android приложения включают в себя различные java-приложения и библиотеки, которые запускаются виртуальной машиной Dalvik с JIT компилятором. Библиотеки включают в себя систему управления, графику OpenGL ES 2.0, движок WebKit, графический движок SGL, SSL и библиотеки Bionic. Android OS состоит аж из 12 миллионов строк кода, в том числе 3-х миллионов строк XML, 2.8 миллионов строк на C, 2.1 миллиона строк на Java и 1.75 миллиона строк на C++.  
  
Ну да ладно, теперь давайте разберёмся более подробно.  
  
**История операционной системы Android:**









![](http://androidzon.ru/uploads/posts/2012-05/1335972119_istoriya-os-android.jpg)









В октябре 2003 года в Пало Альто, штат Калифорния была основана компания Android inc. Главными основателями Android inc. были Энди Рубин, Ник Сирс, Рич Майнер и Крис Уайт.  
  
В августе 2005 года компания Google приобрела Android inc. После этого приобретения Android inc. стала дочерней компанией Google. После покупки Энди Рубин, Рич Майнер и Крис Уайт и дальше продолжили свою работы в Android inc. И почти сразу же после поглощения Android inc., то тут, то там в сети стали появляться слухи о том, что компания Google намерена выйти на рынок мобильных телефонов.  
  
Получив серьёзную поддержку со стороны Google, команда, во главе которой был Энди Рубином начала усиленно работать над операционной системой базирующейся на ядре Linux. И уже к декабрю 2006 года начали распространяться слухи о том, что Google собирается выпустить свой собственный смартфон с использованием своего бренда, так называемый “Гуглофон”.  
  
Но все эти слухи поспешили опровергнуть и Эрик Шмидт заявил следующее: «Сегодняшнее заявление носит более амбициозный характер, чем выпуск смартфона под нашим брендом, о чём пресса спекулирует несколько последних недель. Наше видение заключается в том, что мощнейшая платформа должна отдать свои силы тысячам различных моделей телефонов». И почти сразу же после этих слов 5 ноября 2007 года был официально представлен Open Headset Alliance – консорциум, состоящий из множества различных компаний, в который вошли такие мировые гиганты как: Broadcom Corporation, Google, HTC, Intel, LG, T-Mobile, Marvell Technology Group,Sprint Nextel, Motorola, Nvidia, Qualcomm, Samsung Electronics, Texas Instruments и многие другие.  
  
  
**Версии Android:**  
  
Очень интересное решение для выбора названий каждой очередной версии Android ОС, каждая версия имеет название какого-либо десерта. Первые буквы наименований в порядке версий всегда соответствуют буквам латинского алфавита.









![](http://androidzon.ru/uploads/posts/2012-05/1335973579_versii-android_1.jpg)













![](http://androidzon.ru/uploads/posts/2012-05/1335973875_versii-android_2.jpg)













![](http://androidzon.ru/uploads/posts/2012-05/1335974047_versii-android_3.jpg)









За исключением небольших и непродолжительных по времени периодов в процессе обновлений, начиная с 21 октября 2008 года код OS Android находилась в свободном доступе. Компания Google публиковала код с использованием лицензией Apache. И несмотря на то, что совершенно любой производитель мобильных аппаратов может использовать сам код операционной системы как ему вздумается, всё-таки присутствуют небольшие ограничения. Торговую марку Android запрещено использовать, если производимое устройство не будет соответствовать критериям совместимости Google, но таких не очень много. Также без данного условия нельзя использовать и Google Play, ранее имевший название Android Market а также еще несколько приложения от Google.  
  
  
**Первое устройства:**









![](http://androidzon.ru/uploads/posts/2012-05/1335975098_htc-t-mobile-g1.jpg)









Самым первым выпущенным в массы устройством, работающим под управлением Android, был смартфон T-Mobile G1, разработанный известной компанией HTC. Первая официальная презентация этого аппарата состоялась 23 сентября 2008 года. И спустя небольшой промежуток времени последовали многочисленные анонсы других известных производителей смартфонов о намерении выпустить свои собственные устройства с Android. На данный момент рынок мобильных устройств с данной операционной системой имеет огромное количество предложений. Свои устройства нам предлагают многие, например компания Samsung, которая заняла прочное место среди производителей смарфон и планшетов.  
  
  
**Google Play:**









![](http://androidzon.ru/uploads/posts/2012-05/1335975862_google-play.jpg)









22 октября 2008 года компания Google объявила об открытии своего собственного онлайн-магазина, который будет содержать в себе игры и приложений для устройств, работающих под управлением Android. Изначально он назывался Android Market но в марте 2012 года был переименован. Также была проведена работа по смене дизайна вышеупомянутого магазина.  
Google Play – интернет-магазин, который продвигает альянс Open Handset Alliance (OHA) во главе с Google. Он включает в себя многочисленные игры, различные клиенты социальных сетей, полезные офисные приложения, приложения предназначенные для чтения новостей и книг, программы позволяющие управлять финансами и другие. Содержимое является как платным так и бесплатным, всё очень хорошо распределено по соответствующим категориям.  
  
  
**Разработка программного обеспечения:**









![](http://androidzon.ru/uploads/posts/2012-05/1335976629_razrabotka-programmnogo-obespecheniya.jpg)









Приложения для системы Android являются программами в байт-коде, который отличается от других, проще говоря он нестандартный и для его использования необходима виртуальная машины Dalvik.  
  
Google даёт всем разработчикам очень хороший инструментарий (Android SDK), который находиться в свободном доступе доя скачивания и предназначен для x86-машин под операционными системами Windows XP, Windows Vista, Mac OS X (10.4.8 или выше) и конечно же Linux. Для разработки требуется JDK 5 или JDK 6.  
  
Также разработку приложений для Android ОС можно вести и на языке Java (не ниже Java 1.5). Существует отличный плагин для Eclipse — «Android Development Tools» (ADT), предназначенный для Eclipse версий 3.3-3.5. Для IntelliJ IDEA также есть свой собственный плагин, призванный облегчать разработку Android-приложений.  
  
  
**Архитектура Android ОС:**









![](http://androidzon.ru/uploads/posts/2012-05/thumbs/1335977115_arhitektura-android-os.jpg)









(нажмите на картинку для полномасштабного просмотра)





**Уровень приложений (Applications):**  
В состав системы Android входит свой собственный комплект базовых приложений: различные клиенты электронной почты и SMS, календарь, навигационные карты, браузер, программа для управления контактами и многое многое другое. Все приложения, запускаемые на платформе Android были написаны на языке Java.  
  
  
**Уровень каркаса приложений (Application Framework):**  
Android позволяет использовать всю мощь API, используемого в приложениях ядра. Архитектура построена таким образом, что любое приложение может использовать уже реализованные возможности другого приложения при условии, что последнее откроет доступ на использование своей функциональности. Таким образом, архитектура реализует принцип многократного использования компонентов ОС и приложений.  
  
Главной основой всех приложений является набор систем и специальных служб:  
1. Система представлений (View System) – это богатый набор представлений с расширяемой функциональностью, который служит для построения внешнего вида приложений, включающий такие компоненты, как различные списки, таблицы, поля для ввода, кнопки и прочее.  
2. Контент-провайдеры (Content Providers) – это службы, которые позволяют приложениям получать доступ к данным других приложений, а также при необходимости предоставлять доступ к своим данным.  
3. Менеджер ресурсов (Resource Manager) предназначен для доступа к строковым, графическим и другим типам ресурсов.  
4. Менеджер извещений (Notification Manager) позволяет любому приложению отображать пользовательские уведомления в специально отведённой строке статуса.  
5. Менеджер действий (Activity Manager) управляет жизненным циклом приложений и предоставляет систему навигации по истории работы с действиями.  
  
  
**Уровень библиотек (Libraries):**  
Платформа Android включает в себя набор C/C++ библиотек, используемых различными компонентами ОС. Для разработчиков доступ к функциям этих библиотек реализован с помощью использования Application Framework. Ниже вы можете прочитать о некоторые из них:  
1. System C library - BSD-реализация стандартной системной библиотеки C (libc) для встраиваемых устройств, основанных на Linux.  
2. Media Libraries – библиотеки, основанные на PacketVideo‘s OpenCORE, предназначенные для поддержки проигрывания и записи популярных аудио- и видео- форматов (MPEG4, H.264, MP3, AAC, AMR, JPG, PNG и т.п.).  
3. Surface Manager – менеджер поверхностей управляет доступом к подсистеме отображения 2D- и 3D- графических слоев.  
4. LibWebCore – современный движок web-браузера, который предоставляет всю мощь встроенного Android-браузера.  
5. SGL – специальный движок для работы с 2D-графикой.  
6. 3D libraries – движок для работы с 3D-графикой, который основан на OpenGL ES 1.0 API.  
7. FreeType – библиотека, предназначенная для работы с различными шрифтами.  
8. SQLite – мощный легковесный движок для работы с реляционными БД.  
  
  
**Уровень среды исполнения (Android Runtime):**  
В состав системы Android входит набор библиотек ядра, которые предоставляют большую часть функциональности библиотек ядра на языке Java.  
Данная платформа использует оптимизированную, регистр-ориентированную виртуальную машину Dalvik, в отличии от неё стандартная виртуальная машина Java является стек-ориентированной. Каждое приложение запускается в своем собственном процессе, со своим собственным экземпляром виртуальной машины. Dalvik использует формат Dalvik Executable (*.dex), оптимизированный для минимального использования памяти приложением. Это обеспечивается такими базовыми функциями ядра Linux, как организация поточной обработки и низкоуровневое управление памятью. Байт-код Java, на котором написаны ваши и наши приложения, компилируются в dex-формат при помощи утилиты dx, входящей в состав SDK.  
  
  
**Уровень ядра Linux (Linux Kernel):**  
Android был основан на ОС Linux версии 2.6, тем самым этой платформе доступны системные службы ядра, такие как управление памятью и разнообразными процессами, обеспечение безопасности, работа с сетью и драйверами. Также ядро служит слоем абстракции между аппаратным и программным обеспечением.  
  
  
**Доступные библиотеки:**  
§ SSL — шифрование  
§ Bionic — библиотека стандартных функций, несовместимая с libc  
§ Media Framework (PacketVideo OpenCORE, MPEG4, H.264, MP3, AAC, AMR, JPG, PNG)  
§ Surface Manager  
§ FreeType — шрифты  
§ LibWebCore (на базе WebKit)  
§ SGL — 2D-графика  
§ OpenGL ES — 3D-библиотека  
§ SQLite — легковесная СУБД  
  
По сравнению с обычными приложениями Linux, приложения Android подчиняются дополнительным правилам:  
§ Notification Manager — доступ к строке состояния;  
§ Content Providers — обмен данными между приложениями;  
§ Resource Manager — доступ к таким ресурсам, как файлы XML, PNG, JPEG;  
§ Activity Manager — управление активными приложениями.  
  
И в самом конце хочется добавить, что для операционной системы Android был разработан специальный формат архивных исполняемых файлов-приложений .apk.





Статья из сайта [androidzon.ru](http://androidzon.ru/google-android-os.html)





Записывайтесь на вебинар!
Еще одна полезная статья для владык android устройств.





Многие пользователи Android знают, что с помощью приложения Titanium Backup можно вытащить приложение из устройства в виде apk файла. Сегодня мы рассмотрим способ, с помощью которого можно вытащить apk файл приложения прямо из Google Play Store.





![](http://lifehacker.ru/wp-content/uploads/2012/05/04.png)




Плюсом данного способа является отсутствие необходимости предварительной установки приложения на устройство. К сожалению, работает этот способ только для бесплатных приложений. Итак, что нам понадобится:


 <!-- more -->


## 1. Google Chrome





Создаём на рабочем столе второй ярлык для Google Chrome.





![](http://lifehacker.ru/wp-content/uploads/2012/05/a.png)



Делаем по ярлыку правый клик, выбираем «Свойства». В поле «Объект» дописываем через пробел следующие команды:






	--ignore-certificate-errors
	--allow-running-insecure-content


Получится примерно так:

	...\chrome.exe" --ignore-certificate-errors --allow-running-insecure-content









Нажимаем «Применить» и «ОК».





![](http://lifehacker.ru/wp-content/uploads/2012/05/b.png)



После данной операции нужно перезапустить браузер, закрыв при этом все запущенные экземпляры приложения.





## 2. Имя аккаунта Google и ID устройства





По факту мы собираемся имитировать загрузку приложения на устройство, поэтому необходимо знать имя своего аккаунта, то есть имя вашего почтового ящика Google, а также идентификационный номер вашего Android устройства.





С ящиком всё понятно, а чтобы узнать ID устройства, откройте звонилку на своём смартфоне и наберите *#*#8255#*#*





На появившемся экране необходимо найти строчку «Device ID:»





Идентификационным номером является комбинация букв и цифр, следующая после «android-». К примеру, если в строке вы видите «Device ID: android-1122aa33bb445577», то идентификатором является комбинация «1122aa33bb445577». Запишите эту комбинацию.





Если по каким-то причинам у вас не получилось узнать ваш Device ID указанным выше способом, вы можете просто скачать приложение [Device ID](https://play.google.com/store/apps/details?id=com.redphx.deviceid) в Google Play Store.





## 3. APK Downloader





Скачиваем расширение для браузера под названием APK Downloader ([прямая ссылка на загрузку расширения](http://codekiem.com/apk-downloader/crx/1.2.1.crx)).





В появившемся окне вводим адрес нашего Google аккаунта, то есть адрес почты. Пароль (ага, страшно), а также Device ID. После этого нажимаем «Login».





![](http://lifehacker.ru/wp-content/uploads/2012/05/c.png)



В следующем окне выбираем свою страну и оператора сотовой связи, после чего нажимаем «Save Settings». Далее должно появиться окно с сообщением о успешной активации расширения.





![](http://lifehacker.ru/wp-content/uploads/2012/05/d.png)



## 4. Google Play Store





Теперь заходим на наш любимый [Google Play Store](https://play.google.com/) и выбираем любое бесплатное приложение. В правой части адресной строки браузера появится характерного вида зелёная голова со стрелочкой.





![](http://lifehacker.ru/wp-content/uploads/2012/05/e.png)



Нажимаем на эту иконку, и приложение успешно загружается на компьютер в виде apk файла. По сути, теперь мы умеем создавать standalone дистрибутивы бесплатных приложений.





![](http://lifehacker.ru/wp-content/uploads/2012/05/f.png)



**Убедиться в абсолютной порядочности разработчика расширения APK Downloader не представляется возможным, поэтому вводите данные своего аккаунта на собственный страх и риск. Кроме того, подобные действия в принципе нарушают правила использования Google Play Store.**





Статья из сайта [lifehacker.ru](http://lifehacker.ru/2012/05/30/kak-vytashhit-apk-fajjl-iz-google-play-store/)
Всем привет.





Очень полезная статья, для тех кто активно использует маркет. И хочет что бы все программы устанавливались на телефон.





Зачастую разработчики помечают те или иные приложения в Google Play Store как несовместимые с некоторыми устройствами по причине нестабильной работы приложения на данной модели. Тем не менее, всегда есть шанс того, что на вашем устройстве приложение всё же заработает.





  <!-- more -->



Для владельцев рутованных Android есть простой способ обмануть Play Store, представив своё устройство в качестве другой модели, которая числится для конкретного приложения в списке поддерживаемых. Этот способ избавляет от возни с предварительным выкачиванием apk файла из самого маркета.





Итак, у нас есть рутованный Android. Скачиваем из Play Store любой файловый менеджер, который позволяет получить доступ к системным файлам, а также позволит редактировать их. Мы воспользовались приложением [ES File Explorer](https://play.google.com/store/apps/details?id=com.estrongs.android.pop). После установки приложения заходим в его настройки. Необходимо включить возможность доступа к рут-директории, а также установить возможность записи в файлы, находящиеся в этой директории.





![Как установить несовместимое приложение на Android](http://lifehacker.ru/wp-content/uploads/2012/06/screenshot-1340023180361.png)
![Как установить несовместимое приложение на Android](http://lifehacker.ru/wp-content/uploads/2012/06/screenshot-1340023094634.png)




Теперь идём в папку «system» и находим там файл «build.prop». Перед любыми манипуляциями такого рода лучше конечно забекапиться, а в данном случае хотя бы сделать копию «build.prop» файла куда-нибудь на карту памяти.





![Как установить несовместимое приложение на Android](http://lifehacker.ru/wp-content/uploads/2012/06/screenshot-1340023213651.png)



Открываем файл «build.prop» с помощью встроенного редактора ES проводника как текстовый файл.





![Как установить несовместимое приложение на Android](http://lifehacker.ru/wp-content/uploads/2012/06/screenshot-1340023259603.png)
![Как установить несовместимое приложение на Android](http://lifehacker.ru/wp-content/uploads/2012/06/screenshot-1340023243358.png)




Google Play идентифицирует устройство по данным, записанным в строчках «ro.product.model» и «ro.product.manufacturer». Остаётся лишь изменить значения этих параметров. В данном случае мы подменяем старенький Wildfire на Incredible. После этого нажимаем кнопку «Menu» и сохраняем внесённые изменения.





![Как установить несовместимое приложение на Android](http://lifehacker.ru/wp-content/uploads/2012/06/screenshot-1340023338036.png)
![Как установить несовместимое приложение на Android](http://lifehacker.ru/wp-content/uploads/2012/06/screenshot-1340023633575.png)


Осталось подчистить данные в самом приложении Google Play Store. Для этого заходим в менеджер приложений, находим там Play Store и чистим кэш и данные. После этого необходимо перезагрузить устройство.





![Как установить несовместимое приложение на Android](http://lifehacker.ru/wp-content/uploads/2012/06/screenshot-1340023695040.png)
![Как установить несовместимое приложение на Android](http://lifehacker.ru/wp-content/uploads/2012/06/screenshot-1340023711828.png)




Данный способ не позволит обойти ситуации, когда приложение несовместимо из-за разницы версий операционной системы, либо из-за страны проживания.





Статья из сайта [lifehacker.ru](http://lifehacker.ru/2012/06/19/kak-ustanovit-nesovmestimoe-prilozhenie-na-android/)
Всем привет.





Очень часто у разработчика встает вопрос - "Как же просмотреть какие запросы идут на сервер?".





Сегодня я постараюсь на него ответить.


 <!-- more -->


1. Для мониторинга трафика используйте программу [Fiddler](http://www.fiddler2.com/fiddler2/). Скачиваем и устанавливаем его.





2. Запускаем Fiddler. Заходим в Tools/Fiddler options/Connections. И ставим галочку "allow remote computers to connect". И перегружаем Fiddler.





![](http://android-helper.com.ua/images/uploads/2012/11/blog_fiddler.jpg)





3. Смотрим ваш внутренний IP адрес. Для этого открываем cmd и там пишем ipconfig





4. Для того что бы все работало. Компьютер и телефон должны быть в одной сети.





Не обязательно что бы ноутбук раздавал WiFi. У меня все работает через точку доступа.





5. Заходим в настройки WiFi. И прописываем прокси (IP вашего компьютера) и порт 8888 (такой как на картинке выше)





6. Наслаждаемся просмотром.





Короткий видео ролик, как это работает.

{% youtube Aoa38hbneSs %}


Сегодня просматривая свои записи, нашел интересную статью.





В этой статье автор описывает базовые компоненты android.





Думаю, что она будет интересна не только новичкам но и бывалым программерам, которые просто хотят освежить свои знания.





Тогда прошу к прочтению.


 <!-- more -->


Маленькая схема:





![](http://android-helper.com.ua/images/uploads/2012/10/f3ea651c-e042-4c34-b2fc-964b4cd7ae0f.png)








* Приложения для Android состоят из одного или нескольких компонентов: Activities (Деятельности), Services (Службы), Content Providers (Поставщики данных), а также Broadcast Receivers (Получатели широковещательных сообщений).  
  
* Каждый компонент выполняет свою роль в приложении и может быть активирован отдельно от других (причём активирован может быть даже сторонним приложением).  
  
* В AndroidManifest.xml (файл манифеста) должны быть объявлены все компоненты приложения и системные требования, такие как необходимая минимальная версия Android или определённая аппаратная конфигурация.  
  
* Необходимые для приложения ресурсы (изображения, файлы разметки, строки и т.д.) должны содержать альтернативные варианты для различных конфигураций устройств (например, строки на разных языков или различные разметки и изображения для возможных размеров экрана).  
  
  
Данный текст является переводом (хотя и немного вольным) статьи из [официальной документации по Android](http://developer.android.com/guide/topics/fundamentals.html).  
  
Примечание: некоторые слова в тексте оставлены по-английски, потому что, эти термины совпадают с названиями классов с помощью которых они реализуются и их перевод только усложняет понимание (в скобках написан их буквальный перевод).  
  
  
**Основы**  
Android-приложения написаны на языке программирования Java. Инструмент Android SDK (Software Development Kit — комплект разработки программного обеспечения) компилирует код вместе со всеми данными и файлами ресурсов в пакет Android - архивный файл с расширением .apk. Этот файл позволяет установить приложение на любом устройстве под управлением системы Android.  
  
После установки на устройстве, каждое приложение живёт в своей собственной изолированной программной среде:








  * Операционная система Android является многопользовательской Linux-системой, в которой каждое приложение это отдельный пользователь.



  * По умолчанию, система присваивает каждому приложению уникальный идентификатор пользователя userid (который используется только системой). Система устанавливает разрешения для всех файлов приложения таким образом, чтобы только определённый пользователь (с определённым userid) мог получить к ним доступ.



  * Каждый процесс имеет свою собственную виртуальную машину, так что код приложения запускается изолированно от других приложений.



  * По умолчанию каждое приложение выполняется в отдельном процессе Linux. Android начинает процесс, когда одному из компонентов приложения необходимо запуститься, а затем завершает процесс, когда он больше не нужен или когда системе требуется память для других приложений.






Таким образом, система Android реализует принцип наименьших привилегий. То есть, каждое приложение по умолчанию имеет доступ только к компонентам, которые необходимы для его работы и не более того. Однако, существуют способы обмена данными между приложениями и получения доступа к системным сервисам:








  * Возможно раздать двум приложениям одинаковые идентификаторы пользователей (userid), в этом случае они могут получить доступ к файлам друг друга. Для экономии системных ресурсов приложения с тем же идентификатором также могут быть запущены в одном процессе и использовать одну виртуальную машину. Такие приложения должны быть подписаны на один и тот же сертификат.



  * Приложение может запросить разрешение на доступ к системным данным, таким как контакты пользователя, SMS сообщения, карточка хранения (SD), камера, Bluetooth и многое другое. Все запросы доступа должны быть разрешены пользователем во время установки.






**Компоненты приложений **  
Компоненты — кирпичики, из которых состоит любое приложение. Каждый компонент предоставляет отдельную точку входа в приложение для системы, хотя не каждая такая точка является актуальной для пользователя. Компоненты могут зависеть друг от друга, но каждый из них это отдельная сущность, которая играет особую роль и помогает определить общее поведение приложения.   
  
Существуют четыре типа компонентов приложения. Каждый из них служит различным целям и имеет свой жизненный цикл, который определяет, как компонент создаётся и уничтожается.   
  
_**Activity (Деятельность)**_  
Activity представляет собой один экран с пользовательским интерфейсом. Например, приложение электронной почты, может иметь одну Activity, которая показывает список новых сообщений электронной почты, другую для создания нового сообщения, и ещё одну для чтения письма. Хотя все они работают вместе в рамках одного приложения, каждая из них независима от других. Таким образом, другие приложения могут вызвать любую из этих Activity (если почтовое приложение позволяет это). Например, приложение камеры может открыть Activity в которой создаётся новое сообщение, чтобы пользователь мог отправить фотографии по почте.   
  
_**Service (Служба)**_  
Service это компонент, который работает в фоновом режиме и не имеет пользовательского интерфейса. Службы используются для обработки длительных операций или для выполнения удалённых процессов. Например, Service может воспроизводить музыку в фоновом режиме или получать данные по сети, не блокируя взаимодействие пользователя с работающим приложением. Service могут запустить другие компоненты, например Activity, и затем взаимодействовать с ней.  
  
_**Content provider (Поставщик данных)**_  
Content provider управляет данными приложения. Данные можно хранить в файловой системе, базе данных SQLite, в Интернете или любом другом доступном для приложения месте хранения. Через Content providers другие приложения могут запрашивать или даже изменить данные (если на это есть права доступа). Например, в операционной системе Android существует Content provider, который управляет списком контактов пользователя. Таким образом, любое приложение, с соответствующими разрешениями могут запрашивать информацию о конкретном человеке для чтения или записи. Content provider также можно использовать для чтения и записи данных, которые доступны только для одного приложения.   
  
_**Broadcast receivers (Получатель широковещательных сообщений)**_  
Broadcast receiver - компонент, который позволяет принимать широковещательные сообщения операционной системы. Такими сообщениями являются, например, объявления о том, что экран выключился, батарея разряжена или был сделан фотоснимок. Такие сообщения также могут посылаться пользовательскими приложениями, например, уведомления о том, что некоторые данные были загружены и готовы к использованию. Хотя Broadcast receiver не имеют пользовательского интерфейса, он может создавать уведомления в строке состояния. Однако, чаще всего Broadcast receiver это просто "шлюз" для других компонентов, например, он может запускать Service для обработки определённых событий.   
  
Уникальной особенностью системы Android является то, что любое приложение может запустить компоненты другого приложения. Если необходимо дать пользователю возможность сделать фотографию, то не обязательно это реализовывать, можно вызвать уже существующее приложение. После завершения оно вернёт созданную фотографию в ваше приложение для дальнейшего использования. Для пользователя это будет выглядеть как одно приложение.   
  
Для запуска любого компонента операционная система начинает новый процесс (если его ещё не было) и инициализирует классы, необходимые для компонента. Например, если в вашем приложении запускается Activity для работы с камеры (принадлежащая стороннему приложению), то она запускается в отдельном процессе, который принадлежит этому стороннему приложению, а не в процессе вашего приложения. Поэтому, в отличие от приложений на большинство других систем, приложений Android не имеют единую точку входа (нет функции main()).   
  
Так как система запускает каждое приложение в отдельном процессе с правами доступа к файлам, которые ограничивают доступ для других приложений, ваше приложение не может непосредственно вызвать компонент из стороннего приложения. Однако, операционная система Android это может, поэтому для активации такого компонента, необходимо отправить сообщение операционной системе о своём намерении начать конкретный компонент и она его активирует.  
  
**Активация компонентов**  
Три из четырёх типов компонентов — Activity (деятельность), Service (сервис), а также Broadcast receivers (получатель широковещательных сообщений) — активируются с помощью асинхронного сообщения Intent (намерение). Intent связывает отдельные компоненты друг с другом во время выполнения, будь то компонент принадлежащий вашему приложению или другой.   
  
Intent (намерение) создаётся с помощью класса Intent, который описывает запрос на активацию конкретного компонента или конкретного типа компонента, соответственно Intent может быть явным или неявным.   
  
Для Activity и Service, Intent(намерение) определяет действие, которое надо выполнить (например, "Просмотреть" или "Отправить" что-то), и может указать URI (Uniform Resource Identifier — унифицированный идентификатор ресурса) данных необходимых для выполнения. Например, Intent может передать запрос Activity показать изображение или открыть веб-страницу.   
Для broadcast receivers Intent просто определяет транслируемые сообщения (например, широковещательное сообщения о том, что аккумулятор разряжен содержит только строковую константу обозначающую "батарея разряжена").   
Последний компонент - Content provider не активируется с помощью Intent. Хотя он и может вызывается, если Content provider запрашивает данные из ContentResolver.   
  
Методы для активации каждого типа компонентов:








  * Для запуска Activity используются методы startActivity(Intent intent) или startActivityForResult(Intent intent) (если необходимо вернуть результат).



  * Для запуска Service вызывается метод startService (Intent service).



  * Для запуска Broadcast reciever — sendBroadcast(Intent intent), sendOrderedBroadcast(Intent intent, String receiverPermission), или sendStickyBroadcast(Intent intent).



  * Для формирования запроса для Content Provider используется метод query ()






**Файл манифеста **  
Перед запуском любого компонента операционная система Android читает файл манифеста приложения AndroidManifest.xml, чтобы убедиться, что запускаемый компонент существует. В этом файле должны быть объявлены все компоненты приложения, которые находятся в корневой папке приложения.  
  
Кроме этого манифест-файл выполняет другие функции:








  * Определяет пользовательские разрешения, такие как доступ в Интернет или чтение контактов.



  * Объявление минимального API уровня (версии Android), необходимого для приложения.



  * Объявление аппаратных и программных требований, такие как камера, Bluetooth, или мультитач экран.



  * API библиотек с которыми приложение будет связываться, например библиотеки Google Maps.






Но все же основная задача манифеста сообщить системе о компонентах приложения. Например, можно объявить Activity (деятельность) следующим образом:







	<?xml version="1.0" encoding="utf-8"?>  
	<manifest ... >  
		<application android:icon="@drawable/app_icon.png" ... >  
			<activity android:name="com.example.project.ExampleActivity"  
			android:label="@string/example_label" ... >  
			</activity>  
		</application>  
	</manifest>  








В элементе <application> атрибут Android:icon указывает на ресурсы для иконки приложения.  
  
В элементе <activity> атрибут Android:name определяет полный путь на имя класса Activity (деятельности), а атрибут Android:label задаёт заголовок приложения.   
  
Для определения компонентов используются:  
<activity> для Activity (деятельности)  
<service> для Service (сервисы)  
<receiver> для Broadcast reciever (получатели широковещательных сообщений)  
<provider> для Content providers (поставщики данных)  
  
Activity (деятельность), Service (сервис) и Content provider (поставщики данных), которые существуют в исходниках, но не заявлены в манифесте не видны системе и, следовательно, не смогут запуститься. Однако, Broadcast provider (получатель широковещательных сообщений) может создаваться динамически в коде (как объекты BroadcastReceiver) и регистрироваться с помощью вызова registerReceiver ().   
  
**Объявление возможностей компонента**  
Как уже говорилось в разделе «Активация компонентов», для вызова Activity (деятельность), Service (сервис) и Broadcast receiver (получатель широковещательных сообщений) можно использовать класс Intent. Сделать это можно явно, задав конкретное имя компонента, или не явно, а этом случае описывается только тип действия, который нужно выполнить (и, возможно, данные, необходимые для него). Система сама находит компонент устройства, который может выполнить действия и запускает его. Если найдено несколько подходящих компонентов, то пользователь выбирает, какой из них использовать.   
  
Система определяет компоненты, которые могут реагировать на намерение путём сравнения полученного Intent (намерения), с Intent filters (фильтр намерений), определённых в файлах манифеста других приложений.   
  
При объявлении компонента в файле манифеста, можно дополнительно включить фильтр намерений, которые заявляют возможности компонента, чтобы он мог реагировать на запросы из других приложений. Для объявления фильтра намерения используется элемент <intent-filter>.   
  
Например, приложение электронной почты с Activity (деятельностью) для создания новых сообщений может объявить Intent filter (фильтр намерения) в своём файле манифеста запускаться на запрос "send" (отправить). Activity (деятельность) в стороннем приложении создаёт Intent (намерение) с типом действия "send" (ACTION_SEND), которое система сопоставит с приложением электронной почты и запустит нужную Activity (деятельность).  
  
**Объявление требований приложений **  
Существует большое количество устройств, работающий под управлением системы Android, однако, не все они обеспечивают одинаковые функции и возможности. Чтобы не позволить установить приложение на устройство, в котором отсутствуют необходимые функции, необходимо объявить аппаратные и программные требования в файле манифеста. Большинство из этих заявлений существуют исключительно для ознакомления и система не читает их, однако внешние сервисы, таких как Android Market используют их, чтобы обеспечить фильтрацию для пользователей, которые ищут приложения для своего устройства.   
  
Например, если приложение требует камеру и использует API, введённые в Android версии 2.1 (API уровень 7), надо записать эти требования в файл манифеста. Таким образом, устройства, которые не имеют камеру или с версией Android ниже, чем 2.1 не смогут установить приложение из Android Market.   
  
Однако, приложение может использовать камеру, но но это требование не является критичным для его работы. В этом случае приложение должно выполнять проверку во время выполнения, чтобы отключить функции, использующие камеру.   
  
При проектировании и разработке приложения, необходимо учитывать:   
  
_**Размер экрана и плотность**_  
Android определяет две характеристики экрана для устройства: размер экрана (физические размеры экрана) и плотность (плотность пикселей на экране, или dpi (dots per inch - точек на дюйм). Для упрощения Android обобщает их в отдельных группы  
  
Размер: small (маленький), normal (средний), large (большой), and extra large (очень большой).   
Плотность: low density (низкая), medium density (средняя), high density (высокая), and extra high density (очень высокая).   
  
По умолчанию, приложение совместимо со всеми размерами экрана, так как система Android делает необходимые изменения пользовательского интерфейса и изображений. Однако, лучше создать специализированные макеты и изображения для определённых размеров и плотностей и объявить в манифесте, какие именно размеры экрана приложение поддерживает в элементе <supports-screens>.  
  
_**Средства ввода **_  
Устройства могут иметь различные средства для ввода, такие как аппаратная клавиатура, трекбол или джойстик. Если приложение требует определённое оборудование для ввода, то необходимо объявить это в манифесте в элементе <uses-configuration>. Однако, в большинстве случаев приложения поддерживают любое средство ввода.  
  
_**Аппаратные требования**_  
Не все аппаратные или программные функции, таких как камера, датчик освещённости, Bluetooth или сенсорный экран, могут существовать на конкретном устройстве, поэтому необходимо декларировать любые функции, используемые приложения в элементе .   
  
_**Версия платформы **_  
Устройства работают на разных версиях платформы Android. Каждая последующая версия часто включает в себя дополнительные интерфейсы API, которые не доступны в предыдущей версии. Для того, чтобы указать, какой набор API-интерфейсов доступен, каждой версии платформы соответствует API уровень (например, Android 1.0 — 1 уровень API, Android 2.3 — 9 уровень). Если в приложении используются API, которые были добавлены к платформе после определённой версии, необходимо объявить минимальный уровень API с помощью элемента <uses-sdk>.  
  
**Ресурсы приложения **  
Приложения Android состоят не только из исходного кода, но также из ресурсов для визуального представления, такие как изображения или звуковые файлы. Для приложения необходимо определить меню, стили, цвета и разметку пользовательского интерфейса в файлах XML. Использование ресурсов даёт возможность изменять некоторые части приложения без модификации исходного кода, а также позволяет оптимизировать приложение для различных устройств (с различным языком интерфейса или размером экрана).   
  
Для каждого ресурса, включённого в проект Android, SDK определяет уникальный идентификатор (целое число), которое можно использовать для ссылки на ресурс из кода или из других ресурсов определённых в XML. Например, если приложение содержит изображение с именем logo.png (сохранённое в директории res/drawable), SDK сгенерирует идентификатор ресурса R.drawable.logo, которое можно использовать для ссылки на изображение.   
  
Главным достоинством отдельного хранения исходного кода и ресурсов является возможность создать разные ресурсы для разных аппаратных конфигураций. Например, строки интерфейса для разных языков можно определять в различных xml файлах (они хранятся например в директории res/values-fr/ для французского языка). В зависимости от выбранного пользователем языка система Android подставляет нужные строки в интерфейс.   
  
Android поддерживает множество классификаторов для альтернативных ресурсов. Классификатор это короткая строка в название директории ресурсов для определения когда эти ресурсы должны быть использованы. Часто создаются различные схемы интерфейса для разных размеров и ориентаций экранов устройства. Например, при портретной ориентации кнопки удобнее разместить по вертикали, а для альбомной ориентации - по горизонтали. Чтобы изменить расположение в зависимости от ориентации, можно определить две различные схемы и добавить соответствующие классификаторы к имени каталога каждого макета. Тогда, система автоматически применяет соответствующий макет в зависимости от текущей ориентации устройства.
Из последних новостей





Предлагаем вашему вниманию очередную подборку с ссылками на новости, интересные материалы и полезные ресурсы.  
![](http://habrastorage.org/storage2/c71/e2a/256/c71e2a2564068940c470cc5397ef9c49.png)  



<!-- more -->


### Горячая семерка














![](http://habrastorage.org/storage2/b7a/e2c/aa8/b7ae2caa8cf07084bbf46d89a8fbe15d.png)







### Прошедшие и будущие мероприятия октября














18 октября в Киеве [стартовала международная конференция IDCEE](http://habrahabr.ru/post/155337/), а сегодня [были названы победители конкурса стартапов](http://ain.ua/2012/10/19/98741). Недавно прошла Fronteers 2012 — лучшая конференция по клиентской разработке, с отчетом можно ознакомиться [здесь](http://tohtml.it/post/33822898596/fronteers2012). Также, на прошлой неделе проходила YAC, с которой уже стали доступны [видео докладов](http://events.yandex.ru/events/yac/2012/talks/#frontend). Кроме этого, намечается парочка интересных мероприятий: [Apple «покажет что-то» 23-го октября](http://www.overclockers.ru/hardnews/50140/Priglasheniya_na_meropriyatie_Apple_namechennoe_na_23_oktyabrya_uzhe_razoslany.html), а в конце месяца [Google скорее всего покажет новую версию Android](http://www.youhtc.ru/2012/10/novaya-versiya-android-v-konce-oktyabrya/)














![](http://habrastorage.org/storage2/247/739/e1b/247739e1b416af62303f69a48a14a456.png)







### Bootstrap














Проект Bootstrap продолжает оставаться в тренде среди веб-разработчиков. Отличную подборку всякого полезного для него можно найти в [этой статье](http://habrahabr.ru/post/154687/). Кроме этого, желающие могут ознакомиться с туториалом по созданию [адаптивной темы для WordPress с помощью Bootstrap](http://blog.teamtreehouse.com/responsive-wordpress-bootstrap-theme-tutorial)














![](http://habrastorage.org/storage2/262/844/666/26284466663a6ef243e812b97e20fd6c.png)







### Internet Explorer 10














Интересная статья, [где подробно можно прочесть о том, чего стоит ожидать от нового IE10](http://www.mobilexweb.com/blog/windows-8-surface-ie10-html5). А [здесь](http://timkadlec.com/2012/10/ie10-snap-mode-and-responsive-design/) можно ознакомиться с нюансами работы Responsive Design в Snap Mode. Плюс, ожидаем [предварительную верси. IE10 для Windows 7 к середине ноября](http://viennaos.net/articles/3252-predvaritelnaya-versiya-interner-explorer-10-poyavitsya-v-seredine-noyabrya.html)














![](http://habrastorage.org/storage2/084/60e/6e4/08460e6e482449212a697b8062ac9df8.png)







### Расширяем CSS














Препроцессоры становятся все популярней. [Эта статья покажет](http://ianstormtaylor.com/oocss-plus-sass-is-the-best-way-to-css/), на сколько гибкими могут стать таблицы стилей с использованием OOCSS + Sass. [Здесь можно посмотреть, как с помощью несложного SCSS-миксина грузить изображения для ретина-дисплеев](http://37signals.com/svn/posts/3271-easy-retina-ready-images-using-scss). Те, кто хорошо воспринимает на слух англоязычную информацию, могут открыть для себя [SassCast](http://sasscast.tumblr.com/) — подкаст на тему Sass. Ну, и напоследок загляните в[sassmeister](http://sassmeister.com/) — песочницу для работы с Sass/SCSS














![](http://habrastorage.org/storage2/1b4/866/b43/1b4866b439d67c0d8575aebf831026db.png)







### [Учебник jQuery для начинающих](http://habrahabr.ru/post/155107/)














Многие, кто начинал учить jQuery по русскоязычным ресурсам, не могли обойти стороной [сайт](http://anton.shevchuk.name/) Антона Шевчука, а некоторые даже начинали изучение со статей на этом сайте. Антон решился и [собрал все свои статьи из серии «jQuery для начинающих»](http://habrahabr.ru/post/155107/) в одном учебнике, который и представил на суд общественности.














![](http://habrastorage.org/storage2/f6f/062/60d/f6f06260dd80d8d31e7c4e107b461a43.png)







### Surface на подходе














[Microsoft раскрыла цены на Surface RT](http://habrahabr.ru/post/155001/) в [официальном магазине](http://surface.microsoftstore.com/store/msstore/Content/pbpage.Surface), по итогам чего [младшая модель Surface была распродана за сутки](http://itc.ua/news/microsoft-rasprodala-po-predvaritelnyim-zakazam-vse-planshetyi-surface-rt-tsenoy-499/). Тем временем Microsoft запускает на ТВ [новую рекламу Microsoft Surface](http://wpos.com.ua/microsoft-zapuskaet-na-tv-novuyu-reklamu-microsoft-surface.html) и[первый рекламный ролик Windows 8](http://www.3dnews.ru/software-news/636608/)














![](http://habrastorage.org/storage2/d6f/a12/f9c/d6fa12f9c1b7ef2e341b0771182a3a23.png)







### [Google StreetView приглашает побродить в одном из их датацентров](http://gagadget.com/other/2012-10-18-google_streetview_priglashaet_pobrodit_v_odnom_iz_ikh_datatsentrov)














В Google решили показать один из своих датацентров, находящийся в городе Ленуар. Теперь многие смогут убедиться, что креативные идеи в оформлении помещений айтишного гиганта используются не только в рабочих офисах и комнатах отдыха, но и в теж же датацентрах  
  






### ![](http://habrastorage.org/storage2/ba6/1d0/aa9/ba61d0aa90be53f9f7f44faeabb67e78.gif) Разработка












  * [Видео докладов c последнего YAC](http://events.yandex.ru/events/yac/2012/talks/#frontend)



  * [Подборка полезного для любителей Twitter Bootstrap](http://habrahabr.ru/post/154687/)



  * [Новая статья от Chris Coyier на smashingmagazine:](http://coding.smashingmagazine.com/2012/10/15/css-qa-4/) SVG Fallback, Vertical Rhythm, CSS Project Structure ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Нативная клиентская валидация для веб форм средствами браузеров](http://www.html5rocks.com/en/tutorials/forms/constraintvalidation/). Хорошо расписаны основные проблемы, возникающие при использовании html5 в формах для валидации ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Эффект разворачивания бумажной открытки](http://tympanus.net/Development/PFold/index3.html) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [LearnStreet — новый проект для интерактивного изучения JavaScript, Python, Ruby (в стиле CodeAcademy и khanacademy)](http://www.learnstreet.com/lessons/languages/javascript) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Создание параллакс-эффекта на примере простого урока](http://net.tutsplus.com/tutorials/html-css-techniques/simple-parallax-scrolling-technique/) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Как создать адаптивную тему для WordPress с помощью Bootstrap](http://blog.teamtreehouse.com/responsive-wordpress-bootstrap-theme-tutorial) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Как сделать Lazy-Loading для изображений на сайте](http://speckyboy.com/2012/10/18/how-to-create-lazy-loading-images-for-your-website/) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Использование мета тега viewport в неадаптивных шаблонах (перевод)](http://ruseller.com/lessons.php?rub=2&id=1560)



  * [Строим радиальный градиент средствами HTML5](http://www.script-tutorials.com/html5-radial-gradient/) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [HTML5 media and data URIs](http://www.iandevlin.com/blog/2012/09/html5/html5-media-and-data-uri) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [fbootstrapp](http://ckrack.github.com/fbootstrapp/) — фреймворк на основе bootstrap для создания iframe-приложений под фейсбук ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Подготовка к верстке адаптивных сайтов](http://davidwalsh.name/responsive-css) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Как переделать jQuery accordion на такой же, но на CSS3](http://www.script-tutorials.com/turn-jquery-accordion-into-css3-accordion/) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Sciter — встраиваемый HTML/CSS/scripting engine](http://habrahabr.ru/post/154697/)



  * [Готовим Sublime Text 2 для front-end](http://habrahabr.ru/post/154667/)



  * [SassCast](http://sasscast.tumblr.com/post/33342368483/in-this-episode-of-sasscast-we-sat-down-with-the) — подкаст, где ведущие разговаривают о Sass с Крисом Койером ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)










### ![](http://habrastorage.org/storage2/37d/ecd/fa7/37decdfa7563eab84a2a41fbf4690320.gif) CSS












  * [box-shadow vs. drop-shadow filter: полное сравнение](http://demosthenes.info/blog/598/boxshadow-property-vs-dropshadow-filter-a-complete-comparison) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Кнопки в Metro-стиле стиле Microsoft Windows 8 на CSS3](http://ace-subido.github.com/css3-microsoft-metro-buttons/index.html) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Ryan Seddon (css ninja) делится секретами работы с checkbox-ами](http://thecssninja.com/talks/ridiculous_checkboxes/) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [OOCSS + Sass = The best way to CSS](http://ianstormtaylor.com/oocss-plus-sass-is-the-best-way-to-css/) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Нестандартный подход к media queries](http://www.the-haystack.com/2012/10/17/nesting-media-queries/) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Flexbox – быстрый путь к раскладочному блаженству?](http://css-live.ru/articles/flexbox-bystryj-put-k-raskladochnomu-blazhenstvu.html)



  * [Загружаем изображения для ретина-дисплеев с помощью SCSS](http://37signals.com/svn/posts/3271-easy-retina-ready-images-using-scss) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Короткое видео на тему «Multiple Background Images with CSS»](http://blog.teamtreehouse.com/quick-tip-multiple-background-images-with-css) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Вращающееся меню на CSS](http://ruseller.com/lessons.php?rub=2&id=1563)










### ![](http://habrastorage.org/storage2/d72/076/bca/d72076bca6f7545c0633a6c4419d317c.gif) JavaScripts












  * [Pikaday](http://dbushell.com/2012/10/09/pikaday-javascript-datepicker/) — компонент для выбора даты ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [kwicks](http://devsmash.com/projects/kwicks) — симпатичный аккордеон ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [полезный апгрейд для табов на jQuery ui](http://jsfiddle.net/jasonday/fdhaS/embedded/result/)



  * [Учебник jQuery для начинающих](http://habrahabr.ru/post/155107/)



  * [Загрузчик модулей RequireJS](http://stepansuvorov.com/blog/2012/10/%D0%B7%D0%B0%D0%B3%D1%80%D1%83%D0%B7%D1%87%D0%B8%D0%BA-%D0%BC%D0%BE%D0%B4%D1%83%D0%BB%D0%B5%D0%B9-requirejs/)










### ![](http://habrastorage.org/storage2/7bc/3d0/d88/7bc3d0d883a49a00265feb7836c802aa.gif) Браузеры












  * [Предварительная версия IE10 для Windows 7 появится в середине ноября](http://viennaos.net/articles/3252-predvaritelnaya-versiya-interner-explorer-10-poyavitsya-v-seredine-noyabrya.html)



  * [Подробно о том, чего ожидать от нового IE10](http://www.mobilexweb.com/blog/windows-8-surface-ie10-html5), а также о том, [как в нем работает Responsive Design](http://timkadlec.com/2012/10/ie10-snap-mode-and-responsive-design/) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Internet Explorer для Xbox](http://habrahabr.ru/post/155073/)



  * [Проект Mozilla начал тестирование каталога приложений Firefox Marketplace для платформы Android](http://www.opennet.ru/opennews/art.shtml?num=35126)










### ![](http://habrastorage.org/storage2/63c/872/b21/63c872b219c18a3947a9d98a6bb6a345.gif) Новости












  * [Касперский работает над собственной ОС](http://eugene.kaspersky.ru/2012/10/16/secure-os-for-industrial-control-system-scada/)



  * [Apple приглашает на мероприятие, намеченное на 23 октября](http://www.overclockers.ru/hardnews/50140/Priglasheniya_na_meropriyatie_Apple_namechennoe_na_23_oktyabrya_uzhe_razoslany.html)



  * [IDCEE 2012 — день первый](http://habrahabr.ru/post/155337/)



  * [Названы победители конкурса стартапов на IDCEE-2012](http://ain.ua/2012/10/19/98741)



  * [В персональной поисковой выдаче Google появятся личные документы пользователя](http://habrahabr.ru/post/154949/)



  * [Google анонсировала новый Chromebook с чипом ARM по цене $249](http://itc.ua/news/google-anonsirovala-novyiy-chromebook-s-chipom-arm-po-tsene-249/)



  * [YouTube отказался от подсчета кликов для рейтинга популярности](http://habrahabr.ru/post/154671/)



  * [Google StreetView приглашает побродить в одном из их датацентров](http://gagadget.com/other/2012-10-18-google_streetview_priglashaet_pobrodit_v_odnom_iz_ikh_datatsentrov)



  * [Квартальный доход Microsoft достиг $16 млрд](http://itc.ua/news/kvartalnyiy-dohod-microsoft-dostig-16-mlrd/)



  * [Только ASUS и сама Microsoft осуществят 25 октября запуск планшетов Windows RT](http://www.3dnews.ru/news/636653/)



  * [Microsoft сообщила стоимость Surface RT на официальном сайте: от $500](http://habrahabr.ru/post/155001/), по итогам чего [младшая модель Surface была распродана за сутки](http://itc.ua/news/microsoft-rasprodala-po-predvaritelnyim-zakazam-vse-planshetyi-surface-rt-tsenoy-499/)



  * [Число одновременных пользователей Skype недавно превысило 45 млн](http://www.towave.ru/news/kolichestvo-polzovatelei-skype-prevysilo-45-mln-issledovanie.html)



  * [Проект Mozilla выпустил язык программирования Rust 0.4](http://www.opennet.ru/opennews/art.shtml?num=35097)










### ![](http://habrastorage.org/storage2/eb8/00e/9ef/eb800e9ef3b0e10e217087ef742628a3.gif) Сервисы












  * [Cacoo — сервис для создания диаграмм, вайрфреймов и т.д.](https://cacoo.com/) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [webink fontdropper — сервис-букмарклет, позволяющий применить к тексту любого сайту любой шрифт из целого набор библиотеки компании webink](http://www.webink.com/fontdropper) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Japonizer — генератор настраиваемых фоновых текстур в традиционном японском стиле](http://wanokoto.net/japonizes) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [sassmeister — песочница для работы с Sass](http://sassmeister.com/) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Сервис от Lea Verou для настройки контраста по стандартам WCAG 2.0](http://leaverou.github.com/contrast-ratio/) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)










### ![](http://habrastorage.org/storage2/eb8/00e/9ef/eb800e9ef3b0e10e217087ef742628a3.gif) Demo












  * [Atari перевели некоторые игры на HTML5](http://www.atari.com/arcade) и [как это происходило](http://youtu.be/J6QXRFuUSZs)










### ![](http://habrastorage.org/storage2/be5/3e4/256/be53e4256e771ad12bc412af8b30f91e.gif) Сайты с интересным дизайном и функциональностью












  * [Бодрый сайт-портфолио с простыми но эффектными анимационными переходами](http://www.worstprod.com/)



  * [exitzeroproject.org](http://www.exitzeroproject.org/) — современный сайт с нестандартной навигацией



  * [занимательный с любой точки зрения сайт](http://www.moma.org/interactives/exhibitions/2012/centuryofthechild/)



  * [woodwork.nl](http://woodwork.nl/) — сайт, где навигация выполнена в стиле sliding doors



  * [http://kikk.be/2012](http://kikk.be/2012/home.htm?lng=en/) — сайт для вестивая KIKK с симпатичным дизайном и интересной функциональностью










### ![](http://habrastorage.org/storage2/be5/3e4/256/be53e4256e771ad12bc412af8b30f91e.gif) Дизайн












  * [Evolution of Apple Ads 1975-2002](http://www.retronaut.co/2011/10/evolution-of-apple-ads-1975-2002/) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Скрытый смысл в действительно хороших логотипах](http://www.webdesignerdepot.com/2012/10/the-hidden-meaning-behind-really-good-logos/) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Mobile Design Details: Pull to Refresh](http://www.lukew.com/ff/entry.asp?1643) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Retro Style in Web Design](http://www.splashnology.com/article/retro-style-in-web-design/6771/) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Десять трюков для успешного создания меню в сайтах с адаптивным (responsive) дизайном](http://blog.usabilla.com/10-tips-how-to-handle-responsive-navigation-menus-successfully/) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Очень наглядный урок о создании бесшовной текстуры в фотошопе](http://www.proworks.com/blog/2012/10/18/how-to-create-a-seamless-pattern-in-photoshop/) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Создание в фотошопе 3D текста с креативным эффектом](http://www.webdesignfact.com/2012/10/photoshop-tutorial-3d-text-effects.html) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Создание разбалансированности: использование асимметрии в веб-дизайне](http://tympanus.net/codrops/2012/10/18/creating-off-center-balance-using-asymmetry-in-web-design/) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Новые техники кадрирования в фотошопе последней версии «Crop Until You Drop»](http://psd.tutsplus.com/tutorials/tools-tips/crop-until-you-drop/) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Тест на знание Photoshop CS6](http://psd.tutsplus.com/articles/quizzes/test-your-photoshop-cs6-knowledge-4/) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Техники UI при создании успешных цифровых продуктов](http://dzineblog.com/2012/10/user-interface-techniques-for-creating-successful-digital-products.html) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)










### ![](http://habrastorage.org/storage2/be5/3e4/256/be53e4256e771ad12bc412af8b30f91e.gif) Подборка бесплатных дизайнерских печенек












  * [Пять десятков шрифтов: от Sacred Place и до Kenyan Coffee](http://www.antsmagazine.com/fonts/50-fresh-free-fonts-for-download/) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Три с половиной десятка декоративных шрифтов: от Astonished в стиле гранж и до рукописного BudHand](http://www.1stwebdesigner.com/freebies/35-cool-free-fonts/) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Пакет из одиннадцати хэллоуниских шрифтов](http://www.pvmgarage.com/2012/10/11-free-creepy-halloween-fonts/) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Необычный декоративный шрифт без засечек Slinkster, в котором буквы создаются окружностями задающими форму](http://www.myfonts.com/fonts/will-ryan/slinkster/) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Исходники в PSD-формате различных вертикальных меню](http://designerves.com/article/free-vertical-menu-psd-files/) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [PSD с UI для веб-дизайна в золотых цветах с темным фоном](http://www.pixel-fabric.com/dark-gold-ui-kit-4) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Набор различных переключателей в PSD](http://www.graphicsfuel.com/2012/10/toggle-switches-ui-elements-psd/) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [За подписку предлагается пакет с iPhone UI темой для быстрого создания приложений](http://medialoot.com/item/free-iphone-app-template-appview/) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Хорошо структурированная 55Мб PSD-шка «iOS 6 iTunes & App Store GUI»](http://playground.christophebeghin.fr/ios6/) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Пакеты с Photoshop Actions для создания винтажных фото-эффектов](http://www.1stwebdesigner.com/freebies/40-free-photoshop-actions-vintage-effect/) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)










### ![](http://habrastorage.org/storage2/cc0/d6f/fe8/cc0d6ffe8d4e924a9bf96ab304d98fa0.gif) Занимательное












  * [Впечатляющая инфографика: Свежий взгляд на HTML5](http://www.script-tutorials.com/infographic-a-fresh-look-at-html5/) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Несколько интересных особенностей Windows 8](http://habrahabr.ru/post/155379/)



  * [Fronteers 2012 — лучшая конференция по клиентской разработке, часть 1](http://tohtml.it/post/33822898596/fronteers2012)



  * [diy.org — образовательный портал для детей и не только, которые хотят что либо сделать](https://diy.org/) ![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Подборка сервисов для расширения возможностей вашего Dropbox](http://habrahabr.ru/post/154993/)



  * [10 наиболее активных стран в Facebook](http://ain.ua/2012/10/16/98309)



  * [Акустический штрих-код прост и универсален](http://www.3dnews.ru/news/636640/)



  * [Три рекламных ролика ASUS PadFone 2](http://www.3dnews.ru/news/636704/)



  * [Уличная реклама Microsoft Surface появилась и во Франции — намёк на запуск в Европе](http://www.3dnews.ru/news/636600/)



  * [Internet Explorer 9 Commercial (Google Chrome Version) ](http://www.youtube.com/watch?v=J-HieaOI00s&feature=player_embedded)![](http://habrastorage.org/storage2/7c9/add/77b/7c9add77b3d706b394bcc16238e762f1.gif)



  * [Видео дня: первая телевизионная реклама Microsoft Surface](http://wpos.com.ua/microsoft-zapuskaet-na-tv-novuyu-reklamu-microsoft-surface.html) и [первый рекламный ролик Windows 8](http://www.3dnews.ru/software-news/636608/)






  
  
[Ссылка](http://habrahabr.ru/company/zfort/blog/154633/) на дайджест за прошлую неделю.  
Материал подготовили [dersmoll](http://habrahabr.ru/users/dersmoll/) и [alekskorovin](http://habrahabr.ru/users/alekskorovin/)





Статья из сайта [habrahabr.ru](http://habrahabr.ru/company/zfort/blog/155431/)





От себя хочу выразить благодарность за такой труд.
Добрый день друзья.





Я думаю, что каждый разработчик стыкаеться с вопросом проектирования дизайна приложения.





Но как часто бывает, что рисовать на бумаге намного быстрее и удобнее.





Чем использовать фотошоп или другие программы.


<!-- more -->


Сегодня я нашел отличные PDF файлы для этого. С готовыми макетами, для этих целей.





Вот вам ссылка на сайт [http://interfacesketch.tumblr.com/](http://interfacesketch.tumblr.com/)

Надеюсь вам понравилось.


Оставляйте свои комментарии и подписывайтесь на рассылку.




Всем привет.





С вами снова я. И сегодня мы поговорим, как показывать HTML код в TextView.





Если все готовы. Тогда приступим.


<!-- more -->


Вам необходимо вызвать функцию:







	TextView txtView = new TextView(this);

	Spanned s = Html.fromHtml("Android - это супер <font color=\"red\">android-helper.com.ua</font>");

	txtView.setText(s);









Вот полный код:






	public class TestActivity extends Activity {

 

    @Override

    public void onCreate(Bundle savedInstanceState) {

        super.onCreate(savedInstanceState);

        TextView txtView = new TextView(this);

        Spanned s = Html.fromHtml("Android - это супер <font color=\"red\">android-helper.com.ua</font>");

        txtView.setText(s);

 

        setContentView(txtView);

    }

	}







Все готово. Теперь можете наслаждаться.





Но нужно помнить, что так можно отформатировать не все HTML теги.





Вот список тегов, которые поддерживает класс **Html**.








  * a href="...",



  * b,



  * big,



  * blockquote,



  * br,



  * cite,



  * dfn,



  * div align="...",



  * em,



  * font size="..." color="..." face="...",



  * h1-h6,



  * i,



  * img src="...",



  * p,



  * small,



  * strike,



  * strong,



  * sub,



  * sup,



  * tt,



  * u



Добрый день друзья.





Сегодня один из моих товарищей, посоветовал один хороший сайт.





Некоторые материалы, я буду брать от туда.





Сегодня я бы хотел поделиться информацией о Screen Density и чем отличаются dp от px.


<!-- more -->


Прошу к прочтению. Оригинал статьи [тут](http://startandroid.ru/materialy/pamjatka/40-edinitsy-izmerenija-chem-otlichaetsja-dp-dip-ot-px-screen-density.html).





Для указания ширины, высоты и отступов View-элементов используются различные [единицы измерения](http://developer.android.com/guide/topics/resources/more-resources.html#Dimension) (ЕИ):





**dp** или **dip** - Density-independent Pixels. Абстрактная ЕИ, позволяющая приложениям выглядеть одинаково на различных экранах и разрешениях.





**sp** - Scale-independent Pixels. То же, что и dp, только используется для размеров шрифта в View элементах





**pt** - 1/72 дюйма, определяется по физическому размеру экрана. Эта ЕИ [из типографии](http://en.wikipedia.org/wiki/Point_(typography)).





**px** – пиксел, не рекомендуется использовать т.к. на разных экранах приложение будет выглядеть по-разному.





**mm** – миллиметр, определяется по физическому размеру экрана





**in** – дюйм, определяется по физическому размеру экрана





Давайте разбираться, чем они отличаются друг от друга.





in, mm и pt – неизменны относительно друг друга. Всегда **1 in = 25,4 mm** и **1 in = 72 pt**. Это классические единицы измерения. Т.е. задаете, например, кнопке ширину = 1 in и она должна отобразиться шириной в один дюйм, независимо от разрешения и диагонали экрана.





Что такое px, думаю, тоже понятно. Если у вас есть устройство с экраном шириной 480 px и вы создали кнопку шириной 240 px, то эта кнопка займет в ширину ровно пол-экрана. Но если вы откроете ваше приложение на устройстве с экраном с меньшим разрешением, то соотношение  изменится, например:  
- если разрешение 320х240, ширина экрана = 240 px. Кнопка займет уже не пол-экрана в ширину, а весь экран  
- если же разрешение 1280х800, ширина = 800 px. Кнопка опять же будет занимать в ширину не пол-экрана, а чуть меньше трети





![](http://android-helper.com.ua/images/uploads/2012/09/20110811_L0007_L_differentResolutions.jpg)





А ведь экран приложения – это обычно не одна кнопка, а набор из многих элементов и все они будут расползаться или сжиматься на разных разрешениях. Поэтому использовать px при разработке НЕ рекомендуется.





Для того, чтобы избежать таких ситуаций на разных разрешениях рекомендуется использовать dp (и sp). Его можно определить, как масштабируемый px. За степень масштабируемости отвечает **[Screen Density](http://developer.android.com/guide/practices/screens_support.html)**. Это коэффициент, который используется системой для вычисления значения dp.  На текущий момент есть 5 значений этого коэффициента:  
- low (**ldpi**) = 0,75  
- medium (**mdpi**) = 1  
- tv (**tvdpi**) = 1,33  
- high (**hdpi**) = 1,5  
- extra high (**xhdpi**) = 2





Т.е. когда для экрана стоит режим **mdpi**, то **1 dp = 1 px**. Т.е. кнопка шириной 100 dp будет выглядеть также как и кнопка шириной 100 px.





Если, например, у нас экран с низким разрешением, то используется режим **ldpi**. В этом случае **1 dp = 0,75 px**. Т.е. кнопка шириной 100 dp будет выглядеть так же как кнопка шириной 75 px.





Если у нас экран с высоким разрешением, то используется режим **hdpi **или **xhdpi**. **1 dp = 1, 5 px** или **2 px**. И кнопка шириной 100 dp будет выглядеть так же как кнопка шириной 150 px или 200 px.





Т.е. при различных разрешениях используются различные Density режимы, которые позволяют приложениям масштабироваться и выглядеть если не одинаково, то, по крайне мере, похоже на всех экранах.





Рассмотрим пример. Предположим у нас есть три устройства (характеристики реальны и взяты из спецификаций):





HTC **Wildfire **S: 3,2 inch, 480x320 px, 180 dpi  
HTC **Desire**: 3,7 inch, 800x480 px, 252 dpi  
HTC **Flyer**: 7 inch, 1280x800 px, 170 dpi





Я создам такой экран:





![](http://android-helper.com.ua/images/uploads/2012/09/20110811_L0007_L_DesireScreen.jpg)





Это несколько кнопок, в которых ширина и размер шрифта определены с использованием разных единиц измерения. На каждой кнопке для наглядности я написал ее ширину (**layout_width**) и размер шрифта (**textSize**) через запятую. Обратите внимание, что ширина всех кнопок кроме последней одинакова. Так происходит потому, что 1 in = 72 pt = 25,4 mm в любом случае, а для данного экрана также 1 in = 252 px = 252 dp. Шрифты также везде одинаковы, т.к. размер шрифта по умолчанию равен 14 sp и в данном случае равен 14 px.





xml-код:

	<?xml version="1.0" encoding="utf-8"?> 

	<LinearLayout 

	xmlns:android="http://schemas.android.com/apk/res/android" 

	android:orientation="vertical" 

	android:layout_width="fill_parent" 

	android:layout_height="fill_parent"> 

	<Button 

	android:id="@+id/button1" 

	android:layout_height="wrap_content" 

	android:layout_width="1in" 

	android:text="1 inch, default"> 

	</Button> 

	<Button 

	android:id="@+id/button2" 

	android:layout_height="wrap_content" 

	android:layout_width="72pt" 

	android:text="72 pt, default"> 

	</Button> 

	<Button 

	android:id="@+id/button3" 

	android:layout_height="wrap_content" 

	android:layout_width="25.4mm" 

	android:text="25.4 mm, default"> 

	</Button> 

	<Button 

	android:id="@+id/button4" 

	android:layout_height="wrap_content" 

	android:layout_width="252px" 

	android:text="252 px, 14 px" 

	android:textSize="14px"> 

	</Button> 

	<Button 

	android:id="@+id/button5" 

	android:layout_height="wrap_content" 

	android:layout_width="252dp" 

	android:textSize="14sp" 

	android:text="252 dp, 14 sp"> 

	</Button> 

	<Button 

	android:id="@+id/button6" 

	android:layout_width="wrap_content" 

	android:layout_height="wrap_content" 

	android:text="wrap_content, default"> 

	</Button> 

	</LinearLayout>


  




Посмотрим, как это будет выглядеть на экранах других устройств:





![](http://android-helper.com.ua/images/uploads/2012/09/20110811_L0007_L_ALLScreensMDI.jpg)





Для всех экранов я поставил режим **mdpi**. Скриншоты экранов смасштабированы к одному размеру для наглядности. Надо понимать, что на самом деле диагонали экранов существенно отличаются, а наша цель – добиться, чтобы приложение выглядело одинаково на различных устройствах.





Мы видим, что на всех экранах 1 px остался равен 1 dp (т.к. режим mdpi). И in, pt и mm сохранили свои пропорции (1; 72; 25,4) относительно друг друга. Но обратите внимание, что 1 in уже не равен 252 px на экранах Wildfire и Flyer. Это потому, что у этих устройств другое соотношение диагонали экрана и разрешения:  
- у **Wildfire **экран с** dpi = 180**, т.е. 1 in = 180 px, поэтому первая кнопка (с шириной = 1 inch) теперь короче, чем кнопка с шириной 252 px.   
- для **Flyer**, соответственно,** dpi = 170**.





Видно, что приложение выглядит достаточно по разному на трех экранах. Так было бы, если бы не существовало коэфициента Screen Density. Но он есть и давайте смотреть, чем он полезен. Я включу режим **ldpi **для **Wildfire **и **xhdpi **для **Flyer**. **Desire **оставляю в **mdpi**.





![](http://android-helper.com.ua/images/uploads/2012/09/20110811_L0007_L_ALLScreensSMHDI.jpg)





Ширина кнопок указанная в in, mm, pt неизменна, на эти единицы измерения режимы Density влияния не имеют. Нам интересны четвертая и пятая кнопки. Видим, что на экранах Wildfire и Flyer отличаются размеры px и dp, т.к. мы сменили mdpi на ldpi и xhdpi. Для Wildfire 1 dp стал равен 0,75 px, а для Flyer 1 dp = 2 px. Также видим, что изменился шрифт на кнопках, где размер шрифта был указан по умолчанию или в sp-единицах. Он так же, как и dp смасштабировался благодаря Density режимам. А шрифт, размер которого был указан в px (четвертая кнопка) оставался неизменным и на Wildfire выглядит крупным, а на Flyer – мелким.





Отлично видно, что адекватнее всего перенос на другие экраны перенесли пятая и шестая кнопки. Для пятой кнопки используются dp и sp. Для шестой кнопки – ширина = wrap_content и размер шрифта по умолчанию. А кнопки с in, mm, pt и px статичны и на разных экранах выглядят по-разному. Наверняка, есть случаи, когда необходимо использовать именно эти единицы измерения. Но в основном старайтесь использовать dp (для ширины, высоты и т.д.) и sp (для размера шрифта).





Конечно Density не дает масштабирования абсолютно пропорциального разнице в разрешениях экрана. Погрешность есть, но она невелика и является вполне приемлемой платой за способность приложения «сохранять форму» на разных устройствах.





Кем именно устанавливаются Density режимы для различных экранов – я не знаю. Но подозреваю, что производителями устройств/экранов. Еще мне интересно, можно ли эти режимы переключать при работе устройства. Думаю, чуть позже я найду ответы на эти вопросы.





Для создания этого материала я использовал различные конфигурации экранов, которые можно создавать самому:





![](http://android-helper.com.ua/images/uploads/2012/09/20110811_L0007_L_ScreenConfigs.jpg)





Вы наверно обратили внимание, что в папке Андроид-проекта в Eclipse есть папки **drawable **c суффиксами hdpi, ldpi, mdpi:





![](http://android-helper.com.ua/images/uploads/2012/09/20110811_L0007_L_drawable.jpg)





Папка drawable используется для хранения изображений, а суффиксы дают понять системе из какой именно drawable использовать картинки при текущем Density режиме. Подробнее об этом можно почитать в [хелпе](http://developer.android.com/guide/topics/resources/providing-resources.html). Кстати, там же вы найдете уже изученный нами **–****land**, который связан с горизонтальной ориентацией экрана. Будем по мере изучения Андроид знакомиться с остальными.





Спасибо, что вы с нами.





Ваши комментарии будут уместны :)





Также не забудьте подписаться на бесплатный курс.
Сегодня нашел очень интересную статью.





Вот ее содержание:





Всегда интересно знать, как пользователи работают с вашим приложением: какие функции наиболее востребованы, какие кнопки нажимаются, какие настройки меняются, какие ошибки совершаются. Неплохо так же представлять себе, что это за пользователи - какая версия прошивки у их девайсов, где они географически расположены и т.д. 





Такая информация неоценима для разработчика, ведь с ее помощью можно оптимизировать юзабилити, определиться с приоритеностью функционала, найти пути повышения продаж. Вопрос только как такую статистику собирать.


<!-- more -->


Самый простой путь - воспользоваться готовой системой сбора аналитической информации. Таких систем сейчас более чем достаточно ([1](http://www.foundersspace.com/tech/whats-the-best-analytics-service-for-apps/), [2](http://www.quora.com/What-is-the-best-Mobile-Analytics-service-for-iOS-apps-and-why)). Например:У каждой системы есть свои изюминки: real-time обновление статистики (Localitics), суперточность с отслеживанием уникальных ID каждого пользователя (Bango), наличие средств для проведения опроса пользователей (Apsalar), наличие средств для регулярной отправки уведомлений пользователям (BuzzBox) и т.д. Естественно, есть и море отличий: в интерфейсе, в средствах анализа, в наличии дополнительных API, в стоимости, в наборе поддерживаемых платформ и т.п. 





Принцип работы у всех систем примерно одинаков. Регистрируемся на сайте системы, получаем SDK и уникальный ключ. В приложение подключаем стороннюю библиотеку (единственный jar-файл из SDK). Добавляем код вызова функций, регистрирующих события в приложении. Релизим приложение. Ждем некоторое время, пока пользователи поработают в программе. Заходим на сайт системы и смотрим разнообразные аналитические отчеты. 





Вот, например, как ведется сбор данных в Apsalar:


	import com.apsalar.sdk.Apsalar;



	public void onCreate(Bundle savedInstanceState) {

	...

		Apsalar.startSession(this, "myapikey", "mypassword");

	..

	}



	/** уровень level пройден за countSeconds */

	public void onLevelPassed(int level, int countSeconds) {

	...

  	Apsalar.event("passed", "level", level, "duration", countSeconds);

	...

	}



API, как видите, тривиальное, так что технически добавить код для фиксации событий в приложении совсем не сложно. Количество событий и количество атрибутов у каждого события не ограничено, поэтому детализация собираемой информации может быть весьма высокой. 





Конечно, подобные системы сбора информации - это, прежде всего, инструмент аналитика, желающего увеличить доход от продажи приложения. И накапливаемая статистика событий в приложении - всего лишь первичный материал для анализа. Тот же Apsalar позволяет, например, проводить [Funnel Analysis, Engagment Analysis, Trending Analysis, Path Analysis, Event Analysis, Operational Analysis ](http://apsalar.com/apscience/features/).





Взять к примеру Funnel Analysis (воронку продаж). Если в вашем приложении пользователь должен сделать несколько шагов к совершению покупки (последовательно открыть несколько страниц, нажать несколько кнопок), то Funnel Analysis позволит увидеть, сколько пользователей (и каких именно) отсеивается на каждом шаге. Любопытно, что существуют системы монетизации, активно [использующие ](http://moneynews.ru/AuthorsArticle/14844/)подобную информацию.





Резюме. Готовых систем сбора аналитической информации для Android приложений сейчас множество, выбор широк. Многие из них бесплатные и, одновременно, обладают достойным функционалом. Подключаются подобные системы тривиально, весят "копейки" (10-30 kb), а пользу разработчику могут принести немалую. Единственное но: не у всех пользователей неограниченный трафик. Так что пользователи должны иметь возможность сбор статистики отключать.





**Update**: Полезная статья на хабре [Flurry Analytics. Как держать руку на пульсе приложения ](http://habrahabr.ru/blogs/android_development/122510/)





[Блог](http://apsalar.com/blog/)компании Apsalar.   
Еще пара сервисов: [Appoxee ](http://www.appoxee.com/), [AppFiguers ](http://www.appfigures.com/). По поводу Appoxee см. так же [how to create post app download engagement.](http://appsmarketing.mobi/deliver-post-app-download-engagement-appoxee-mobile/)





Спасибо [DV](http://derevyanko.blogspot.com/2011/07/android.html)
Добрый день друзья.





Многие разработчики сталкиваются с проблемой проектирования пользовательского интерфейса.





Все ищут идеи у других программ, которые скачивают с [Google Play](https://play.google.com/store)


<!-- more -->


Я же в своей статье хочу дать несколько полезных ссылок на сайты где вы сможете черпнуть идей для своего приложения.





#### [Проектируя для кончиков пальцев.](http://justnotes.ru/proektiruya-dlya-konchikov-palcev.html)





Использование пальцев перевернуло устоявшиеся представления о настольных приложениях. Дизайнер интерактивной среды Джош Кларк объясняет, о чём важно помнить при проектировании интерфейсов для мобильных сенсорных экранов, и сравнивает удобные для пальцев тач-интерфейсы iPhone, iPad и Android.





#### [Дизайн пользовательского интерфейса приложения для iPhone](http://justnotes.ru/dizayn-polzovatelskogo-interfeysa-prilozheniya-dlya-iphone.html)





Необходимые знания: ничего кроме внимания к деталям и основ Photoshop  
Инструменты: ручка, бумага, Photoshop (или другой графический редактор, позволяющий экспортировать png-файлы)  
Продолжительность работы: 2-5 часов.  
  
Проектирование для устройств на платформе iOS4 сильно отличается от разработки сайтов. Сара Парментер объясняет, как создать качественный пользовательский интерфейс приложения.





### [Очень много различных примеров](http://pttrns.com/)









Если у вас есть еще какие то статьи или сайты пишите, я с радость буду их добавлять.
Добрый день друзья.





Сегодня нашел очень увлекательную [статью](http://derevyanko.blogspot.com/2012/01/android.html) которая помогает проанализировать коды вашей программы.





Надеюсь, что вам понравится!


<!-- more -->


А вот и описание:

























Одним из путей улучшения качества кода приложения является [регулярное](http://habrahabr.ru/blogs/code_review/135234/#habracut)применение статических анализаторов кода. Статический анализ кода позволяет находить ошибки в коде, отслеживать несоблюдение стандарта кодирования, находить "плохой" код, который может привести к проблемам в будущем, а так же неэффективный код, негативно сказывающийся на производительности в настоящем, строить метрики кода, находить полностью или частично одинаковые фрагменты кода и так далее. 





Для разработчиков, ведущих кодирование в одиночку, статические анализаторы вещь вообще неоценимая. Ведь им некому показать код своего приложения. Так что "электронный помощник", способный грамотно выполнить "code review", может им здорово пригодится.





Вопрос - какие статические анализаторы кода доступны разработчику Android приложений? Для Java статических анализаторов существует множество (см. список [lint ](http://en.wikipedia.org/wiki/Lint_(software))приложений для Java в википедии), но не все они умеют работать с Android-приложениями и, тем более, учитывать их специфику.





Мне удалось отыскать следующие статические анализаторы кода, которые умеют работать с Android-приложениями:








  * [Lint ](http://tools.android.com/tips/lint). "Родной" анализатор кода для Android, входит в состав Android SDK начиная с r16.



  * [FindBugs ](http://findbugs.sourceforge.net/)(бесплатный).



  * [Checkstyle ](http://checkstyle.sourceforge.net/)(бесплатный).



  * [CodePro Analytix ](http://code.google.com/intl/ru-RU/javadevtools/codepro/doc/index.html)(бесплатный).



  * [PMD ](http://pmd.sourceforge.net/)(бесплатный)



  * Motodev App Validator (бесплатный). Входит в состав среды разработки[MOTODEV Studio for Android ](http://developer.motorola.com/docstools/motodevstudio/). Есть [online ](http://developer.motorola.com/testing/app-validator/)вариант.



  * [Klocwork Solo ](http://www.klocwork.com/products/solo/)(платный). Доступна триальная версия



  * [JTest ](http://www.parasoft.com/jsp/products/jtest.jsp)от Parasoft (платный).



  * [Julia ](http://juliasoft.com/)(платный). Доступен бесплатный [online ](http://julia.scienze.univr.it/)вариант.






Далее представлены результаты сравнения всех этих анализаторов - какой анализатор что умеет, для чего предназначен, насколько удобно пользоваться, какие ошибки находит, насколько он полезен на практике. 





Чтобы было интереснее сравнивать, я "натравил" каждый из этих анализаторов на одно и то же тестовое приложение. В качестве такового я взял код одной из ранних версий моего приложения [Animated Widget Contact Launcher ](https://market.android.com/details?id=com.mobilityflow.awidget&hl=ru). Версию я выбрал годичной давности, багов и проблем в ней было вагон (с FindBugs на тот момент я был не знаком). Так что "что поискать" в ней точно было.





### Lint





[Lint ](http://tools.android.com/tips/lint)- анализатор кода, который поставляется вместе с Android SDK. Он появился совсем недавно, в версии r16. 





Lint нацелен на поиск проблем, связанных с ресурсами. Неиспользуемые ресурсы, ненужные или наоборот, отсутствующие, аттрибуты, неоптимальные конструкции в layout и т.д. Список проблем, которые ищет Lint, приведен [здесь ](http://tools.android.com/tips/lint-checks). 





Работать с Lint очень удобно. Вызывать и настраивать его можно прямо из Eclipse. Для найденных ошибок показывается объяснение - в чем состоит ошибка и как ее исправить. Ошибки делятся на 3 уровня (error, warning, information). 





При проверке тестового приложения был выдан 101 warning. Все по существу - ложных срабатываний не было, за исключением пары сообщений об неиспользуемости ресурсов (и это при отсутствии библиотек; если же библиотеки используются, то разработчики прямо предупреждают о возможности ложных сообщений, так что будьте осторожны при чистке кода).









![](http://3.bp.blogspot.com/-UJ2JPXSVb9s/TwVtraTmfMI/AAAAAAAAAFQ/R32F2qPO1uk/s320/lint2.png)









###  





### FindBugs





FindBugs я пользуюсь уже почти год и очень доволен. Находит реальные ошибки в коде. Вот полный [список проблем ](http://findbugs.sourceforge.net/bugDescriptions.html), которые он умеет находить.





В декабре 2011, после длительного перерыва, FindBugs обновился с версии 1.3.9 до 2.0. Субъективно новая версия стала точнее, удобнее и быстрее предыдущей. Настраивается она теперь прямо из Eclipse (важно: в свойствах проекта, а не в свойствах workspace). Плагин для eclipse устанавливается с помощью location URL: `http://findbugs.cs.umd.edu/eclipse/` (в Eclipse выбрать `Help\Install new software`, ввести location URL в поле Work with).









![](http://2.bp.blogspot.com/-dKUxauuPo5s/TwV0S48r2zI/AAAAAAAAAFc/0cjP_W2wTuM/s320/findbugs_settings.jpg)









FindBugs нашел в тестовом приложении 12 ошибок при дефолтном уровне чувствительности. При максимальной чувствительности ошибок нашлось 137. При этом ложных срабатываний было всего 10 (анализатору не понравился способ именования классов в автоматические генерируемом файле ресурсов; этот файл нужно просто исключить из обработки в настройках FindBugs). Подавляющее большинство остальных ошибок я исправил в более поздних версиях.









![](http://4.bp.blogspot.com/-hybSpfAErHs/TwV0q3gJQhI/AAAAAAAAAFo/Q_9jti2d1oI/s320/findbugs_sample.jpg)









Приведу примеры ошибок, которые нашел FindBugs:








  * `Should be a static inner class` (вложенный класс не сделан статичным, хотя доступ к внешнему классу ему не нужен).



  * `Should this field be static?` (константа не объявлена как static)



  * `Switch statement found where one case falls through to the next case`(пропущен break)



  * `Comparison of String parameter using == or != in` (строки в Java небходимо сравнивать через equal)






Специфичных для Android правил в FindBugs пока нет. Но, возможно, со временем они появятся - разработчики [готовы идти навстречу пожеланиям пользователей.](http://groups.google.com/group/openintents/browse_thread/thread/b3a520a90254ce7f?pli=1)





###  





### Checkstyle





[Checkstyle ](http://checkstyle.sourceforge.net/)нацелен на проверку соблюдения стандарта кодирования. Проверка соблюдения правил именования, правил расстановки скобочек, правил оформления кода и т.д. - вот цель этого анализатора. Полный список правил можно посмотреть в [документации ](http://checkstyle.sourceforge.net/config_coding.html). Плагин для eclipse устанавливается с помощью location URL: `http://eclipse-cs.sf.net/update/`





После анализа тестового приложения Checkstyle выдал 8741(!) ворнинг. Я внимательно просмотрел все типы ворнингов.. и не нашел для себя ничего полезного. На мой взгляд - это совершенно не тот инструмент, который необходим индивидуальным разработчикам и небольшим командам. С другой стороны, его активно используют и [дорабатывают ](http://sevntu-checkstyle.github.com/sevntu.checkstyle/), так что видимо область применения у него все же есть.









![](http://3.bp.blogspot.com/-2S9FFxInHYo/TwV4wSDKRhI/AAAAAAAAAF0/xlOO_lzrCSc/s320/checkstyle_settings.png)









###  





### CodePro Analytix





[CodePro Analytix ](http://code.google.com/intl/ru-RU/javadevtools/codepro/doc/index.html)- разработка компании Instantiations. Google купил эту компанию и [сделал эти продукт бесплатным ](http://googlewebtoolkit.blogspot.com/2010/09/google-relaunches-instantiations.html), за что ему большое спасибо.





Заявленные [возможности CodePro Analytix ](http://code.google.com/intl/ru-RU/javadevtools/codepro/doc/index.html)впечатляют. [Аудит кода ](http://code.google.com/intl/ru-RU/javadevtools/codepro/doc/features/audit/audit.html)на основе нескольких различных наборов правил ("The Elements of Java Style", "Effective Java", "Potential Errors and Refactoring", "Security" и т.д.). Измерение кода с помощью различных метрик. Поиск "дублей" в коде - результатов копипаста. И т.д.





Провел аудит кода тестового приложения используя все возможные наборы правил. Получил: 152 предупреждения с уровнем серьезности High, 1246 - medium, 1062 - low. Для сравнения - анализ с помощью единственного набора правил "Code Pro Core" выдал 64 medium и 4 low предупреждения.









![](http://4.bp.blogspot.com/-RD18joLpJgo/TwWG7-5R8EI/AAAAAAAAAGM/l3WFRuLTkG8/s320/codepro_audit.png)









Что-же нашел Code Pro? Частично, результаты поиска пересеклись с результатами FindBugs и Lint. Но только частично. Большую часть ошибок составили минорные проблемы в коде, которые не были обнаружены другими анализаторами. Например:








  * `String literal can be replaced by a character literal`. В StringBuilder вместо append("\n") использовать append('\n').



  * `Badly located array declarators`. Массив объявлен как "String abc[]" вместо "String[] abc".



  * `Constant on right side of comparison`. Код "if (a == 5) { .. }" следует переписать так "if (5 == a") { .. }"



  * `Switch statements should include all possible enumeration constants`. В перечислимом типе 3 возможных значения, а в switch задействовано только 2 из них.



  * `Do not divide by powers of 2: use ">> 1" rather than "/ 2"`



  * `Invalid string literal: "Yes"`. Строки следует хранить в ресурсах, а не кодировать их жестко в код.



  * `Use charAt() rather than startsWith() when the constant is a single character string`. Код skinName.startsWith("/") можно переписать skinName.charAt(0) == '/'



  * `Define the initial capacity of StringBuilder instances`






Если не полениться и настроить Code Pro под себя, то инструмент оказывается весьма полезным. Возможно, некоторые рекомендации похожи на "ловлю блох".. но почему бы не привыкнуть писать более оптимальный код, если это возможно?





Кстати, юзабилити у Code Pro на высоте. Находясь в списке ошибок можно:








  * автоматически исправить ошибку (естестенно, автоматический рефакторинг кода поддерживается не для всех типов правил);



  * проигнорировать ошибку - она перестанет появляться в списке ошибок;



  * отключить правило, по которому была найдена ошибка;



  * настроить (!) параметры правила,






и так далее.





Кроме аудита, очень понравилось, как Code Pro ищет дубли. Незаменимая функция.









![](http://4.bp.blogspot.com/-yKmH44qnn_o/TwWG1iYOocI/AAAAAAAAAGA/6Feo9xpPQ9Y/s320/codepro_compare.png)









### PMD





[PMD ](http://pmd.sourceforge.net/)- еще один анализатор кода, типа Code Pro. Основное назначение - поиск неоптимального кода, проблем с производительностью, нарушений стиля кодирования, дублей в коде и т.д. Плагин PMD устанавливается с помощью location URL: `http://pmd.sourceforge.net/rules/android.html`





Примечательно, что в PMD реализовано [несколько правил, специфичных для Android ](http://pmd.sourceforge.net/rules/android.html)





Для тестового приложения PMD выдал около 2000 предупреждений. Примеры:








  * `Substitute calls to size() == 0 (or size() != 0) with calls to isEmpty()`



  * `Private field ''{0}'' could be made final; it is only initialized in the declaration or constructor.`



  * `UnnecessaryCaseChange: Using equalsIgnoreCase() is cleaner than using toUpperCase/toLowerCase().equals()`



  * `UnusedFormalParameter: Avoid unused {0} parameters such as ''{1}''. Avoid passing parameters to methods or constructors and then not using those parameters.`



  * `InefficientEmptyStringCheck: String.trim().length()==0 is an inefficient way to validate an empty String.`



  * `UseIndexOfChar: String.indexOf(char) is faster than String.indexOf(String).`



  * `BooleanInversion: Use bitwise inversion to invert boolean values`






Несмотря на то, что PMD генерирует множество лишних предупреждений, следует отметить, что и полезных подсказок он выдает множество. Так же как и Code Pro, PMD следует тщательно настраивать.





В PMD, так же как в Code Pro, реализована функция поиска повторяющихся участков кода. Визуализация найденных фрагментов, правда, похуже. Зато результаты поиска - другие, так что программы дополняют друг друга.









![](http://1.bp.blogspot.com/-07qFCT9CevQ/TwWOUNRVzfI/AAAAAAAAAGY/EBMZ6YGA2-U/s320/pmd.jpg)









###  





### Motodev App Validator





Motodev App Validator входит в состав среды разработки [MOTODEV Studio for Android ](http://developer.motorola.com/docstools/motodevstudio/). Прочитать про него можно в презентации [Static Analysis For Improved Application Performance And Quality Presentation (PDF) ](http://assets.en.oreilly.com/1/event/68/Static%20Analysis%20For%20Improved%20Application%20Performance%20And%20Quality%20Presentation.pdf)





Те, кто не использует MOTODEV Studio, могут попробовать [online вариант Motodev App Validator ](http://developer.motorola.com/testing/app-validator/)(требуется зарегистрироваться на сайте). 





Online вариант Motodev App Validator принимает на вход apk-файл приложения. К сожалению, 400 килобайтную apk-шку тестового приложения online вариант не заглотил - выдал ошибку. Мелкие приложение в 30-40 кб анализирует, а с "крупным" не работает. Пришлось [качать Motodev Studio ](http://developer.motorola.com/docstools/motodevstudio/download/)





Скачал, запустил. Для тестового приложения Application Validator выдал 101 предупреждение. Из них:








  * 75 - `"Drawable "XXX.png" does not exist in the "drawable-ldpi" folder. Add the appropriate "XXX.png" drawable to the "drawable-ldpi" folder."` - ничего нового.



  * 13 - `"Default layout file YYY.xml does not have an xlarge-specific version. This app may not have the look and feel expected on devices with extra large screens. Define an xlarge layout for YYY.xml or add <supports-screens android:xlargeScreens="false"> to the manifest file."` - так же ничего нового.



  * 4 - `"The import android.util.DisplayMetrics is never used ZZZ.java"` - ошибка, на которую умеет указывать сам Eclipse.



  * 1 - `"The value of the local variable AAA is not used"` - эту ошибку умеют находить многие анализаторы.



  * 3 - `"The static field A.B should be accessed in a static way ClassA.B"` - и эту тоже.






Интересным оказалось лишь одно сообщение - `"The application declares the permission android.permission.CALL_PHONE which implies the unsupported feature android.hardware.telephony..."`. Честно говоря, результаты работы не впечатлили.









![](http://1.bp.blogspot.com/-NHo6NN7u7ZY/TwZeDM5UqkI/AAAAAAAAAGw/EfpMA2g-Ong/s320/motodev_settings.png)









Впрочем, судя по списку правил, Application Validator умеет находить и более интересные вещи: незакрытые курсоры, недочеты Android Manifest, отсутствие перевода строки в локализованных ресурсах, ненужные или наоборот, пропущенные permissions и т.д.





###  





### Klocwork Solo for Java





[Klocwork Solo ](http://www.klocwork.com/products/solo/)- платный статический анализатор кода. По заверениям разработчиков, способен находить более 200 типов проблем, связанных с уязвимостью и надежностью кода. Анализатор умеет находить проблемы, специфичные для Android-приложений. Интегрируется с EClipse. Триальная 30-дневная версия доступна после регистрации на сайте. У триальной версии ограничение - не более 300 файлов в проекте.





Полный список правил, которые проверяет Kockwork Solo, можно посмотреть в[документации ](http://download.klocwork.com/docs/issuehelp/index.html). На настоящий момент правил, специфичных для Android, всего девять.









![](http://2.bp.blogspot.com/-EX-wZ8D7340/TwWqBFoC-LI/AAAAAAAAAGk/aaRqJPj4WPM/s320/klocwork_settings.png)









Для тестового приложения Kockwork Solo выдал 240 предупреждений. Неожиданно, очень интересных. Примеры:








  * `NPE.RET : Null pointer dereference of 'xy' where null is returned from a method`. В приложении имеется такой код: `Point xy = m_SA.getShortcutPosition(); Rect r = new Rect(0, 0, xy.x, xy.y);`. Функция getShortcutPosition() в отдельных случаях может возвращать null. Но в вызывающей функции проверки на null нет. Это типичная ошибка.



  * `NPE.COND : Null pointer dereference of 'xxx' where null comes from condition`. Объект xxx используется без проверки на null, а между тем, он запросто может быть равен null.



  * `RTC.CALL : Type cast from 'android.view.View' to 'android.widget.ImageButton' is redundant because method 'setTag' is defined in 'android.view.View'`. В приложении код такой:`((ImageButton)findViewById(R.id.hs_image)).setTag(combination)`. Т.е. анализатор обнаружил ненужное приведение типа.



  * `REDUN.FINAL : Redundant 'final' modifier` - приватный метод объявлен как final. Приватные методы всегда final, так что объявление излишне.



  * `JD.SYNC.IN : Field 'VarName' synchronized inconsistently.` - доступ к переменной VarName синхронизирован частично. Это ошибка - доступ должен либо всегда синхронизироваться, либо никогда.



  * `ANDROID.NPE : Null pointer dereference of 'window' in an Android application`. Код в приложении следующий: `Window window = activity.getWindow(); window.getDecorView().getWindowVisibleDisplayFrame(rect)` Т.е. не выполняется проверка window на null






Так что Kockwork Solo находит реальные ошибки, причем иные, чем FindBugs (списки дефектов, которые они обнаруживают, пересекаются незначительно). Лично меня очень заинтересовали ошибки типа NPE.RET и Android.NPE. Такие ошибки, судя по всему, не находит ни один другой анализатор.





Юзабилити у продукта не понравилось. В списке ошибок есть фильтрация, есть возможность указать статус ошибки. Но если указать статус "Ignored", то ошибка пропадает и не ясно, как ее вернуть. Если отфильтровать список, то часть ошибок из списка пропадает и опять же не ясно, как сбросить фильтр. Не интуитивно все как-то. В CodePro сделано удобнее.









![](http://1.bp.blogspot.com/-Lmwoy5r95EE/TwZ1c_3J7AI/AAAAAAAAAG8/YJ0REyWSlCQ/s320/klocwok_screen.jpg)









###  





### JTest от Parasoft





Триальную версию [Jtest ](http://www.parasoft.com/jsp/products/jtest.jsp)просто так скачать не дают. Так что этот анализатор я в работе проверить не смог. Судя по описанию - функциональность очень интересная. Например, JTest, так же как и Code Pro, умеет самостоятельно рефакторить код.





###  





### Julia





Julia - коммерческий анализатор кода Java / Android приложений. "Семантический инструмент, основанный на [математической теории ](http://www.juliasoft.com/public/Biblioteca/cade11.pdf)". 





Как указано на сайте разработчика, протестировать работу анализатора можно[online ](http://julia.scienze.univr.it/), загрузив в него jar-файл. У android приложения нет jar файла, есть apk (бинарный формат - другой). APK-файл анализатор принял.. но ни один из доступных способов анализа (Nullness, Termination, Check) ничего не выдал. Пишет - "there are no warnings". 





Загрузил первый попавшийся JAR - работает. Судя по всему, там неплохой анализ на "отсутствие проверки на null". Жаль, что apk-шки не грузятся.





**Update**: Написал разработчикам. Они мне подсказали, что можно экспортировать Android приложение в JAR-файл прямо из Eclipse. Экспортировал, загрузил в Julia.





Nullness analysis и Termination analysis результатов не выдали. Дело в том, что в демонстрационной online-версии для данных типов анализа существует ограничение: общее количество методов не должно превышать 10000 и 8500 соответственно. В тестовом приложении количество методов оказалось большим, так что процедура анализа принудительно останавливалась до завершения работы.





Третий тип анализа - "Checks", - выдал 286 предупреждений. По большей части, вот таких:








  * `[Classcast] A you sure that this cast from classA into classB is always legal?`



  * `[BadNames] Method XXX has a bad name`



  * `[Deadcode] Methos XXX is not reachable`



  * `[BadEq] Inefficient comparison with the empty string. Use isEmpty() instead`



  * `[Approximation] Unsafe comparison beween non-integral numbers.`



  * `[StaticFieldAccess] Modification of static field from a non-static context`(это что-то новенькое; другие анализаторы на такие ошибки не ругались).



  * `[Unused class] Class YYY is not used.`



  * `[Field access] Field XXX is never reach in reachable code.`



  * `[Useless call] Useless call toString()`



  * `[BadEq] Suspicious use of == rather then equals() to compare two java.lang.String`






В принципе, кое что интересно есть. Но: пользоваться очень неудобно (результаты выдаются в виде странички на флеш), поскольку сервис online, приходится "отдавать" исходники приложения в виде jar, что не всегда приемлемо.





**Update2**. Попросил разработчиков Julia провести анализ тестового приложения и прислать мне результаты. Они любезно согласились.





Termination analysis - это анализ кода на наличие бесконечных циклов и рекурсий в коде. Он выдал одно предупреждение. Анализатору не понравился код   
 
	private void expungeStaleEntries() {  
	Reference sv;  
	while ((sv = queue.poll()) != null) {  
	hash.remove(reverseLookup.remove(sv));  
	}  
	}  
  
из реализации SoftHashMap, взятой [отсюда ](http://www.javaspecialists.eu/archive/Issue098.html). Опасения анализатора понятны. Тем не менее, код правильный.





Nullness analysis проверяет в коде отсутствие необходимых и наличие излишних проверок на null. Таких предупреждений было выдано 187. Примеры ошибок:








  * `X1.java:57: is the return value of getY1 non-null?`



  * `X2.java:57: is the 0th actual parameter of parseInt non-null?`



  * `X3.java:69,70,72,78,105,109,178: is the return value of getY2 non-null?`



  * `X4.java:227,261,309: is the value of field mX1 non-null?`



  * `X5.java:84: is this nullness check useless?`



  * `X6.java:318,361: is the receiver of the call to iterator non-null?`



  * `X7.java:34: is the formal parameter srcRect non-null?`






Отмечу, что Kockwork Solo выдал всего 43 предупреждения, связанных с проверкой на null. Подробнее результаты, полученные Julia и Kockwork Solo, сравниваются ниже.





###  





### Напоследок. Сравнительные тесты





Ну как же без тестов... Многие анализаторы обнаруживают одни и те же типы проблемы в коде. Сравним, кто что находит.





#### Неверное сравнение строк





В Java строки надо сравнивать через equal. Между тем, по старой сишной привычке, можно сравнить строки через != и == и получить ошибку. Этот баг настолько распространен, что его ищут чуть ли не все анализаторы.





В тестовом приложении оказалось семь таких багов. Вот они:  
 
	1. widget_name == ""  
	2. title != adapter.getItem(i).Title  
	3. srcStr == "S"  
	4. m_K != ""  
	5. contact_name != m_B.getB().GetR(this)  
	6. contact_name == ""  
	7. name == "" ? "" : name + ": "  







#### Проблемы со switch





Для switch характерны следующие проблемы:








  * 1. Отсутствие default



  * 2. Пропущен break



  * 3. Switch выполняется по значению перечислимого типа. В "case" используются не все значения, входящие в перечислимый тип.



  * 4. Switch слишком маленький - например, в нем одно или два значения. Можно обойтись if/else.



  * 5. В двух case используется одинаковый код.






Далеко не всегда эти проблемы являются реальными ошибками. Тем не менее, анализаторы кода как правило считают своим долгом о них сообщить.





Разные анализаторы работают с разными типами проблем. Итак, вот как отработали анализаторы на тестовом приложении.







#### NP-анализ





Отсутствие проверки на null и, как результат, "NUll pointer exception" - одна из наиболее частых ошибок при разработке под Android. Другая сторона медали - излишние проверки. 





К слову сказать, FindBugs успешно отлавливает такую ошибку: вначале у объекта вызывается функция, а затем объект проверяется на null. 





Klocwork и Julia "заточены" под Android. И эта "заточенность" проявляется, прежде всего, в возможности NP-анализа. Как я писал вышел, Klocwork для тестового приложения выдал 43 NP-предупреждения, Julia - 187. Сравним, кто что нашел.





##### NP анализ. Файл 1





Проблема 1.1. `String action = intent.getAction(); if (action.equals("abc")) {..};` Переменная action может быть null. Проблему обнаружили обе программы.  
Проблема 1.2. `intent.getExtras().getInt(...);` Результат getExtras() не проверяется на null. Проблему обнаружили обе программы.   
Проблема 1.3. `Uri uri = intent.getData(); Integer.parseInt(uri.getQueryParameter("widget_id"))`. Оба анализатора сообщили об использовании uri без проверки uri на null. Julia дополнительно сообщила о том, что результаты работы uri.getQueryParameter на null не проверяются и в parseInt может быть передан null.  
Проблема 1.4. `WidgetContent wc = WidgetFabric.getWidgetContent(); wc.getFlagValue();`. Оба анализатора сообщили, что wc может быть null. В реализации getWidgetContent() действительно есть ветка кода, которая возвращает null.  
Проблема 1.5. `((Singleton)context.getApplicationContext()).getABC().Register();`Об этой проблеме сообщила только Julia. Функция getABC() может вернуть null и вызывать Register() нельзя. На самом деле, объект ABC создается в [синглетоне, реализованном поверх класса Application. ](http://derevyanko.blogspot.com/2010/12/android_26.html)Инициализируется он в момент запуска приложения и null быть не может. Однако, инициализация ABC проводится не в конструкторе синглетона, а в функции onCreate. Анализатор не знает про тонкости создания синглетона и предупреждает об ошибке, которая вряд ли возможна.





##### NP анализ. Файл 2





Проблема 2.1. `CheckBoxPreference pref = (CheckBoxPreference)getPreferenceScreen().findPreference("pref_name");`. findPreference может возвращать null.  
Проблема 2.2. `List list_skins = ((Singleton)this.getApplicationContext()).getSkinManager().getListSkins("skin_name");`Проблема аналогична 1.5. Функция getSkinManager может возвращать null, но только теоретически.  
Проблема 2.3. `int len_skins = list_skins.size();` Переменная list_skins действительно может быть null.  
Проблема 2.4. `for (int j = 0; j < len_skins; ++j) { array_skins[j] = list_skins.get(j).SkinTag; }` Результаты get не проверяются на null. Такая проверка необходима, если list_skins может содержать null. В приложении такого быть не может, так что проверка не нужна.  
Проблема 2.5. `String skin_name = (String) p.getEntries()[p.findIndexOfValue(skin_tag)];` Результат работы getEntries() не проверяется на null.  
Проблема 2.6. `CharSequence[] titles = res.getTextArray(idTitles); if (values[0].equals(svalue)) {...};` Значение values[0] не проверяется на null.  
Julia сообщила обо всех этих проблемах. Klocwork - только о 2.3.





##### NP анализ. Файл 3





Проблема 3.1. `m_AsyncTask = new AppInfoReceiverTask(mUtils.getList());` Эту ошибка нашла только Julia - переменная mUtils может быть null. На самом деле, mUtils инициализируется в onCreate (речь идет о наследнике Activity) и null быть не может.  
Проблема 3.2. `protected void onActivityResult(int requestCode, int resultCode, Intent data) { data.getExtras().getString(...);` Эту проблему нашли оба анализатора: data.getExtra может вернуть null.  
Проблема 3.3. `(LauncherContent)WidgetFabric.getWidgetContent()` Эту проблему нашел Klocwork. Julia ее пропустила.  
Проблема 3.4. `SpinnerItem selected_item = (SpinnerItem)spinner.getSelectedItem(); String s = selected_item.Title;`Функция getSelectedItem может вернуть null согласно документации. Проблему нашла только Julia  
Проблема 3.5. `ListView list_view = (ListView) dialog.findViewById(R.id.listview); list_view.setAdapter(new SelectImageAdapter(list_images) );` Теоретически, findViewById может вернуть null. На проблему указала только Julia.  
Проблема 3.6. `private final void remove_shortcut(AppInfo appInfo) { m_List.remove(appInfo); }` В функцию может быть передан null, appInfo на null не проверяется. Проблему нашла только Julia.  
Проблема 3.7. `for (SkinManager.SkinInfo skin : skins) { ... }` Переменная skins может содержать null. Проблему нашли оба анализатора.





Резюме. Julia находит почти все NP-ошибки, которые обнаруживает Klocwork, плюс еще ряд дополнительных. Одновременно, она генерирует довольно много ложных сообщений, которые на практике придется просто игнорировать. Самая большая проблема на мой взгляд - она не учитывает, что в Activity переменные инициализируются в onCreate, а не в конструкторе.





### Итоги





В итоге получается следующая картина. В настоящее время существует восемь доступных статических анализаторов кода для Android приложений: Lint, FindBugs, Checkstyle, CodePro, PMD, Motodev App Validator, Klocwork Solo, Julia. Основная специализация у них следующая:








  * Lint и Motodev App Validator - поиск проблем в ресурсах Android приложения;



  * FindBugs, Klocwork Solo и Julia - поиск ошибок в коде приложения;



  * Checkstyle - проверка соблюдения правил оформления кода и стандарта кодирования;



  * CodePro и PMD - поиск неоптимального кода, проблемного кода, поиск дублей.






FindBugs и Lint прекрасно работают "с нуля" - настраивать их практически не требуется. CodePro и PMD требуют тонкой настройки. Но если отключить в них ненужные проверки, они приносят реальную пользу. Motodev App Validator и Checkstyle мне показались не слишком полезными - на любителя. Klocwork Solo - находит ряд ошибок, которые не находят другие анализаторы. Он платный, но и триальную версию можно вполне успешно использовать для небольших приложений. Julia находит ряд NP-ошибок, которые не находит Klocwork, но при этом генерирует еще и множество ложных предупреждений (ошибка возможна, но только теоретически). К сожалению, воспользоваться бесплатной версией практически не возможно.

























 





 





 









 




Добрый день друзья.





Сегодня у нас стартует рубрика программирования для начинающих.





Освоив эту рубрику, вы станете не только понимать Android, но и быть неким гуру в разработке.



 <!-- more -->

 





Перед началом программирования, нужно подготовить ваш компьютер.












  1. Устанавливаем [Java](http://www.oracle.com/technetwork/java/javase/downloads/jdk-6u32-downloads-1594644.html)



  2. Установим [Android SDK](http://developer.android.com/sdk/index.html)



  3. Скачаем [Eclipse](http://eclipse.org/downloads/) (рекомендую Classic)



  4. Установим [Android плагин для Eclipse (ADT)](http://developer.android.com/sdk/eclipse-adt.html#downloading)



  5. Подключим ваше устройство, [устанавливаем драйвера](http://developer.android.com/sdk/win-usb.html). Если драйверов нету, тогда добавляйте его как ADT Interface (Android устройство)



  6. Научимся пользоваться эмулятором










 





Если есть вопросы, задавайте их в соц. сетях или в Twitter.





 





После завершения этих задач, можно будет приступить к написанию вашей первой программы.




</li>&ndash;&gt;-->
    <!--&lt;!&ndash;&ndash;&gt;-->
    <!--&lt;!&ndash;<li>ПрограммированиеДрузья всем привет.

Я очень рад, что некоторые из ребят в коучинге пишут замечательные топики!

Вот с какой проблемой мы столкнулись в коучинге и как ее решали!

<!-- more -->


В процессе коучинга, создавая своё первое приложение - калькулятор, научился использовать кастомные шрифты. Спешу безвозмездно поделиться своим опытом!

**Какие шрифты подходят?**

Можно использовать шрифты TrueType (TTF)

**Куда положить шрифт?**

В корневой директории (на одном уровне с директориями java и res и файлом AndroidManifest.xml) создать папку assets, а внутри неё можно создать отдельную папку для шрифтов fonts
В эту папку бросить свой файл со шрифтом Custom.ttf

**Как Android узнает, где находятся кастомные шрифты?**

В файле **<project_name>.iml** в разделе configuration необходимо добавить строчку

	<configuration>
	...
	<option name="ASSETS_FOLDER_RELATIVE_PATH" value="/src/	main/assets" />
	</configuration>

а в файле **res/values/strings.xml** - строчку

	<string name="digit_keyboard_font">fonts/Custom.ttf</string>

**Как назначить шрифт своим View-элементам?**

Теперь в коде, в методе onCreate можно использовать свой шрифт. Обратите внимание на код, в котором скрывается первая секретная фишка!

	Typeface keys = Typeface.createFromAsset(getAssets(), 	getString(R.string.digit_keyboard_font));
	TextView key = (TextView)findViewById(R.id.button_about_ok);
	key.setTypeface(keys);


Как видите, таким способом можно применить шрифт к надписям на кнопках и других **View**, которые можно явно привести типу **TextView**.


Ещё одна супер-полезная и очень секретная фишка
Допустим, требуется применить шрифт к группе элементов, которые располагаются в layout-файле внутри корневого элемента типа **ViewGroup** с присвоенным ему уникальным **id**


	<LinearLayout
    android:id="@+id/digit_keyboard_layout"
    android:layout_width="wrap_content"
    android:layout_height="match_parent"
    android:layout_gravity="center_horizontal"
    android:orientation="vertical">

    <TableLayout
        android:id="@+id/table1"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content">

        <TableRow
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_weight="3">

            <Button
                android:id="@+id/button_one"
                style="@style/calc_button_style"
                android:layout_width="@dimen/button_width"
                android:text="@string/one"
                android:layout_alignParentStart="false"
                android:layout_alignParentEnd="false"
                android:layout_weight="1"/>

            <Button
                android:id="@+id/button_two"
                style="@style/calc_button_style"
                android:layout_width="@dimen/button_width"
                android:text="@string/two"
                android:layout_weight="1"/>

            <Button
                android:id="@+id/button_three"
                android:text="@string/three"
                style="@style/calc_button_style"
                android:layout_width="@dimen/button_width"
                android:layout_weight="1"
                />
        </TableRow>
    </TableLayout>
	</LinearLayout>


Используйте в коде приложения вот такой метод


	// Sets the font on all TextViews in the ViewGroup.
    public void setFont(ViewGroup group, Typeface font) {
        int count = group.getChildCount();
        View v;
        for(int i = 0; i < count; i++) {
            v = group.getChildAt(i);
            if(v instanceof TextView) {
                ((TextView)v).setTypeface(font);
            } else if(v instanceof ViewGroup) {
                setFont((ViewGroup) v, font);
            }
        }
    }

Метод рекурсивно вызывает сам себя пока не доберётся до нужного элемента в любой сложной xml-структуре **layout**. 

Вызывая этот метод устанавливаем шрифт группе элементов.

	Typeface keys = Typeface.createFromAsset(getAssets(), 	getString(R.string.digit_keyboard_font));
	ViewGroup keyboardArea = (ViewGroup)findViewById(R.id.digit_keyboard_layout);
	setFont(keyboardArea, keys);

У кого есть какие то наработки или идеи, пишите в комментариях. Мы обязательно добавим статью на блог!

Жду ваших комментариев!### Как зарутить ganymotion?

Всем привет.

Один из участников моего коучинга, задал мне [вопрос на форуме](http://forum.android-helper.com.ua/viewtopic.php?f=15&t=9). Один из ответов был использовать Ganymotion в его разработке. На что он ответил, что не может добраться к базе данных.

Я реально проверил это. И знаете, что оно так и есть. Было принято решение получить доступ к базе любой ценой. И это свершилось.

Сегодня я хотел бы поделится своим опытом - **"Как получить доступ к базе данных в Ganymotion?"**

Готовы? Тогда вперед.

<!-- more -->

#### Подготовка

1. [Установка Ganymotion](http://android-helper.com.ua/android-studio-genymotion/)
2. Выбираем из списка нужный емулятор
3. [Скачиваем root файл](https://drive.google.com/file/d/0B-p1r5SNN4adTGgyajV6ckNtV00/edit?usp=sharing).
4. Открываем **terminal** - Mac (**cmd** - Windows)

#### Root

Заходим в папку где у вас скачан файл (см. выше)

И в terminal пишем следующее!

	adb devices
	adb root
	adb connect <IP вашего устройства см. adb devices вместе с портом>
	adb remount
	adb push su /system/xbin/
	adb push su /system/bin
	adb shell chmod 6755 /system/bin/su
	adb shell chmod 6755 /system/xbin/su

Все ваш емулятор теперь имеет права root.

#### Видео урок

{% youtube rsBGF9_Un8o %}


1. Ставьте лайк
2. Пишите комментарии
3. Рассказывайте друзьямДобрый день друзья.
Сегодня наша статья будет полезна не только гуру android программирования, но и тем кто только стал на этот не легкий тернистый путь.

Сегодня мы поговорим о том как с помощь Intent намерений можно выполнять самые различные операции.

Ну что поехали?

<!-- more -->

**Открыть браузер**

	Uri uri = Uri.parse("http://www.google.com");
	Intent it  = new Intent(Intent.ACTION_VIEW,uri);
	startActivity(it);

**Открыть карту с координатами**

	Uri uri = Uri.parse("geo:38.899533,-77.036476");
	Intent it = new Intent(Intent.Action_VIEW,uri);
	startActivity(it); 

**Показать путь**

	Uri uri = Uri.parse("http://maps.google.com/maps?f=d&saddr=startLat%20startLng&daddr=endLat%20endLng&hl=en");
	Intent it = new Intent(Intent.ACTION_VIEW,URI);
	startActivity(it);

**Позвонить с программы**

	Uri uri = Uri.parse("tel:xxxxxx");
	Intent it = new Intent(Intent.ACTION_DIAL, uri);  
	startActivity(it);  

	Uri uri = Uri.parse("tel.xxxxxx");
	Intent it =new Intent(Intent.ACTION_CALL,uri);

Не забудьте добавить разрешение в манифесте.

	<uses-permission id="android.permission.CALL_PHONE" />

**Отправка сообщения с помощью встроенной программы**

	Intent it = new Intent(Intent.ACTION_VIEW);   
	it.putExtra("sms_body", "The SMS text");   
	it.setType("vnd.android-dir/mms-sms");   
	startActivity(it);  

**Отправка сообщения на номер телефона**

	Uri uri = Uri.parse("smsto:0800000123");   
	Intent it = new Intent(Intent.ACTION_SENDTO, uri);   
	it.putExtra("sms_body", "The SMS text");   
	startActivity(it);  

**Отправка MMS**

	Uri uri = Uri.parse("content://media/external/images/media/23");   
	Intent it = new Intent(Intent.ACTION_SEND);   
	it.putExtra("sms_body", "some text");   
	it.putExtra(Intent.EXTRA_STREAM, uri);   
	it.setType("image/png");   
	startActivity(it); 

**Отправка почты**
 
	Uri uri = Uri.parse("mailto:xxx@abc.com");
	Intent it = new Intent(Intent.ACTION_SENDTO, uri);
	startActivity(it);

	Intent it = new Intent(Intent.ACTION_SEND);   
	it.putExtra(Intent.EXTRA_EMAIL, "me@abc.com");   
	it.putExtra(Intent.EXTRA_TEXT, "The email body text");   
	it.setType("text/plain");   
	startActivity(Intent.createChooser(it, "Choose Email Client"));  

	Intent it=new Intent(Intent.ACTION_SEND);     
	String[] tos={"me@abc.com"};     
	String[] ccs={"you@abc.com"};     
	it.putExtra(Intent.EXTRA_EMAIL, tos);     
	it.putExtra(Intent.EXTRA_CC, ccs);     
	it.putExtra(Intent.EXTRA_TEXT, "The email body text");     
	it.putExtra(Intent.EXTRA_SUBJECT, "The email subject text");     
	it.setType("message/rfc822");     
	startActivity(Intent.createChooser(it, "Choose Email Client"));   


**Добавление файлов**

	Intent it = new Intent(Intent.ACTION_SEND);   
	it.putExtra(Intent.EXTRA_SUBJECT, "The email subject text");   
	it.putExtra(Intent.EXTRA_STREAM, "file:///sdcard/mysong.mp3");   
	sendIntent.setType("audio/mp3");   
	startActivity(Intent.createChooser(it, "Choose Email Client"));

**Проигрывание музыки**

	Intent it = new Intent(Intent.ACTION_VIEW);
	Uri uri = Uri.parse("file:///sdcard/song.mp3");
	it.setDataAndType(uri, "audio/mp3");
	startActivity(it);

	Uri uri = Uri.withAppendedPath(MediaStore.Audio.Media.INTERNAL_CONTENT_URI, "1");   
	Intent it = new Intent(Intent.ACTION_VIEW, uri);   
	startActivity(it);  

**Удаление программы**

	Uri uri = Uri.fromParts("package", strPackageName, null);   
	Intent it = new Intent(Intent.ACTION_DELETE, uri);   
	startActivity(it);

	Uri uninstallUri = Uri.fromParts("package", "xxx", null);
	returnIt = new Intent(Intent.ACTION_DELETE, uninstallUri);

**Установка программы**

	Uri installUri = Uri.fromParts("package", "xxx", null);
	returnIt = new Intent(Intent.ACTION_PACKAGE_ADDED, installUri);

**Поиск на маркете**

	Uri uri = Uri.parse("market://search?q=pname:pkg_name");  
	Intent it = new Intent(Intent.ACTION_VIEW, uri);  
	startActivity(it);  


**Показать детали программы**

	Uri uri = Uri.parse("market://details?id=app_id");  
	Intent it = new Intent(Intent.ACTION_VIEW, uri);  
	startActivity(it);  

**Поиск в Google**

	Intent intent = new Intent();
	intent.setAction(Intent.ACTION_WEB_SEARCH);
	intent.putExtra(SearchManager.QUERY,"searchString")
	startActivity(intent);


Ну вот и все, расскажи своим друзьям. Нажимай лайки и пиши свои комментарии.### Genymotion





Вероятно название **Genymotion** вам ни о чем не говорит. Но уверяю вас это не надолго. Как только вы его испробуете из памяти уже не сотрете. В nutshell, Genymotion это полностью готовый модуль заменяющий стандартный эмулятор Android (который стал бесполезным из-за недостаточной производительности на последних последних версиях Android) который можно скачать на официальном сайте [genymotion.com](http://www.genymotion.com/). Решение основано на **Virtual Box** соответственно является виртуальным а не эмулируемым устройством.



![Genymotion](https://lh3.googleusercontent.com/-wk22pXuAJXA/UeeXbDsp0LI/AAAAAAAAIyI/8TFeBRdx5Yk/w871-h191-no/genymotion.png)  
  
Genymotion

<!-- more -->

Я не являюсь экспертом ни в виртуализации ни в эмуляции, но похоже, что эмуляция уже не актуальна. На теперешнее время **iOS** предлагает симулятор (приложения компилируются под целевую архитектуру) и последние **Windows Phone SDK** укомплектовано Windows Phone эмулятором который по сути является виртуальной машиной. Мне кажется, что виртуализация лучший вариант для решения проблем производительности, как следствие эмуляции, и «различий бинарников» от которых страдает симуляция.





Если вы уже испробовали Genymotion, вы знаете об основных отличиях стандартного эмулятора от реального устройства и Genymotion: скорость! с очень быстрый и превращает процесс разработки под Android в удовольствие. Genymotion освобождает от необходимости постоянно отрываться от рабочей станции к реальному девайсу для тестирования. Благодаря этой софтине все происходит на вашей машине. Для того, чтобы продемонстрировать, насколько быстр Genymotion, я запустил небольшой проект с несколькими тестами на двух устройствах (Nexus 4) и экземпляр Genymotion работающем на моем MacBook. Результаты говорят сами за себя, тесты на Genymotion прошли по крайней мере в 10 раз быстрее, чем на Nexus 4:



![Tests](https://lh3.googleusercontent.com/-Vp3Bq5WCeT0/UeeXbFc9pqI/AAAAAAAAIyM/eb6bNTx0d1U/w902-h361-no/tests.png)  
  
Tests



Впервые я попробовал Genymotion кода он еще был известным по имени AndroVM. На тот момент этот продукт имел большой потенциал, но был сыроват и сложен в настройке, что перекрывало все пути к средам разработки под Android. Последняя версия софта которую продемонстрировал Genymobile (компания которая стоит за Genymotion) вытолкнула Genymotion на новый уровень. После нового неплохого демо от команды Genymotion на Droidcon France, я решил еще раз попробовать часок его потестить и пришел к выводу что его рационально использовать в ежедневной разработке. Теперь свой личный девайс использую либо лишь для последней фазы тестирования, либо как обычный телефон. Скорость основное преимущество Genymotion, но есть еще:








  * 



протестированные и доверительные ROM’ы: Команда очень старается чтобы обеспечить CTS-compliant своих ROM’ов. Недавно они заявили что прошли 99.4% AOSP CTS. Можно ожидать что в ближайшее будет обеспечена полная совместимость.







  * 



аппаратное управление: Вы можете эмулировать много различных фич, например управление GPS сенсором. Вам всего лишь нужно указать на маркером на карте точку и он подхватит соответствующие координаты. ![GPS test](https://lh4.googleusercontent.com/-nTA9xWhMFUo/UeeXbZS7H3I/AAAAAAAAIyE/J1ZUuSD7Fv0/w838-h549-no/gps_control_center.png)







  * 



поддержка сервиса **Google Play**: Некоторые ROM’ы были укомплектованы приложениями от Google, у вас будет доступ к тем самым фичам что и у настоящего апарата. Соответственно, вы можете устанавливать и тестировать те же фреймворки, такие как **Google Play Services**. Это позволит вам тестировать приложения даже если они используют **Google Maps Android API v2** или последнее локационное API (через провайдер локации).







  * 



полная интеграция с **Android Studio & Eclipse**: Genymotion представляет простой UI для начала/создания нового виртуального устройства в мгновении. Также можете использовать плагины.







  * 



независимость от среды: доступен под Windows, Mac OS X or Linux







  * 



поддержка консоли: Genymotion предоставляет возможность написать модификации скрипта для состояний сенсора.










Давайте уточним, наличие быстрой виртуальной машины никак не значит что вы не должны тестировать на реальных устройствах. Это хорошая возможность быстро на кидать и отшлифовать прототип. Как не крути, лучшим способом удостоверится, что все работает плавно на реальных устройствах на них и провеять. У Genymotion все еще есть некоторые незначительные баг/недостающие фичи (это все еще Бета). Но его скорость, простота интеграции в среду разработки делают его мощным инструментом в арсенале разработчика.
В этой статье я расскажу как как установить среду разработки Android используя Android Studio и Genymotion. При переходе от Eclispe/ADT к Android Studio я исследовал альтернативные конфигурации для улучшения сборочной среды. Нашел неплохой эмулятор Genymotion. Интересный, довольно быстрый и очень простой.





**Что нам нужно?**




<!-- more -->



  * [Android Studio](http://android-helper.com.ua/android-studio/)



  * [Oracle VM VirtualBox](https://www.virtualbox.org/wiki/Downloads)



  * [Genymotion Android emulator](http://www.genymotion.com/)



  * [Genymotion Android studio plugin](http://www.genymotion.com/)






**Установка Oracle VM VirtualBox** Если вы используете Windows в загруженном вами пакете будет все необходимое, в противном случае вам нужно будет скачать и установить ее самостоятельно. Процесс простой и прямолинейный но эти действия необходимо выполнить иначе Android Emulator не запуститься.





**Установка Genymotion Android device emulator** Первое что нужно это сделать создать аккаунт, чтобы иметь возможность скачать эмулятор. Вы можете выбирать среди платформ, в моем случае это Mac OS X. Когда вы его скачали и установили у вас должно получиться что-то такое:



![Genymotion Android device emulator](https://lh4.googleusercontent.com/-XTLtY_Lu-uo/UdZ1ohxTDpI/AAAAAAAAIxU/UHNpDYatWSE/w878-h549-no/emulator1.png)  
  
Genymotion Android device emulator



У вас может быть доступно множество эмуляторов. Вы выбираете и грузите его с сети. Как результат у вас готовый эмулятор.



![Genymotion Android device emulator](https://lh3.googleusercontent.com/-bSICk3KwvT0/UdZ1oresDZI/AAAAAAAAIxE/VXQYFWzmdBs/w878-h549-no/emulator2.png)  
  
Genymotion Android device emulator



**Установка Android Studio Plugin** Чтобы интегрировать средство разработки с эмулятором вам необходимо установить плагин для Android Studio. Зайдите в Preferences там Plugin, выбираем нужный нам. Добавляем плагин который мы уже скачали и видим:



![Genymotion Android Studio Plugin](https://lh3.googleusercontent.com/-7ESa9bvI8oY/UdZ1ouyWdyI/AAAAAAAAIxQ/cod9TPdH1Qc/w878-h549-no/emulator3.png)  
  
Genymotion Android Studio Plugin



**Результат**





Теперь вы можете запустить Android проект и вы увидите:



![Genymotion Android Studio Plugin](https://lh4.googleusercontent.com/-pu_27RpWvZI/UdZ1pYXK1xI/AAAAAAAAIxM/qk4W1XYDUw4/w878-h549-no/emulator4_1.png)  
  
Genymotion Android Studio Plugin



Эмулятор полностью интегрирован в вашу среду разработки . Первый раз когда вы запустите эмулятор вы можете увидеть диалог который спросит путь к Android SDK:



![Genymotion Android Studio Plugin](https://lh3.googleusercontent.com/-kJdXolrj9RQ/UdZ1pOHCHFI/AAAAAAAAIxI/L8cSs1wTSNk/w878-h549-no/emulator4.png)  
  
Genymotion Android Studio Plugin



Как-только все настроено можно запускать свой проект. ![Genymotion Android Studio Plugin](https://lh4.googleusercontent.com/-vvfjkEI4RRw/UdZ1ph1p7II/AAAAAAAAIxc/n31dDQvUqj4/w878-h549-no/emulator5.png)





**Видео**



{% youtube 63T-8YRlFmE %}





Надеюсь статья была для вас полезной. Если да нажимайте рассказать друзьям :)
Друзья всем привет.





Сегодня речь пойдет о замечательной среде разработки Android Studio.





Когда мы транслировали в прямом эфире [I\O 2013](http://android-helper.com.ua/google-io-2013/), многие из вас увидели хорошую программу для разработки и даже было несколько слов о ней сказано.





Сегодня я постараюсь сделать небольшой обзор того, почему же она вызвала такой фурор.


<!-- more -->


### Видео





Ну что глянем сначала видео?





{% youtube uWnhrW-Gu0U %}



### Краткое описание








  1. Когда я первый раз ее запустил, то увидел, что основы этой студии идут от очень хорошего продукта для разработки Intellij.






![Android studio - Начало](http://android-helper.com.ua/images/uploads/2013/05/as1.jpg)





2. Структура проекта отличается от той которую использует Eclipse.



![Android studio - Структура](http://android-helper.com.ua/images/uploads/2013/05/as3.jpg)
Android studio - Структура



### А теперь начинаются самое интересное.








  1. 



Начнем с малого. Каждый из вас думал какой цвет ему использовать в своей программе. Придумал выбрал в редакторе, вставил в код и потом на другой день просто забыл или это синий или голубоватый. Я думаю так бывало с каждым. Но эту проблему решили. ![Android studio - Цвета](http://android-helper.com.ua/images/uploads/2013/05/as2.jpg)







  2. 



Следующим по очереди идет java код. К примеру я покажу **MainActivity.java**. И дам каждому пункту описание. ![Android studio - MainActivity](http://android-helper.com.ua/images/uploads/2013/05/as4.jpg)






    1. Теперь если мы пишем для **ImageView** _setImageResource(R.drawable.bla-bla)_, то у нас слева будет показан ресурс который мы используем.



    2. Теперь не нужно переходить в **strings.xml**, что бы посмотреть какая строка у вас будет в конкретном **TextView**. Студия сама покажет вам строку. А также может показать для какого языка она не переведена.



    3. Что я заметил, так это светло-желтый цвет выделения одного из запросов. Мне стало интересно почему. Когда я навел на него мышку, то увидел, что мне подсказывает возможный **NullPointerException**. И это очень порадовало. Так как много багов потом появляется просто из-за того, что ты забыл поставить проверку.






  3. 



Еще одним замечательным свойством, есть просмотр того, что вы сделали в вашем дизайне. Это значит, что теперь с помощью одной команды вы сможете увидеть ваш layout на всех устройствах. Очень удобно. ![Android studio - Просмотр на устройсвах](http://android-helper.com.ua/images/uploads/2013/05/as5.jpg)







  4. 



Еще одним бесспорным моментом является то, что теперь сборка ваших проектов работает намного быстрее.







  5. 



Intellij всегда брала тем, что у нее очень много полезных советов для правильного и главное быстрого написания кода.







  6. Но есть и несколько недостатков. Но это все исправляют и они не существенны.






### Завершение





Надеюсь вам понравилась статья. Если кто то, что нарыл нового в студии, то пишите, буду обновлять статью.
Всем привет.





За этих 2 дня мы посомтрели очень много полезной информации.





Сегодня же стартует не менее важная презентация.


<!-- more -->




**Google I/O Pitch Night**





Что вы можете тут взять для себя?





Как делать стартапы и правильно их презентовать.





Ну что смотрим?


{% youtube 9yZ6KpZ6y44 %}

Срочно!





Все трансляции в одном месте!<!-- more -->





**Google I/O 2013: Day 2 Android Sessions**





**Google I/O 2013 Technical Sessions 2**





**Google I/O 2013 Chrome Sessions**




{% youtube hXPAXKb-LQE %}Всем привет.





Сегодня стартует очень популярная конференция **Google I/O 2013**.





И наш сайт ведет онлайн трансляцию.



 <!-- more -->

Что будет и сама трансляция








  * на ней будет представлена новая версия операционной системы Android 4.3



  * новые планшеты семейства Nexus



  * умные очки Google Glass






**Онлайн трансляция:**


{% youtube 9pmPa_KxsAM %}






Расскажите друзьям.
> 


> 
> Привет друзья. Я очень рад, приветствовать вас на нашем блоге. Сегодня мы рассмотрим следующую задачу.
> 
> 







### Задача





Нужно сделать вывод сообщения поверх ActionBar.


 <!-- more -->

![device-2013-05-03-234631](http://android-helper.com.ua/images/uploads/2013/05/device-2013-05-03-234631.png)]
![device-2013-05-03-234636](http://android-helper.com.ua/images/uploads/2013/05/device-2013-05-03-234636.png)
![device-2013-05-03-234643](http://android-helper.com.ua/images/uploads/2013/05/device-2013-05-03-234643.png)
![device-2013-05-03-234657](http://android-helper.com.ua/images/uploads/2013/05/device-2013-05-03-234657.png)




### Краткое описание





И так наша задача вывести нотификацию поверх ActionBar. Ну скажем это одно из требований дизайна и заказчика.





### Видео


{% youtube xIuhouqkX8E %}






### Коды для реализации





**MainActivity.java**




    
    @Override
    
    public void onCreate(Bundle savedInstanceState) {
    
        super.onCreate(savedInstanceState);
    
        ActionBar actionBar = getActionBar();
    
        actionBar.setDisplayOptions(ActionBar.DISPLAY_SHOW_HOME
    
                | ActionBar.DISPLAY_SHOW_TITLE | ActionBar.DISPLAY_SHOW_CUSTOM);
    
    
    
        setContentView(R.layout.main);
    
    
    
        prepareNotificationBar();
    
    
    
        initButtons();
    
    }
    
    
    
    private void prepareNotificationBar() {
    
        android.view.Window window = getWindow();
    
    
    
        // Получаем полное строенние вашего приложения
    
        ViewGroup decor = (ViewGroup) window.getDecorView();
    
        // Берем первый элемент, это то что было построенно
    
        View allcontent = decor.getChildAt(0);
    
        // Удаляем его что бы очистить строение
    
        decor.removeView(allcontent);
    
    
    
        LayoutInflater li = getLayoutInflater();
    
        // загружаем части элементов
    
        FrameLayout main = (FrameLayout) li.inflate(R.layout.content_frame, null);
    
        FrameLayout notificationFrame = (FrameLayout) li.inflate(R.layout.notification_frame, null);
    
        // находим нужные нам фреймы
    
        notificationBar = (ViewGroup) main.findViewById(R.id.notificationLayout);
    
        content = (ViewGroup) main.findViewById(R.id.contentLayout);
    
    
    
        // ВАЖНО! получаем высоту статус бара
    
        // -----
    
        int resourceId = getResources().getIdentifier("status_bar_height", "dimen", "android");
    
    
    
        statusBarHeight = 0;
    
    
    
        if (resourceId > 0) {
    
            statusBarHeight = getResources().getDimensionPixelSize(resourceId);
    
        }
    
        // -----
    
    
    
        // Сдвигаем наши фреймы на высоту статус бара
    
        notificationBar.setPadding(notificationBar.getPaddingLeft(), statusBarHeight, notificationBar.getPaddingRight(),
    
                0);
    
        notificationBar.addView(notificationFrame);
    
    
    
        content.setPadding(content.getPaddingLeft(), statusBarHeight, content.getPaddingRight(),
    
                0);
    
    
    
        // добавляем фреймы
    
        content.addView(allcontent);
    
        decor.addView(main);
    
    }
    
    







### Скачать коды





Скачать коды программы вы можете на нашей [странице](http://android-helper.com.ua/codes/)





### Скачать приложение





Также мы выложили на [Play Market](https://play.google.com/store/apps/details?id=com.android_helper.ActionBarNotification) наше приложение. Установив его, вы сможете посмотреть как оно работает. (Не забудьте поставить +1 и написать позитивный комментарий :) ).





[![Android app on Google Play](https://developer.android.com/images/brand/en_app_rgb_wo_45.png)](https://play.google.com/store/apps/details?id=com.android_helper.ActionBarNotification)





### Оценка статьи





Надеюсь, что вам понравилась статья. Жду ваши комментарии и несколько лайков.
### Задача





Красочный переход между Activity.


 <!-- more -->


### Краткое описание





Многие из вас видели как красиво в некоторых приложениях идут переходы между Activity. Если взять простые примеры от Google, то вы увидите только плавное смещение с лева на право. А у нас с вами задача сделать так, что бы из первого Activity появлялось второе.





### Видео урок



{% youtube Bfh0cJBOASQ %}





### Коды





**Activity1.java**




    
    	SplitAnimation.startActivity(Activity1.this, new Intent(Activity1.this, Activity2.class));





**Activity2.java**




    
    
		@Override
    
    protected void onCreate(Bundle savedInstanceState) {
    
        super.onCreate(savedInstanceState);
    
    
    
        // Preparing the 2 images to be split
    
        SplitAnimation.prepareAnimation(this);
    
    
    
        setContentView(R.layout.act_two);
    
    
    
        // Animating the items to be open, revealing the new activity
    
        SplitAnimation.animate(this, 1000);
    
    }
    
    
    
    @Override
    
    protected void onStop() {
    
        // If we're currently running the entrance animation - cancel it
    
        SplitAnimation.cancel();
    
    
    
        super.onStop();    //To change body of overridden methods use File | Settings | File Templates.
    
    }
    
    



**SplitAnimation.java**




    
    	public static void startActivity(Activity currActivity, Intent intent) {
    
        // Подготовка acticity
    
        prepare(currActivity);
    
    
    
        currActivity.startActivity(intent);
    
        // Чистка анимаций текущей activity
    
        currActivity.overridePendingTransition(0, 0);
    
    }
    
    
    
    private static void prepare(Activity currActivity) {
    
    
    
        // Получаем content activity и делаем из него bitmap
    
        View root = currActivity.getWindow().getDecorView().findViewById(android.R.id.content);
    
        root.setDrawingCacheEnabled(true);
    
        Bitmap bmp = root.getDrawingCache();
    
    
    
        // Указываем в какой части экрана будет делится activity
    
        splitYCoord = bmp.getHeight() / 2;
    
    
    
        // Разделяем экран
    
        mBmp1 = Bitmap.createBitmap(bmp, 0, 0, bmp.getWidth(), splitYCoord);
    
        mBmp2 = Bitmap.createBitmap(bmp, 0, splitYCoord, bmp.getWidth(), bmp.getHeight() - splitYCoord);
    
    
    
        // Указываем координаты положения частей activity
    
        mLoc1 = new int[]{0, root.getTop()};
    
        mLoc2 = new int[]{0, root.getTop() + splitYCoord};
    
    }
    
    
    
    public static void prepareAnimation(final Activity destActivity) {
    
        mTopImage = createImageView(destActivity, mBmp1, mLoc1);
    
        mBottomImage = createImageView(destActivity, mBmp2, mLoc2);
    
    }
    
    
    
    private static ImageView createImageView(Activity destActivity, Bitmap bmp, int loc[]) {
    
        ImageView imageView = new ImageView(destActivity);
    
        imageView.setImageBitmap(bmp);
    
    
    
        WindowManager.LayoutParams windowParams = new WindowManager.LayoutParams();
    
        windowParams.gravity = Gravity.TOP;
    
        windowParams.x = loc[0];
    
        windowParams.y = loc[1];
    
        windowParams.height = ViewGroup.LayoutParams.WRAP_CONTENT;
    
        windowParams.width = ViewGroup.LayoutParams.WRAP_CONTENT;
    
        windowParams.flags =
    
                WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN
    
        ;
    
        windowParams.format = PixelFormat.TRANSLUCENT;
    
        windowParams.windowAnimations = 0;
    
        destActivity.getWindowManager().addView(imageView, windowParams);
    
    
    
        return imageView;
    
    }
    
    
    
    public static void animate(final Activity destActivity, final int duration) {
    
        animate(destActivity, duration, new DecelerateInterpolator());
    
    }
    
    
    
    public static void animate(final Activity destActivity, final int duration, final TimeInterpolator interpolator) {
    
    
    
        // Post this on the UI thread's message queue. It's needed for the items to be already measured
    
        new Handler().post(new Runnable() {
    
    
    
            @Override
    
            public void run() {
    
                mSetAnim = new AnimatorSet();
    
                mTopImage.setLayerType(View.LAYER_TYPE_HARDWARE, null);
    
                mBottomImage.setLayerType(View.LAYER_TYPE_HARDWARE, null);
    
                mSetAnim.addListener(new Animator.AnimatorListener() {
    
                    @Override
    
                    public void onAnimationStart(Animator animation) {
    
                    }
    
    
    
                    @Override
    
                    public void onAnimationEnd(Animator animation) {
    
                        clean(destActivity);
    
                    }
    
    
    
                    @Override
    
                    public void onAnimationCancel(Animator animation) {
    
                        clean(destActivity);
    
                    }
    
    
    
                    @Override
    
                    public void onAnimationRepeat(Animator animation) {
    
    
    
                    }
    
                });
    
    
    
                // Animating the 2 parts away from each other
    
                Animator anim1 = ObjectAnimator.ofFloat(mTopImage, "translationY", mTopImage.getHeight() * -1);
    
                Animator anim2 = ObjectAnimator.ofFloat(mBottomImage, "translationY", mBottomImage.getHeight());
    
    
    
                if (interpolator != null) {
    
                    anim1.setInterpolator(interpolator);
    
                    anim2.setInterpolator(interpolator);
    
                }
    
    
    
                mSetAnim.setDuration(duration);
    
                mSetAnim.playTogether(anim1, anim2);
    
                mSetAnim.start();
    
            }
    
        });
    
    }
    


### Скачать коды





Скачать коды программы вы можете на нашей [странице](http://android-helper.com.ua/codes/)





### Скачать приложение





Также мы выложили на [Play Market](https://play.google.com/store/apps/details?id=com.android_helper.SplitActivityAnimation) наше приложение. Установив его, вы сможете посмотреть как оно работает. (Не забудьте поставить +1 и написать позитивный комментарий :) ).





[![Android app on Google Play](https://developer.android.com/images/brand/en_app_rgb_wo_45.png)](https://play.google.com/store/apps/details?id=com.android_helper.SplitActivityAnimation)





### Оценка статьи





Надеюсь, что вам понравилась статья. Жду ваши комментарии и несколько лайков.




Добрый день.





14 выпуск передачи — Программирование под андроид.





Сегодня в уроке : Добавление звука на Splashscreen 


<!-- more -->


Смотрим, учимся, рассказываем друзьям.

{% youtube mOs_M8_Tyks %}


Добрый день.





13 выпуск передачи — Программирование под андроид.





Сегодня в уроке : жизненный цикл activity.


<!-- more -->


Смотрим, учимся, рассказываем друзьям.


{% youtube IL5APBsiaIQ %}

Добрый день друзья.





12 выпуск передачи - Программирование под андроид.


<!-- more -->


Смотрим, учимся, рассказываем друзьям.


{% youtube tYVErdtRY9o %}

Всем привет.





Один из моих читателей попросил написать, как можно сделать картинку на весь экран.





Я думаю, что он хочет сделать скажем так splashscreen.



 <!-- more -->

Если же нет, то тогда и он и все остальные новички, смогут увидеть эту реализацию.





Смотрим уроки и комментируем.


{% youtube nMnGGQ-M1YQ %}

{% youtube zrrH7VpDfrw %}

{% youtube -OkikdXA4y8 %}














Рассказывайте друзьям!
20 апреля в Санкт-Петербурге [ITmozg](http://spb.itmozg.ru/) снова соберет на одной площадке новичков и профессионалов IT-рынка на ежегодном Фестивале профессионального развития — [BitByte](http://bitbyte.itmozg.ru/). 









![Bitbyte](http://www.droidnews.ru/wp-content/uploads/2013/03/bitbyte_logo_2013-600x242.jpg)


 <!-- more -->

  
   
В программе:  
— Две параллельные секции докладов, посвященные техническим и карьерным вопросам;  
— Выставка, где можно напрямую пообщаться с представителями IT-компаний, узнать о возможностях трудоустройства;  
— Много активностей: головоломки и тесты, розыгрыши и подарки, сюрпризы и еще много-много интересного :)













Среди компаний-участников: Google, Oracle, EMC, Яндекс.Деньги, Sperasoft, Mail. ru Group, T-Systems, Электрон и многие другие.





Участие бесплатное! Вход только по регистрации [http://bitbyte.itmozg.ru/register#form](http://bitbyte.itmozg.ru/register#form) 





Все подробности на сайте мероприятия: [http://bitbyte.itmozg.ru](http://bitbyte.itmozg.ru/)
Ну что, кто может сказать, когда мы уже, наконец, увидим следующую версию Android? Наверное, большинство из читателей скажет, что подобное событие произойдёт на мероприятии Google I/O. Во всяком случае об этом твердит большинство источников, и именно на это намекает прошлый опыт. Так что терпеливо ждём 15 мая.









![Эволюция Android](http://www.droidnews.ru/wp-content/uploads/2013/04/Android-5.0-Key-Lime-Pie-Rumors1-600x347.jpg)



 <!-- more -->




Однако, пока мы застыли в ожидании, давайте посмотрим, какие интересные слухи и догадки блуждают по Сети касаемо Android 5.0 Key Lime Pie.









Первое, о чем можно встретить упоминание — свежее ядро Linux версии 3.8. Любители перепрошиваться знают, насколько важно в системе грамотно собранное ядро. Ведь от него во многом зависит скорость работы мультитаскинга, оно может сильно влиять на расход заряда батареи, ядро же определит, сколько оперативной свободной памяти будет выделено пользователю. Так что у многих сейчас есть надежды, что оптимизация ядра поможет улучшить ситуацию вокруг некоторых давних проблем нашей любимой ОС.





Второй интересный слух про Kie Lime Pie гласит, что эта версия Android будет работать исключительно на четырёхъядерных устройствах. Однако, лично мне кажется, что такое развитие событий очень маловероятно. Вряд ли в Google решатся так сразу оставить огромное количество чуть менее современных устройств без обновления системы.





Куда более вероятным кажется, что в Key Lime Pie появится унифицированная Google-платформа для общения Google Babel, которая объединит в себе Google Talk, Google Plus, Google Voice.





Наверняка же к Android 5.0 обновится клавиатура, которая порадует нас более обширными словарями и улучшенными алгоритмами предугадывания вводимого текста.





Интересным остаётся вопрос, на каком именно устройстве нам продемонстрируют Key Lime Pie. Будет ли это Nexus 5 или же ожидаемый многими Motorola X Phone. Что вы думаете по этому поводу?





А вам какие из этих слухов кажутся максимально достоверными? Или какие наоборот — откровенной чепухой? Чего бы хотелось, чтобы подтвердилось?









 
Всем привет.





Сегодня один из моих читателей попросил написать статью как можно изменять цвет елементам.





В своем примере я покажу, как можно менять цвет выбранной кнопки.




 <!-- more -->




А теперь части кода:





**colors.xml**





	<color name="widget_button_pressed">#FFFF00</color>

	<color name="widget_button">#00000000</color>

	<color name="widget_background">#FF000000</color>



	<?xml version="1.0" encoding="utf-8"?>

	<selector xmlns:android="http://schemas.android.com/apk/res/android">



		<item android:drawable="@color/widget_button_pressed" android:state_pressed="true"/>

		<item android:drawable="@color/widget_button_pressed" android:state_selected="true"/>

		<item android:drawable="@color/widget_button_pressed" android:state_focused="true"/>

		<item android:drawable="@color/widget_button"/>

	</selector>



	<Button

		android:layout_width="wrap_content"

		android:layout_height="wrap_content"

		android:background="@drawable/button_selector"

		android:text="@string/hello_world" />





Полный проект вы можете скачать на нашей [странице с кодами](http://android-helper.com.ua/codes/).
Всем привет друзья.





Сегодня я подготовил для вас видео урок.





Как использовать Switch елемент для android 4.0+, а для версий ниже использовать CheckBox.

 <!-- more -->

{% youtube Ifs96nSYUlg %}






**Коды**





**/layout-v14/switch_for_include.xml**



	<?xml version="1.0" encoding="utf-8"?>

	<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"

    android:layout_width="match_parent"

    android:layout_height="match_parent"

    android:orientation="horizontal" >



    <Switch

        android:id="@+id/checkBox1"

        android:layout_width="fill_parent"

        android:layout_height="wrap_content"

        android:text="Android-helper.com.ua" />



	</LinearLayout>


**/layout/switch_for_include.xml**



	<?xml version="1.0" encoding="utf-8"?>

	<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"

    android:layout_width="match_parent"

    android:layout_height="match_parent"

    android:orientation="horizontal" >



    <TextView

        android:layout_width="fill_parent"

        android:layout_height="wrap_content"

        android:layout_weight="1"

        android:text="Android-helper.com.ua" />



    <CheckBox

        android:id="@+id/checkBox1"

        android:layout_width="wrap_content"

        android:layout_height="wrap_content"

        android:layout_weight="0" />



	</LinearLayout>


**/layout/activity_main.xml**


	<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"

    xmlns:tools="http://schemas.android.com/tools"

    android:layout_width="match_parent"

    android:layout_height="match_parent"

    android:orientation="vertical"

    tools:context=".MainActivity" >



    <TextView

        android:layout_width="wrap_content"

        android:layout_height="wrap_content"

        android:gravity="center"

        android:paddingBottom="30dp"

        android:text="Пример того как использовать Swich на разных устройствах" />



    <include layout="@layout/switch_for_include" />



	</LinearLayout>




**MainActivity.java**



	public class MainActivity extends Activity implements OnCheckedChangeListener {



    @Override

    protected void onCreate(Bundle savedInstanceState) {

        super.onCreate(savedInstanceState);

        setContentView(R.layout.activity_main);

        CompoundButton compoundButton = (CompoundButton) findViewById(R.id.checkBox1);

        compoundButton.setOnCheckedChangeListener(this);

    }



    @Override

    public void onCheckedChanged(CompoundButton arg0, boolean arg1) {

        Toast.makeText(this, "Все работает сейчас у нас " + arg1, Toast.LENGTH_LONG).show();

    }



	}


Коды программы вы можете скачать [тут](http://android-helper.com.ua/codes/)




Очень познавательная статья.





Читать всем разработчикам!





Перед любым начинающим Android-разработчиком рано или поздно встает вопрос о том, где и как удобнее запускать и отлаживать свои программы.













Самый верный способ — через Android Debug Bridge на реальном Android-устройстве. Но если, по каким то причинам, этот способ не подходит, то остается два варианта — воспользоваться штатным эмулятором Android Virtual Device (AVD) из Android SDK, или установить Android на виртуальную машину.  Про второй вариант я и хочу рассказать в этой статье. Android на виртуальной машине серьезно превосходит AVD по быстродействию и времени загрузки, но есть и недостатки — сложнее эмулировать телефонию (возможно, при помощи дополнительных программ), пока не разобрался как смонтировать SD-карту.







 <!-- more -->





**Итак! Нам понадобится**:





1. Готовая к работе среда разработки и Android SDK Tools - см. StartAndroid.ru урок 2.  
[http://startandroid.ru/uroki/vse-uroki-spiskom/9-urok-2-ustanovka-i-nastrojka-sredy-razrabotki.html](http://startandroid.ru/uroki/vse-uroki-spiskom/9-urok-2-ustanovka-i-nastrojka-sredy-razrabotki.html)





2. VirtualBox последней версии.  
[https://www.virtualbox.org/](https://www.virtualbox.org/).





3. Образ Android. Выбираем любую версию с сайта проекта Android-x86.  
[http://code.google.com/p/android-x86/](http://code.google.com/p/android-x86/)









### Шаг 1 — устанавливаем Virtual Box.





![](http://startandroid.ru/images/stories/articles/A0002/A0002_050.png)





![](http://startandroid.ru/images/stories/articles/A0002/A0002_060.png)





![](http://startandroid.ru/images/stories/articles/A0002/A0002_070.png)





![](http://startandroid.ru/images/stories/articles/A0002/A0002_080.png)





![](http://startandroid.ru/images/stories/articles/A0002/A0002_090.png)





![](http://startandroid.ru/images/stories/articles/A0002/A0002_100.png)













### Шаг 2 — Создаем виртуальную машину с Android.





![](http://startandroid.ru/images/stories/articles/A0002/A0002_110.png)





![](http://startandroid.ru/images/stories/articles/A0002/A0002_120.png)





![](http://startandroid.ru/images/stories/articles/A0002/A0002_130.png)





![](http://startandroid.ru/images/stories/articles/A0002/A0002_140.png)





![](http://startandroid.ru/images/stories/articles/A0002/A0002_150.png)





![](http://startandroid.ru/images/stories/articles/A0002/A0002_160.png)





![](http://startandroid.ru/images/stories/articles/A0002/A0002_170.png)













### Шаг 3 — настройка виртуальной машины и её запуск.





![](http://startandroid.ru/images/stories/articles/A0002/A0002_180.png)





![](http://startandroid.ru/images/stories/articles/A0002/A0002_190.png)





![](http://startandroid.ru/images/stories/articles/A0002/A0002_200.png)





![](http://startandroid.ru/images/stories/articles/A0002/A0002_210.png)





![](http://startandroid.ru/images/stories/articles/A0002/A0002_220.png)





Система не может найти диск для загрузки и останавливается. Монтируем скачанный образ Android.





![](http://startandroid.ru/images/stories/articles/A0002/A0002_230.png)





![](http://startandroid.ru/images/stories/articles/A0002/A0002_240.png)









Выбрать можно любой, но я советую работать с версией для EEEPC, например  
[android-x86-3.2-RC2-eeepc.iso](http://code.google.com/p/android-x86/downloads/detail?name=android-x86-3.2-RC2-eeepc.iso&can=4&q=). В других может возникнуть проблема — из под Android не будет виден виртуальный сетевой адаптер.





Перегружаем машину.





![](http://startandroid.ru/images/stories/articles/A0002/A0002_250.png)





![](http://startandroid.ru/images/stories/articles/A0002/A0002_260.png)





![](http://startandroid.ru/images/stories/articles/A0002/A0002_270.png)





Нажимаем ENTER и ждет загрузки Android.





![](http://startandroid.ru/images/stories/articles/A0002/A0002_280.png)





Закрываем обучающие подсказки. И выключаем функцию интеграции мыши, которая некорректно работает с нашей ОС, скрывая курсор.





![](http://startandroid.ru/images/stories/articles/A0002/A0002_290.png)













### Шаг 4 — настройка сети в виртуальном Android.





Щелкаем внутри окна и оказываемся в пространстве виртуальной машины.   
(чтобы вернуть курсор нужно нажать **правый CTRL**)





![](http://startandroid.ru/images/stories/articles/A0002/A0002_300.png)









Нажимаем **Alt+F1** и оказываемся в консоли.





![](http://startandroid.ru/images/stories/articles/A0002/A0002_310.png)









Присваиваем адрес сетевому адаптеру командой **ifconfig**:  
**ifconfig eth0 192.168.56.2 netmask 255.255.255.0**









Проверяем или переходим к следующему шагу. Основной комп пингуется по адресу 192.168.56.1 ("VirtualBox Host-Only Ethernet Adapter" в диспетчере устройств).  
Команда **ping**:  
**ping 192.168.56.1**  
**Ctrl+C**









Если все сработало нормально то увидим:





![](http://startandroid.ru/images/stories/articles/A0002/A0002_320.png)













### Шаг 5 — подсоединяем Android Debug Bridge (ADB) к виртуальной ОС.





Нажимаем **Alt+F7**, чтобы вернуться к графическому интерфейсу. Нажимаем **правый CTRL** и возвращаемся к реальной ОС. Не закрываем виртуальную машину.





Создаем на рабочем столе ярлык на **adb.exe**





![](http://startandroid.ru/images/stories/articles/A0002/A0002_330.png)





Нужный нам файл находится в папке Android SDK "platform-tools".





![](http://startandroid.ru/images/stories/articles/A0002/A0002_340.png)





Дописываем команду текстом "**connect 192.168.56.2**":





![](http://startandroid.ru/images/stories/articles/A0002/A0002_360.png)





![](http://startandroid.ru/images/stories/articles/A0002/A0002_370.png)









Запускаем ярлык.





Теперь ADB соединен с виртуальным Android, а он, в свою очередь, доступен для запуска и отладки программ из Eclipse. Цель достигнута. :)





Пересоединять ADB придется в том случае, когда вы закрыли или перезагрузили виртуальную машину.





**Так-же в случае, если вы перезагрузили виртуальный Android, придется возвращаться к шагу 4, так как настройки сетевого адаптера будут сброшены**. Поэтому я рекомендую не выключать виртуальную машину, а погружать её в сон, но ярлычек потом запустить все равно придется.





![](http://startandroid.ru/images/stories/articles/A0002/A0002_380.png)





![](http://startandroid.ru/images/stories/articles/A0002/A0002_390.png)













Заходим в Eclipse и проверяем как работает





![](http://startandroid.ru/images/stories/articles/A0002/A0002_400.png)





![](http://startandroid.ru/images/stories/articles/A0002/A0002_410.png)





![](http://startandroid.ru/images/stories/articles/A0002/A0002_420.png)













![](http://startandroid.ru/images/stories/articles/A0002/A0002_430.png)





Благодарности:





**renton** с habrahabr.ru — его идея.  
[http://habrahabr.ru/post/119599/](http://habrahabr.ru/post/119599/)





 Источник [startandroid.ru](http://startandroid.ru/ru/articles/listofarticles/206-bystraja-alternativa-android-virtual-device.html)
Всем привет.





Есть много программ с которых программисты и дизайнеры берут свои идеи.





И вот одна из которых это приложение facebook для android.





С этой программы дизайнеры взяли такую вещь как sliding menu.





Давайте посмотрим, что это такое.

 <!-- more -->



![Screenshot_2013-01-17-19-47-11](http://android-helper.com.ua/images/uploads/2013/01/Screenshot_2013-01-17-19-47-11.png)




 





![Screenshot_2013-01-02-02-24-31](http://android-helper.com.ua/images/uploads/2013/01/Screenshot_2013-01-02-02-24-31.png)





 





### Задача





Сделать что то подобное.





### Реализация





Для реализации данной задачи, мы будем использовать открытую библиотеку [SlidingMenu](https://github.com/jfeinstein10/SlidingMenu).





Также как она работает можете посмотреть, скачав приложение с [маркета](https://play.google.com/store/apps/details?id=com.slidingmenu.example).





### Коды





**MainActivity.java**



	public class MainActivity extends Activity {



    @Override

    protected void onCreate(Bundle savedInstanceState) {

        super.onCreate(savedInstanceState);

        setContentView(R.layout.activity_main);



        setTitle("Attach");

        // configure the SlidingMenu

        SlidingMenu menu = new SlidingMenu(this);

        menu.setMode(SlidingMenu.LEFT);

        menu.setTouchModeAbove(SlidingMenu.TOUCHMODE_FULLSCREEN);

        menu.setShadowWidthRes(R.dimen.shadow_width);

        menu.setShadowDrawable(R.drawable.shadow);

        menu.setBehindOffsetRes(R.dimen.slidingmenu_offset);

        menu.setFadeDegree(0.35f);



        // ///////////

        menu.attachToActivity(this, SlidingMenu.SLIDING_CONTENT);

        // //////////



        menu.setMenu(R.layout.menu);

    }



    @Override

    public boolean onCreateOptionsMenu(Menu menu) {

        // Inflate the menu; this adds items to the action bar if it is present.

        getMenuInflater().inflate(R.menu.activity_main, menu);

        return true;

    }



	}


**drawable/shadow.xml**


	<?xml version="1.0" encoding="utf-8"?>

	<shape xmlns:android="http://schemas.android.com/apk/res/android" >



    <gradient

        android:centerColor="#11000000"

        android:endColor="#33000000"

        android:startColor="#00000000" />



	</shape>


**layout/menu.xml**


	<?xml version="1.0" encoding="utf-8"?>

	<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"

    android:layout_width="match_parent"

    android:layout_height="match_parent"

    android:orientation="vertical" >



    <TextView

        android:id="@+id/textView1"

        android:layout_width="wrap_content"

        android:layout_height="wrap_content"

        android:text="Menu 1"

        android:textAppearance="?android:attr/textAppearanceLarge" />



    <TextView

        android:id="@+id/textView2"

        android:layout_width="wrap_content"

        android:layout_height="wrap_content"

        android:text="Menu 2"

        android:textAppearance="?android:attr/textAppearanceLarge" />



    <TextView

        android:id="@+id/textView3"

        android:layout_width="wrap_content"

        android:layout_height="wrap_content"

        android:text="Menu 3"

        android:textAppearance="?android:attr/textAppearanceLarge" />



    <TextView

        android:id="@+id/textView4"

        android:layout_width="wrap_content"

        android:layout_height="wrap_content"

        android:text="Menu 4"

        android:textAppearance="?android:attr/textAppearanceLarge" />



	</LinearLayout>


**values/dimens.xml**



	<?xml version="1.0" encoding="utf-8"?>

	<resources>



    <dimen name="slidingmenu_offset">60dp</dimen>

    <dimen name="list_padding">10dp</dimen>

    <dimen name="shadow_width">15dp</dimen>



	</resources>


### Видео


{% youtube eHWNIS64I0Q %}






Рабочий код на странице с [кодами](http://android-helper.com.ua/codes/).
Привет друзья.





После выхода android 4. Все дизайнеры как будто сговорились и прикручивают actionbar кругом.





И заказчик говорит, что именно так должно быть и для старых версий.





И что же делать? Писать свой actionbar?


 <!-- more -->


Нам на помощь приходит очень классная и бесплатная библиотека [ActionBarSherlock](http://actionbarsherlock.com/)





Я думаю, что большая часть из вас будет ее использовать.





Но могут быть и такие которые скажут, мы не используем сторонние библиотеки.





Это вам решать, но от себя добавлю, что эту библиотеку рекомендует google.





Пришло время писать код.





### Задача





Сделать actionbar меню для всех телефонов.





### Ресурсы





ActionBarSherlock





### Примеры реализации





![feature_02](http://android-helper.com.ua/images/uploads/2013/01/feature_02.png)





 





![feature_03](http://android-helper.com.ua/images/uploads/2013/01/feature_03.png)



 





![feature_01](http://android-helper.com.ua/images/uploads/2013/01/feature_01.png)





 





 





### Реализация








  1. Подключаем проект Sherlock в eclipse. Скачать можно [тут](https://api.github.com/repos/JakeWharton/ActionBarSherlock/zipball/4.2.0).



  2. Создаем свой проект



  3. Подключаем библиотеку sherlock к вашему проекту



  4. Делаем файл меню



  5. ВАЖНО! Все активити и фрагменты должны наследоваться от SherlockActivity и SherlockFragment






### Коды





#### menu/activity_main.xml





	<menu xmlns:android="http://schemas.android.com/apk/res/android" >



    <item

        android:id="@+id/item1"

        android:icon="@android:drawable/ic_menu_agenda"

        android:orderInCategory="100"

        android:showAsAction="always|withText"

        android:title="Item 1"/>

    <item

        android:id="@+id/item2"

        android:icon="@android:drawable/ic_menu_call"

        android:orderInCategory="200"

        android:showAsAction="always|withText"

        android:title="Item 2"/>

    <item

        android:id="@+id/item3"

        android:icon="@android:drawable/ic_menu_camera"

        android:orderInCategory="300"

        android:showAsAction="ifRoom|withText"

        android:title="Item3"/>

    <item

        android:id="@+id/menu_settings"

        android:orderInCategory="400"

        android:showAsAction="never"

        android:title="@string/menu_settings"/>



	</menu>





#### MainActivity.java



	package com.ua.android_helper.testactionbar;



	import android.os.Bundle;

	import com.actionbarsherlock.app.SherlockActivity;

	import com.actionbarsherlock.view.Menu;



	public class MainActivity extends SherlockActivity {



    @Override

    protected void onCreate(Bundle savedInstanceState) {

        super.onCreate(savedInstanceState);

        setContentView(R.layout.activity_main);

    }



    @Override

    public boolean onCreateOptionsMenu(Menu menu) {

        getSupportMenuInflater().inflate(R.menu.activity_main, menu);

        return true;

    }



	}


#### AndroidManifest.xml


	<?xml version="1.0" encoding="utf-8"?>

	<manifest xmlns:android="http://schemas.android.com/apk/res/android"

    package="com.ua.android_helper.testactionbar"

    android:versionCode="1"

    android:versionName="1.0" >



    <uses-sdk

        android:minSdkVersion="8"

        android:targetSdkVersion="17" />



    <application

        android:allowBackup="true"

        android:icon="@drawable/ic_launcher"

        android:label="@string/app_name"

        android:theme="@style/Theme.Sherlock" >

        <activity

            android:name="com.ua.android_helper.testactionbar.MainActivity"

            android:label="@string/app_name" >

            <intent-filter>

                <action android:name="android.intent.action.MAIN" />



                <category android:name="android.intent.category.LAUNCHER" />

            </intent-filter>

        </activity>

    </application>



	</manifest>



**Видео**

{% youtube GOB72vWY_5s %}


Друзья всем привет.





Сегодня я бы хотел поведать вам о замечательном поведении в ActionBar.





C Android 3.0 в ActionBar добавили классное поведение для выбранных элементов.





Но давайте это посмотрим на примере.

 <!-- more -->



#### Задача





Дать возможность в ListView выбрать несколько элементов и например скопировать их названия. И эти названия вывести в диалог.





#### Результат урока





[![device-2013-01-25-092939](http://android-helper.com.ua/images/uploads/2013/01/device-2013-01-25-092939-180x300.png)](http://android-helper.com.ua/images/uploads/2013/01/device-2013-01-25-092939.png)[![device-2013-01-25-093344](http://android-helper.com.ua/images/uploads/2013/01/device-2013-01-25-093344-180x300.png)](http://android-helper.com.ua/images/uploads/2013/01/device-2013-01-25-093344.png)





#### [![device-2013-01-25-093353](http://android-helper.com.ua/images/uploads/2013/01/device-2013-01-25-093353-180x300.png)](http://android-helper.com.ua/images/uploads/2013/01/device-2013-01-25-093353.png)





####  





####  





####  





####  





####  





####  





####  





####  





####  





#### [![device-2013-01-25-093405](http://android-helper.com.ua/images/uploads/2013/01/device-2013-01-25-093405-180x300.png)](http://android-helper.com.ua/images/uploads/2013/01/device-2013-01-25-093405.png)





#### [![device-2013-01-25-093431](http://android-helper.com.ua/images/uploads/2013/01/device-2013-01-25-093431-180x300.png)](http://android-helper.com.ua/images/uploads/2013/01/device-2013-01-25-093431.png)





####  





####  





####  





####  





####  





####  





####  





####  





####  





#### Реализация





Создаем проект с минимальным значением android - 11.





Activity наследуем от ListActivity.



[java]public class MainActivity extends ListActivity {



    String[] data = { "one", "two", "three", "four", "five" };



    @Override

    protected void onCreate(Bundle savedInstanceState) {

        super.onCreate(savedInstanceState);

        prepareListView();

    }

[/java]  
  




Заполняем ListView



[java] private void prepareListView() {



        ArrayAdapter<String> adapter = new ArrayAdapter<String>(this, android.R.layout.simple_list_item_activated_1,

                data);

        getListView().setAdapter(adapter);[/java]  
  




Создаем menu для action mode



[xml]<?xml version="1.0" encoding="utf-8"?>

<menu xmlns:android="http://schemas.android.com/apk/res/android" >



	<item

		android:id="@+id/copy"

		android:icon="@android:drawable/ic_menu_save"

		android:showAsAction="always|withText"

		android:title="@string/copy">

	</item>



</menu>[/xml]  
  




Добавляем обработчики для action mode и показываем диалог



[java]private final MultiChoiceModeListener callback = new MultiChoiceModeListener() {



        private final StringBuilder message = new StringBuilder();



        @Override

        public boolean onPrepareActionMode(ActionMode mode, Menu menu) {

            return false;

        }



        @Override

        public void onDestroyActionMode(ActionMode mode) {



        }



        @Override

        public boolean onCreateActionMode(ActionMode mode, Menu menu) {

            mode.getMenuInflater().inflate(R.menu.context, menu);

            return true;

        }



        @Override

        public boolean onActionItemClicked(ActionMode mode, MenuItem item) {

            if (item.getItemId() == R.id.copy) {

                AlertDialog.Builder builder = new AlertDialog.Builder(MainActivity.this);

                builder.setTitle("Action Mode").setMessage(message.toString()).create().show();

            }

            mode.finish();

            return false;

        }



        @Override

        public void onItemCheckedStateChanged(ActionMode mode, int position, long id, boolean checked) {

            if (checked) {

                String title = data[position];

                message.append("\n" + title);

            }

        }

    };[/java]  
  




Добавляем возможность вызова action mode из ListView и множественный выбор.



[java]//

        getListView().setChoiceMode(ListView.CHOICE_MODE_MULTIPLE_MODAL);

        //

        getListView().setMultiChoiceModeListener(callback);[/java]  
  




Все готово.





Для того что бы скачать исходники вам необходимо перейти на [страницу с исходниками](http://android-helper.com.ua/codes/)
Всем привет.





Прошу простить меня, что очень долго не радовал своих читателей блога, хорошими примерами.





Вот недавно я лазил по просторах инета и нашел замечательную [статью](http://habrahabr.ru/post/166351/).





О том как можно сделать разметку html в обычном TextView.

 <!-- more -->



Автор довольно хорошо высветел эту тему. Хотел переработать для вас, но все что тут написано, действительно нужно.





Ну что ж господа. Прошу к прочтению.





Недавно мне понадобилось сделать довольно хитроумный чат в приложении под Android. Помимо собственно информации требовалось передавать пользователям дополнительную функциональность в контексте определенного сообщения: имя автора сообщения по нажатию на него должно вставляться в текстовое поле ответа, а если это сообщение о только что созданном игровом сеансе, пользователи должны иметь возможность присоединиться к игре по клику и так далее. Одним из главных требований была возможность создавать сообщение, содержащее несколько ссылок, что и задало направление исследований.  
  
**WebView**, обладая нужной функциональностью, был отвергнут по причине тяжести решения: я даже не стал создавать 100 или сколько-нибудь там экземпляров в тестовых целях, по одному на каждое сообщение, поскольку сразу было понятно, что это расточительство нормально работать не будет.





К счастью, самый обычный [**TextView**](http://developer.android.com/reference/android/widget/TextView.html) обладает неожиданно потрясающей функциональностью по разметке текста и может использоваться как в качестве отдельного элемента, так и служить целой страницей, будучи несравненно легковеснее, чем **WebView**.





Я реализовал весь, необходимый мне функционал и выяснил ещё несколько довольно интересных вещей, столкнувшись с некоторым количеством подводных камней (впрочем, не очень острых). Можно сказать, всё нижеописанное — руководство по созданию достаточно мощной справочной системы в своём приложении практически даром.





### Задачи





В данном примере мы создадим приложение с двумя **Activity**, одна из которых содержит **TextView**, исполняющий роль браузера, из которого, в частности, можно вызвать вторую **Activity**, демонстрирующую работу с параметрами вызова. Мы выясним, каким образом можно создавать страницы текста с разметкой и изображениями и связывать их ссылками. 





Содержимое страниц берётся из строк в ресурсах приложения, а изображения являются drawable-ресурсами. Небольшие изменения в коде позволят использовать другие расположения.





![](http://habrastorage.org/storage2/a04/b2e/d4b/a04b2ed4b25633dfdc13fe3927e3c859.jpg)





### Создание приложения





Любым удобным нам способом создаём обычное приложение:









**AndroidManifest.xml**



	<manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.example.markup.tutorial" android:versionCode="1" android:versionName="1.0">

 	<uses-sdk android:minSdkVersion="7" android:targetSdkVersion="15" /> 

 	<application android:icon="@drawable/ic_launcher" android:label="@string/app_name" android:theme="@style/AppTheme">

  	<activity android:name=".MainActivity" android:label="@string/title_activity_main">

   	<intent-filter>

    	<action android:name="android.intent.action.MAIN" /> 

    	<category android:name="android.intent.category.LAUNCHER" /> 

   	</intent-filter>

  	</activity>

  	<activity android:name=".AnotherActivity" android:exported="false">

   	<intent-filter>

    <data android:scheme="activity-run" android:host="AnotherActivityHost" /> 

    <action android:name="android.intent.action.VIEW" /> 

    <category android:name="android.intent.category.DEFAULT" /> 

   	</intent-filter>

  	</activity>

 	</application>

	</manifest> 
  








Немного пояснений к манифесту. Если с первой **Activity** всё понятно, вторая (**AnotherActivity**) содержит некие дополнительные описатели.





**android:exported=«false»** необходимо для того, чтобы компилятор не выдавал предупреждения о том, что мы забыли что-то прописать в экспортируемом компоненте. На мой взгляд, чисто декоративный момент, но чем меньше жёлтых треугольничков — тем спокойнее.





Раздел **intent-filter** содержит описатели того, каким образом и при каких обстоятельствах будет происходить запуск **Activity**.





 означает, что можно запустить **Activity** ссылкой вида **activity-run://AnotherActivityHost?params...**





Значения **action** и **category** необходимы системе для того чтобы обнаружить и запустить **Activity**.









**MainActivity.java**

	package com.example.markup.tutorial;

	import org.xml.sax.XMLReader;

	import android.os.Bundle;

	import android.app.Activity;

	import android.graphics.drawable.Drawable;

	import android.text.Editable;

	import android.text.Html;

	import android.text.Spannable;

	import android.text.Spanned;

	import android.text.method.LinkMovementMethod;

	import android.widget.TextView;



	public class MainActivity extends Activity {



    TextView tvContent;

    

    @Override

    public void onCreate(Bundle savedInstanceState) {

        super.onCreate(savedInstanceState);

        setContentView(R.layout.activity_main);

        

        tvContent = (TextView)findViewById(R.id.tvContent);

        tvContent.setLinksClickable(true);

        tvContent.setMovementMethod(new LinkMovementMethod());

        

        setArticle("article_main");

    }



    void setArticle(String strArticleResId) {

    	int articleResId = getResources().getIdentifier(strArticleResId, "string", getPackageName());

    	String text = getString(articleResId);

    	if (text == null) text = "Article not found";

    	

    	Spanned spannedText = Html.fromHtml(text, htmlImageGetter, htmlTagHandler);

    	Spannable reversedText = revertSpanned(spannedText);

    	

    	tvContent.setText(reversedText);

    }

    

    final Spannable revertSpanned(Spanned stext) {

        Object[] spans = stext.getSpans(0, stext.length(), Object.class);

        Spannable ret = Spannable.Factory.getInstance().newSpannable(stext.toString());

        if (spans != null && spans.length > 0) {

            for(int i = spans.length - 1; i >= 0; --i) {

                ret.setSpan(spans[i], stext.getSpanStart(spans[i]), stext.getSpanEnd(spans[i]), stext.getSpanFlags(spans[i]));

            }

        }



        return ret;

    }

    

    Html.ImageGetter htmlImageGetter = new Html.ImageGetter() {

        public Drawable getDrawable(String source) {

            int resId = getResources().getIdentifier(source, "drawable", getPackageName());

            Drawable ret = MainActivity.this.getResources().getDrawable(resId);

            ret.setBounds(0, 0, ret.getIntrinsicWidth(), ret.getIntrinsicHeight());

            return ret;

        }

    };



    Html.TagHandler htmlTagHandler = new Html.TagHandler() {

        public void handleTag(boolean opening, String tag, Editable output,	XMLReader xmlReader) {

            Object span = null;

            if (tag.startsWith("article_")) span = new ArticleSpan(MainActivity.this, tag);

            else if ("title".equalsIgnoreCase(tag)) span = new AppearanceSpan(0xffff2020, AppearanceSpan.NONE, 20, true, true, false, false);

            else if (tag.startsWith("color_")) span = new ParameterizedSpan(tag.substring(6));

            if (span != null) processSpan(opening, output, span);

        }

    };

    

    void processSpan(boolean opening, Editable output, Object span) {

        int len = output.length();

        if (opening) {

            output.setSpan(span, len, len, Spannable.SPAN_MARK_MARK);

        } else {

            Object[] objs = output.getSpans(0, len, span.getClass());

            int where = len;

            if (objs.length > 0) {

                for(int i = objs.length - 1; i >= 0; --i) {

                    if (output.getSpanFlags(objs[i]) == Spannable.SPAN_MARK_MARK) {

                        where = output.getSpanStart(objs[i]);

                        output.removeSpan(objs[i]);

                        break;

                    }

                }

            }

            

            if (where != len) {

                output.setSpan(span, where, len, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);

            }

        }

    }

    

	}   








**AnotherActivity.java**



	package com.example.markup.tutorial;



	import android.app.Activity;

	import android.app.AlertDialog;

	import android.content.DialogInterface;

	import android.net.Uri;

	import android.os.Bundle;



	public class AnotherActivity extends Activity {



    @Override

    public void onCreate(Bundle savedInstanceState) {

        super.onCreate(savedInstanceState);

    

        Uri uri = getIntent().getData();

        

        String caption = uri.getQueryParameter("caption");

        String text = uri.getQueryParameter("text");

        

        new AlertDialog.Builder(this)

        	.setTitle(caption)

        	.setMessage(text)

        	.setPositiveButton("OK", dioclOK)

        	.setCancelable(false)

        	.create().show();

    }

    

    DialogInterface.OnClickListener dioclOK = new DialogInterface.OnClickListener() {

        

        public void onClick(DialogInterface dialog, int which) {

            dialog.dismiss();

            finish();

        }

    };

    

	}  












**AppearanceSpan.java**



	package com.example.markup.tutorial;



	import android.text.TextPaint;

	import android.text.style.CharacterStyle;



	public class AppearanceSpan extends CharacterStyle {

    

    public static final int NONE = -1;

    

    final int color, bgColor, textSize;

    final boolean boldText, italicText, strikeThruText, underlineText;

    

    public AppearanceSpan(int color, int bgColor, int textSize, boolean boldText, boolean italicText, 

            boolean strikeThruText, boolean underlineText) {

        this.color = color;

        this.bgColor = bgColor;

        this.textSize = textSize;

        this.boldText = boldText;

        this.italicText = italicText;

        this.strikeThruText = strikeThruText;

        this.underlineText = underlineText;

    }

    

    @Override

    public void updateDrawState(TextPaint tp) {

        if (color != NONE) tp.setColor(color);

        if (bgColor != NONE) tp.bgColor = bgColor;

        tp.setFakeBoldText(boldText);

        tp.setStrikeThruText(strikeThruText);

        if (textSize != NONE) tp.setTextSize(textSize);

        tp.setUnderlineText(underlineText);

        tp.setTextSkewX(italicText ? -0.25f : 0);

    }



	} 
  












**ArticleSpan.java**


	package com.example.markup.tutorial;



	import android.text.style.ClickableSpan;

	import android.view.View;



	public class ArticleSpan extends ClickableSpan {



    final MainActivity activity;

    final String articleId;

    

    public ArticleSpan(MainActivity activity, String articleId) {

        super();

        this.activity = activity;

        this.articleId = articleId;

    }

    

    @Override

    public void onClick(View arg0) {

        activity.setArticle(articleId);

    }



	}
  












**ParameterizedSpan.java**


	package com.example.markup.tutorial;



	import android.graphics.Color;

	import android.text.TextPaint;

	import android.text.style.CharacterStyle;



	public class ParameterizedSpan extends CharacterStyle {



    int color = 0;

    

    public ParameterizedSpan(String param) {

        try {

            color = Color.parseColor("#" + param);

        } catch(Exception ex) { }

    }



    @Override

    public void updateDrawState(TextPaint tp) {

        tp.setColor(color);

    }



	}
  








### Подготовка ресурсов









**layout/activity_main.xml"**

	<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"

    xmlns:tools="http://schemas.android.com/tools"

    android:layout_width="fill_parent"

    android:layout_height="fill_parent" >



    <ScrollView 

        android:id="@+id/sv"

        android:layout_width="fill_parent"

        android:layout_height="fill_parent"

        >

        <TextView

            android:id="@+id/tvContent"

            android:layout_width="wrap_content"

            android:layout_height="wrap_content"

            android:text="Content" />

    </ScrollView>

	</RelativeLayout>  
  












**values/strings.xml"**


	<resources>

    <string name="app_name">MarkupTutor</string>

    <string name="hello_world">Hello world!</string>

    <string name="menu_settings">Settings</string>

    <string name="title_activity_main">MainActivity</string>

    

    <string name="article_main" formatted="false"><![CDATA[

		<title>Главная страница</title><br/>

		<br/>

		<img src="res_pushkin_little"> <article_pushkin_stih>А.С. 	Пушкин "Как пить мы станем"</article_pushkin_stih><br/>

		<img src="res_activity_little"> <a href="activity-run://	AnotherActivityHost?caption=Another%20Activity&text=Hello%20from%20markup!">Вызвать другую Activity</a><br/>

		<br/>

		<color_ff00ff00>Тест параметризированного тэга <color_ffff00ff>и вложенных спанов</color_ffff00ff>.</color_ff00ff00><br/>

		Тест анимированного GIF-а:<br/>

		<img src="res_alien_anim">

    ]]></string>

        	

    <string name="article_pushkin_stih" formatted="false"><![CDATA[

		<br/><article_main>На главную</article_main><br/><br/>

		<img src="res_pushkin" /><br/><br/>

		Сват Иван, как пить мы станем,<br/>

		Непременно уж помянем<br/>

		Трех Матрен, Луку с Петром,<br/>

		Да Пахомовну потом.<br/>

		Мы живали с ними дружно,<br/>

		Уж как хочешь - будь что будь -<br/>

		Этих надо помянуть,<br/><br/>



		Помянуть нам этих нужно.<br/>

		Поминать, так поминать,<br/>

		Начинать, так начинать,<br/>

		Лить, так лить, разлив разливом.<br/>

		Начинай-ка, сват, пора.<br/>

		Трех Матрен, Луку, Петра<br/>

		В первый раз помянем пивом,<br/>

		А Пахомовну потом<br/>

		Пирогами да вином,<br/>

		Да еще ее помянем:<br/>

		Сказки сказывать мы станем -<br/>

		Мастерица ведь была<br/>

		И откуда что брала.<br/>

		А куды разумны шутки,<br/>

		Приговорки, прибаутки,<br/>

		Небылицы, былины<br/>

		Православной старины!..<br/>

		Слушать, так душе отрадно.<br/>

		И не пил бы и не ел,<br/>

		Всё бы слушал да сидел.<br/>

		Кто придумал их так ладно?<br/>

		Стариков когда-нибудь<br/>

		(Жаль, теперь нам не досужно)<br/>

		Надо будет помянуть -<br/>

		Помянуть и этих нужно...<br/>

		Слушай, сват, начну первой,<br/>

		Сказка будет за тобой.<br/>

    ]]></string>

	</resources>
  








Строки, содержащие разметку, должны иметь аттрибут **formatted** со значением **false**, а содержимое должно передаваться в блоке **CDATA**, чтобы у компилятора не было претензий к разметке и специальным символам. В данном примере признаком статьи будет префикс **article_** в названии строки.





Также замечен странный глюк, проявляющийся в том, что если текст начинается с тега, то заканчивается он этим же тегом. Если у вас в начале статьи ссылка, советую ставить перед ней либо пробел, либо`  
`.





Изображения могут быть формата jpg, png или gif без анимации. Анимированный gif отображается статичной картинкой. Расположение стандартное для ресурсов, для дисплеев разной плотности можно подготовить свой вариант картинки. В данном примере все изображения находятся в **drawable-nodpi**





![](http://habrastorage.org/storage2/a2c/313/a58/a2c313a588ebcbd9f6d257576518d942.png)





### Как всё работает





Рассмотрим некоторые части кода подробно.

	public void onCreate(Bundle savedInstanceState) {

    super.onCreate(savedInstanceState);

    setContentView(R.layout.activity_main);

    

    tvContent = (TextView)findViewById(R.id.tvContent);

    tvContent.setLinksClickable(true);

    tvContent.setMovementMethod(new LinkMovementMethod());

    

    setArticle("article_main");

	} 
  




**TextView** используемый нами в качестве браузера, требует особой инициализации:





**tvContent.setLinksClickable(true);** указывает на то, что ссылки в данном элементе реагируют на нажатие.





**tvContent.setMovementMethod(new LinkMovementMethod());** назначает способ навигации по элементу. Использованный нами [**LinkMovementMethod**](http://developer.android.com/reference/android/text/method/LinkMovementMethod.html) интересен сам по себе и, возможно, заслуживает отдельной статьи. Я лишь скажу, что при необходимости более полного контроля можно создать его наследника, переопределенные методы которого позволят отслеживать все действия со ссылками в элементе.



	void setArticle(String strArticleResId) {

    int articleResId = getResources().getIdentifier(strArticleResId, "string", getPackageName());

    String text = getString(articleResId);

    if (text == null) text = "Article not found";

    

    Spanned spannedText = Html.fromHtml(text, htmlImageGetter, htmlTagHandler);

    Spannable reversedText = revertSpanned(spannedText);

    

    tvContent.setText(reversedText);

	} 
  




В данном методе происходит получение строки по идентификатору из строковых ресурсов, её преобразование из HTML в специальный объект **Spanned**, затем ещё одно преобразование в **Spannable** и установка в **TextView** в качестве содержимого. Всё это кажется довольно громоздким, но тому есть причины.





В **TextView**, на мой взгляд, странный порядок обработки спанов — с конца списка. При естественном расположении спанов после преобразования строки из HTML, изменения внешнего вида вложенных спанов перекрываются свойствами спанов, их содержащих. Для нормального отображения приходится буквально выворачивать маркировку наизнанку с помощью метода **revertSpanned**:



	final Spannable revertSpanned(Spanned stext) {

    Object[] spans = stext.getSpans(0, stext.length(), Object.class);

    Spannable ret = Spannable.Factory.getInstance().newSpannable(stext.toString());

    if (spans != null && spans.length > 0) {

        for(int i = spans.length - 1; i >= 0; --i) {

            ret.setSpan(spans[i], stext.getSpanStart(spans[i]), stext.getSpanEnd(spans[i]), stext.getSpanFlags(spans[i]));

        }

    }



    return ret;

	}  
  




Определение обработчика ссылок на изображения минималистично и призвано загружать только картинки из ресурсов. Поскольку мы рассматриваем вариант справочной системы, я посчитал, что этого будет достаточно. С вашего позволения, я не буду цитировать его. Если вы хотите большего, можно обратиться, например, к [данной статье](http://habrahabr.ru/post/155879/).





Более интересен нам будет **Html.TagHadler**:



	Html.TagHandler htmlTagHandler = new Html.TagHandler() {

    public void handleTag(boolean opening, String tag, Editable output,	XMLReader xmlReader) {

        Object span = null;

        if (tag.startsWith("article_")) span = new ArticleSpan(MainActivity.this, tag);

        else if ("title".equalsIgnoreCase(tag)) span = new AppearanceSpan(0xffff2020, AppearanceSpan.NONE, 20, true, true, false, false);

        else if (tag.startsWith("color_")) span = new ParameterizedSpan(tag.substring(6));

        if (span != null) processSpan(opening, output, span);

    }

	};
  




Здесь у нас происходит несколько интересных вещей.





При преобразовании из **HTML** в **Spanned** методом **Html.fromHtml**, обрабатываются тэги 





`br`, `p`, `div`, `em`, `b`,`strong`, `cite`, `dfn`, `i`, `big`, `small`, 





`font`, `blockquote`, `tt`, `a`, `u`, `sup`, `sub`, `h1...h6` и `img`.





В случае, если тэг не опознан, вызывается Html.TagHandler (если, конечно, он передан в вызов).





Мы проверяем, не является ли переданный тэг «нашим» и если это так, создаём соответствующий **Span** — элемент разметки, а затем накладываем его на текст. Я создал несколько собственных **Span**-ов, они будут рассмотрены далее. Как правило, **Span**-ы наследуются от [**android.text.style.CharacterStyle**](http://developer.android.com/reference/android/text/style/CharacterStyle.html).





К сожалению, у меня не получилось малой кровью добиться центрования отдельных строк или абзацев, а встроенной возможности для этого не существует. Также, нельзя прочесть атрибуты тэга из **xmlReader**, поскольку он реализован не полностью. По этой причине пришлось изобретать свой способ передачи параметров: значение является частью тега. В нашем примере таким образом передаётся значение цвета в тэге **color**, преобразовываемом в **ParameterizedSpan**. Получается что-то вроде``





<color_ffff0000>красный. Это достаточно ограниченный и не очень удобный способ, но иногда лучше такой, чем никакого.



	void processSpan(boolean opening, Editable output, Object span) {

        int len = output.length();

        if (opening) {

            output.setSpan(span, len, len, Spannable.SPAN_MARK_MARK);

        } else {

            Object[] objs = output.getSpans(0, len, span.getClass());

            int where = len;

            if (objs.length > 0) {

                for(int i = objs.length - 1; i >= 0; --i) {

                    if (output.getSpanFlags(objs[i]) == Spannable.SPAN_MARK_MARK) {

                        where = output.getSpanStart(objs[i]);

                        output.removeSpan(objs[i]);

                        break;

                    }

                }

            }

            

            if (where != len) {

                output.setSpan(span, where, len, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);

            }

        }

    } 
  




Этот код делает следующее: В случае, если передан открывающий **Span**, он добавляется к концу строки в текущем её виде. В случае, если **Span** закрывающий, мы находим в строке его открывающий аналог, запоминаем его положение, затем удаляем и добавляем новый, но уже с информацией о начальном положении и длине. 





Мы завершили рассмотрение класса Activity, являющегося основным модулем нашего приложения. Теперь рассмотрим вспомогательные классы.



	package com.example.markup.tutorial;



	import android.text.TextPaint;

	import android.text.style.CharacterStyle;



	public class AppearanceSpan extends CharacterStyle {

    

    public static final int NONE = -1;

    

    final int color, bgColor, textSize;

    final boolean boldText, italicText, strikeThruText, underlineText;

    

    public AppearanceSpan(int color, int bgColor, int textSize, boolean boldText, boolean italicText, 

            boolean strikeThruText, boolean underlineText) {

        this.color = color;

        this.bgColor = bgColor;

        this.textSize = textSize;

        this.boldText = boldText;

        this.italicText = italicText;

        this.strikeThruText = strikeThruText;

        this.underlineText = underlineText;

    }

    

    @Override

    public void updateDrawState(TextPaint tp) {

        if (color != NONE) tp.setColor(color);

        if (bgColor != NONE) tp.bgColor = bgColor;

        tp.setFakeBoldText(boldText);

        tp.setStrikeThruText(strikeThruText);

        if (textSize != NONE) tp.setTextSize(textSize);

        tp.setUnderlineText(underlineText);

        tp.setTextSkewX(italicText ? -0.25f : 0);

    }

	}
  




Это Span общего назначения и с его помощью можно задать большинство параметров стиля текста. Его можно использовать как базу для создания стилей текста из собственных тэгов.







	package com.example.markup.tutorial;

	import android.text.style.ClickableSpan;

	import android.view.View;



	public class ArticleSpan extends ClickableSpan {



    final MainActivity activity;

    final String articleId;

    

    public ArticleSpan(MainActivity activity, String articleId) {

        super();

        this.activity = activity;

        this.articleId = articleId;

    }

    

    @Override

    public void onClick(View arg0) {

        activity.setArticle(articleId);

    }

	}







Этот класс описывает элемент, который по нажатию на него обеспечивает переход к статье, чей идентификатор является его параметром. Здесь я применил производное от способа, описанного мной ранее: сам тэг является собственным параметром, а его класс определяется префиксом article_. Поднимемся выше, к описанию **Html.TagHandler**:








	if (tag.startsWith("article_")) span = new ArticleSpan(MainActivity.this, tag);






Обработчик тэгов, увидев тэг, начинающийся на article_, создаёт ArticleSpan, задавая ему в качестве параметра название тэга. Элемент, при нажатии на него, вызывает метод MainActivity.setArticle, после чего в TextView устанавливается новый текст.







	package com.example.markup.tutorial;


	import android.graphics.Color;

	import android.text.TextPaint;

	import android.text.style.CharacterStyle;



	public class ParameterizedSpan extends CharacterStyle {



    int color = 0;

    

    public ParameterizedSpan(String param) {

        try {

            color = Color.parseColor("#" + param);

        } catch(Exception ex) { }

    }



    @Override

    public void updateDrawState(TextPaint tp) {

        tp.setColor(color);

    }

	}




Здесь реализован элемент, получающий параметр явно и отдельно от своего имени. Претензия на своего рода стандарт именования тэгов, раз уж нельзя передавать атрибуты. 





Конечно, всё описанное является вариациями одного принципа, каждый выберёт то, что ему удобнее.





### Вызов Activity





Здесь всё очень просто. Вызов осуществляется посредством использования обычного тэга `` с заданием схемы и хоста, которые описаны в **AndroidManifest.xml** для вызываемой **Activity**.





В HTML мы видим следующее:

	<a href="activity-run://AnotherActivityHost?caption=Another%20Activity&text=Hello%20from%20markup!">Вызвать другую Activity</a> 
  




При нажатии на ссылку, происходит вызов AnotherActivity с передачей параметров в Intent. Эти параметры можно получить и использовать:

	Uri uri = getIntent().getData();
	String caption = uri.getQueryParameter("caption");
	String text = uri.getQueryParameter("text");
  




### Использованные материалы





Следующие материалы очень ускорили создание данной статьи, да и, чего уж там, сделали его вообще возможным:





[www.sherif.mobi/2011/09/html-and-activity-links-in-textview.html](http://www.sherif.mobi/2011/09/html-and-activity-links-in-textview.html)  
[stackoverflow.com/questions/3874999/alignment-in-html-fromhtml](http://stackoverflow.com/questions/3874999/alignment-in-html-fromhtml)  
[stackoverflow.com/questions/11865334/how-to-use-xmlreader-in-taghandler-handletag](http://stackoverflow.com/questions/11865334/how-to-use-xmlreader-in-taghandler-handletag)  
[stackoverflow.com/questions/4044509/android-how-to-use-the-html-taghandler](http://stackoverflow.com/questions/4044509/android-how-to-use-the-html-taghandler)  
[stackoverflow.com/questions/1792604/html-imagegetter](http://stackoverflow.com/questions/1792604/html-imagegetter)





Я очень рад, что существует на свете [StackOverflow.com](http://stackoverflow.com/).





Надеюсь статья вам пригодится и вы теперь не будете плодить много елементов.





Рабочий код на странице с [кодами](http://android-helper.com.ua/codes/).




Продолжая тему своего маркета.





Нашел еще одну интересную статью.





Хорошая новость для пользователей [Google Apps for Business](http://www.google.com/enterprise/apps/business/#utm_medium=blog&utm_source=en-na-us-entblog-playprivatechannel12042012&utm_campaign=launch), [Education](http://www.google.com/enterprise/apps/education/#utm_medium=blog&utm_source=en-na-us-entblog-playprivatechannel12042012&utm_campaign=launch) и [Government](http://www.google.com/enterprise/apps/government/#utm_medium=blog&utm_source=en-na-us-entblog-playprivatechannel12042012&utm_campaign=launch) была опубликована в[блоге Google](http://googleenterprise.blogspot.com/2012/12/a-new-way-to-distribute-your-internal.html). Отныне в Google Play можно создавать корпоративные каналы обновлений и распространять через них внутренние приложения для своих работников.  
  
![](http://habrastorage.org/storage2/cc9/d98/20b/cc9d9820bcd9d9662370983f3c2e6b97.png)  
  
  
  






##### Как это работает





  
Каждый домен Google Apps for Business теперь может иметь приватный канал в Play Store. Администраторы домена могут давать пользователем права на публикацию приложений в консоли разработчика, а также настраивать доступ к каналу в Play Store для отдельных пользователей и групп.  
  
Чтобы увидеть этот канал на девайсе, пользователям нужно войти в Play с помощью своего корпоративного аккаунта.  
  






##### Как включить





  
Администраторы Google Apps могут включить канал в панели управления:








  * В разделе **Organizations & users > Services** нужно включить **Google Play Developer Console**.



  * Для группы пользователей, которым следует разрешить публикацию, нужно:  





    * В **Settings > Mobile** разрешить обновлять **Google Play Private Channel**



    * В **Organizations & users > Services** включить для них **Google Play Developer Console**








  * Остальным пользователям нужно дать доступ к Google Play Private Channel






  
  






##### Дополнительная информация












  * Канал виден только из девайсов и пока что недоступен для веб-интерфейса



  * Каждый девелопер должен проходить обычную регистрацию в консоли разработчика (за $25)



  * Для приложений в приватном канале доступны рейтинги, отзывы, цены и таргетирование



  * Организация может иметь лишь один приватный канал






  
  
Официальная документация: [http://support.google.com/a/bin/answer.py?hl=en&answer=2494992](http://support.google.com/a/bin/answer.py?hl=en&answer=2494992)
Сегодня что то мне не спится.





Хочу побольше дать интересных тем.





Не так много разработчиков выкладывают свои приложения на маркет.


<!-- more -->


Много приложений остается закрытыми в офисной рутине.





Но вот нашел статью, как можно и в офисе организовать свой маркет. Может кому будет полезной.





В рамках работы над большим количеством android приложений появилось желание создать свой Android Market на локальном сервере (с шахматами и поэтессами).  
Свой маркет должен решать две простые задачи:








  * Распространение и обновление корпоративных приложений. У нас есть набор внутри корпоративных приложений, которые нельзя публиковать на Google Play. Сейчас пользователи оповещаются о новых версиях по емайлу, что не удобно.



  * Бета тестирование заказных приложений на большой группе коллег, с обратной связью.






  
  
И так, нам необходимо реализовать небольшое Android приложение, которое будет скачивать список доступных приложений, проверять наличие обновлений для уже установленных, устанавливать/удалять приложения.  






#### Серверная часть





  
Серверной частью приложения может быть как сервис с широким функционалом (регистрация пользователей, отчеты, разграничение доступа к приложениям), так и просто xml файл:



	<MyMarket>

    <application name="TestApp1" 

    package="com.example.testapp1"

    versionCode="1"

    versionName="1.0" 

    url="http://mobile...../android/download/TestApp1.apk"/>

		.....

	</MyMarket>





  
В моем случае серверной частью фактически выступает http шара.  
Данный xml файл в приложении трансформируется в список приложений, доступных для установки.  
  






#### Установка





  
Пользователь выбирает нужное ему приложение и устанавливает,   
Маркет скачивает apk файл на флешку устройства и инициирует установку приложения, конечно, должна быть разрешена установка из сторонних источников.  
Установить незаметно в фоне мы не можем, поэтому после выполнения данного кода:




	URL url = new URL(apkurl);

            HttpURLConnection c = (HttpURLConnection) url.openConnecвленtion();

            c.setRequestMethod("GET");

            c.setDoOutput(true);

            c.connect();



            File file = this.getExternalFilesDir("download");

            File outputFile = new File(file, "app.apk");

            FileOutputStream fos = new FileOutputStream(outputFile);

            InputStream is = c.getInputStream();



            byte[] buffer = new byte[1024];

            int len1 = 0;

            while ((len1 = is.read(buffer)) != -1) {

                fos.write(buffer, 0, len1);

            }

            fos.close();

            is.close();

            

            Intent intent = new Intent(Intent.ACTION_VIEW);

            intent.setDataAndType(Uri.fromFile(outputFile),

                    "application/vnd.android.package-archive");

            startActivity(intent);





  
Пользователь увидит стандартное окно установки приложений:  
![image](http://img-fotki.yandex.ru/get/4117/1154545.a5/0_7d3c3_bd08d241_L)  
  






#### Обновление





  
Приложение Market может по определенному интервалу проверять наличие новых версий, делается это достаточно просто, так как доступен список всех установленных приложений:




	private boolean checkNewVersion(String packageName, int versionCodeNew) {

        List<ApplicationInfo> apps = getPackageManager()

                .getInstalledApplications(0);

        for (int i = 0; i < apps.size(); i++) {

            ApplicationInfo app = apps.get(i);

            if (packageName.equals(app.packageName)) {

                PackageManager manager = getPackageManager();

                PackageInfo info;

                try {

                    info = manager.getPackageInfo(app.packageName, 0);

                    int versionCode = info.versionCode;

                    if (versionCodeNew > versionCode) {

                        Toast.makeText(this, "New Version!", Toast.LENGTH_LONG)

                                .show();

                        return true;

                    }

                } catch (NameNotFoundException e) {

                    e.printStackTrace();

                }

            }

        }

        return false;

    }



  
В случае необходимости обновления приложения, повторяем процесс Установки, приложение будет обновлено.  
  






#### Удаление





  
Удалить программу лучше из интерфейса нашего маркета, чтобы не заставлять пользователя выискивать тестируемое приложение среди всех его программ, для этого достаточно вызвать этот код:



	 Uri packageURI = Uri.parse("package:"+packageName);

        Intent intent = new Intent(Intent.ACTION_DELETE, packageURI);

        startActivity(intent);





  
![image](http://img-fotki.yandex.ru/get/4134/1154545.a5/0_7d3c5_830496a8_L)  
  






#### Обратная связь





  
Получение сообщений об ошибках, вместе с логом ошибки, очень важно для разработчика, особенно на этапе тестирования приложения, добавим функцию автоматического сбора этой информации через Маркет.  
  
Для этого в каждое приложение, распространяемое через наш Маркет добавляем следующий класс




	public class CustomExceptionHandler implements UncaughtExceptionHandler {

    private File logsFolder = null;

    public static final String ERROR_INTENT = "com.example.markettestapp1.SEND_ERROR";

    public CustomExceptionHandler(File logsFolder) {

        this.logsFolder = logsFolder;

    }

    @Override

    public void uncaughtException(Thread thread, Throwable ex) {

        final Writer result = new StringWriter();

        final PrintWriter printWriter = new PrintWriter(result);

        ex.printStackTrace(printWriter);

        String stacktrace = result.toString();

        printWriter.close();

        try {

            if (!logsFolder.exists()) {

                logsFolder.createNewFile();

            }

            BufferedWriter writer = new BufferedWriter(new FileWriter(logsFolder, true));

            writer.write(""+new Date()+"\n"+stacktrace);

            writer.close();

        } catch (IOException e) {

            e.printStackTrace();

        }

        

        Intent intent = new Intent();

        intent.setAction(ERROR_INTENT);

        intent.putExtra("packageName", Test1Application.getApplication().getPackageName());

        intent.putExtra("stacktrace", stacktrace);

        Test1Application.getInstanceApplication().sendBroadcast(intent);

        

        android.os.Process.killProcess(android.os.Process.myPid());

    }

	}


  
Как видно из кода, это хендлер, который получает ошибки (Exception), генерит строку со стеком, сохраняет ее в локальный файл и отправляет ошибку в виде броадкаст сообщения.  
  
А в Application классе включаем переадресацию всех сообщений об ошибках в этот хендлер



	public class Test1Application extends Application {

    @Override

    public void onCreate() {

        super.onCreate();

        application = this;

        Thread.setDefaultUncaughtExceptionHandler(new CustomExceptionHandler(new File(this.getApplicationContext().getExternalFilesDir(null),"exceptions.log")));

    }




  
Таким образом, если в тестируемои приложении происходит ошибка, то перед смертью пишется сообщение в лог и посылается броадкаст сообщение в маркет.,  
Перед передачей приложения заказчику, этот код удаляется (комментируется).  
  
В самом Маркете мы просто отлавливаем данное сообщение:


	public class SendErrorReceiver  extends BroadcastReceiver {

    public static final String ERROR_INTENT = "com.example.markettestapp1.SEND_ERROR";

    @Override

    public void onReceive(Context context, Intent intent) {

        Intent i = new Intent(context, SendErrorActivity.class);

        i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);

        i.putExtra("stacktrace", intent.getStringExtra("stacktrace"));

        i.putExtra("packageName", intent.getStringExtra("packageName"));

        context.startActivity(i);

    }

	}




  
AndroidManifest.xml:


	<receiver android:name="com.example.markettestapp1.SendErrorReceiver" android:enabled="true" >

            <intent-filter>

                <action android:name="com.example.markettestapp1.SEND_ERROR" >

                </action>

            </intent-filter>

        </receiver>





  
  
И дальше маркет уже может переслать это сообщение на почту разработчику, загрузить в какой нибудь веб-сервис или попросить пользователя добавить комментарий к ошибке  
![image](http://img-fotki.yandex.ru/get/4121/1154545.a5/0_7d3c4_5b504bb_L)  
  
Я надеюсь, данный пример поможет многим начинающим разработчикам, разобраться, как написать свой универсальный велосипед для бета тестирования приложений и централизованному сбору статистики ошибок.  
  
ps: В статье использован исходный код и картинки взятые из прототипа приложения.




Привет друзья.





Собирался написать статью по анимации фрагментов, но к счастью она уже написана.





Думаю вам понравится.

 <!-- more -->



Всем доброго времени суток. Этот пост хочу посвятить теме фрагментов для Android. На Хабре есть уже переводы и некоторые статьи, которые упоминают о том, как начать работать с фрагментами под Android. Например, статья [Fragments API в Android 3.0](http://habrahabr.ru/post/113196/). В ней находится описание того, что такое фрагменты и в какой версии Android они доступны, поэтому те, кто ещё не добрался до неё могут при желании ознакомиться, я же не буду пересказывать этого в своём посте. Поэтому сразу перейду к делу.   
  
  






#### Начало работы





  
Скажу только кратко, что фрагменты — это компоненты UI пользователя, которые могут использоваться с помощью класса Activity для отображение пользовательских данных, но их жизненный цикл от него не зависит. Функционал, которым наделены фрагменты имеет более широкий функционал для работы с ними, чем Activity, поэтому их использование для разработчиков имеет не малое значение, если они хотят, чтобы их приложение имело более современный по нынешним нормам интерфейс пользователя.  
  
Теперь перейдём к сути поста. Разработчиками Google фрагменты были наделены, на мой взгляд, отличной поддержкой анимации отображения самого фрагмента. Об этом и пойдёт далее речь. Я искал по Хабру посты на данную тематику, но так ничего и не нашёл, поэтому сейчас поделюсь своими знаниями.   
  






#### Создаём проект





  
Давайте создадим небольшой проект. Я создал проект под свой Samsung Nexus S, там у меня стоит версия Android 4.1.2, собственно её я и использовал (Api Level 16). Сам проект я назвал FragmentsAnimationTest.  
  
Для демонстрации нам понадобится главное активити и его лейаут, пара фрагментов, каждый также со своим лейаутом и ещё пара xml-файлов для самой анимации, о которых я расскажу позже.  
  
Приложение будет выглядеть следующим образом: на экране будет отображаться один из фрагментов, переключение между ними будет осуществляться с помощью обычной кнопки, и, соответственно, само переключение фрагментов будет сопровождаться анимационными эффектами.   
  
Сначала расположим элементы главного активити в файле activity_main.xml:







	<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"

    xmlns:tools="http://schemas.android.com/tools"

    android:layout_width="match_parent"

    android:layout_height="match_parent"

    tools:context=".MainActivity" >



    <FrameLayout

        android:id="@+id/fragCont"

        android:layout_width="wrap_content"

        android:layout_height="match_parent"

        android:layout_weight="1" >

    </FrameLayout>

    

    <Button

        android:id="@+id/btn"

        android:layout_width="wrap_content"

        android:layout_height="wrap_content"

        android:text="SWITCH FRAGMENTS" 

        android:layout_toRightOf="@id/fragCont"/>



	</RelativeLayout>





  
  
Из кода видно, что используется главный лейаут — RelativeLayout, достаточно удобный при работе с фрагментами, в него помещаются два стандартных элемента FrameLayout — собственно, он и будет являться контейнером для фрагментов и кнопка, которой будем переключать фрагменты между собой. Пока что всё должно быть предельно просто.  
  
Дальше займёмся нашими фрагментами. Создадим для них разметки и сами классы:  
fragment1.xml 




	<?xml version="1.0" encoding="utf-8"?>

	<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"

    android:layout_width="match_parent"

    android:layout_height="match_parent"

    android:orientation="vertical" 

    android:background="#5A4">

    

    <TextView 

        android:layout_width="200dp"

        android:layout_height="fill_parent"

        android:text="fragment 1"/>



	</LinearLayout>



  
  
fragment2.xml



	<?xml version="1.0" encoding="utf-8"?>

	<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"

    android:layout_width="match_parent"

    android:layout_height="match_parent"

    android:orientation="vertical" 

    android:background="#A55">

    

    <TextView 

        android:layout_width="200dp"

        android:layout_height="fill_parent"

        android:text="fragment 2"/>



	</LinearLayout>



  
  
Для обоих фрагментов код практически одинаков, отличаются только текстом, который будет отображаться в самом фрагменте для его идентификации и цветом фона, чтобы хорошо было видно анимацию.  
  
Fragment1.java



	public class Fragment1 extends Fragment {



    @Override

    public View onCreateView(LayoutInflater inflater, ViewGroup container, 

                                Bundle savedInstanceState) {

        return inflater.inflate(R.layout.fragment_1, null);

    }

	}





  
  
Fragment2.java



	public class Fragment2 extends Fragment{



    @Override

    public View onCreateView(LayoutInflater inflater, ViewGroup container, 

                                Bundle savedInstanceState) {

        return inflater.inflate(R.layout.fragment_2, null);

    }

	}




  
  
В классах также должно быть всё понятно, если знакомы с темой фрагментов. В них просто указывается какой именно леаут будет использоваться при отображении конкретного фрагмента и всё.  
  
Теперь приступим к самому вкусному. Поработаем с классом главной активити, вот её код:


	public class MainActivity extends Activity {



    private Fragment fragment2;

    private Fragment fragment1;

    private FragmentTransaction ft;



    @Override

    protected void onCreate(Bundle savedInstanceState) {

    super.onCreate(savedInstanceState);

    setContentView(R.layout.activity_main);

    

    fragment1 = new Fragment1();

    fragment2 = new Fragment2();

    ft = getFragmentManager().beginTransaction();

    ft.setCustomAnimations(R.animator.slide_in_left, R.animator.slide_in_right);

//	ft.setTransition(FragmentTransaction.TRANSIT_FRAGMENT_OPEN);

    

    ft.replace(R.id.fragCont, fragment1);

    ft.addToBackStack(null);

    

    ft.commit();

    

    Button btn = (Button) findViewById(R.id.btn);

    btn.setOnClickListener(new OnClickListener() {

        

        @Override

        public void onClick(View v) {

        ft = getFragmentManager().beginTransaction();

        ft.setCustomAnimations(R.animator.slide_in_left, R.animator.slide_in_right);

//		ft.setTransition(FragmentTransaction.TRANSIT_FRAGMENT_OPEN);

        if(fragment1.isVisible()){

            ft.replace(R.id.fragCont, fragment2);

        }else{

            ft.replace(R.id.fragCont, fragment1);

        }

        ft.commit();

        }

    });

    }

	}




  
  
Разберём что именно происходит в нашей активити. Сначала создаются оба фрагмента, которые, как уже говорилось, будут поочерёдно менять друг друга. Далее указываем строкой ft = getFragmentManager().beginTransaction() получаем FragmentTransaction, с помощью которой мы сможем взаимодействовать с нашими фрагментами, но это всё есть в статье, которую я указывал ранее. Прежде, чем перейти к разбору следующего кода, сделаю небольшое отступление.   
  
Существует две возможности создавать анимацию для отображения фрагментов: 








  * 1ый способ — это подключение стандартной анимации с помощью метода setTransition(int transit). В классе FragmentTransaction есть несколько уже предописанных анимаций.



  * 2ой способ — это именно то, что нас интересует в данной теме, реализация кастомной анимации. Осуществляется с помощью метода setCustomAnimations()






  
Теперь вернёмся к разбору нашего кода. Посмотрим на следующую строку ft.setCustomAnimations(R.animator.slide_in_left, R.animator.slide_in_right), тут происходит подключение анимации ко всем фрагментам, с которыми будет происходить работа до завершения транзакции, до строки ft.commit(). Что же именно происходит? В setCustomAnimations передаётся два параметра. Первый параметр описывает анимацию, для отображения фрагмента, который появляется, а второй — описывает анимацию для фрагмента, который сменяется, т.е. убирается с экрана устройства. Важно упомянуть, что данный метод следует вызвать до появления фрагментов, в противном случае, анимация не будет применена.  
  
Пара сток-комментариев — это для того, чтобы можно было попробовать поиграться с предописанной анимацией, достаточно их раскомментировать и закомментировать предыдущую строку — ft.setCustomAnimations(R.animator.slide_in_left, R.animator.slide_in_right), в обоих случаях, хотя это и необязательно.  
  
Давайте разберём код активити до конца и перейдём к созданию самой анимации.  
  
После установки анимации, происходит показ фрагмента, добавление его в стек и завершение транзакции для отображения всех изменений. Потом инициализируем нашу кнопку и прикрепляем к ней слушатель события нажатия кнопки, внутри которого находится код для смены фрагментов, по нажатию кнопки начинаем транзакцию, подключаем анимацию и меняем фрагмент на противоположный показываемому в настоящий момент. Код прост, поэтому глубокого объяснения не требует.  
  






#### Создаём анимацию





  
Перейдём к главной части нашей темы. Научимся создавать саму анимацию. Способ создания анимации здесь немного отличается от того, как мы привыкли это делать в ранних версиях Android. Реализация проходит следующим образом. Для на чала нужно создать папку animator в папке ресурсов приложения, это будет выглядеть так — res/animator/. Сюда мы должны положить xml-файлы, которые будут описывать как именно должна проигрываться анимация. Поместим их туда:  
slide_in_left.xml



	<?xml version="1.0" encoding="utf-8"?>

	<set xmlns:android="http://schemas.android.com/apk/res/android">

  <objectAnimator xmlns:android="http://schemas.android.com/apk/res/android"

    android:interpolator="@android:anim/accelerate_decelerate_interpolator"

    android:propertyName="y" 

    android:valueType="floatType"

    android:valueTo="0" 

    android:valueFrom="-1280"

    android:duration="1500"/>

	</set>


  
  
и slide_in_right.xml


	<?xml version="1.0" encoding="utf-8"?>

	<set xmlns:android="http://schemas.android.com/apk/res/android"

     android:ordering="together">

  

  	<objectAnimator 

      android:interpolator="@android:anim/accelerate_interpolator"

      android:propertyName="alpha"

      android:valueType="floatType"

      android:valueTo="0"

      android:duration="300"/>

    

  	<objectAnimator xmlns:android="http://schemas.android.com/apk/res/android"

    android:interpolator="@android:anim/accelerate_decelerate_interpolator"

    android:propertyName="x" 

    android:valueType="floatType"

    android:valueTo="1280" 

    android:valueFrom="0"

    android:duration="1500"/>  

  

	</set>




  
  
Теперь подробно их разберём. Элементы самих визуальных эффектов описываются в теге objectAnimator, каждый такой тег говорит об описании нового эффекта анимации. Теперь посмотрим на сами атрибуты. Первый атрибут в файле slide_in_left.xml — это interpolator, у него имеется несколько значений, о них можно более подробно узнать из документации [Property Animation](http://developer.android.com/guide/topics/graphics/prop-animation.html#object-animator). Interpolator отвечает за то, чтобы отобразить определённым способом в течении определённого времени наш фрагмент. Далее у нас следует атрибут propertyName, в нём указывается с какое именно свойство фрагмента мы будем изменять при анимации, в нашем примере первым идёт y, а valueType указывает какого типа у нас именяемый параметр. В книге Pro Android 4 аргументируется эта ситуация тем, что если посмотреть на метод setX() в классе View, то станет понятно, что он принимает значение типа float, с методом setY() дело обстоит также, отсюда и значение floatType.   
  
Далее идут не маловажные атрибуты valueFrom и valueTo, они указывают от какого до какого значания изменять значение указаннное в propertyName, в нашем первом случае это y. Если параметр valueFrom не указан, то значение берётся равное текущему. В нашем случае valueFrom равен -1280, это означает, что движение фрагмента по оси y будет начинаться со значения -1280, это значение было выбрано из-за того, что оно находится за пределами экрана устройства и перемещение будет происходить пока значение y не станет равным 0 для верхнего левого угла нашего фрагмента в течении 1500 миллисекунд. И, наконец, duration — атрибут указывает сколько именно будет длиться наш анимированный эффект в миллисекундах.  
  
И последний нюанс, который я хочу описать. Глядя в какой-либо из файлов описания анимации, можно заметить тэг set, в который помещены все эффекты анимации, он служит для объединения эффектов либо их разделения. В файле slide_in_right.xml используется атрибут ordering в теге set, в нашем случае он имеет значение together, что означает проигрывать эффекты одновременно, в противовес ему существует значение sequentially, которое требует последовательного отображения эффектов в анимации, что очень удобно в некоторых случаях.  
  
Собственно и всё. В файле slide_in_right.xml приведен пример как можно использовать другие свойства для анимирования, например alpha-канал. Надеюсь данная статья пригодится тем, кому не всё равно как будет выглядеть его приложение.  
  
Как вы сами понимаете, уважаемые хабраюзеры, скрины не смогут отобразить результат работы.  
  
Литература и источники, которые использовались при написании поста были упомянуты в ходе самой статьи.





Статья из сайта [habrahabr.ru](http://habrahabr.ru/post/162389/)
Друзья всем привет.





Поздравляю всех с Новым годом.





Но не стоит долго отдыхать. И новые статьи уже ждут вас.


<!-- more -->


Сегодня нашел хорошую статью которая упростит вам работу, по внедрению социальных сетей к себе в приложение.





При разработке игрушки для Android'а у меня появилась идея добавить в нее немного социального взаимодействия для охвата большей аудитории. Сама игрушка не располагала к тому, чтобы распространятся «вирусным» способом, поэтому я решил ограничится публикацией результатов игры в социальных сетях в случае выигрыша и при условии попадания результата в локальную таблицу рекордов, и я стал искать решение этого вопроса.  
  
  






##### Выбор социальной сети





  
Я себе поставил задачу публиковать сообщения не во всех социальных сетях сразу, а хотя бы в одной. Выбор встал между соц. сетями «ВКонтакте», «Facebook» и «Twitter». Так как хотелось распространять игру по всему миру, а не только на просторах СНГ, сеть «ВКонтакте» практически сразу была исключена из списка. Выбор между «Facebook» и «Twitter» был сделан просто, и может быть, не совсем объективно — «Facebook» мне не очень нравится, пользоваться я им не люблю из-за, на мой взгляд, крайне неудачного интерфейса, поэтому я решил использовать «Twitter», тем более, что в нем существует возможность интегрировать аккаунт с «Facebook» и дублировать туда сообщения.  
  






##### Поиск способа реализации





  
Искать способ реализовать свою идею я начал с [Twitter4j SDK](http://twitter4j.org/en/index.html). К сожалению, кроме сухой javadoc документации, представляющей собой простое справочное руководство, и отрывочных примеров, там ничего больше не обнаружилось. Также было просмотрено немало тем на stackoverflow.com, но и там ничего подходящего не нашлось (если честно, не хотелось сильно углубляться в дебри TwitterAPI, да и к тому же мои знания Java и платформы Android оставляют желать лучше).  
  






##### Есть идея, есть решение





  
Наконец блуждание в гугле навело меня на статью [Интеграция Android-приложения с Twitter](http://idev.by/android/20828/). Некоторые идеи были не совсем понятны, но код показался достаточно простым, и его автор утверждал, что его решение работает. Потратив немного времени, я адаптировал код автора для своего приложения, и стал проверять его работоспособность. Процедура авторизации проходила (хотя и показалась мне довольно непонятной для обычного, далекого от IT пользователя), но дальше дело не двигалось. Как отсылать сообщения (вернее, в какой момент), я так и не разобрался.  
Также не понравилось, что остается висеть открытый браузер, который вылезает после закрытия моего приложения. Поковырявшись денек, я оставил идею использовать TwitterAPI и стал искать более простое и приятное решение.  
  






##### Самое простое решение





  
Самое простое решение, которое меня вполне удовлетворило, было найдено, более того, оно было в некоторых аспектах даже лучше, чем предыдущее.  
Суть идеи в том, чтобы просто отсылать данные, а куда они будут реально отправлены, решает система и пользователь. Из плюсов — то, что пользователю предоставляется возможность выбрать, куда он хочет отправить сообщение — SMS/MMS, твиттер, фейсбук, в вконтакте, или что-то еще. Я решил, что пользователь наиболее активно пользуется скорее всего только одной из социальных сетей, и ему не понадобится размещать пост в нескольких сетях, к тому же это решение в данном аспекте соответствовало первому варианту. Из минусов данного решения можно отметить то, что у пользователя должно быть установлено соответствующее клиентское приложение (для твиттера в маркете, помимо официального клиента, есть много сторонних). Существование клиента для Фейсбук я не проверял, но полагаю, что оно либо есть, либо появится в довольно ближайшем будущем. Клиент для в ВКонтакте, насколько я в курсе, уже создан (где-то тут была новость о конкурсе на его разработку), и его официальное появление тоже вопрос ближайшего будущего. Также я решил, что пользователь, который достаточно активен в соц. сети для того, чтобы опубликовать там результаты игры, уже озаботился установкой клиента для нее.  
Собственно, само решение — это пять строчек кода, и мне уже стыдно, что я томил читателя своими нудными рассуждениями, вместо того, чтобы сразу опубликовать его:  
  








		// в коде моей Activity

    void shareTextInSocialMedia(String msg)

    {

    	//canShareText();

    	Intent share = new Intent(Intent.ACTION_SEND);

        share.putExtra(Intent.EXTRA_TEXT, msg);

        share.setType("text/plain");

        //startActivity(Intent.createChooser(share, "Share this via"));

        startActivityForResult(Intent.createChooser(share, "Share this via"), 0);

    }    



  
При выполнении приведенного кода возникает список приложений, способных произвести отправку (у меня это Send SMS/MMS и Post to Twitter при установленном твиттер-клиенте), пользователь выбирает нужное приложение, и продолжает работу уже в нем.   
Большой минус — мое приложение закрывается после выполнения этого кода, причем не сразу — в случае твиттер-клиента там сначала можно отредактировать сообщение, и в это время моя программа висела в фоне и играла музыку, и пропала только после нажатия кнопки «Твитнуть». Я попробовал использовать startActivityForResult вместо startActivity, но ничего не изменилось. В случае отправки SMS мое приложение тоже пропало, хотя момент я не засек так же точно. На stackoverflow.com мне сказали, что проблема в твиттер-клиенте («Ah, I see. This is a classic example of application does not respecting Android lifecycle (shame on Twitter)»). Я сначала удовлетворился тем, что от меня тут ничего не зависит, но потом проверил SMS способ, и несколько засомневался, так как он тоже не работал корректно.  
  






##### Бонус для самых упорных





  
Меня несколько напрягало то, что в случае отсутствия приложений, способных обработать отправку сообщения, пользователю будет показано противное сообщение об этом, и я захотел проверить, нужно ли показывать кнопку «Share» в своем приложении, и StackOverflow подсказал мне решение:  
  





		boolean canShareText( boolean allowSmsMms)

    {

        PackageManager manager = getPackageManager();

        List&lt;ResolveInfo&gt; list = manager.queryIntentActivities(createShareIntent(""), 0);



        if (list != null &amp;&amp; list.size() &gt; 0) 

        {

    		if (allowSmsMms) return true;

    		int handlersCount = 0;

    		for (ResolveInfo li : list)

    		{

    			if (li!=null &amp;&amp; li.activityInfo!=null &amp;&amp; li.activityInfo.packageName!=null &amp;&amp; li.activityInfo.packageName=="com.android.mms") {}

    			else

    				++handlersCount;

    		}

    		if (handlersCount&gt;0) return true;

        } 

    	return false;

    }




  
В данном коде перечисляются все доступные способы отправки сообщения, в том числе и с использованием СМС.  
Я решил не показывать кнопку «Share», если доступна отсылка только SMS/MMS, и добавил опциональную возможность проигнорировать это приложение. Имя пакета «com.android.mms» получил во время прогона на эмуляторе, так что возможно не везде будет срабатывать.





Статья из сайта [habrahabr.ru](http://habrahabr.ru/post/164187/)
Всем привет.





Сегодня набрел на Google Play Service. И мне стало интересно, что это такое.





И как его можно применить в разработке.


 <!-- more -->


Нашел очень хорошую статью на [Хабре](http://habrahabr.ru/post/153341/).





На Google I/O 2012 было объявлено о скором появлении на свет некоей «платформы Google Play Services». Платформы для разработчиков, которые жаждут интегрировать сервисы Google в свои приложения.  
  
26 сентября в [блоге на G+](https://plus.google.com/+AndroidDevelopers/posts/J1A5hc1ZnS1) было объявлено о запуске Google Play Services v.1.0  
  






#### Что это?





  
Сервисы Google Play (Google Play Services) — это платформа, предназначенная для интеграции продуктов Google, таких как Google+, в ваши Android-приложения. Платформа Google Play Services состоит из системного сервиса, работающего на устройстве, и тонкого клиента. Тонким клиентом выступает ваше приложение с подключенной клиентской библиотекой. Можно изобразить это так:  
![](http://habrastorage.org/storage2/725/647/caf/725647caf708eb37b4480dddfa7b5c7e.png)  
Google Play Services распространяется в виде обычного приложения через Google Play Store и поэтому независима от вашего оператора связи или производителя устройства. Новые девайсы имеют подержку Google Play Services «с завода». Устройства на платформе Android 2.2 (Froyo) или выше, имеющие доступ к Google Play Store получат обновления в течение ближайших нескольких дней. Это позволит вам использовать новейшие API на подавляющем большинстве устройств в экосистеме Android. Устройства с Android ниже версии 2.2 или не подключенные к Google Play Store не поддерживаются.  
  
Платформа Google Play services содержит бо́льшую часть логики взаимодействия с продуктами Google. Доступ к использованию возможностей платформы предоставляется через простую процедуру аутентификации, которая проста как для разработчика так и для пользователя. Для разработчика процедура заключается в вызове пары методов клиентской библиотеки, а остальную работу за него выполнят компоненты Google Play services. Для пользователя приложения процедура аутентификации — это несколько кликов.  
  






#### Компоненты Google Play services





  
Google Play services 1.0 включает в себя следующие компоненты и API:








  * OAuth 2.0 аутентификация в сервисах Google



  * Google+ sign-in — аутентификация с помощью аккаунта G+



  * Гугло-кнопка +1 в вашем приложении






  
Не густо, конечно, но обещают развивать и дополнять платформу новыми сервисами и API  
  
Подробности по установке, использованию и вообще есть [здесь](https://developers.google.com/android/google-play-services/).





Сейчас думаю как же его можно использовать в своих программах.





Жду предложений в комментариях.
Всем привет.





Как истинный программист, не сижу на месте, а постоянно развиваюсь.





И что бы доносить вам ценную информацию, я читаю много сайтов.





Но к сожалению, не могу все переработать сам.

<!-- more -->



Поэтому просто выставляю интересные статьи на блоге.





Речь пойдет о PhoneGap.





![](http://android-helper.com.ua/images/uploads/2012/12/завантаження.jpg)



Что это такое и для чего оно надо. Спросите вы.





Но постойте, ведь много программистов никогда не писали на java. А свои приложения хотят показать всему миру.





И тут на помощь им приходить движек PhoneGap.





На этом движке пишут приложения на HTML5 + JavaScript + CSS.





Не буду вас долго мучат. Сразу к делу.





1. Создаем проект





2. Подготавливаем проект





Из архива, который можно скачать [тут](http://phonegap.com/download), нам понадобится:








  1. Файл cordova-2.2.0.jar из lib/android копируем в libs



  2. Файл cordova-2.2.0.js из lib/android копируем в assets/www



  3. Каталог xml из lib/android копируем в res






3. Теперь меняем код главного Activity:


	package com.android_helper.phonegap1;

	import org.apache.cordova.DroidGap;

	import android.os.Bundle;

	public class MainActivity extends DroidGap {



	@Override

	public void onCreate(Bundle savedInstanceState) {

		super.onCreate(savedInstanceState);

		super.loadUrl("file:///android_asset/www/index.html");

	}

	}








Тут мы изменили имя абстрактного предка на DroidGap, убрали метод setContentView, который устанавливал "андроидную" разметку и выполнили загрузку локальной html-страницы, в которой дальше все и будет происходить. Кстати и создадим её в каталоге assets/www/index.html:


	<!DOCTYPE html>

	<html>

  	<head>

   	 <title>Device Properties Example</title>



    	<script type="text/javascript" charset="utf-8" src="cordova-2.0.0.js"></script>

    	<script type="text/javascript" charset="utf-8">



    	// Wait for Cordova to load

    	//

    	document.addEventListener("deviceready", onDeviceReady, false);



    	// Cordova is ready

    	//

   	 function onDeviceReady() {

        var element = document.getElementById('deviceProperties');



        element.innerHTML = 'Device Name: '     + device.name     + '<br />' + 

                            'Device Cordova: '  + device.cordova  + '<br />' + 

                            'Device Platform: ' + device.platform + '<br />' + 

                            'Device UUID: '     + device.uuid     + '<br />' + 

                            'Device Version: '  + device.version  + '<br />';

    	}



    	</script>

 	 </head>

  	<body>

    	<p id="deviceProperties">Loading device properties...</p>

  	</body>

	</html>





4. Добавляем разрешения (permission) в AndroidManifest.xml



		<manifest xmlns:android="http://schemas.android.com/apk/res/android"

		package="com.android_helper.phonegap1"

		android:versionCode="1"

		android:versionName="1.0" >



		<supports-screens

		android:anyDensity="true"

		android:largeScreens="true"

		android:normalScreens="true"

		android:resizeable="true"

		android:smallScreens="true" />



		<uses-sdk

		android:minSdkVersion="8"

		android:targetSdkVersion="15" />



		<uses-permission android:name="android.permission.VIBRATE" />

		<uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />

		<uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />

		<uses-permission android:name="android.permission.ACCESS_LOCATION_EXTRA_COMMANDS" />

		<uses-permission android:name="android.permission.READ_PHONE_STATE" />

		<uses-permission android:name="android.permission.INTERNET" />

		<uses-permission android:name="android.permission.RECEIVE_SMS" />

		<uses-permission android:name="android.permission.RECORD_AUDIO" />

		<uses-permission android:name="android.permission.MODIFY_AUDIO_SETTINGS" />

		<uses-permission android:name="android.permission.READ_CONTACTS" />

		<uses-permission android:name="android.permission.WRITE_CONTACTS" />

		<uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />

		<uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />

		<uses-permission android:name="android.permission.GET_ACCOUNTS" />

		<uses-permission android:name="android.permission.BROADCAST_STICKY" />



		<application

		android:icon="@drawable/ic_launcher"

		android:label="@string/app_name"

		android:theme="@style/AppTheme" >

		<activity

			android:name=".MainActivity"

			android:configChanges="orientation|keyboardHidden"

			android:label="@string/title_activity_main" >

			<intent-filter>

				<action android:name="android.intent.action.MAIN" />



				<category android:name="android.intent.category.LAUNCHER" />

			</intent-filter>

		</activity>

	</application>



	</manifest>





Рекомендую убрать те которыми не пользуетесь. Ведь при установке приложения пользователь уйдет в астрал. И подумает, что ваше приложение шпион. :)





Ну вот и все.





Запускаем и смотрим.





![](http://android-helper.com.ua/images/uploads/2012/12/Screenshot-5554-dev22-1.png)



Рабочий код на странице с [кодами](http://android-helper.com.ua/codes/).





Понравилось, нажми лайк и расскажи своим друзьям.




Всем привет.





Когда разрабатываешь хорошее приложение. Часто бывает нужно сделать красивые отделения между элементами.





Что бы долго не говорить посмотрите ниже:





![](http://android-helper.com.ua/images/uploads/2012/12/img-1024x564.jpg)


 <!-- more -->
 





Каждый программист ищет свои пути решения данной задачи.





Я же хочу показать вам как это делать с помощью обычного adapter.





Смотрим результат:



{% youtube GHpLuRLujOk %}





Приступим:





**MultipleItemsList**:

		@Override

    public void onCreate(Bundle savedInstanceState) {

        super.onCreate(savedInstanceState);

        mAdapter = new MyCustomAdapter();

        for (int i = 1; i < 50; i++) {

            mAdapter.addItem("item " + i);

            if (i % 4 == 0) {

                mAdapter.addSeparatorItem("separator " + i);

            }

        }

        setListAdapter(mAdapter);

    }




Сам адаптер **MyCustomAdapter:**

	private class MyCustomAdapter extends BaseAdapter {



        private static final int TYPE_ITEM = 0;

        private static final int TYPE_SEPARATOR = 1;

        private static final int TYPE_MAX_COUNT = TYPE_SEPARATOR + 1;



        private ArrayList<String> mData = new ArrayList<String>();

        private LayoutInflater mInflater;



        private TreeSet<Integer> mSeparatorsSet = new TreeSet<Integer>();



        public MyCustomAdapter() {

            mInflater = (LayoutInflater)getSystemService(Context.LAYOUT_INFLATER_SERVICE);

        }



        public void addItem(final String item) {

            mData.add(item);

            notifyDataSetChanged();

        }



        public void addSeparatorItem(final String item) {

            mData.add(item);

            // save separator position

            mSeparatorsSet.add(mData.size() - 1);

            notifyDataSetChanged();

        }



        @Override

        public int getItemViewType(int position) {

            return mSeparatorsSet.contains(position) ? TYPE_SEPARATOR : TYPE_ITEM;

        }



        @Override

        public int getViewTypeCount() {

            return TYPE_MAX_COUNT;

        }



        @Override

        public int getCount() {

            return mData.size();

        }



        @Override

        public String getItem(int position) {

            return mData.get(position);

        }



        @Override

        public long getItemId(int position) {

            return position;

        }



        @Override

        public View getView(int position, View convertView, ViewGroup parent) {

            ViewHolder holder = null;

            int type = getItemViewType(position);

            System.out.println("getView " + position + " " + convertView + " type = " + type);

            if (convertView == null) {

                holder = new ViewHolder();

                switch (type) {

                    case TYPE_ITEM:

                        convertView = mInflater.inflate(R.layout.item1, null);

                        holder.textView = (TextView)convertView.findViewById(R.id.text);

                        break;

                    case TYPE_SEPARATOR:

                        convertView = mInflater.inflate(R.layout.item2, null);

                        holder.textView = (TextView)convertView.findViewById(R.id.textSeparator);

                        break;

                }

                convertView.setTag(holder);

            } else {

                holder = (ViewHolder)convertView.getTag();

            }

            holder.textView.setText(mData.get(position));

            return convertView;

        }



    }



    public static class ViewHolder {

        public TextView textView;

    }


Вот и все.





Понравилось? Расскажи своим друзьям.





Рабочий код на странице с [кодами](http://android-helper.com.ua/codes/).
Всем привет.





К одной статье мне прислали комментарий.





Благодаря ему, я написал данную статью.





Как видно из названия, то речь пойдет о **WebView**


 <!-- more -->


Кода много не будет, так как вы всегда можете скачать готовый проект на нашей странице с кодами.





Рассмотрим два варианта загрузки html страницы в WebView








  1. **Локальный файл**



  2. **Веб-страница (на примере http://android-helper.com.ua/)**






#### Локальный файл





		WebView mWebView = (WebView) myView.findViewById(R.id.web);



		WebSettings settings = mWebView.getSettings();

		settings.setJavaScriptEnabled(true);

		settings.setDefaultTextEncodingName("utf-8");

		settings.setDefaultZoom(WebSettings.ZoomDensity.MEDIUM);



		mWebView.loadUrl("file:///android_asset/www/index.html");





#### Веб-страница (на примере http://android-helper.com.ua/)






		WebView mWebView = (WebView) myView.findViewById(R.id.web);



		WebSettings settings = mWebView.getSettings();

		settings.setJavaScriptEnabled(true);

		settings.setDefaultTextEncodingName("utf-8");

		settings.setDefaultZoom(WebSettings.ZoomDensity.MEDIUM);

		mWebView.loadUrl("http://android-helper.com.ua");







Напомню, что скачать полный пример вы можете на странице с [кодами](http://android-helper.com.ua/codes/).
Всем привет.





Пока я готовлюсь к вебинару. Времени на написание статей не хватает.





Именно это меня провоцирует брать готовый материал из чужих сайтов.





Сегодня речь пойдет о динамическом размещении элементов на action bar.


 <!-- more -->


В этом уроке:





- программно размещаем элементы в ActionBar  
- используем элементы из фрагментов





Недавно на форуме был вопрос о том, как во время работы программы менять содержимое ActionBar. Тема действительно интересная, и незаслуженно мною пропущенная. В этом уроке будем с ней разбираться.





Опробуем три способа работы с элементами:





1) Добавление/удаление MenuItem в объект Menu





2) Показ/скрытие группы в Menu





3) Элементы, относящиеся к фрагментам





С первыми двумя пунктами все понятно, эти механизмы мы рассматривали еще в Уроке 14.





Более интересен третий пункт. Фрагмент может реализовать в себе метод[onCreateOptionsMenu](http://developer.android.com/reference/android/app/Fragment.html#onCreateOptionsMenu(android.view.Menu, android.view.MenuInflater)) и, тем самым, создать свои элементы для ActionBar. Как только фрагмент будет добавлен на экран, эти элементы добавятся в ActionBar. А когда фрагмент с экрана уберут, элементы исчезнут.





Создадим приложение, которое реализует три этих варианта.





Добавим строки в **strings.xml**:



	<?xml version="1.0" encoding="utf-8"?>

	<resources>



    <string name="add_del">Добавить/удалить</string>

    <string name="visible">Показать/скрыть</string>

    <string name="fragment">Фрагмент</string>

    <string name="frag1_text">Fragment 1</string>

    <string name="frag2_text">Fragment 2</string>

    <string name="menu_item1">Item 1</string>

    <string name="menu_item2">Item 2</string>

    <string name="menu_item31">Item 31</string>

    <string name="menu_item32">Item 32</string>



	</resources>


Создадим два фрагмента. Начнем с layout-файлов.





**fragment1.xml**:


	<?xml version="1.0" encoding="utf-8"?>

	<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"

    android:layout_width="match_parent"

    android:layout_height="match_parent"

    android:background="#77ff0000"

    android:orientation="vertical" >



    <TextView

        android:layout_width="wrap_content"

        android:layout_height="wrap_content"

        android:text="@string/frag1_text" >

    </TextView>



	</LinearLayout>





**fragment2.xml**:


	<?xml version="1.0" encoding="utf-8"?>

	<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"

    android:layout_width="match_parent"

    android:layout_height="match_parent"

    android:background="#7700ff00"

    android:orientation="vertical" >



    <TextView

        android:layout_width="wrap_content"

        android:layout_height="wrap_content"

        android:text="@string/frag2_text" >

    </TextView>



	</LinearLayout>


Файлы с пунктами меню (они же - элементы ActionBar):





**res/menu/fragment1.xml**:



	<?xml version="1.0" encoding="utf-8"?>

	<menu xmlns:android="http://schemas.android.com/apk/res/android" >



    <item

        android:id="@+id/frag1_item"

        android:icon="@android:drawable/ic_dialog_info"

        android:showAsAction="ifRoom|withText"

        android:title="@string/menu_item31">

    </item>



	</menu>



**res/menu/fragment2.xml**:



	<?xml version="1.0" encoding="utf-8"?>

	<menu xmlns:android="http://schemas.android.com/apk/res/android" >



    <item

        android:id="@+id/frag2_item"

        android:icon="@android:drawable/ic_dialog_email"

        android:showAsAction="ifRoom|withText"

        android:title="@string/menu_item32">

    </item>



	</menu>




По одному элементу для каждого фрагмента. Эти элементы будут появляться в ActionBar при выводе фрагмента на экран.





Классы.





**Fragment1.java**:



	public class Fragment1 extends Fragment {

		public void onCreate(Bundle savedInstanceState) {

		setHasOptionsMenu(true);

		super.onCreate(savedInstanceState);

		}



	public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {

		return inflater.inflate(R.layout.fragment1, null);

	}



	public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {

		inflater.inflate(R.menu.fragment1, menu);

		super.onCreateOptionsMenu(menu, inflater);

	}



	}





**Fragment2.java**:



	public class Fragment2 extends Fragment {

	public void onCreate(Bundle savedInstanceState) {

		setHasOptionsMenu(true);

		super.onCreate(savedInstanceState);

	}



	public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {

		return inflater.inflate(R.layout.fragment2, null);

	}



	public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {

		inflater.inflate(R.menu.fragment2, menu);

		super.onCreateOptionsMenu(menu, inflater);

	}

	}



В **onCreate **с помощью [setHasOptionsMenu](http://developer.android.com/reference/android/app/Fragment.html#setHasOptionsMenu(boolean)) включаем режим вывода элементов фрагмента в ActionBar.





В **onCreateView **создаем View, в **onCreateOptionsMenu **– меню. Все как обычно.





Фрагменты готовы.





Теперь займемся Activity. Перепишем **res/layout/main.xml**:




	<?xml version="1.0" encoding="utf-8"?>

	<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"

    xmlns:tools="http://schemas.android.com/tools"

    android:id="@+id/LinearLayout1"

    android:layout_width="match_parent"

    android:layout_height="match_parent"

    android:orientation="vertical" >



    <CheckBox

        android:id="@+id/chbAddDel"

        android:layout_width="wrap_content"

        android:layout_height="wrap_content"

        android:onClick="onClick"

        android:text="@string/add_del" >

    </CheckBox>



    <CheckBox

        android:id="@+id/chbVisible"

        android:layout_width="wrap_content"

        android:layout_height="wrap_content"

        android:onClick="onClick"

        android:text="@string/visible" >

    </CheckBox>



    <Button

        android:id="@+id/btnFrag"

        android:layout_width="wrap_content"

        android:layout_height="wrap_content"

        android:onClick="onClick"

        android:text="@string/fragment" >

    </Button>



    <FrameLayout

        android:id="@+id/cont"

        android:layout_width="match_parent"

        android:layout_height="match_parent" >

    </FrameLayout>



	</LinearLayout>





Два чекбокса и кнопка. Чекбоксы отвечают за работу с элементами с помощью первого и второго способов. Кнопка будет показывать поочередно два фрагмента в контейнере cont.





**res/menu/main.xml**:


	<menu xmlns:android="http://schemas.android.com/apk/res/android" >



    <group android:id="@+id/groupVsbl" >

        <item

            android:id="@+id/item2"

            android:icon="@android:drawable/ic_menu_call"

            android:showAsAction="always|withText"

            android:title="@string/menu_item2">

        </item>

    </group>



	</menu>




Создаем группу, а в ней элемент. Эту группу будем скрывать и показывать.





**MainActivity.java**:

	
	public class MainActivity extends FragmentActivity {



	final int MENU_ID = 1;



	CheckBox chbAddDel;

	CheckBox chbVisible;



	Fragment frag1;

	Fragment frag2;

	Fragment frag;



	@Override

	public void onCreate(Bundle savedInstanceState) {

		super.onCreate(savedInstanceState);

		setContentView(R.layout.activity_main);



		chbAddDel = (CheckBox) findViewById(R.id.chbAddDel);

		chbVisible = (CheckBox) findViewById(R.id.chbVisible);



		frag = frag1 = new Fragment1();

		frag2 = new Fragment2();



	}



	@Override

	public boolean onCreateOptionsMenu(Menu menu) {

		getMenuInflater().inflate(R.menu.activity_main, menu);

		menu.setGroupVisible(R.id.groupVsbl, chbVisible.isChecked());

		if (chbAddDel.isChecked()) {

			menu.add(0, MENU_ID, 0, R.string.menu_item1).setIcon(android.R.drawable.ic_delete)

					.setShowAsAction(MenuItem.SHOW_AS_ACTION_ALWAYS | MenuItem.SHOW_AS_ACTION_WITH_TEXT);

		} else {

			menu.removeItem(MENU_ID);

		}

		return true;

	}



	public void onClick(View view) {

		switch (view.getId()) {

			case R.id.chbAddDel:

			case R.id.chbVisible:

				invalidateOptionsMenu();

				break;

			case R.id.btnFrag:

				frag = (frag == frag1) ? frag2 : frag1;

				getSupportFragmentManager().beginTransaction().replace(R.id.cont, frag).commit();

				break;

			default:

				break;

		}



	}

	}


В **onCreateOptionsMenu **настраиваем видимость группы groupVsbl в зависимости от значения чекбокса chbVisible.





В зависимости от значения чекбокса chbAddDel создаем или удаляем элемент.





В **onСlick **для чекбоксов вызываем метод [invalidateOptionsMenu](http://developer.android.com/reference/android/app/Activity.html#invalidateOptionsMenu()) - перерисовка меню/ActionBar. А по нажатию на кнопку поочередно выводим на экран Fragment1 или Fragment2.





Все сохраняем и запускаем приложение.





![](http://startandroid.ru/images/stories/lessons/L0112/L0112_010.JPG)





Жмем галку **Добавить/удалить**. Появляется элемент. Мы добавили MenuItem в Menu.





![](http://startandroid.ru/images/stories/lessons/L0112/L0112_020.JPG)





Жмем галку **Показать/скрыть**. Появляется элемент. Мы показали группу меню, в которой один пункт.





![](http://startandroid.ru/images/stories/lessons/L0112/L0112_030.JPG)





Соответственно, убирая галки - убираете элементы.





Понажимаем кнопку **Фрагмент**. Появляется элемент то одного, то другого фрагмента.





![](http://startandroid.ru/images/stories/lessons/L0112/L0112_040.JPG)





![](http://startandroid.ru/images/stories/lessons/L0112/L0112_050.JPG)





Еще, как вариант, можно играться с видимостью не всей группы, а конкретного элемента - метод [setVisible](http://developer.android.com/reference/android/view/MenuItem.html#setVisible(boolean)).





Если в ActionBar нажать на overflow-кнопку, будет вызван метод onPrepareOptionsMenu для Activity и для фрагмента, который сейчас отображен. 





Надеюсь статья вам поможет.





Полный проект вы можете скачать на [странице с кодами](http://android-helper.com.ua/codes/).
Всем привет.





Как много мы с вами видим разного рода красивых дизайнов, где с помощью пальца, можно менять не только экран но и Tabs.





Более подробно мы с вами остановимся на реализации данной задачи.


  <!-- more -->


Как вы поняли из названия статьи, мы будем использовать **PagerTabStrip**





Решил долго ничего не придумывать и записал видео как это сделать:









Теперь сам код:





**activity_main.xml**



	<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"

		xmlns:tools="http://schemas.android.com/tools"

		android:layout_width="fill_parent"

		android:layout_height="fill_parent"

		android:orientation="vertical" >



		<android.support.v4.view.ViewPager

			android:id="@+id/viewpager"

			android:layout_width="fill_parent"

			android:layout_height="fill_parent" >



			<android.support.v4.view.PagerTabStrip

				android:id="@+id/pagerTabStrip"

				android:layout_width="wrap_content"

				android:layout_height="wrap_content"

				android:layout_gravity="top"

				android:background="#a22c2e" />

		</android.support.v4.view.ViewPager>



	</RelativeLayout>


**fragment_default.xml**


	<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"

	android:layout_width="fill_parent"

	android:layout_height="fill_parent" >



	<TextView

		android:id="@+id/text"

		android:layout_width="wrap_content"

		android:layout_height="wrap_content"

		android:layout_gravity="center"

		android:text="Test" />



	</FrameLayout>



**MainActivity**



	public class MainActivity extends FragmentActivity {



		private ViewPager mViewPager;



		@Override

		public void onCreate(Bundle savedInstanceState) {

			super.onCreate(savedInstanceState);

			setContentView(R.layout.activity_main);



			mViewPager = (ViewPager) findViewById(R.id.viewpager);

			PagerTabStrip pagerTabStrip = (PagerTabStrip) findViewById(R.id.pagerTabStrip);

			// pagerTabStrip.setTextColor(color.white);

			// pagerTabStrip.setTabIndicatorColor(color.holo_red_dark);



			TitleAdapter titleAdapter = new TitleAdapter(getSupportFragmentManager());

			mViewPager.setAdapter(titleAdapter);

			mViewPager.setCurrentItem(0);

		}



		@Override

		public boolean onCreateOptionsMenu(Menu menu) {

			getMenuInflater().inflate(R.menu.activity_main, menu);

			return true;

		}

	}







**TitleAdapter**


	public class TitleAdapter extends FragmentPagerAdapter {

	private final String titles[] = new String[] { "View1", "View2", "View3" };

	private final Fragment frags[] = new Fragment[titles.length];



	public TitleAdapter(FragmentManager fm) {

		super(fm);

		frags[0] = new FragmentView1();

		frags[1] = new FragmentView2();

		frags[2] = new FragmentView3();

	}



	@Override

	public CharSequence getPageTitle(int position) {

		Log.v("TitleAdapter - getPageTitle=", titles[position]);

		return titles[position];

	}



	@Override

	public Fragment getItem(int position) {

		Log.v("TitleAdapter - getItem=", String.valueOf(position));

		return frags[position];

	}



	@Override

	public int getCount() {

		return frags.length;

	}

	}


**FragmentView1**


	public class FragmentView1 extends Fragment {

	@Override

	public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {

		View myView = inflater.inflate(R.layout.fragment_default, container, false);

		TextView text = (TextView) myView.findViewById(R.id.text);

		text.setText("Fragment View 1\n - Пример для android-helper.com.ua");

		return myView;

	}



}


**FragmentView2**


	public class FragmentView2 extends Fragment {

	@Override

	public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {

		View myView = inflater.inflate(R.layout.fragment_default, container, false);

		TextView text = (TextView) myView.findViewById(R.id.text);

		text.setText("Fragment View 2\n - Пример для android-helper.com.ua");

		return myView;

	}



	}




**FragmentView3**




	public class FragmentView2 extends Fragment {

	@Override

	public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {

		View myView = inflater.inflate(R.layout.fragment_default, container, false);

		TextView text = (TextView) myView.findViewById(R.id.text);

		text.setText("Fragment View 3\n - Пример для android-helper.com.ua");

		return myView;

	}



	}


Полный проект вы можете скачать на [странице с кодами](http://android-helper.com.ua/codes/).





Надеюсь вам понравилась статья.





Пишите ваши комментарии и подписывайтесь на обновления.
Привет всем.





Сейчас готовлю вебинар и нашел статью, которой хотел поделится со своими читателями.





Прошу к прочтению:


  <!-- more -->


Android – мобильная операционная система, разработанная специально для смартфонов, планшетов и нетбуков. Операционная система Android основана на модифицированном ядре Linux. Первыми разработками занималась компания Android Inc, которая позже была куплена Google. После приобретения компании и всех прав, было инициировано создание альянса Open Handset Alliance (OHA). Впоследствии, Google и другие участники Open Headset Alliance начали свою полноценно сотрудничество для совместной разработки этой новой операционной системы. У Android имеется очень большое сообщество разносторонних разработчиков, которые расширяют функциональность и производительность устройств.









![](http://androidzon.ru/uploads/posts/2012-05/1335970797_google-android.jpg)









Система Android от компании Google имеет свой собственный официальный магазин по продаже мобильных приложений и игр который был открыт 22 октября 2008 года. Изначально он назывался Android Market, однако в марте месяце 2012 года компания Google решила переименовать Android Market в Google Play. На сегодняшний день он включает в себя как платные приложения, так и бесплатные. Так как система Android является полностью открытой, все пользователи имеют возможность загружать приложения не только с официального, но и с других ресурсов.  
  
Большинство приложений для вышеупомянутой системы пишется на языке Java, управляющие устройством через специаьно разработанные Google библиотеки.  
  
Официально об операционной системе Android стало известно 5 ноября 2007 года, когда было официально объявлено основание Open Headset Alliance – консорциум, состоящий из 80 компаний. Большая часть кода Android была выпущена с использованием лицензией Apache.  
  
Android приложения включают в себя различные java-приложения и библиотеки, которые запускаются виртуальной машиной Dalvik с JIT компилятором. Библиотеки включают в себя систему управления, графику OpenGL ES 2.0, движок WebKit, графический движок SGL, SSL и библиотеки Bionic. Android OS состоит аж из 12 миллионов строк кода, в том числе 3-х миллионов строк XML, 2.8 миллионов строк на C, 2.1 миллиона строк на Java и 1.75 миллиона строк на C++.  
  
Ну да ладно, теперь давайте разберёмся более подробно.  
  
**История операционной системы Android:**









![](http://androidzon.ru/uploads/posts/2012-05/1335972119_istoriya-os-android.jpg)









В октябре 2003 года в Пало Альто, штат Калифорния была основана компания Android inc. Главными основателями Android inc. были Энди Рубин, Ник Сирс, Рич Майнер и Крис Уайт.  
  
В августе 2005 года компания Google приобрела Android inc. После этого приобретения Android inc. стала дочерней компанией Google. После покупки Энди Рубин, Рич Майнер и Крис Уайт и дальше продолжили свою работы в Android inc. И почти сразу же после поглощения Android inc., то тут, то там в сети стали появляться слухи о том, что компания Google намерена выйти на рынок мобильных телефонов.  
  
Получив серьёзную поддержку со стороны Google, команда, во главе которой был Энди Рубином начала усиленно работать над операционной системой базирующейся на ядре Linux. И уже к декабрю 2006 года начали распространяться слухи о том, что Google собирается выпустить свой собственный смартфон с использованием своего бренда, так называемый “Гуглофон”.  
  
Но все эти слухи поспешили опровергнуть и Эрик Шмидт заявил следующее: «Сегодняшнее заявление носит более амбициозный характер, чем выпуск смартфона под нашим брендом, о чём пресса спекулирует несколько последних недель. Наше видение заключается в том, что мощнейшая платформа должна отдать свои силы тысячам различных моделей телефонов». И почти сразу же после этих слов 5 ноября 2007 года был официально представлен Open Headset Alliance – консорциум, состоящий из множества различных компаний, в который вошли такие мировые гиганты как: Broadcom Corporation, Google, HTC, Intel, LG, T-Mobile, Marvell Technology Group,Sprint Nextel, Motorola, Nvidia, Qualcomm, Samsung Electronics, Texas Instruments и многие другие.  
  
  
**Версии Android:**  
  
Очень интересное решение для выбора названий каждой очередной версии Android ОС, каждая версия имеет название какого-либо десерта. Первые буквы наименований в порядке версий всегда соответствуют буквам латинского алфавита.









![](http://androidzon.ru/uploads/posts/2012-05/1335973579_versii-android_1.jpg)













![](http://androidzon.ru/uploads/posts/2012-05/1335973875_versii-android_2.jpg)













![](http://androidzon.ru/uploads/posts/2012-05/1335974047_versii-android_3.jpg)









За исключением небольших и непродолжительных по времени периодов в процессе обновлений, начиная с 21 октября 2008 года код OS Android находилась в свободном доступе. Компания Google публиковала код с использованием лицензией Apache. И несмотря на то, что совершенно любой производитель мобильных аппаратов может использовать сам код операционной системы как ему вздумается, всё-таки присутствуют небольшие ограничения. Торговую марку Android запрещено использовать, если производимое устройство не будет соответствовать критериям совместимости Google, но таких не очень много. Также без данного условия нельзя использовать и Google Play, ранее имевший название Android Market а также еще несколько приложения от Google.  
  
  
**Первое устройства:**









![](http://androidzon.ru/uploads/posts/2012-05/1335975098_htc-t-mobile-g1.jpg)









Самым первым выпущенным в массы устройством, работающим под управлением Android, был смартфон T-Mobile G1, разработанный известной компанией HTC. Первая официальная презентация этого аппарата состоялась 23 сентября 2008 года. И спустя небольшой промежуток времени последовали многочисленные анонсы других известных производителей смартфонов о намерении выпустить свои собственные устройства с Android. На данный момент рынок мобильных устройств с данной операционной системой имеет огромное количество предложений. Свои устройства нам предлагают многие, например компания Samsung, которая заняла прочное место среди производителей смарфон и планшетов.  
  
  
**Google Play:**









![](http://androidzon.ru/uploads/posts/2012-05/1335975862_google-play.jpg)









22 октября 2008 года компания Google объявила об открытии своего собственного онлайн-магазина, который будет содержать в себе игры и приложений для устройств, работающих под управлением Android. Изначально он назывался Android Market но в марте 2012 года был переименован. Также была проведена работа по смене дизайна вышеупомянутого магазина.  
Google Play – интернет-магазин, который продвигает альянс Open Handset Alliance (OHA) во главе с Google. Он включает в себя многочисленные игры, различные клиенты социальных сетей, полезные офисные приложения, приложения предназначенные для чтения новостей и книг, программы позволяющие управлять финансами и другие. Содержимое является как платным так и бесплатным, всё очень хорошо распределено по соответствующим категориям.  
  
  
**Разработка программного обеспечения:**









![](http://androidzon.ru/uploads/posts/2012-05/1335976629_razrabotka-programmnogo-obespecheniya.jpg)









Приложения для системы Android являются программами в байт-коде, который отличается от других, проще говоря он нестандартный и для его использования необходима виртуальная машины Dalvik.  
  
Google даёт всем разработчикам очень хороший инструментарий (Android SDK), который находиться в свободном доступе доя скачивания и предназначен для x86-машин под операционными системами Windows XP, Windows Vista, Mac OS X (10.4.8 или выше) и конечно же Linux. Для разработки требуется JDK 5 или JDK 6.  
  
Также разработку приложений для Android ОС можно вести и на языке Java (не ниже Java 1.5). Существует отличный плагин для Eclipse — «Android Development Tools» (ADT), предназначенный для Eclipse версий 3.3-3.5. Для IntelliJ IDEA также есть свой собственный плагин, призванный облегчать разработку Android-приложений.  
  
  
**Архитектура Android ОС:**









![](http://androidzon.ru/uploads/posts/2012-05/thumbs/1335977115_arhitektura-android-os.jpg)









(нажмите на картинку для полномасштабного просмотра)





**Уровень приложений (Applications):**  
В состав системы Android входит свой собственный комплект базовых приложений: различные клиенты электронной почты и SMS, календарь, навигационные карты, браузер, программа для управления контактами и многое многое другое. Все приложения, запускаемые на платформе Android были написаны на языке Java.  
  
  
**Уровень каркаса приложений (Application Framework):**  
Android позволяет использовать всю мощь API, используемого в приложениях ядра. Архитектура построена таким образом, что любое приложение может использовать уже реализованные возможности другого приложения при условии, что последнее откроет доступ на использование своей функциональности. Таким образом, архитектура реализует принцип многократного использования компонентов ОС и приложений.  
  
Главной основой всех приложений является набор систем и специальных служб:  
1. Система представлений (View System) – это богатый набор представлений с расширяемой функциональностью, который служит для построения внешнего вида приложений, включающий такие компоненты, как различные списки, таблицы, поля для ввода, кнопки и прочее.  
2. Контент-провайдеры (Content Providers) – это службы, которые позволяют приложениям получать доступ к данным других приложений, а также при необходимости предоставлять доступ к своим данным.  
3. Менеджер ресурсов (Resource Manager) предназначен для доступа к строковым, графическим и другим типам ресурсов.  
4. Менеджер извещений (Notification Manager) позволяет любому приложению отображать пользовательские уведомления в специально отведённой строке статуса.  
5. Менеджер действий (Activity Manager) управляет жизненным циклом приложений и предоставляет систему навигации по истории работы с действиями.  
  
  
**Уровень библиотек (Libraries):**  
Платформа Android включает в себя набор C/C++ библиотек, используемых различными компонентами ОС. Для разработчиков доступ к функциям этих библиотек реализован с помощью использования Application Framework. Ниже вы можете прочитать о некоторые из них:  
1. System C library - BSD-реализация стандартной системной библиотеки C (libc) для встраиваемых устройств, основанных на Linux.  
2. Media Libraries – библиотеки, основанные на PacketVideo‘s OpenCORE, предназначенные для поддержки проигрывания и записи популярных аудио- и видео- форматов (MPEG4, H.264, MP3, AAC, AMR, JPG, PNG и т.п.).  
3. Surface Manager – менеджер поверхностей управляет доступом к подсистеме отображения 2D- и 3D- графических слоев.  
4. LibWebCore – современный движок web-браузера, который предоставляет всю мощь встроенного Android-браузера.  
5. SGL – специальный движок для работы с 2D-графикой.  
6. 3D libraries – движок для работы с 3D-графикой, который основан на OpenGL ES 1.0 API.  
7. FreeType – библиотека, предназначенная для работы с различными шрифтами.  
8. SQLite – мощный легковесный движок для работы с реляционными БД.  
  
  
**Уровень среды исполнения (Android Runtime):**  
В состав системы Android входит набор библиотек ядра, которые предоставляют большую часть функциональности библиотек ядра на языке Java.  
Данная платформа использует оптимизированную, регистр-ориентированную виртуальную машину Dalvik, в отличии от неё стандартная виртуальная машина Java является стек-ориентированной. Каждое приложение запускается в своем собственном процессе, со своим собственным экземпляром виртуальной машины. Dalvik использует формат Dalvik Executable (*.dex), оптимизированный для минимального использования памяти приложением. Это обеспечивается такими базовыми функциями ядра Linux, как организация поточной обработки и низкоуровневое управление памятью. Байт-код Java, на котором написаны ваши и наши приложения, компилируются в dex-формат при помощи утилиты dx, входящей в состав SDK.  
  
  
**Уровень ядра Linux (Linux Kernel):**  
Android был основан на ОС Linux версии 2.6, тем самым этой платформе доступны системные службы ядра, такие как управление памятью и разнообразными процессами, обеспечение безопасности, работа с сетью и драйверами. Также ядро служит слоем абстракции между аппаратным и программным обеспечением.  
  
  
**Доступные библиотеки:**  
§ SSL — шифрование  
§ Bionic — библиотека стандартных функций, несовместимая с libc  
§ Media Framework (PacketVideo OpenCORE, MPEG4, H.264, MP3, AAC, AMR, JPG, PNG)  
§ Surface Manager  
§ FreeType — шрифты  
§ LibWebCore (на базе WebKit)  
§ SGL — 2D-графика  
§ OpenGL ES — 3D-библиотека  
§ SQLite — легковесная СУБД  
  
По сравнению с обычными приложениями Linux, приложения Android подчиняются дополнительным правилам:  
§ Notification Manager — доступ к строке состояния;  
§ Content Providers — обмен данными между приложениями;  
§ Resource Manager — доступ к таким ресурсам, как файлы XML, PNG, JPEG;  
§ Activity Manager — управление активными приложениями.  
  
И в самом конце хочется добавить, что для операционной системы Android был разработан специальный формат архивных исполняемых файлов-приложений .apk.





Статья из сайта [androidzon.ru](http://androidzon.ru/google-android-os.html)





Записывайтесь на вебинар!
Всем привет.





Очень часто у разработчика встает вопрос - "Как же просмотреть какие запросы идут на сервер?".





Сегодня я постараюсь на него ответить.


 <!-- more -->


1. Для мониторинга трафика используйте программу [Fiddler](http://www.fiddler2.com/fiddler2/). Скачиваем и устанавливаем его.





2. Запускаем Fiddler. Заходим в Tools/Fiddler options/Connections. И ставим галочку "allow remote computers to connect". И перегружаем Fiddler.





![](http://android-helper.com.ua/images/uploads/2012/11/blog_fiddler.jpg)





3. Смотрим ваш внутренний IP адрес. Для этого открываем cmd и там пишем ipconfig





4. Для того что бы все работало. Компьютер и телефон должны быть в одной сети.





Не обязательно что бы ноутбук раздавал WiFi. У меня все работает через точку доступа.





5. Заходим в настройки WiFi. И прописываем прокси (IP вашего компьютера) и порт 8888 (такой как на картинке выше)





6. Наслаждаемся просмотром.





Короткий видео ролик, как это работает.

{% youtube Aoa38hbneSs %}


Всем привет.





Продолжаю собирать полезную информацию по программированию.





Сегодня хотел поделиться с вами работой DialogFragment.


<!-- more -->


Продолжаем рассматривать наследников Fragment. [DialogFragment](http://developer.android.com/reference/android/app/DialogFragment.html) – отличается от обычного фрагмента тем, что отображается как диалог и имеет соответствующие методы.





Построить диалог можно двумя способами: используя свой layout-файл и через AlertDialog.Builder. Нарисуем приложение, которое будет вызывать два диалога, построенных разными способами.









Создадим проект:





**Project name**: P1101_DialogFragment  
**Build Target**: Android 4.1   
**Application name**: DialogFragment  
**Package name**: ru.startandroid.develop.p1101dialogfragment  
**Create Activity**: MainActivity









Добавим строки в **strings.xml**:




	<string name="dialog_1">Dialog 1</string>

	<string name="dialog_2">Dialog 2</string>

	<string name="message_text">Text of your message</string>

	<string name="yes">Yes</string>

	<string name="no">No</string>

	<string name="maybe">Maybe</string>








Мы будем создавать два диалога, соответственно нам понадобятся два фрагмента.





Создадим layout-файл для первого фрагмента.





**dialog1.xml**:


	<?xml version="1.0" encoding="utf-8"?>

	<LinearLayout

 	xmlns:android="http://schemas.android.com/apk/res/android"

 	android:layout_width="wrap_content"

 	android:layout_height="match_parent"

 	android:orientation="vertical">

	<TextView

 	android:id="@+id/textView1"

 	android:layout_width="wrap_content"

 	android:layout_height="wrap_content"

 	android:layout_gravity="center"

 	android:layout_margin="20dp"

 	android:text="@string/message_text"

 	android:textAppearance="?android:attr/textAppearanceLarge">

	</TextView>

	<LinearLayout

 	android:layout_width="wrap_content"

 	android:layout_height="wrap_content">

	<Button

 	android:id="@+id/btnYes"

 	android:layout_width="wrap_content"

 	android:layout_height="wrap_content"

 	android:layout_margin="10dp"

 	android:text="@string/yes">

	</Button>

	<Button

 	android:id="@+id/btnNo"

 	android:layout_width="wrap_content"

 	android:layout_height="wrap_content"

 	android:layout_margin="10dp"

 	android:text="@string/no">

	</Button>

	<Button

 	android:id="@+id/btnMaybe"

 	android:layout_width="wrap_content"

 	android:layout_height="wrap_content"

 	android:layout_margin="10dp"

 	android:text="@string/maybe">

	</Button>

	</LinearLayout>

	</LinearLayout>




Так будет выглядеть наш диалог – текст сообщения и три кнопки.









Создаем класс **Dialog1.java**:

	package com.example.dialogfragments;



	import android.content.DialogInterface;

	import android.os.Bundle;

	import android.support.v4.app.DialogFragment;

	import android.util.Log;

	import android.view.LayoutInflater;

	import android.view.View;

	import android.view.View.OnClickListener;

	import android.view.ViewGroup;

	import android.widget.Button;



	public class Dialog1 extends DialogFragment implements OnClickListener {



		final String LOG_TAG = "myLogs";



		@Override

		public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {

		getDialog().setTitle("Title!");

		View v = inflater.inflate(R.layout.dialog1, null);

		v.findViewById(R.id.btnYes).setOnClickListener(this);

		v.findViewById(R.id.btnNo).setOnClickListener(this);

		v.findViewById(R.id.btnMaybe).setOnClickListener(this);

		return v;

		}



		public void onClick(View v) {

		Log.d(LOG_TAG, "Dialog 1: " + ((Button) v).getText());

		dismiss();

		}



		@Override

		public void onDismiss(DialogInterface dialog) {

		super.onDismiss(dialog);

		Log.d(LOG_TAG, "Dialog 1: onDismiss");

		}



		@Override

		public void onCancel(DialogInterface dialog) {

		super.onCancel(dialog);

		Log.d(LOG_TAG, "Dialog 1: onCancel");

		}

	}





В **onCreateView** мы получаем объект Dialog с помощью метода [getDialog](http://developer.android.com/reference/android/app/DialogFragment.html#getDialog()) и устанавливаем заголовок диалога. Далее мы создаем view из layout, находим в нем кнопки и ставим им текущий фрагмент в качестве обработчика.





В **onClick** выводим в лог текст нажатой кнопки и сами явно закрываем диалог методом [dismiss](http://developer.android.com/reference/android/app/DialogFragment.html#dismiss()).





Метод [onDismiss](http://developer.android.com/reference/android/app/DialogFragment.html#onDismiss(android.content.DialogInterface)) срабатывает, когда диалог закрывается. Пишем об этом в лог.





Метод [onCancel](http://developer.android.com/reference/android/app/DialogFragment.html#onCancel(android.content.DialogInterface)) срабатывает, когда диалог отменяют кнопкой Назад. Пишем об этом в лог.









Создаем второй фрагмент. Здесь мы будем строить диалог с помощью билдера, поэтому layout-файл не понадобится. Создаем только класс **Dialog2.java**:


	package com.example.dialogfragments;



	import android.app.AlertDialog;

	import android.app.Dialog;

	import android.content.DialogInterface;

	import android.content.DialogInterface.OnClickListener;

	import android.os.Bundle;

	import android.support.v4.app.DialogFragment;

	import android.util.Log;



	public class Dialog2 extends DialogFragment implements OnClickListener {



	final String LOG_TAG = "myLogs";



	@Override

	public Dialog onCreateDialog(Bundle savedInstanceState) {

		AlertDialog.Builder adb = new AlertDialog.Builder(getActivity()).setTitle("Title!")

				.setPositiveButton(R.string.yes, this).setNegativeButton(R.string.no, this)

				.setNeutralButton(R.string.maybe, this).setMessage(R.string.message_text);

		return adb.create();

	}



	public void onClick(DialogInterface dialog, int which) {

		int i = 0;

		switch (which) {

			case Dialog.BUTTON_POSITIVE:

				i = R.string.yes;

				break;

			case Dialog.BUTTON_NEGATIVE:

				i = R.string.no;

				break;

			case Dialog.BUTTON_NEUTRAL:

				i = R.string.maybe;

				break;

		}

		if (i > 0) {

			Log.d(LOG_TAG, "Dialog 2: " + getResources().getString(i));

		}

	}



	@Override

	public void onDismiss(DialogInterface dialog) {

		super.onDismiss(dialog);

		Log.d(LOG_TAG, "Dialog 2: onDismiss");

	}



	@Override

	public void onCancel(DialogInterface dialog) {

		super.onCancel(dialog);

		Log.d(LOG_TAG, "Dialog 2: onCancel");

	}

	}




Обычно для заполнения фрагмента содержимым мы использовали метод onCreateView. Для создания диалога с помощью билдера используется [onCreateDialog](http://developer.android.com/reference/android/app/DialogFragment.html#onCreateDialog(android.os.Bundle)). Создаем диалог с заголовком, сообщением и тремя кнопками. Обработчиком для кнопок назначаем текущий фрагмент.





В **onClick** определяем, какая кнопка была нажата и выводим соответствующий текст в лог. В случае создания диалога через билдер, диалог сам закроется по нажатию на кнопку, метод dismiss здесь не нужен.





Методы **onDismiss** и **onCancel** – это закрытие и отмена диалога, аналогично первому фрагменту.









Меняем layout-файл для MainActivity - **main.xml**:


	<?xml version="1.0" encoding="utf-8"?>

	<LinearLayout

 	xmlns:android="http://schemas.android.com/apk/res/android"

	xmlns:tools="http://schemas.android.com/tools"

	 android:id="@+id/LinearLayout1"

	 android:layout_width="match_parent"

	 android:layout_height="match_parent"

	 android:orientation="vertical">

	<Button

	 android:id="@+id/btnDlg1"

	 android:layout_width="wrap_content"

	 android:layout_height="wrap_content"

	 android:onClick="onClick"

	 android:text="@string/dialog_1">

	</Button>

	<Button

	 android:id="@+id/btnDlg2"

	 android:layout_width="wrap_content"

	 android:layout_height="wrap_content"

	 android:onClick="onClick"

	 android:text="@string/dialog_2">

	</Button>

	</LinearLayout>







Здесь только две кнопки.









Кодим **MainActivity.java**:



	package com.example.dialogfragments;



	import android.os.Bundle;

	import android.support.v4.app.DialogFragment;

	import android.support.v4.app.FragmentActivity;

	import android.view.View;



	public class MainActivity extends FragmentActivity {



	DialogFragment dlg1;

	DialogFragment dlg2;



	@Override

	public void onCreate(Bundle savedInstanceState) {

		super.onCreate(savedInstanceState);

		setContentView(R.layout.activity_main);

		dlg1 = new Dialog1();

		dlg2 = new Dialog2();

	}



	public void onClick(View v) {

		switch (v.getId()) {

			case R.id.btnDlg1:

				dlg1.show(getSupportFragmentManager(), "dlg1");

				break;

			case R.id.btnDlg2:

				dlg2.show(getSupportFragmentManager(), "dlg2");

				break;

			default:

				break;

		}



	}

	}




Создаем диалоги и запускаем их методом [show](http://developer.android.com/reference/android/app/DialogFragment.html#show(android.app.FragmentManager, java.lang.String)), который на вход требует FragmentManager и строку-тэг. Транзакция и коммит происходят внутри этого метода, нам об этом думать не надо.





Все сохраняем и запускаем приложение.





![](http://startandroid.ru/images/stories/lessons/L0110/L0110_010.JPG)









Жмем **Dialog1**





![](http://startandroid.ru/images/stories/lessons/L0110/L0110_020.JPG)





Отобразился наш простенький диалог.





Жмем какую-нибудь кнопку, например, **Yes **- диалог закрылся. Смотрим логи:





_Dialog 1: Yes  
Dialog 1: onDismiss_





Все верно.









Снова запустим первый диалог и нажмем клавишу **Назад **(**Back**). Смотрим лог:





_Dialog__ 1: __onCancel__  
Dialog 1: onDismiss_





Сработал onCancel – диалог был отменен, и onDismiss – диалог закрылся.





Если мы будем поворачивать экран, то каждый раз будет отрабатывать onDismiss, но диалог снова будет отображен после поворота.









Запустим второй диалог – нажмем кнопку **Dialog 2**.





![](http://startandroid.ru/images/stories/lessons/L0110/L0110_030.JPG)





Отобразился стандартный сконструированный нами диалог. Жмем, например, **No **– диалог закрылся. В логах:





_Dialog 2: No  
Dialog 2: onDismiss_









Снова запустим второй диалог и нажмем **Назад**. В логах:





_Dialog__ 2: __onCancel__  
Dialog 2: onDismiss_





Все так же, как и в первом случае.









Еще несколько слов по теме.





Если вы не хотите, чтобы ваш диалог можно было закрыть кнопкой, используйте для вашего диалог-фрагмента метод [setCancelable](http://developer.android.com/reference/android/app/DialogFragment.html#setCancelable(boolean)) с параметром false.





Есть еще один вариант вызова диалога. Это метод [show](http://developer.android.com/reference/android/app/DialogFragment.html#show(android.app.FragmentTransaction, java.lang.String)), но на вход он уже принимает не FragmentManager, а FragmentTransaction. В этом случае система также сама вызовет commit внутри show, но мы можем предварительно поместить в созданную нами транзакцию какие-либо еще операции или отправить ее в BackStack.





Вы можете использовать диалог-фрагменты, как обычные фрагменты и отображать их на Activity, а не в виде диалога. Но при этом будьте аккуратнее с использованием **getDialog**. Я так понял, что он возвращает null в этом случае.





Если **AlertDialog.Builder** вам незнаком, то посмотрите Урок 60 и несколько следующих за ним. Там достаточно подробно описано, как создавать различные диалоги.





Статья из сайта [startandroid.ru](http://startandroid.ru/uroki/vse-uroki-spiskom/180-urok-110-android-3-fragments-dialogfragment-dialog.html)





Полный проект вы можете скачать на [странице с кодами](http://android-helper.com.ua/codes/).





Пишите ваши комментарии.
Сегодня просматривая свои записи, нашел интересную статью.





В этой статье автор описывает базовые компоненты android.





Думаю, что она будет интересна не только новичкам но и бывалым программерам, которые просто хотят освежить свои знания.





Тогда прошу к прочтению.


 <!-- more -->


Маленькая схема:





![](http://android-helper.com.ua/images/uploads/2012/10/f3ea651c-e042-4c34-b2fc-964b4cd7ae0f.png)








* Приложения для Android состоят из одного или нескольких компонентов: Activities (Деятельности), Services (Службы), Content Providers (Поставщики данных), а также Broadcast Receivers (Получатели широковещательных сообщений).  
  
* Каждый компонент выполняет свою роль в приложении и может быть активирован отдельно от других (причём активирован может быть даже сторонним приложением).  
  
* В AndroidManifest.xml (файл манифеста) должны быть объявлены все компоненты приложения и системные требования, такие как необходимая минимальная версия Android или определённая аппаратная конфигурация.  
  
* Необходимые для приложения ресурсы (изображения, файлы разметки, строки и т.д.) должны содержать альтернативные варианты для различных конфигураций устройств (например, строки на разных языков или различные разметки и изображения для возможных размеров экрана).  
  
  
Данный текст является переводом (хотя и немного вольным) статьи из [официальной документации по Android](http://developer.android.com/guide/topics/fundamentals.html).  
  
Примечание: некоторые слова в тексте оставлены по-английски, потому что, эти термины совпадают с названиями классов с помощью которых они реализуются и их перевод только усложняет понимание (в скобках написан их буквальный перевод).  
  
  
**Основы**  
Android-приложения написаны на языке программирования Java. Инструмент Android SDK (Software Development Kit — комплект разработки программного обеспечения) компилирует код вместе со всеми данными и файлами ресурсов в пакет Android - архивный файл с расширением .apk. Этот файл позволяет установить приложение на любом устройстве под управлением системы Android.  
  
После установки на устройстве, каждое приложение живёт в своей собственной изолированной программной среде:








  * Операционная система Android является многопользовательской Linux-системой, в которой каждое приложение это отдельный пользователь.



  * По умолчанию, система присваивает каждому приложению уникальный идентификатор пользователя userid (который используется только системой). Система устанавливает разрешения для всех файлов приложения таким образом, чтобы только определённый пользователь (с определённым userid) мог получить к ним доступ.



  * Каждый процесс имеет свою собственную виртуальную машину, так что код приложения запускается изолированно от других приложений.



  * По умолчанию каждое приложение выполняется в отдельном процессе Linux. Android начинает процесс, когда одному из компонентов приложения необходимо запуститься, а затем завершает процесс, когда он больше не нужен или когда системе требуется память для других приложений.






Таким образом, система Android реализует принцип наименьших привилегий. То есть, каждое приложение по умолчанию имеет доступ только к компонентам, которые необходимы для его работы и не более того. Однако, существуют способы обмена данными между приложениями и получения доступа к системным сервисам:








  * Возможно раздать двум приложениям одинаковые идентификаторы пользователей (userid), в этом случае они могут получить доступ к файлам друг друга. Для экономии системных ресурсов приложения с тем же идентификатором также могут быть запущены в одном процессе и использовать одну виртуальную машину. Такие приложения должны быть подписаны на один и тот же сертификат.



  * Приложение может запросить разрешение на доступ к системным данным, таким как контакты пользователя, SMS сообщения, карточка хранения (SD), камера, Bluetooth и многое другое. Все запросы доступа должны быть разрешены пользователем во время установки.






**Компоненты приложений **  
Компоненты — кирпичики, из которых состоит любое приложение. Каждый компонент предоставляет отдельную точку входа в приложение для системы, хотя не каждая такая точка является актуальной для пользователя. Компоненты могут зависеть друг от друга, но каждый из них это отдельная сущность, которая играет особую роль и помогает определить общее поведение приложения.   
  
Существуют четыре типа компонентов приложения. Каждый из них служит различным целям и имеет свой жизненный цикл, который определяет, как компонент создаётся и уничтожается.   
  
_**Activity (Деятельность)**_  
Activity представляет собой один экран с пользовательским интерфейсом. Например, приложение электронной почты, может иметь одну Activity, которая показывает список новых сообщений электронной почты, другую для создания нового сообщения, и ещё одну для чтения письма. Хотя все они работают вместе в рамках одного приложения, каждая из них независима от других. Таким образом, другие приложения могут вызвать любую из этих Activity (если почтовое приложение позволяет это). Например, приложение камеры может открыть Activity в которой создаётся новое сообщение, чтобы пользователь мог отправить фотографии по почте.   
  
_**Service (Служба)**_  
Service это компонент, который работает в фоновом режиме и не имеет пользовательского интерфейса. Службы используются для обработки длительных операций или для выполнения удалённых процессов. Например, Service может воспроизводить музыку в фоновом режиме или получать данные по сети, не блокируя взаимодействие пользователя с работающим приложением. Service могут запустить другие компоненты, например Activity, и затем взаимодействовать с ней.  
  
_**Content provider (Поставщик данных)**_  
Content provider управляет данными приложения. Данные можно хранить в файловой системе, базе данных SQLite, в Интернете или любом другом доступном для приложения месте хранения. Через Content providers другие приложения могут запрашивать или даже изменить данные (если на это есть права доступа). Например, в операционной системе Android существует Content provider, который управляет списком контактов пользователя. Таким образом, любое приложение, с соответствующими разрешениями могут запрашивать информацию о конкретном человеке для чтения или записи. Content provider также можно использовать для чтения и записи данных, которые доступны только для одного приложения.   
  
_**Broadcast receivers (Получатель широковещательных сообщений)**_  
Broadcast receiver - компонент, который позволяет принимать широковещательные сообщения операционной системы. Такими сообщениями являются, например, объявления о том, что экран выключился, батарея разряжена или был сделан фотоснимок. Такие сообщения также могут посылаться пользовательскими приложениями, например, уведомления о том, что некоторые данные были загружены и готовы к использованию. Хотя Broadcast receiver не имеют пользовательского интерфейса, он может создавать уведомления в строке состояния. Однако, чаще всего Broadcast receiver это просто "шлюз" для других компонентов, например, он может запускать Service для обработки определённых событий.   
  
Уникальной особенностью системы Android является то, что любое приложение может запустить компоненты другого приложения. Если необходимо дать пользователю возможность сделать фотографию, то не обязательно это реализовывать, можно вызвать уже существующее приложение. После завершения оно вернёт созданную фотографию в ваше приложение для дальнейшего использования. Для пользователя это будет выглядеть как одно приложение.   
  
Для запуска любого компонента операционная система начинает новый процесс (если его ещё не было) и инициализирует классы, необходимые для компонента. Например, если в вашем приложении запускается Activity для работы с камеры (принадлежащая стороннему приложению), то она запускается в отдельном процессе, который принадлежит этому стороннему приложению, а не в процессе вашего приложения. Поэтому, в отличие от приложений на большинство других систем, приложений Android не имеют единую точку входа (нет функции main()).   
  
Так как система запускает каждое приложение в отдельном процессе с правами доступа к файлам, которые ограничивают доступ для других приложений, ваше приложение не может непосредственно вызвать компонент из стороннего приложения. Однако, операционная система Android это может, поэтому для активации такого компонента, необходимо отправить сообщение операционной системе о своём намерении начать конкретный компонент и она его активирует.  
  
**Активация компонентов**  
Три из четырёх типов компонентов — Activity (деятельность), Service (сервис), а также Broadcast receivers (получатель широковещательных сообщений) — активируются с помощью асинхронного сообщения Intent (намерение). Intent связывает отдельные компоненты друг с другом во время выполнения, будь то компонент принадлежащий вашему приложению или другой.   
  
Intent (намерение) создаётся с помощью класса Intent, который описывает запрос на активацию конкретного компонента или конкретного типа компонента, соответственно Intent может быть явным или неявным.   
  
Для Activity и Service, Intent(намерение) определяет действие, которое надо выполнить (например, "Просмотреть" или "Отправить" что-то), и может указать URI (Uniform Resource Identifier — унифицированный идентификатор ресурса) данных необходимых для выполнения. Например, Intent может передать запрос Activity показать изображение или открыть веб-страницу.   
Для broadcast receivers Intent просто определяет транслируемые сообщения (например, широковещательное сообщения о том, что аккумулятор разряжен содержит только строковую константу обозначающую "батарея разряжена").   
Последний компонент - Content provider не активируется с помощью Intent. Хотя он и может вызывается, если Content provider запрашивает данные из ContentResolver.   
  
Методы для активации каждого типа компонентов:








  * Для запуска Activity используются методы startActivity(Intent intent) или startActivityForResult(Intent intent) (если необходимо вернуть результат).



  * Для запуска Service вызывается метод startService (Intent service).



  * Для запуска Broadcast reciever — sendBroadcast(Intent intent), sendOrderedBroadcast(Intent intent, String receiverPermission), или sendStickyBroadcast(Intent intent).



  * Для формирования запроса для Content Provider используется метод query ()






**Файл манифеста **  
Перед запуском любого компонента операционная система Android читает файл манифеста приложения AndroidManifest.xml, чтобы убедиться, что запускаемый компонент существует. В этом файле должны быть объявлены все компоненты приложения, которые находятся в корневой папке приложения.  
  
Кроме этого манифест-файл выполняет другие функции:








  * Определяет пользовательские разрешения, такие как доступ в Интернет или чтение контактов.



  * Объявление минимального API уровня (версии Android), необходимого для приложения.



  * Объявление аппаратных и программных требований, такие как камера, Bluetooth, или мультитач экран.



  * API библиотек с которыми приложение будет связываться, например библиотеки Google Maps.






Но все же основная задача манифеста сообщить системе о компонентах приложения. Например, можно объявить Activity (деятельность) следующим образом:







	<?xml version="1.0" encoding="utf-8"?>  
	<manifest ... >  
		<application android:icon="@drawable/app_icon.png" ... >  
			<activity android:name="com.example.project.ExampleActivity"  
			android:label="@string/example_label" ... >  
			</activity>  
		</application>  
	</manifest>  








В элементе <application> атрибут Android:icon указывает на ресурсы для иконки приложения.  
  
В элементе <activity> атрибут Android:name определяет полный путь на имя класса Activity (деятельности), а атрибут Android:label задаёт заголовок приложения.   
  
Для определения компонентов используются:  
<activity> для Activity (деятельности)  
<service> для Service (сервисы)  
<receiver> для Broadcast reciever (получатели широковещательных сообщений)  
<provider> для Content providers (поставщики данных)  
  
Activity (деятельность), Service (сервис) и Content provider (поставщики данных), которые существуют в исходниках, но не заявлены в манифесте не видны системе и, следовательно, не смогут запуститься. Однако, Broadcast provider (получатель широковещательных сообщений) может создаваться динамически в коде (как объекты BroadcastReceiver) и регистрироваться с помощью вызова registerReceiver ().   
  
**Объявление возможностей компонента**  
Как уже говорилось в разделе «Активация компонентов», для вызова Activity (деятельность), Service (сервис) и Broadcast receiver (получатель широковещательных сообщений) можно использовать класс Intent. Сделать это можно явно, задав конкретное имя компонента, или не явно, а этом случае описывается только тип действия, который нужно выполнить (и, возможно, данные, необходимые для него). Система сама находит компонент устройства, который может выполнить действия и запускает его. Если найдено несколько подходящих компонентов, то пользователь выбирает, какой из них использовать.   
  
Система определяет компоненты, которые могут реагировать на намерение путём сравнения полученного Intent (намерения), с Intent filters (фильтр намерений), определённых в файлах манифеста других приложений.   
  
При объявлении компонента в файле манифеста, можно дополнительно включить фильтр намерений, которые заявляют возможности компонента, чтобы он мог реагировать на запросы из других приложений. Для объявления фильтра намерения используется элемент <intent-filter>.   
  
Например, приложение электронной почты с Activity (деятельностью) для создания новых сообщений может объявить Intent filter (фильтр намерения) в своём файле манифеста запускаться на запрос "send" (отправить). Activity (деятельность) в стороннем приложении создаёт Intent (намерение) с типом действия "send" (ACTION_SEND), которое система сопоставит с приложением электронной почты и запустит нужную Activity (деятельность).  
  
**Объявление требований приложений **  
Существует большое количество устройств, работающий под управлением системы Android, однако, не все они обеспечивают одинаковые функции и возможности. Чтобы не позволить установить приложение на устройство, в котором отсутствуют необходимые функции, необходимо объявить аппаратные и программные требования в файле манифеста. Большинство из этих заявлений существуют исключительно для ознакомления и система не читает их, однако внешние сервисы, таких как Android Market используют их, чтобы обеспечить фильтрацию для пользователей, которые ищут приложения для своего устройства.   
  
Например, если приложение требует камеру и использует API, введённые в Android версии 2.1 (API уровень 7), надо записать эти требования в файл манифеста. Таким образом, устройства, которые не имеют камеру или с версией Android ниже, чем 2.1 не смогут установить приложение из Android Market.   
  
Однако, приложение может использовать камеру, но но это требование не является критичным для его работы. В этом случае приложение должно выполнять проверку во время выполнения, чтобы отключить функции, использующие камеру.   
  
При проектировании и разработке приложения, необходимо учитывать:   
  
_**Размер экрана и плотность**_  
Android определяет две характеристики экрана для устройства: размер экрана (физические размеры экрана) и плотность (плотность пикселей на экране, или dpi (dots per inch - точек на дюйм). Для упрощения Android обобщает их в отдельных группы  
  
Размер: small (маленький), normal (средний), large (большой), and extra large (очень большой).   
Плотность: low density (низкая), medium density (средняя), high density (высокая), and extra high density (очень высокая).   
  
По умолчанию, приложение совместимо со всеми размерами экрана, так как система Android делает необходимые изменения пользовательского интерфейса и изображений. Однако, лучше создать специализированные макеты и изображения для определённых размеров и плотностей и объявить в манифесте, какие именно размеры экрана приложение поддерживает в элементе <supports-screens>.  
  
_**Средства ввода **_  
Устройства могут иметь различные средства для ввода, такие как аппаратная клавиатура, трекбол или джойстик. Если приложение требует определённое оборудование для ввода, то необходимо объявить это в манифесте в элементе <uses-configuration>. Однако, в большинстве случаев приложения поддерживают любое средство ввода.  
  
_**Аппаратные требования**_  
Не все аппаратные или программные функции, таких как камера, датчик освещённости, Bluetooth или сенсорный экран, могут существовать на конкретном устройстве, поэтому необходимо декларировать любые функции, используемые приложения в элементе .   
  
_**Версия платформы **_  
Устройства работают на разных версиях платформы Android. Каждая последующая версия часто включает в себя дополнительные интерфейсы API, которые не доступны в предыдущей версии. Для того, чтобы указать, какой набор API-интерфейсов доступен, каждой версии платформы соответствует API уровень (например, Android 1.0 — 1 уровень API, Android 2.3 — 9 уровень). Если в приложении используются API, которые были добавлены к платформе после определённой версии, необходимо объявить минимальный уровень API с помощью элемента <uses-sdk>.  
  
**Ресурсы приложения **  
Приложения Android состоят не только из исходного кода, но также из ресурсов для визуального представления, такие как изображения или звуковые файлы. Для приложения необходимо определить меню, стили, цвета и разметку пользовательского интерфейса в файлах XML. Использование ресурсов даёт возможность изменять некоторые части приложения без модификации исходного кода, а также позволяет оптимизировать приложение для различных устройств (с различным языком интерфейса или размером экрана).   
  
Для каждого ресурса, включённого в проект Android, SDK определяет уникальный идентификатор (целое число), которое можно использовать для ссылки на ресурс из кода или из других ресурсов определённых в XML. Например, если приложение содержит изображение с именем logo.png (сохранённое в директории res/drawable), SDK сгенерирует идентификатор ресурса R.drawable.logo, которое можно использовать для ссылки на изображение.   
  
Главным достоинством отдельного хранения исходного кода и ресурсов является возможность создать разные ресурсы для разных аппаратных конфигураций. Например, строки интерфейса для разных языков можно определять в различных xml файлах (они хранятся например в директории res/values-fr/ для французского языка). В зависимости от выбранного пользователем языка система Android подставляет нужные строки в интерфейс.   
  
Android поддерживает множество классификаторов для альтернативных ресурсов. Классификатор это короткая строка в название директории ресурсов для определения когда эти ресурсы должны быть использованы. Часто создаются различные схемы интерфейса для разных размеров и ориентаций экранов устройства. Например, при портретной ориентации кнопки удобнее разместить по вертикали, а для альбомной ориентации - по горизонтали. Чтобы изменить расположение в зависимости от ориентации, можно определить две различные схемы и добавить соответствующие классификаторы к имени каталога каждого макета. Тогда, система автоматически применяет соответствующий макет в зависимости от текущей ориентации устройства.
Добрый день друзья.





По просьбе одного из участников нашего сообщества. Был поднят вопрос:





Как можно достучаться до элементов на табах.





Сегодня я вам покажу на эту тему видео и дам комментарии.


<!-- more -->


Смотрим видео.


{% youtube waUgWu8PV1w %}






#### bottom_selector.xml



	<?xml version="1.0" encoding="utf-8"?>

	<selector xmlns:android="http://schemas.android.com/apk/res/android">



		<item android:drawable="@android:drawable/ic_lock_silent_mode_off" android:state_selected="true"/>

		<item android:drawable="@android:drawable/ic_lock_silent_mode_off" android:state_focused="true"/>

		<item android:drawable="@android:drawable/ic_lock_silent_mode_off" android:state_pressed="true"/>

		<item android:drawable="@android:drawable/ic_lock_silent_mode"/>

	</selector>


	



#### text_colors_selector.xml



	<?xml version="1.0" encoding="utf-8"?>

	<selector xmlns:android="http://schemas.android.com/apk/res/android">



		<item android:state_selected="true" android:color="@android:color/white"/>

		<item android:state_focused="true" android:color="@android:color/white"/>

		<item android:state_pressed="true" android:color="@android:color/white"/>

		<item android:color="@android:color/darker_gray"/>



	</selector>

	



#### tab_host_layout.xml


	<?xml version="1.0" encoding="utf-8"?>

	<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"

		android:layout_width="fill_parent"

		android:layout_height="fill_parent"

		android:background="@android:color/black" >



	<ImageView

		android:id="@+id/tab_image"

		android:layout_width="fill_parent"

		android:layout_height="fill_parent"

		android:layout_above="@+id/tab_text"

		android:cropToPadding="true"

		android:scaleType="center"

		android:src="@android:drawable/ic_menu_add" />



	<TextView

		android:id="@+id/tab_text"

		android:layout_width="fill_parent"

		android:layout_height="wrap_content"

		android:layout_alignParentBottom="true"

		android:layout_marginBottom="5dp"

		android:gravity="center_horizontal"

		android:text="Text"

		android:textColor="@color/text_colors_selector"

		android:textSize="13sp" />



	<TextView

		android:id="@+id/tab_unread_message"

		android:layout_width="wrap_content"

		android:layout_height="wrap_content"

		android:layout_alignParentRight="true"

		android:layout_marginRight="10dp"

		android:layout_marginTop="2dp"

		android:gravity="center"

		android:text="5"

		android:textColor="@android:color/white"

		android:textSize="14sp"

		android:textStyle="bold" />



	</RelativeLayout>
	



#### MainActivity.java


1. Комментируем и добавляем построение табов



		// mTabsAdapter.addTab(mTabHost.newTabSpec("simple").setIndicator("Android"), AndroidFragment.class, null);

		// mTabsAdapter.addTab(mTabHost.newTabSpec("contacts").setIndicator("IOs"), IOsFragment.class, null);

		// mTabsAdapter.addTab(mTabHost.newTabSpec("custom").setIndicator("Windows"), WindowsFragment.class, null);

		// mTabsAdapter.addTab(mTabHost.newTabSpec("throttle").setIndicator("DOS"), DOSFragment.class, null);



		mTabsAdapter.addTab(setupTab(new TextView(this), "Android", R.drawable.bottom_selector, 0),

				AndroidFragment.class, null);

		mTabsAdapter

				.addTab(setupTab(new TextView(this), "IOs", R.drawable.bottom_selector, 0), IOsFragment.class, null);

		mTabsAdapter.addTab(setupTab(new TextView(this), "Windows", R.drawable.bottom_selector, 0),

				WindowsFragment.class, null);

		mTabsAdapter

				.addTab(setupTab(new TextView(this), "DOS", R.drawable.bottom_selector, 0), DOSFragment.class, null);

	



2. Добавляем 2 функции сразу после onCreate





		private TabSpec setupTab(final View view, final String tag, final int imageRes, final int notificationItem) {

		View tabview = createTabView(mTabHost.getContext(), tag, imageRes, notificationItem);

		TabSpec setContent = mTabHost.newTabSpec(tag).setIndicator(tabview).setContent(new TabContentFactory()                         {

			@Override

			public View createTabContent(final String tag) {

				return view;

			}

		});

		// mTabHost.addTab(setContent);

		return setContent;

		}



		private static View createTabView(final Context context, final String text, final int imageRes,

			final int notificationItem) {

		View view = LayoutInflater.from(context).inflate(R.layout.tab_host_layout, null);

		TextView tv = (TextView) view.findViewById(R.id.tab_text);

		tv.setText(text);

		ImageView iv = (ImageView) view.findViewById(R.id.tab_image);

		iv.setImageResource(imageRes);

		tv = (TextView) view.findViewById(R.id.tab_unread_message);

		tv.setText(String.valueOf(notificationItem));

		if (notificationItem == 0) {

			tv.setVisibility(View.GONE);

		} else {

			tv.setVisibility(View.VISIBLE);

		}

		return view;

		}






3. Добавляем функцию нотификации после метода onPageScrollStateChanged

4. Делаем нотификацию

		public void updateNotification(final int notificationItem, final int position) {

			View view = mTabHost.getTabWidget().getChildAt(position);

			TextView tv = (TextView) view.findViewById(R.id.tab_unread_message);

			tv.setText(String.valueOf(notificationItem));

			if (notificationItem == 0) {

				tv.setVisibility(View.GONE);

			} else {

				tv.setVisibility(View.VISIBLE);

			}

		}





P.S. Забыл на видео сказать, что нужно еще модифицировать activity_main.xml





#### activity_main.xml





	<?xml version="1.0" encoding="utf-8"?>

	<TabHost xmlns:android="http://schemas.android.com/apk/res/android"

	android:id="@android:id/tabhost"

	android:layout_width="match_parent"

	android:layout_height="match_parent" >



	<LinearLayout

		android:layout_width="match_parent"

		android:layout_height="match_parent"

		android:orientation="vertical" >



		<FrameLayout

			android:id="@android:id/tabcontent"

			android:layout_width="0dp"

			android:layout_height="0dp"

			android:layout_weight="0" />



		<android.support.v4.view.ViewPager

			android:id="@+id/pager"

			android:layout_width="match_parent"

			android:layout_height="0dp"

			android:layout_weight="1" />



		<TabWidget

			android:id="@android:id/tabs"

			android:layout_width="match_parent"

			android:layout_height="53dp"

			android:layout_weight="0"

			android:orientation="horizontal" />

	</LinearLayout>



	</TabHost>




Если вам понравилась статья, пишите свои комментарии.





Поделись этой статьей с другом.
Нашел довольно интересную статью по работе с mp3 файлами на стороне android.





Думаю это будет интересно как для профи так и для новичка.





Прошу к прочтению.


<!-- more -->


В данной статье описан процесс получения всей основной информации о аудиотреках в устройстве с Android, основы работы с плейлистами и проигрывания аудиофайлов.





**Общие принципы работы с провайдерами данных**





Источники данных ( Content Providers, Провайдеры данных ) в Android предоставляют интерфейс общего доступа к любому источнику данных путем отделения уровня доступа к данным от уровня приложения. Источники данных предлагают стандартный API, с помощью которого приложения могут обмениваться своими данными между собой, и использовать различные системные базы данных.





Типичный запрос к провайдеру данных выглядит следующим образом. Сначала запрашивается системный объект класса ContentResolver, который позволяет подключаться к провайдерам данных. Затем необходимо настроить параметры запроса и вызвать метод ContentResolver.query, в который передаются параметры запроса и который в случае успешного выполнения возвращает объект класса Cursor, предоставляющий интерфейс для работы с данными, возвращаемые в результате запроса к базе данных.




    
    
    
    [java]String[] projection = new String[] {
    
    People._ID,
    
    People.NAME,
    
    People.NUMBER,
    
    };
    
    
    
    Uri mContactsUri = People.CONTENT_URI;
    
    ContentResolver resolver = appContext.getContentResolver();
    
    
    
    Cursor managedCursor = resolver.query( mContactsUri,
    
              projection,.
    
              null, 
    
              null,
    
              People.NAME + " ASC"); 
    
    
    
    for( int i=0;i&lt;managedCursor.getCount();i++)
    
    {
    
          managedCursor.moveToPosition(i);
    
          String nameOfContact =  managedCursor.getString(1);
    
          ….    
    
    }
    
    [/java]
    
    





Подробнее о работе с провайдерами данных можно посмотреть на сайте разработчиков -[http://developer.android.com/guide/topics/providers/content-providers.html](http://developer.android.com/guide/topics/providers/content-providers.html).





**Провайдер данных MediaStore.Audio**





Провайдер данных MediaStore представляет собой централизованную базу данных мультимедиа, размещенных в памяти устройства или на сменном носителе ( SD карте ), включая аудио-, видеофайлы и изображения. Данные в MediaStore записываются автоматически при сканировании системой внутренней или сменной памяти, при этом рассылаются сообщения ACTION_MEDIA_SCANNER_STARTED и ACTION_MEDIA_SCANNER_FINISHED. Любая программа может уведомить сканер о наличии нового файла вызовом




    
    
    
    [java]sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE, newFilePath));[/java]





Примечание: чтобы запретить сканеру обрабатывать определенный каталог на диске, поместите туда пустой файл с именем .nomedia.





При сканировании анализируются ID теги и другая информация, которая становится доступна в пользовательских приложениях. Доступ к данным аудиофайлов осуществляется через провайдер MediaStore.Audio, который также дает возможность работать с плейлистами ( списками воспроизведения ). 





В примерах этой статьи будет использоваться вызов myquery, который утилизирует получение курсора по URI провайдера данных и других параметров запроса.




    
    [java]public static Cursor myquery(Context context, Uri uri, String[] projection,
    
                 String selection, String[] selectionArgs, String sortOrder, int limit) {
    
                 try {
    
                       ContentResolver resolver = context.getContentResolver();
    
                       if (resolver == null) {
    
                            return null;
    
                       }
    
                        if (limit &gt; 0) {
    
                            uri = uri.buildUpon().appendQueryParameter("limit", "" + limit).build();
    
                         }
    
                      return resolver.query(uri, projection, selection, selectionArgs, sortOrder);
    
                    } catch (UnsupportedOperationException ex) {
    
                                return null;
    
                     }
    
                 
    
                  }[/java]





**Простое перечисление всей музыки в телефоне**




    
    [java]String[] projection = { MediaStore.Audio.Media._ID,             // 0
    
                              MediaStore.Audio.Media.ARTIST,          // 1
    
                              MediaStore.Audio.Media.TITLE,           // 2
    
                              MediaStore.Audio.Media.ALBUM_ID,  // 3
    
                              MediaStore.Audio.Media.ALBUM,           // 4
    
                              MediaStore.Audio.Media.DATA,            // 5
    
                              MediaStore.Audio.Media.DISPLAY_NAME,    // 6
    
                              MediaStore.Audio.Media.DURATION,
    
                                            MediaStore.Audio.Media.TITLE_KEY
    
            };      // 7
    
    
    
    String selection = MediaStore.Audio.Media.IS_MUSIC + " != 0 ";
    
    Cursor musicListSDCardCursor = myquery(
    
                               this,
    
                               MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,
    
                               projection, selection , null, null,0);
    
    Cursor musicListInternalMemoryCursor = myquery(
    
                               this,
    
                               MediaStore.Audio.Media.INTERNAL_CONTENT_URI,
    
                               projection, selection , null, null,0);
    
    [/java]





**Списки альбомов**





Получение списка альбомов:




    
    [java]String[] projection = {
    
                 MediaStore.Audio.Albums.ALBUM,            // 0
    
                 MediaStore.Audio.Albums.NUMBER_OF_SONGS,  // 1
    
                 MediaStore.Audio.Albums.LAST_YEAR,       // 2
    
                               MediaStore.Audio.Albums.ARTIST,           // 3
    
                               MediaStore.Audio.Albums._ID               // 4
    
                                            };
    
    
    
    
    
      Cursor albumsListSDCardCursor = myquery(
    
                               this,
    
                               MediaStore.Audio.Albums.EXTERNAL_CONTENT_URI,
    
                               projection, null , null, null,0);
    
    
    
      Cursor albumsListInternalMemoryCursor = myquery(
    
                               this,
    
                               MediaStore.Audio.Albums.INTERNAL_CONTENT_URI,
    
                               projection, null , null, null,0);
    
    [/java]





Получение списка дорожек, входящих в данный альбом:




    
    [java]// String albumId содержит выбранный MediaStore.Audio.Albums._ID  
    
    
    
    String[] projection = { MediaStore.Audio.Media._ID,             // 0
    
                              MediaStore.Audio.Media.ARTIST,          // 1
    
                              MediaStore.Audio.Media.TITLE,           // 2
    
                              MediaStore.Audio.Media.ALBUM_ID,  // 3
    
                              MediaStore.Audio.Media.ALBUM,           // 4
    
                              MediaStore.Audio.Media.DATA,            // 5
    
                              MediaStore.Audio.Media.DISPLAY_NAME,    // 6
    
                              MediaStore.Audio.Media.DURATION,
    
                                            MediaStore.Audio.Media.TITLE_KEY
    
            };      // 7
    
    
    
           String selection = MediaStore.Audio.Media.IS_MUSIC + " != 0 AND "+
    
                   MediaStore.Audio.Media.ALBUM_ID +"=?";
    
           String[] args = new String[] {albumId};
    
    
    
    Cursor musicListSDCardCursor = myquery(
    
                               this,
    
                               MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,
    
                               projection, selection , args, null,0);
    
    Cursor musicListInternalMemoryCursor = myquery(
    
                               this,
    
                               MediaStore.Audio.Media.INTERNAL_CONTENT_URI,
    
                               projection, selection , args, null,0);
    
    [/java]





**Списки исполнителей**





Получение списка всех исполнителей:




    
    [java]String[] projection = {
    
                MediaStore.Audio.Artists.ARTIST,            // 0
    
                MediaStore.Audio.Artists.NUMBER_OF_ALBUMS,  // 1
    
                MediaStore.Audio.Artists.NUMBER_OF_TRACKS,
    
                              MediaStore.Audio.Artists._ID
    
                                            };
    
    
    
    
    
      Cursor artistListSDCardCursor = myquery(
    
                               this,
    
                               MediaStore.Audio.Artists.EXTERNAL_CONTENT_URI,
    
                               projection, null , null, null,0);
    
    
    
      Cursor artistListInternalMemoryCursor = myquery(
    
                               this,
    
                               MediaStore.Audio.Artists.INTERNAL_CONTENT_URI,
    
                               projection, null , null, null,0);
    
    [/java]





Получение списка композиций данного исполнителя:




    
    [java]// String artistId содержит выбранный MediaStore.Audio.Artists._ID  
    
    String[] projection = {
    
                  String[] projection = { MediaStore.Audio.Media._ID,             // 0
    
                              MediaStore.Audio.Media.ARTIST,          // 1
    
                              MediaStore.Audio.Media.TITLE,           // 2
    
                              MediaStore.Audio.Media.ALBUM_ID,  // 3
    
                              MediaStore.Audio.Media.ALBUM,           // 4
    
                              MediaStore.Audio.Media.DATA,            // 5
    
                              MediaStore.Audio.Media.DISPLAY_NAME,    // 6
    
                              MediaStore.Audio.Media.DURATION,
    
                                            MediaStore.Audio.Media.TITLE_KEY
    
            };      // 7
    
    
    
           String selection = MediaStore.Audio.Media.IS_MUSIC + " != 0 AND "+
    
                   MediaStore.Audio.Media.ARTIST_ID +"=?";
    
           String[] args = new String[] {artistId};
    
    
    
          Cursor musicListSDCardCursor = myquery(
    
                               this,
    
                               MediaStore.Audio.Artists.EXTERNAL_CONTENT_URI,
    
                               projection, null , null, null,0);
    
    
    
          Cursor musicListInternalMemoryCursor = myquery(
    
                               this,
    
                               MediaStore.Audio.Artists.INTERNAL_CONTENT_URI,
    
                               projection, null , null, null,0);
    
    [/java]





**Списки жанров**





Получение списка всех жанров:




    
    [java]String[] projection = { MediaStore.Audio.Genres._ID,          // 0
    
                  MediaStore.Audio.Genres.NAME          // 1
    
                                                        };
    
        Cursor genresListSDCardCursor = myquery(
    
                               this,
    
                               MediaStore.Audio.Genres.EXTERNAL_CONTENT_URI,
    
                               projection, null , null, MediaStore.Audio.Genres.NAME, 0);
    
    
    
        Cursor genresListInternalMemoryCursor = myquery(
    
                               this,
    
                               MediaStore.Audio.Genres.INTERNAL_CONTENT_URI,
    
                               projection, null , null, MediaStore.Audio.Genres.NAME, 0);[/java]





Получение списка композиций выбранного жанра:




    
    [java]// String genreId содержит выбранный MediaStore.Audio.Genres._ID
    
     String[] projection = { MediaStore.Audio.Genres.Members._ID,             // 0
    
                              MediaStore.Audio.Genres.Members.ARTIST,          // 1
    
                              MediaStore.Audio.Genres.Members.TITLE,           // 2
    
                              MediaStore.Audio.Genres.Members.ALBUM_ID,  // 3
    
                              MediaStore.Audio.Genres.Members.ALBUM,           // 4
    
                              MediaStore.Audio.Genres.Members.DATA,            // 5
    
                              MediaStore.Audio.Genres.Members.DISPLAY_NAME,    // 6
    
                              MediaStore.Audio.Genres.Members.DURATION,
    
                                            MediaStore.Audio.Media.TITLE_KEY
    
                       };      // 7
    
    
    
            String selection = MediaStore.Audio.Genres.Members.IS_MUSIC + " != 0";
    
    
    
      Cursor musicListSDCardCursor = myquery(
    
                               this,
    
                               MediaStore.Audio.Genres.Members.getContentUri("external", Long.valueOf(s)),
    
                               projection, selection , null, null,0);
    
    
    
      Cursor musicListInternalMemoryCursor = myquery(
    
                               this,
    
                               MediaStore.Audio.Genres.Members.getContentUri("internal", Long.valueOf(s)),
    
                               projection, selection , null, null,0);
    
    
    
    [/java]





**Работа с плейлистами**





Получение списка всех плейлистов в устройстве:




    
    [java]String[] projection = { MediaStore.Audio.Playlists._ID,             // 0
    
                                 MediaStore.Audio.Playlists.NAME          // 1
    
                                                        };
    
    
    
                    
    
    
    
    Cursor playListSDCardCursor = myquery(
    
                               this,
    
                               MediaStore.Audio.Playlists.EXTERNAL_CONTENT_URI,
    
                               projection, null , null, MediaStore.Audio.Playlists.NAME,0);
    
    
    
    Cursor playListInternalMemoryCursor = myquery(
    
                               this,
    
                               MediaStore.Audio.Playlists.INTERNAL_CONTENT_URI,
    
                               projection, null , null, MediaStore.Audio.Playlists.NAME,0);[/java]





Создание нового плейлиста:




    
    [java]ContentValues cv = new ContentValues();
    
    cv.put(MediaStore.Audio.Playlists.NAME, "Новый плейлист");
    
    Uri uri = getContentResolver().insert(MediaStore.Audio.Playlists.getContentUri("external"), cv);[/java]





Добавление композиции в плейлист:




    
    [java]// long playlistId - MediaStore.Audio.Playlists._ID выбранного плейлиста
    
    // int audioId - MediaStore.Audio.Media._ID композиции
    
            ContentResolver resolver = getContentResolver();
    
            String[] cols = new String[] {
    
                    "count(*)"
    
            };
    
            Uri uri = MediaStore.Audio.Playlists.Members.getContentUri("external", playlistId);
    
            Cursor cur = resolver.query(uri, cols, null, null, null);
    
            cur.moveToFirst();
    
            final int base = cur.getInt(0);
    
            cur.close();
    
            ContentValues values = new ContentValues();
    
            values.put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, Integer.valueOf(base + 1));
    
            values.put(MediaStore.Audio.Playlists.Members.AUDIO_ID, audioId);
    
            resolver.insert(uri, values);[/java]





Перечисление всех композиций плейлиста:




    
    [java]// String playlistId - MediaStore.Audio.Playlists._ID выбранного плейлиста
    
    
    
    String[] projection = {         MediaStore.Audio.Media._ID,             // 0
    
                              MediaStore.Audio.Media.ARTIST,          // 1
    
                              MediaStore.Audio.Media.TITLE,           // 2
    
                              MediaStore.Audio.Media.ALBUM_ID,  // 3
    
                              MediaStore.Audio.Media.ALBUM,           // 4
    
                              MediaStore.Audio.Media.DATA,            // 5
    
                              MediaStore.Audio.Media.DISPLAY_NAME,    // 6
    
                              MediaStore.Audio.Media.DURATION,
    
                                            MediaStore.Audio.Media.TITLE_KEY
    
            };     
    
    
    
           
    
     Cursor musicListSDCardCursor = myquery(
    
                               this,
    
                               MediaStore.Audio.Playlists.Members.getContentUri("external", Long.valueOf(playlistId)),
    
                               projection, null , null, null,0);
    
    
    
      Cursor musicListInternalMemoryCursor = myquery(
    
                               this,
    
                               MediaStore.Audio.Playlists.Members.getContentUri("internal", Long.valueOf(playlistId)),
    
                               projection, null , null, null,0);
    
    [/java]





**Проигрывание аудиотрека**





Чтобы открыть mp3 файл в одном из плееров, установленных в системе, можно использовать Intents таким образом:




    
    [java]Intent it = new Intent(Intent.ACTION_VIEW);
    
     Uri uri = Uri.parse( "file:///sdcard/mymusic/happysong.mp3");
    
     it.setDataAndType(uri, "audio/mp3");
    
     startActivity(it);[/java]





Для проигрывания mp3 файлов из приложения можно использовать объект класса MediaPlayer. Класс MediaPlayer из Android SDK работает на основе модели автомата состояний ( конечного автомата, state machine ) и используется для воспроизведения аудио и видео роликов. 





После создания объекта класса MediaPlayer устанавливается путь к файлу аудиоролика на диске и вызывается метод MediaPlayer.prepare(), который инициализирует MediaPlayer и приводит его в состояние готовности к воспроизведению аудиофайла. 





После успешной инициализации MediaPlayer приложение может вызывать его методы start(), stop() и pause() для управления воспроизведением. 




    
    [java]// Общий пример воспроизведения mp3 с использованием класса MediaPlayer
    
    
    
         MediaPlayer mediaPlayer = new  MediaPlayer();
    
    
    
         
    
        try {
    
              mediaPlayer.setDataSource("/sdcard/mytracks/happysong.mp3");
    
              mediaPlayer.prepare();
    
              mediaPlayer.start();
    
    
    
            } catch (IllegalArgumentException iae) {
    
                  // TODO Auto-generated catch block
    
                  iae.printStackTrace();
    
     
    
            } catch (IllegalStateException ise) {
    
                 // TODO Auto-generated catch block
    
                 ise.printStackTrace();
    
    
    
            } catch (IOException ioe) {
    
                 // TODO Auto-generated catch block
    
                 ioe.printStackTrace();
    
            } catch (Exception e) {
    
                 // TODO Auto-generated catch block
    
                 e.printStackTrace();
    
            }
    
    
    
    [/java]





Подробнее об использовании класса MediaPlayer можно посмотреть на сайте разработчиков [http://developer.android.com/reference/android/media/MediaPlayer.html](http://developer.android.com/reference/android/media/MediaPlayer.html).





**Пример - проигрывание случайной дорожки**





Программа открывает в проигрывателе случайно выбранный mp3 файл.




    
    [java]package org.me.androidrandomplay;
    
    
    
    import android.app.Activity;
    
    import android.os.Bundle;
    
    import android.content.*;
    
    import android.database.Cursor;
    
    import android.net.Uri;
    
    import  android.provider.MediaStore;
    
    import android.widget.Toast;
    
    
    
    public class AndroidRandomPlay extends Activity {
    
    
    
        /** Called when the activity is first created. */
    
        @Override
    
        public void onCreate(Bundle icicle) {
    
            super.onCreate(icicle);
    
    
    
    
    
            String[] projection = { 
    
                                    MediaStore.Audio.Media._ID,
    
                                    MediaStore.Audio.Media.DATA
    
                                  };  
    
    
    
            String selection = MediaStore.Audio.Media.IS_MUSIC + " != 0 ";
    
            Cursor musicListSDCardCursor = myquery(
    
                                       this,
    
                                       MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,
    
                                       projection, selection , null, null,0);
    
            Cursor musicListInternalMemoryCursor = myquery(
    
                                       this,
    
                                       MediaStore.Audio.Media.INTERNAL_CONTENT_URI,
    
                                       projection, selection , null, null,0);
    
    
    
            java.util.Vector&lt;String&gt; paths = new java.util.Vector();
    
    
    
            if( musicListSDCardCursor!= null )
    
            {
    
                for(int i=0;i&lt;musicListSDCardCursor.getCount();i++)
    
                {
    
                    musicListSDCardCursor.moveToPosition(i);
    
                    String p = musicListSDCardCursor.getString(1);
    
                    if(p.endsWith("mp3"))
    
                            paths.addElement(p);
    
    
    
                }
    
                musicListSDCardCursor.close();
    
            }
    
    
    
             if( musicListInternalMemoryCursor!= null )
    
            {
    
                for(int i=0;i&lt;musicListInternalMemoryCursor.getCount();i++)
    
                {
    
                    musicListInternalMemoryCursor.moveToPosition(i);
    
                    String p = musicListInternalMemoryCursor.getString(1);
    
                    if(p.endsWith("mp3"))
    
                            paths.addElement(p);
    
    
    
                }
    
                musicListInternalMemoryCursor.close();
    
            }
    
    
    
            if( paths.isEmpty() ) 
    
            {
    
                Toast.makeText( this, "no media found", Toast.LENGTH_LONG).show();   
    
                return;
    
            }
    
    
    
            java.util.Random r = new  java.util.Random();
    
            int pos = r.nextInt(paths.size()-1);
    
            if( paths.size() == 1 ) pos = 0;
    
    
    
            String url  = paths.elementAt(pos);
    
    
    
            if( url.length() == 0 ) return;
    
    
    
            Toast.makeText( this, url, Toast.LENGTH_LONG).show();
    
    
    
            try{
    
    
    
                Intent it = new Intent(Intent.ACTION_VIEW);
    
                Uri uri = Uri.parse( "file://"+url);
    
                it.setDataAndType(uri, "audio/mp3");
    
                startActivity(it);
    
          
    
            }catch (Exception e)
    
            {
    
                Toast.makeText( this, e.toString(), Toast.LENGTH_LONG).show();
    
            }
    
        }
    
    
    
        public static Cursor myquery(Context context, Uri uri, String[] projection,
    
                 String selection, String[] selectionArgs, String sortOrder, int limit) {
    
                 try {
    
                       ContentResolver resolver = context.getContentResolver();
    
                       if (resolver == null) {
    
                            return null;
    
                       }
    
                        if (limit &gt; 0) {
    
                            uri = uri.buildUpon().appendQueryParameter("limit", "" + limit).build();
    
                         }
    
                      return resolver.query(uri, projection, selection, selectionArgs, sortOrder);
    
                    } catch (UnsupportedOperationException ex) {
    
                                return null;
    
                     }
    
                  }
    
    
    
    }[/java]
Многие меня спрашивают.





Что когда нужно вызывать в Activity. И когда вызываются разные методы.





И мне попалась интересная статья.





Лично для себя я читал официальную статью. Аналогов на русской тогда не было.





И так прошу к прочтению.


<!-- more -->


### Теория





При работе приложения, мы **создаем** новые **Activity** и **закрываем** старые, **сворачиваем** приложение, снова **открываем** и т.д. Activity умеет обрабатывать все эти движения. Это необходимо, например, для освобождения ресурсов или сохранения данных. В [хелпе](http://developer.android.com/guide/topics/fundamentals/activities.html#Lifecycle) достаточно подробно это описано.





Созданное при работе приложения **Activity **может быть в одном из **трех состояний**:





**Resumed**- Activity видно на экране, оно находится в фокусе, пользователь может с ним взаимодействовать. Это состояние также иногда называют Running.  
**Paused**- Activity не в фокусе, пользователь не может с ним взаимодействовать, но его видно (оно перекрыто другим Activity, которое занимает не весь экран или полупрозрачно).  
**Stopped**- Activity не видно (полностью перекрывается другим Activity), соответственно оно не в фокусе и пользователь не может с ним взаимодействовать.





Когда Activity переходит из одного **состояния** в другое, система вызывает различные его **методы**, которые мы можем заполнять своим кодом. Схематично это можно изобразить так:





![](http://android-helper.com.ua/images/uploads/2012/10/20111005_L0023_L_StatesSchema.jpg)





Для упрощения понимания я дал краткое описание состояний в скобках под названиями. А крестом обозначил отсутствие Activity.





Итак, мы имеем следующие методы Activity, которые вызывает система:





**onCreate**() – вызывается при первом создании Activity  
**onStart**() – вызывается перед тем, как Activity будет видно пользователю  
**onResume**() – вызывается перед тем как будет доступно для активности пользователя (взаимодействие)





**onPause**() – вызывается перед тем, как будет показано другое Activity  
**onStop**() – вызывается когда Activity становится не видно пользователю  
**onDestroy**() – вызывается перед тем, как Activity будет уничтожено





Т.е. эти методы **НЕ** вызывают смену состояния. Наоборот, смена состояния Activity является триггером, который вызывает эти методы. Тем самым нас уведомляют о смене, и мы можем реагировать соответственно. Посмотрим на практике, когда и в каком порядке вызываются эти методы.





###  





### Практика





В этом уроке нам надо будет эмулировать событие смены ориентации экрана. Но эмулятор с Android 2.3 делает это криво, поэтому в проекте будем использовать версию 2.2. Для этого надо [создать](http://startandroid.ru/uroki/vse-uroki-spiskom/12-urok-3-sozdanie-avd-pervoe-prilozhenie-struktura-android-proekta.html) новое AVD по версии 2.2 





![](http://android-helper.com.ua/images/uploads/2012/10/20111005_L0023_L_AVD22.jpg)




Создадим проект (обратите внимание, используем Android 2.2.):





**Project name**: P0231_OneActivityState  
**Build Target**: Android 2.2  
**Application name**: OneActivityState  
**Package name**: ru.startandroid.develop.p0231oneactivitystate  
**Create Activity**: MainActivity





Layout не меняем, нам он сейчас не важен.



	import android.app.Activity;

	import android.os.Bundle;

	import android.util.Log;



	public class MainActivity extends Activity {

  

  	final String TAG = "States";

  

    /** Called when the activity is first created. */

    @Override

    public void onCreate(Bundle savedInstanceState) {

        super.onCreate(savedInstanceState);

        setContentView(R.layout.main);

        Log.d(TAG, "MainActivity: onCreate()");

    }

    

  	@Override

  	protected void onStart() {

    	super.onStart();

   		Log.d(TAG, "MainActivity: onStart()");

  	}



  	@Override

  	protected void onResume() {

    	super.onResume();

    	Log.d(TAG, "MainActivity: onResume()");

  	}



  	@Override

  	protected void onPause() {

    	super.onPause();

    	Log.d(TAG, "MainActivity: onPause()");

  	}



  	@Override

  	protected void onStop() {

    	super.onStop();

    	Log.d(TAG, "MainActivity: onStop()");

  	}

    

  	@Override

  	protected void onDestroy() {

   		super.onDestroy();

    	Log.d(TAG, "MainActivity: onDestroy()");

  	}

	}







Добавим все остальные **методы** из схемы, и в каждый добавим запись в **лог**.





В каментах подсказали важное замечание! При реализации этих методов обязательно вызывайте соответствующие методы супер-класса и обязательно перед вашим кодом. См. код выше. Каждый метод содержит вызов метода супер-класса и свой код расположен после этих вызовов.





Все сохраним и запустим приложение. После того, как запустилось, смотрим лог:





_MainActivity: onCreate()  
MainActivity: onStart()  
MainActivity: onResume()_





Activity создалось, прошло два состояния (Stopped, Paused) и теперь находится в третьем состоянии - Resumed. Т.е. оно создалось (onCreate), отобразилось (onStart) и получило возможность взаимодействовать с пользователем (onResume).





Теперь нажмем кнопку Back на эмуляторе. Activity закрылось. Смотрим лог:





_MainActivity: onPause()  
MainActivity: onStop()  
MainActivity: onDestroy()_





Activity проделывает путь, обратный созданию. Сначала теряет фокус (onPaused), затем исчезает с экрана (onStop), затем полностью уничтожается (onDestroy).





###  





### Смена ориентации экрана





Посмотрим, как ведет себя Activity, когда происходит смена ориентации экрана. Запустите снова приложение (либо найдите его в списке приложений в системе на эмуляторе, либо снова нажмите CTRL+F11 в Eclipse ). В логах снова отобразились три метода, вызванные при создании. Теперь в эмуляторе нажмите CTRL+F12, ориентация сменилась. Кажется, что ничего особенного не произошло, но смотрим логи и видим:





_MainActivity: onPause()  
MainActivity: onStop()  
MainActivity: onDestroy()  
MainActivity: onCreate()  
MainActivity: onStart()  
MainActivity: onResume()_





Activity полностью уничтожается и снова создается. При этом обычно выполняются процедуры сохранения и восстановления данных, чтобы не потерялись данные, и приложение сохранило свой вид. Про то, как это делается, мы будем говорить в последующих уроках.





Также есть еще метод **onRestart**. Он вызывается перед методом **onStart**, если Activity не создается с нуля, а восстанавливается из состояния **Stoped**. Его мы рассмотрим в следующем уроке.





Обычно в учебниках эта тема дается по-другому. Но мне это шаблонное объяснение кажется недостаточно понятным, поэтому я написал свое. Как всегда, надеюсь, что у меня получилось раскрыть тему )





Советую вам после этого урока прочитать хелп, ссылку на который я дал в самом начале урока. Там все очень хорошо написано. И знания лучше усвоятся. Пока что, главное – это понять в какой момент, какой метод вызывается. А уже дальше мы будем разбираться, как это можно использовать и что там кодить.





Статья взята из сайта [startandroid.ru](http://startandroid.ru/)
Добрый день друзья.





Продолжаю собирать важную информацию по программированию под android.





Сегодня речь пойдет о SOAP и REST запросах.


 <!-- more -->


Одной из задач, часто решаемых разработчиками мобильного софта, является получение данных от удаленного **web сервиса**. Этот процесс включает в себя несколько этапов: отправка запрос web-сервису, получение ответа и парсинг ответа с целью получения данных. В Android нет встроенного SOAP клиента, однако существует несколько довольно неплохих сторонних библиотек. Мы не будем пользоваться чужими поделками, а разработаем собственный клиент на базе Android API.  
  
_**SOAP **(Simple Object Access Protocol) это основанный на XML протокол, предназначенный для обмена данными между распределенными приложениями.  **REST **(Representational State Transfer)- архитектура позволяющая строить распределенные, масштабируемые приложения. Основная задача сервера в этой архитектуре предоставить клиентам доступ к ресурсам по их идентификаторам (URI). Под доступом подразумевается как получение информации, так и ее изменение. SOAP и REST строятся поверх существующих web протоколов, например HTTP. Я не буду здесь вдаваться в детали, если Вы не знакомы с темой, рекомендую посмотреть вот эту [статью](http://habrahabr.ru/blogs/webdev/131343/)._  
  






### Формат запроса для SOAP сервису





Прежде чем переходить к написанию кода, давайте посмотрим на структуру SOAP.





![](http://android-helper.com.ua/images/uploads/2012/10/soap_structure.png)





Обычный** SOAP запрос** выглядит так:




	POST /InStock HTTP/1.1

	Host: www.example.org

	Content-Type: application/soap+xml; charset=utf-8

	Content-Length: length

	SOAPAction: "http://www.w3schools.com/GetItems"

 

	<?xml version="1.0"?>

	<soap:Envelope

	xmlns:soap="http://www.w3.org/2001/12/soap-envelope"

	soap:encodingStyle="http://www.w3.org/2001/12/soap-encoding">

	<soap:Header>

  	<m:Trans xmlns:m="http://www.w3schools.com/transaction/"

  	soap:mustUnderstand="1">234

	  </m:Trans>

	</soap:Header>

	<soap:Body>

  	<m:GetPrice xmlns:m="http://www.w3schools.com/prices">

    	<m:Item>Apples</m:Item>

	  </m:GetPrice>

	</soap:Body></soap:Envelope>




То есть SOAP запрос/ответ передается как пакет (SOAP Envelope), состоящий из заголовка (SOAP Header) и тела (SOAP Body).**SOAP Header** - вспомогательный  компонент, содержащий конфиденциальную информацию для приложения, например параметры  аутентификации. **SOAP Body** - это сообщение с полезной информацией. Заголовок может также содержать** SOAP Action**, который определяет функцию, запрашиваемую сервисом.  
  






### Отправка запроса SOAP-сервису





Чтобы вызвать SOAP-сервис вы должны сделать две вещи:  
**Во-первых**, вручную сконструировать SOAP пакет, например вот так:




	String envelope="<?xml version=\"1.0\" encoding=\"utf-8\"?>"+

	"<soap:Envelope xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\"xmlns:soap=\"http://schemas.xmlsoap.org/soap/envelope/\">"+

  	"<soap:Body>"+

    "<GetItems xmlns=\"http://tempuri.org/\">"+

      "<startDate>%s</ startDate>"+

      "<getAll>%s</getAll>"+

    "</Items>"+

  	"</soap:Body>"+

	"</soap:Envelope>";




где %s метка формата. С помощью метода String.format на ее место  будет подставляться конкретное значение.


	String requestEnvelope=String.format(envelope, "10-5-2011","true");



**Во-вторых**, вызвать web-сервис, например так:

	String CallWebService(String url,

    String soapAction,

   	String envelope)  {

  	final DefaultHttpClient httpClient=new DefaultHttpClient();

	  // параметры запроса

	  HttpParams params = httpClient.getParams();

     HttpConnectionParams.setConnectionTimeout(params, 10000);

     HttpConnectionParams.setSoTimeout(params, 15000);

     // устанавливаем параметры

  	HttpProtocolParams.setUseExpectContinue(httpClient.getParams(), true);

 

  	// С помощью метода POST отправляем конверт

  	HttpPost httppost = new HttpPost(url);

  	// и заголовки

     httppost.setHeader("soapaction", soapAction);

     httppost.setHeader("Content-Type", "text/xml; charset=utf-8");

 

     String responseString="";

     try {

 

      // выполняем запрос

   	HttpEntity entity = new StringEntity(envelope);

   	httppost.setEntity(entity);

 

   	// Заголоаок запроса

   	ResponseHandler<string> rh=new ResponseHandler<string>() {

    // вызывается, когда клиент пришлет ответ

    public String handleResponse(HttpResponse response)

      throws ClientProtocolException, IOException {

 

     // получаем ответ

     HttpEntity entity = response.getEntity();

 

     // читаем его в массив

           StringBuffer out = new StringBuffer();

           byte[] b = EntityUtils.toByteArray(entity);

 

           // write the response byte array to a string buffer

           out.append(new String(b, 0, b.length));

           return out.toString();

    }

   	};

 

   	responseString=httpClient.execute(httppost, rh); 

 

  	}

     catch (Exception e) {

      Log.v("exception", e.toString());

  	}

 

     // закрываем соединение

  	httpClient.getConnectionManager().shutdown();

  	return responseString;

 		}




После вызова этой функции Вы получите ответ, который будет выглядеть как-то так:


	<?xml version="1.0" encoding="utf-8"?>

	<soap:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">

  	<soap:Body>

    	<GetItemsResponse xmlns="http://tempuri.org/">

     	 <GetItemsResult>



        <Items>

          <Item>

            <name>string</name>

            <description>string</ description >

          </iPhoneCategory>

          <iPhoneCategory>

            <name>string</name>

            <description>string</ description >

          </ Item >

        </Items>

      	</GetItemsResult>

    	</ GetItemsResponse >

  	</soap:Body>

	</soap:Envelope>


Этот ответ нужно разобрать XML парсером и извлечь нужные данные.  
  






### Отправка запроса REST-сервису





Расбота с REST-сервисом намного проще. Вы должны вызвать сервис, передав ему URL с параметрами, например вот так:  
  
	http://example.com/resources/getitems  
  
Пример вызова REST сервиса:


	String callWebErvice(String serviceURL){

        // http get client

            HttpClient client=new DefaultHttpClient();

            HttpGet getRequest=new HttpGet();

 

            try {

                // создаем a URI объект

                getRequest.setURI(new URI(serviceURL));

            } catch (URISyntaxException e) {

                Log.e("URISyntaxException", e.toString());

            }

 

            // Создаем BufferedReader дял чтения ответа

            BufferedReader in=null;

            // и HttpResponse для получения ответа

            HttpResponse response=null;

            try {

                // выполняем запрос

                response = client.execute(getRequest);

            } catch (ClientProtocolException e) {

                Log.e("ClientProtocolException", e.toString());

            } catch (IOException e) {

                Log.e("IO exception", e.toString());

            }

            try {

                in=new BufferedReader(new InputStreamReader(response.getEntity().getContent()));

            } catch (IllegalStateException e) {

                Log.e("IllegalStateException", e.toString());

            } catch (IOException e) {

                Log.e("IO exception", e.toString());

            }

            StringBuffer buff=new StringBuffer("");

            String line="";

            try {

                while((line=in.readLine())!=null)

                {

                    buff.append(line);

                }

            } catch (IOException e) {

                Log.e("IO exception", e.toString());

                return e.getMessage();

            }

 

            try {

                in.close();

            } catch (IOException e) {

                Log.e("IO exception", e.toString());

            }

            // возвращаем ответ в виде строки текста

            return buff.toString();

    }




Соединение с web-сервисом по протоколу Secure Sockets Layer (SSL)  
  
HttpClinet не поддерживает SSL соединения, поэтому если Вам необходимо работать с защищенным web-сервисом, то используйте  javax.net.ssl.HttpsURLConnection. Ниже приведен пример, иллюстрирующий работу с SSL SOAP web-сервисом.


	String CallWebService(String url,

             String soapAction,

            String envelope) throws IOException  {

        URL address=new URL(url);

        URLConnection connection=address.openConnection();

        HttpsURLConnection post=(HttpsURLConnection)connection;

        post.setDoInput(true);

        post.setDoOutput(true);

        post.setRequestMethod("POST");

        post.setRequestProperty("SOAPAction", soapAction);

        post.setRequestProperty( "Content-type", "text/xml; charset=utf-8" );

        post.setRequestProperty( "Content-Length", String.valueOf(envelope.length()));

        post.setReadTimeout(4000);

 

        OutputStream outStream=post.getOutputStream();

        Writer out=new OutputStreamWriter(outStream);

        out.write(envelope);

        out.flush();

        out.close();

 

        InputStream inStream = post.getInputStream();

        BufferedInputStream in = new BufferedInputStream(inStream,4);

        StringBuffer buffer=new StringBuffer();

        // читаем за раз 4 байта

        byte[] buffArray=new byte[4];

        int c=0;

            while((c=in.read(buffArray))!=-1){

                for(int i=0;i<c;i++)

                    buffer.append((char)buffArray[i]);

            }

 

            return buffer.toString();

    }


Итак, мы отправили запрос web-сервису и получили ответ в виде строки. Настало время использовать парсер.  
  






### Использование парсера в Android





В зависимости от реализации сервиса в ответ на наш запрос может прийти ответ в формате XML, SOAP или JSON.  
  






#### Программирование XML парсера в Android





Рассмотрим конкретный пример. Допустим, нам пришел XML ответ, содержащий имя, фамилию и возраст пользователя:


	<?xml version="1.0"?>

	<person>

    <firstname>Jack</firstname>

    <lastname>smith</lastname>

    <age>28</age>

	</person>





С помощью этих параметров нужно создать объект класса Person:




	public class Person{

        public String firstName;

        public String lastName;

        public int age;

    }


### Использование DOM Parser





В библиотека **org.w3c.dom** можно найти классы, с помощью которых можно разобрать xml, создав документ и сравнив каждый узел с шаблоном. Приведенная ниже функция использует DOM парсер:



	void parseByDOM(String response) throws 	ParserConfigurationException, SAXException, IOException{

        Person person=new Person();

        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();

        DocumentBuilder db = dbf.newDocumentBuilder();

        Document doc = db.parse(new InputSource(new StringReader(response)));

        // нормализируем документ

        doc.getDocumentElement().normalize();

        // получаем корневой узел

        NodeList nodeList = doc.getElementsByTagName("person");

        Node node=nodeList.item(0);

        // узел имеет три дочерних узла

        for (int i = 0; i < node.getChildNodes().getLength(); i++) {

        Node temp=node.getChildNodes().item(i);

        if(temp.getNodeName().equalsIgnoreCase("firstname")){

            person.firstName=temp.getTextContent();

        }

        else if(temp.getNodeName().equalsIgnoreCase("lastname")){

            person.lastName=temp.getTextContent();

        }

        else if(temp.getNodeName().equalsIgnoreCase("age")){

            person.age=Integer.parseInt(temp.getTextContent());

        }

 

        }

 

        Log.e("person", person.firstName+ " "+person.lastName+" "+String.valueOf(person.age));

    }




Показаный метод работает, однако для его использования нужно знать структуру разбираемого xml и порядок перечисления узлов. Более гибок в этом плане SAX парсер.  
 





###  Использование SAX Parser





SAX Parser находится в пакете **org.xml.sax**. В процессе разбора документа SAX генерирует события, для которых программист должен написать обработчики. Создадим класс-потомок основе класса **DefaultHandler **и переопределим следующие методы:  
 








  * **startDocument()**: Этот метод вызывается при открытии XML документа.



  * **startElement(String uri, String localName, String qName, Attributes attributes)**: вызывается, когда парсер встречает XML-узел.



  * **endElement(String uri, String localName, String Name)**: вызывается, когда парсер считал закрывающий тег.



  * **characters(char[] ch, int start, int length)**: этот метод вызывается, когда парсер считывает данные из узла.






Напишем класс для парсинга нашего примера





	public class PersonParser extends DefaultHandler

	{

 

    // arraylist для сохранения объектов persons

    ArrayList persons;

    // вспомогательный объект

    Person tempPerson;

    // буфер

    StringBuilder builder;

 

    /**

     * Инициализируем arraylist

     * @throws SAXException

     */

    @Override

    public void startDocument() throws SAXException {

        pesons=new ArrayList();

 

    }

 

    /**

     * Инициализируем вспомогательный объект и буфер 

     * @param uri

     * @param localName

     * @param qName

     * @param attributes

     * @throws SAXException

     */

    @Override

    public void startElement(String uri, String localName, String qName,

            Attributes attributes) throws SAXException {

 

        if(localName.equalsIgnoreCase.equals("person")){

            tempPerson=new Person();

            builder=new StringBuilder();

        }

 

    }

    /**

     * Завершение чтения тега person и

     * добавление данных в arraylist

     * @param uri

     * @param localName

     * @param qName

     * @throws SAXException

     */

    @Override

    public void endElement(String uri, String localName, String qName)

            throws SAXException {

        // закончилось чтение person, добавим собранные данные в массив

        if(localName.toLowerCase().equals("person"))

        {

            this.persons.add(tempPerson);

        }

        // закончилось чтение  "firstname", добавим эти данные во вспомогательный объект

        else if(localName.toLowerCase().equals("firstname")){

            tempPerson.firstName=builder.toString();

        }

        // закончилось чтение  "lastname", добавим эти данные во вспомогательный объект

        else if(localName.toLowerCase().equals("lastname")){

            tempPerson.lastName=builder.toString();

        }

        // закончилось чтение  "age", добавим эти данные во вспомогательный объект

        else if(localName.toLowerCase().equals("age")){

            tempPerson.age=Integer.parseInt(builder.toString());

        }

    }

 

    /**

     * Считываем данные из каждого тега

     * @param ch

     * @param start

     * @param length

     * @throws SAXException

     */

    @Override

    public void characters(char[] ch, int start, int length)

            throws SAXException {

        // читаем символы в буфер

        String tempString=new String(ch, start, length);

         builder.append(tempString);

    }

	}



Код довольно прост. Парсер проходится по всем узлам, и в зависимости от считанного тега, вы выполняете то или иное действие. Используем этот класс:


	public ArrayList getPersons(final String response) throws 

	ParserConfigurationException, SAXException, IOException

    {

        BufferedReader br=new BufferedReader(new StringReader(response));

        InputSource is=new InputSource(br);

        PersonParser parser=new PersonParser();

        SAXParserFactory factory=SAXParserFactory.newInstance();

           SAXParser sp=factory.newSAXParser();

           XMLReader reader=sp.getXMLReader();

           reader.setContentHandler(parser);

           reader.parse(is);

           ArrayList persons=parser.persons;

 

        return persons;

 

    }




### Программирование JSON парсера в Android





Некоторые сервисы могут вернуть ответ не в виде XML, а как JSON массив:



	"persons"

	[

	{

		"person"{

			"firstName": "John",

     	"lastName": "Smith",

    	"age": 25

		}

	}

	{

		"person"{

			"firstName": "Catherine",

     	"lastName": "Jones",

     	"age": 35

		}

	}

	]





Здесь мы видим JSON массив persons, содержащий несколько JSON объектов person. На самом деле, работать с JSON намного проще, чем с XML:

	public ArrayList<Person> getMessage(String response){

        JSONObject jsonResponse;

        ArrayList<Person> arrPersons=new ArrayList<Person>;

        try {

            // получаем ответ

            jsonResponse = new JSONObject(response);

            // получаем массив

            JSONArray persons=jsonResponse.optJSONArray("persons");

            // проходимся по массиву и извлекаем персоны

            for(int i=0;i<persons.length();i++){

                // получаем объект person

                JSONObject person=persons.getJSONObject(i);

                // получаем firstname

                String firstname=person.optString("firstname");

                // получаем lastname

                String lastname=person.optString("lastname");

                // получаем age

                int age=person.optInt("age");

 

                // создаем объект и добавляем его в массив

                Person p=new Person();

                p.firstName=firstname;

                p.lastName=lastname;

                p.age=age;

                arrPersons.add(p);

            }

 

        } catch (JSONException e) {

 

            e.printStackTrace();

        }

 

        return arrPersons;

    }    



Обратите внимание, здесь мы использовали методы optJSONArray, optString, optInt вместо getString, getInt, поскольку opt-методы эти методы возвращают пустую строку или 0, если какой-то элемент не найден, в то время как get-методы генерируют исключения.





Источник статьи [mobilab.ru](http://www.mobilab.ru/androiddev/androidwebserviceclient.html)
Столкнулся с необходимостью распознавать речь на android устройстве.





Долго собирал крупицы информации, пока не нашел хорошею и полною статью





Прошу к прочтению.


<!-- more -->


Последнее время большой интерес у пользователей вызывает возможность распознавания речи в телефонах. Огромная заслуга в популяризации этого направления принадлежит компании Aple, однако Google также располагает подобными технологиями. Собственно этой теме и будет посвящена данная статья. Мы разработаем приложение, которое будет распознавать речь пользователя и воспроизводить результат с помощью голосового движка "Text To Speech" (TTS). Отметим, что распознавание происходит на серверах Google, поэтому для работы приложению необходимо разрешить использовать коммуникационные возможности. Кроме того, распознавание речи не работает на эмуляторе. Тестировать программу необходимо на реальном устройстве.





На самом деле работать с распознаванием и синтезом речи в Android очень просто. Все сложные вычисления скрыты от нас в довольно элегантную библиотеку с простым API. Вы сможете осилить этот урок, даже если имеете весьма поверхностные знания о программировании для Android.





Давайте создадим новый проект в Eclipse. Для наших нужд понадобится версия SDK не меньше 8. Опишем в общих чертах создаваемую программу. При запуске приложения пользователю будет показана кнопка, после нажатия на которую пользователю будет предложено надиктовать фразу. Затем будет осуществлено распознавание и будет показан список возможных вариантов. Поскольку технологии распознавания речи далеки от совершенства, программа не может ручаться за точность результата, именно поэтому будет предложено несколько вариантов. После того, как пользователь выберет один из них, будет запущен генератор голоса, который воспроизведет выбранную фразу. 





Нам понадобится несколько текстовых строк, объявим их в фале "res/values/strings.xml"





	<resources>

    <string name="intro">Press the button to speak!</string>

    <string name="app_name">SpeechRepeat</string>

    <string name="speech">Speak now!</string>

    <string name="word_intro">Suggested words&#8230;</string>

	</resources>







Откроем файл "res/layout/main.xml" и зададим шаблон дизайна приложения. Для этого переключимся из графического в XML редактор и изменим содержимое файла





	<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"

    android:layout_width="fill_parent"

    android:layout_height="fill_parent"

    android:orientation="vertical"

    android:background="#ff330066"

    android:paddingBottom="5dp" >

 

	</LinearLayout>







Добавим в Linear Layout элемент Text View






	<TextView android:layout_width="fill_parent"

    android:layout_height="wrap_content"

    android:text="@string/intro"

    android:padding="5dp"

    android:textStyle="bold"

    android:textSize="16dp"

    android:gravity="center"

    android:textColor="#ffffff33" />







обратите внимание, TextView ссылается на строку intro, которую мы задали в файле strings.xml. 





После Text View добавим кнопку





	<Button android:id="@+id/speech_btn"

    android:layout_width="match_parent"

    android:layout_height="wrap_content"

    android:text="@string/speech" />








Пользователь будет нажимать эту кнопку, чтобы начать говорить. Кнопка имеет параметр id, через который ее можно вызвать из Java кода. После нажатия на кнопку пользователю показывается сообщение. Нам также понадобится TextView для вывода слов с предложениями






	<TextView android:layout_width="fill_parent"

    android:layout_height="wrap_content"

    android:padding="5dp"

    android:text="@string/word_intro"

    android:textStyle="italic" />






TextView будет использовать строковый ресурс. Нам также понадобится список для вариантов слов







	<ListView android:id="@+id/word_list"

    android:layout_width="fill_parent"

    android:layout_height="0dip"

    android:layout_weight="1"

    android:paddingLeft="10dp"

    android:paddingTop="3dp"

    android:paddingRight="10dp"

    android:paddingBottom="3dp"

    android:layout_marginLeft="20dp"

    android:layout_marginRight="20dp"

    android:layout_marginTop="5dp"

    android:layout_marginBottom="5dp"

    android:background="@drawable/words_bg" />







ListView будет заполняться данными в процессе работы программы, поэтому для доступа к этому компоненту также требуется ID. Обратите также внимание на наличие ресурса drawable. Вы должны сохранить файл words_bg.xml в папке res




	<shape xmlns:android="http://schemas.android.com/apk/res/android"

    android:dither="true">

    <gradient

    android:startColor="#ff000000"

    android:endColor="#ff000000"

    android:centerColor="#00000000"

    android:angle="180" />

    <corners android:radius="10dp" />

    <stroke

    android:width="2dp"

    android:color="#66ffffff" />

	</shape> 







Ничего особенного. Вы можете настроить дизайн ListView по своему усмотрению. Нам осталось задать еще один элемент пользовательского интерфейса - шаблон для элемента ListView. Создайте новый файл res/layout/word.xml со следующим содержанием





	<TextView xmlns:android="http://schemas.android.com/apk/res/android"

    android:layout_width="fill_parent"

    android:layout_height="fill_parent"

    android:gravity="center"

    android:padding="5dp"

    android:textColor="#ffffffff"

    android:textSize="16dp" >

	</TextView>







Таким образом, каждый элемент списка представляет собой просто Text View.





Если Вы все сделали правильно, то при запуске должно получиться следующее





![](http://android-helper.com.ua/images/uploads/2012/10/speechsample1.jpg)




### Программируем распознавание речи в Android





После того, как шаблон будущего приложения создан, можно перейти к кодированию. Откройте java файл главной Activity и добавьте в начало файла





	import java.util.ArrayList;

	import java.util.List;

	import java.util.Locale;

 

	import android.app.Activity;

	import android.content.Intent;

	import android.content.pm.PackageManager;

	import android.content.pm.ResolveInfo;

	import android.os.Bundle;

	import android.speech.RecognizerIntent;

	import android.speech.tts.TextToSpeech.OnInitListener;

	import android.speech.tts.TextToSpeech;

	import android.util.Log;

	import android.view.View;

	import android.view.View.OnClickListener;

	import android.widget.AdapterView;

	import android.widget.AdapterView.OnItemClickListener;

	import android.widget.ArrayAdapter;

	import android.widget.Button;

	import android.widget.ListView;

	import android.widget.Toast;

	import android.widget.TextView;






Изменим немного декларацию главного класса






	public class SpeechRepeatActivity extends Activity implements OnClickListener, OnInitListener {





OnInitListener необходим для работы TTS движка. Внутри класса добавим объявления переменных перед методом onCreate







	//переменная для проверки возможности

	//распознавания голоса в телефоне

	private static final int VR_REQUEST = 999;

 

	//ListView для отображения распознанных слов

	private ListView wordList;

 

	//Log для вывода вспомогательной информации

	private final String LOG_TAG = "SpeechRepeatActivity";

	//***здесь можно использовать собственный тег***

 

	//переменные для работы TTS 

 

	//переменная для проверки данных для TTS 

	private int MY_DATA_CHECK_CODE = 0;

 

	//Text To Speech интерфейс

	private TextToSpeech repeatTTS;



Внутри метода onCreate автоматически сгенерирован код, вызывающий метод родительского класса и устанавливающий главный контекст вывода.




	//вызов суперкласса

	super.onCreate(savedInstanceState);

	//установка контекста вывода

	setContentView(R.layout.main);








Cоздадим переменные для работы с кнопкой и списком распознанных слов



	Button speechBtn = (Button) findViewById(R.id.speech_btn);

	wordList = (ListView) findViewById(R.id.word_list);








Далее необходимо проверить поддерживается ли возможность распознавания голоса телефоном


	//проверяем, поддерживается ли распознование речи

	PackageManager packManager = getPackageManager();

	List<ResolveInfo> intActivities = packManager.queryIntentActivities(new 

        Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH), 0);

	if (intActivities.size() != 0) {

    // распознавание поддерживается, будем отслеживать событие щелчка по кнопке

    speechBtn.setOnClickListener(this);

	}

	else

	{

    // распознавание не работает. Заблокируем 

    // кнопку и выведем соответствующее 

    // предупреждение.

    speechBtn.setEnabled(false);

    Toast.makeText(this, "Oops - Speech recognition not supported!", Toast.LENGTH_LONG).show();

	}








Мы запрашиваем среду, поддерживается ли Recognizer Intent. Если поддерживается, мы говорим приложению, что нужно отслеживать щелчок пользователя по кнопке. Если интент не поддерживается, мы блокируем кнопку и выводим соответствующее сообщение пользователю.





Напишем код, обрабатывающий нажатие на кнопку. Внутри класса после метода OnCreate добавим метод OnClick.






	public void onClick(View v) {

    if (v.getId() == R.id.speech_btn) {

        // отслеживаем результат

        listenToSpeech();

    }

	}







Как видите, при нажатии на кнопку мы вызываем метод listenToSpeech().



	private void listenToSpeech() {

 

    //запускаем интент, распознающий речь и передаем ему требуемые данные

    Intent listenIntent = new Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH);

    //указываем пакет

 	listenIntent.putExtra(RecognizerIntent.EXTRA_CALLING_PACKAGE, 

           getClass().getPackage().getName());

    //В процессе распознования выводим сообщение

    listenIntent.putExtra(RecognizerIntent.EXTRA_PROMPT, "Say a word!");

    //устанавливаем модель речи

    	listenIntent.putExtra(RecognizerIntent.EXTRA_LANGUAGE_MODEL, 

            RecognizerIntent.LANGUAGE_MODEL_FREE_FORM);

    //указываем число результатов, которые могут быть получены

    listenIntent.putExtra(RecognizerIntent.EXTRA_MAX_RESULTS, 10);

 

    //начинаем прослушивание

    startActivityForResult(listenIntent, VR_REQUEST);

	}





Большая часть приведенного кода стандартна для программ, использующих распознавание голоса. Обратите внимание на параметр EXTRA_PROMPT. Он задает строку-приглашение для пользователя. Параметр EXTRA_MAX_RESULTS определяет максимальное число вариантов распознавания. В конце концов, мы вызываем startActivityForResult. Результат его работы будет передан в метод onActivityResult.





На следующем скриншоте показан экран в момент распознавания речи.





![](http://android-helper.com.ua/images/uploads/2012/10/speechsample2.jpg)





Определим метод onActivityResult



	@Override

	protected void onActivityResult(int requestCode, int resultCode, Intent data) {

    //проверяем результат распознавания речи

    if (requestCode == VR_REQUEST && resultCode == RESULT_OK)

    {

        //Добавляем распознанные слова в список результатов

        ArrayList<String> suggestedWords = 

                 data.getStringArrayListExtra(RecognizerIntent.EXTRA_RESULTS);

        //Передаем список возможных слов через ArrayAdapter компоненту ListView  

        wordList.setAdapter(new ArrayAdapter<String> (this, R.layout.word, suggestedWords));

    }

 

    //tss код здесь

 

    //вызываем метод родительского класса

    super.onActivityResult(requestCode, resultCode, data);

	}





Обратите внимание, при проверке результата мы сравниваем переменную requestCode с константой VR_REQUEST, которую использовали ранее при вызове метода startActivityForResult. Таким образом, мы рассматриваем только результаты от нашего запроса. В метод возвращается 10 вариантов распознанных слов, которые мы записываем в список ArrayList. Этот список мы используем в ArrayAdapter компонента List View. 





Если приложение справилось с задачей и смогло что-то распознать, вы увидите похожий н показанный на левом скриншоте результат. Если приложению не удалось распознать фразу, будет показано сообщение, как на правом скриншоте





![](http://android-helper.com.ua/images/uploads/2012/10/speechsample3.jpg)
![](http://android-helper.com.ua/images/uploads/2012/10/speechsample4.jpg)



Вот, собственно и все. Распознавание голоса в Android - довольно простая задача. Мы вызываем интент RecognizerIntent с требуемыми нами параметрами. Результат  возвращается в onActivityResult.





### Генерация речи в Android





Перейдем ко второй части нашего приложения, связанного с генерацией речи. Мы хотим, чтобы телефон проговаривал фразу из списка результатов. Мы должны определить строку, на которую щелкнул пользователь. Вернемся к методу onCreate и добавим в конец этого метода код




	//засекаем щелчок пользователя по слову из списка

	wordList.setOnItemClickListener(new OnItemClickListener() {

 

    //метод вызывается в ответ на щелчок по слову

    public void onItemClick(AdapterView<?> parent, View view, int position, long id)

    {

        //записываем в переменную TextView строки

        TextView wordView = (TextView)view;

        //получаем строку с текстом

        String wordChosen = (String) wordView.getText();

        //выводим ее в лог для отладки

        Log.v(LOG_TAG, "chosen: "+wordChosen);

        //выводим Toast сообщение

        Toast.makeText(SpeechRepeatActivity.this, "You said: "+wordChosen, 

                Toast.LENGTH_SHORT).show();

    }

	});





Мы используем метод setOnItemClickListener чтобы установить отслеживание щелчков для каждой строки. Внутри нового объекта OnItemClickListener мы описали метод onItemClick, который вызывается в ответ на щелчок по строке списка. Выбранная строка передается, как View в этот метод. Поскольку при проектировании шаблона приложения мы указали, что наш список состоит из TextView, мы преобразуем полученное значение в объект TextView и достаем из него строковое значение. Мы записываем это слово в лог и показываем пользователю Toast сообщение.





Если Вас не интересует процесс генерации речи, Вы можете остановиться и протестировать приложение. 





Для генерации речи необходимо настроить движок TTS. Добавим код в конец метода onCreate



	//подготовка движка TTS для проговаривания слов

	Intent checkTTSIntent = new Intent(); 

	//проверка наличия TTS 

	checkTTSIntent.setAction(TextToSpeech.Engine.ACTION_CHECK_TTS_DATA); 

	//запуск checkTTSIntent интента

	startActivityForResult(checkTTSIntent, MY_DATA_CHECK_CODE); 





Как и в случае распознавания, результат интента возвращается в метод onActivityResult. В этом методе перед строкой super.onActivityResult(requestCode, resultCode, data); добавьте





	//returned from TTS data check

	if (requestCode == MY_DATA_CHECK_CODE)

	{ 

    //все необходимые приложения установлены, создаем TTS 

    if (resultCode == TextToSpeech.Engine.CHECK_VOICE_DATA_PASS) 

        repeatTTS = new TextToSpeech(this, this); 

    //движок не установлен, предположим пользователю установить его

    else

    { 

        //интент, перебрасывающий пользователя на страницу TSS в Google Play

        Intent installTTSIntent = new Intent(); 

        installTTSIntent.setAction(TextToSpeech.Engine.ACTION_INSTALL_TTS_DATA); 

        startActivity(installTTSIntent); 

    } 

	}






Таким образом, мы проверяем наличие TTS движка, и если он не установлен - предлагаем пользователю установить соответствующую программу. 





Чтобы завершить настройку TTS, добавим метод onInit, который вызывается при успешной инициализации TTS.







	public void onInit(int initStatus) {

    if (initStatus == TextToSpeech.SUCCESS)  

        repeatTTS.setLanguage(Locale.UK); //Язык

	}







Здесь мы устанавливаем язык генератора речи.





Для того, чтобы заставить движок проговорить строку, нужно вызвать метод repeatTTS.speak. Вернемся к методу onCreate. Внутри метода onItemClick после строки Toast.makeText(SpeechRepeatActivity.this, "You said: "+wordChosen, Toast.LENGTH_SHORT).show(); добавьте следующий код






	repeatTTS.speak("You said: "+wordChosen, TextToSpeech.QUEUE_FLUSH, null);




Таким образом, одновременно с Toast сообщением пользователь услышит сгенерированную речь. Отметим еще раз, что эмулятор не поддерживает распознавание речи, поэтому тестировать программу необходимо на телефоне.





Полный проект вы можете скачать на [странице с кодами](http://android-helper.com.ua/codes/).





Статья взята из сайта [mobilab.ru](http://www.mobilab.ru/androiddev/androidspeechrecognition.html)
Добрый день друзья.





Много уже работал с базами данных.





Но ни как не мог подготовить статью на эту тему.





Сегодня я ее нашел хорошею статью. И покажу ее вам.

<!-- more -->



По умолчанию в Android используется база данных SQLite - это довольно популярная, легкая и быстрая реляционная база данных. Если для вас SQL – это пустой звук, то, скорее всего, вы мало что поймете из этой статьи. Предполагается, что читатель знаком с SQL, знает что такое запросы выборки, триггеры и представления. Если это не так - почитайте какое-нибудь введение в SQL, а потом возвращайтесь сюда.  
  
База данных SQLite  имеет некоторые особенности, о которых нужно помнить:








  * Не поддерживается проверка типов данных. Это значит, что Вы случайно сможете записать данные не того типа, например поместить строку в колонку, предназначенную для целых чисел.



  * Не поддерживается ссылочная целостность:  нет поддержки FOREIGN KEY и конструкций JOIN.



  * Полная поддержка Unicode отключена по умолчанию.






  
Давайте создадим простую базу данных, содержащую информацию о работниках. База содержит две таблицы:  Employees - для хранения данных о сотрудниках и Dept - о департаментах. И представление ViewEmps, связывающее работников с департаментами.





![](http://android-helper.com.ua/images/uploads/2012/10/android_db_sql.jpg)




## Создание SQLite базы данных в Android проекте





По умолчанию, Android не содержит удобных СУБД для создания и работы с базами данных (есть sqlite3.exe - консоль для работы с базой данных), поэтому давайте создадим базу и все необходимые таблицы непосредственно из кода.   
  
Во-первых, мы напишем класс, который будет управлять всеми операциями с базой данных: созданием базы, созданием таблиц, вставкой и удалением записей. Давайте создадим класс потомок от **SQLiteOpenHelper**. Нам нужно переопределить два метода:








  * onCreate(SQLiteDatabase db) - вызывается при создании базы данных. Здесь мы можем создать таблицы, определить в них колонки, создать виды и триггеры.



  * onUpgrade(SQLiteDatabse db, int oldVersion, int newVersion) - вызывается, при внесении изменений в базу, например при создании и удалении таблиц






  
Внутри нашего класса определим переменные





	public class DatabaseHelper extends SQLiteOpenHelper {

 

 	static final String dbName="demoDB";

 	static final String employeeTable="Employees";

 	static final String colID="EmployeeID";

 	static final String colName="EmployeeName";

 	static final String colAge="Age";

 	static final String colDept="Dept";

 

 	static final String deptTable="Dept";

 	static final String colDeptID="DeptID";

 	static final String colDeptName="DeptName";

 

 	static final String viewEmps="ViewEmps";

 

 	// и создадим конструктор

 

	public DatabaseHelper(Context context) {

  	super(context, dbName, null,33);

		}

	}


Как видите, здесь мы просто вызываем конструктор суперкласса, который имеет четыре параметра:








  * **Context **- контекст, связанный с базой данных.



  * **dataBaseName **- имя базы данных.



  * **CursorFactory** - можно использовать класс, созданный на основе класса Cursor. Это позволяет проводить некоторые дополнительные проверки и операции с результатами запросов. Если сюда подставить ссылку на наш класс, он будет использоваться вместо стандартного курсора. Мы не будем работать с  **CursorFactory**, поэтому передадим значение null.



  * **Version**- версия базы данных. Смысл этого параметра будет раскрыт ниже






## Создание базы данных





Давайте переопределим метод **onCreate**


	public void onCreate(SQLiteDatabase db) {

  	// TODO Auto-generated method stub

 

  	db.execSQL("CREATE TABLE "+deptTable+" ("+

        colDeptID+ " INTEGER PRIMARY KEY , "+

        colDeptName+ " TEXT)");

 

  	db.execSQL("CREATE TABLE "+employeeTable+

        " ("+colID+" INTEGER PRIMARY KEY AUTOINCREMENT, "+

        colName+" TEXT, "+colAge+" Integer, "+colDept+

        " INTEGER NOT NULL ,FOREIGN KEY ("+colDept+")

        REFERENCES "+deptTable+" ("+colDeptID+"));");

 

 	 db.execSQL("CREATE TRIGGER fk_empdept_deptid " +

    " BEFORE INSERT "+

    " ON "+employeeTable+

 

    " FOR EACH ROW BEGIN"+

    " SELECT CASE WHEN ((SELECT "+colDeptID+" FROM "+

    deptTable+" WHERE "+colDeptID+"=new."+colDept+" ) IS NULL)"+

    " THEN RAISE (ABORT,'Foreign Key Violation') END;"+

    "  END;");

 

  	db.execSQL("CREATE VIEW "+viewEmps+

    " AS SELECT "+employeeTable+"."+colID+" AS _id,"+

    " "+employeeTable+"."+colName+","+

    " "+employeeTable+"."+colAge+","+

    " "+deptTable+"."+colDeptName+""+

    " FROM "+employeeTable+" JOIN "+deptTable+

    " ON "+employeeTable+"."+colDept+" ="+deptTable+"."+colDeptID

    );

 	 //Inserts pre-defined departments

  	InsertDepts(db);

 	}


Внутри метода мы с помощью SQL запросов создаем таблицы, триггеры и представления. Запросы вызываются для базы db с помощью метода **execSQL**.  
   
Метод **onCreate  **вызывается при создании базы данных, как только база создана, мы добавляем туда таблицы с необходимым набором полей. Вызов метода происходит, когда база данных не существует на диске, то есть для данного конкретного устройства этот метод будет вызван всего один раз, сколько бы мы потом не запускали нашу программу.  
 





##  Изменение базы данных





   
Иногда возникает необходимость внести изменения в базу данных: поменять схему, добавить новые таблицы или поменять типы столбцов таблиц. Все это можно сделать внутри метода **onUpdate(SQLiteDatabase db,int old Version,int newVerison)** .




	public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {

  	// TODO Auto-generated method stub

 

  	db.execSQL("DROP TABLE IF EXISTS "+employeeTable);

  	db.execSQL("DROP TABLE IF EXISTS "+deptTable);

 

  	db.execSQL("DROP TRIGGER IF EXISTS dept_id_trigger");

  	db.execSQL("DROP TRIGGER IF EXISTS dept_id_trigger22");

  	db.execSQL("DROP TRIGGER IF EXISTS fk_empdept_deptid");

  	db.execSQL("DROP VIEW IF EXISTS "+viewEmps);

  	onCreate(db);

 	}




Этот метод вызывается, когда изменяется номер, указанный в конструкторе класса. Помните то загадочное число 33, внутри конструктора **DatabaseHelper**? Если Вам вдруг понадобится внести изменение в свою базу, просто поменяйте номер в конструкторе. То есть, если вы измените конструктор


	public DatabaseHelper(Context context) {

  	super(context, dbName, null,34);

 	}




приложение поймет, что вы хотите изменить свою базу и вызовет метод onUpgrade. Обычно внутри этого метода удаляются таблицы и создаются заново с другим набором полей.   
 





##  Управление внешними ключами





Давайте создадим триггер, который будет следить при добавлении нового сотрудника за тем, чтобы указанный в описании сотрудника департамент присутствовал в таблице Dept.   
   
 SQL команда, создающая такой триггер, выглядит следующим образом:





	CREATE TRIGGER fk_empdept_deptid Before INSERT ON Employees

	FOR EACH ROW BEGIN

    SELECT CASE WHEN ((SELECT DeptID FROM Dept WHERE DeptID =new.Dept ) IS NULL)

    THEN RAISE (ABORT,'Foreign Key Violation') END;

    END

 

Добавим в метод onCreate вызов метода execSQL с соответствующим запросом:

	db.execSQL("CREATE TRIGGER fk_empdept_deptid " +

    " BEFORE INSERT "+

    " ON "+employeeTable+

 

    " FOR EACH ROW BEGIN"+

    " SELECT CASE WHEN ((SELECT "+colDeptID+" FROM "+deptTable+

    " WHERE "+colDeptID+"=new."+colDept+" ) IS NULL)"+

    " THEN RAISE (ABORT,'Foreign Key Violation') END;"+

    "  END;");


# Выполнение SQL команд в Android





 Как уже было отмечено выше, Вы можете выполнить любую SQL команду с помощью метода **db.execSQL(String statement)**.   
 





##  Добавление записи в таблицу





 Можно добавить новую запись в таблицу с помощью SQL команды **INSERT**, а можно воспользоваться методом **db.insert**:



	SQLiteDatabase db=this.getWritableDatabase();

	ContentValues cv=new ContentValues();

  	cv.put(colDeptID, 1);

  	cv.put(colDeptName, "Sales");

  	db.insert(deptTable, colDeptID, cv);

 		
	cv.put(colDeptID, 2);

  	cv.put(colDeptName, "IT");

  	db.insert(deptTable, colDeptID, cv);

  	db.close();



Обратите внимание, для соединения с базой данных мы вызвали метод **this.getWritableDatabase()**. Класс **ContentValues** позволяет создать карту с параметрами ключ-значение. Эта карта затем используется методом **insert**, который фактически добавляет запись в таблицу. Метод **ContentValues.put** создает пару ключ-значение. Еще одно замечание, хорошим тоном считается закрывать базу данных вызовом метода  **close()** после завершения выполнения группы команд.  
  






## Изменение значений в таблице





Изменить значение в какой-либо записи можно с помощью SQL команды **UPDATE **или с помощью метода  **db.update**:


	public int UpdateEmp(Employee emp)

  	{

   	SQLiteDatabase db=this.getWritableDatabase();

   	ContentValues cv=new ContentValues();

   	cv.put(colName, emp.getName());

   	cv.put(colAge, emp.getAge());

   	cv.put(colDept, emp.getDept());

   	return db.update(employeeTable, cv, colID+"=?", new String []{String.valueOf(emp.getID())});

  	}


Метод update имеет следующие параметры: 








  * **String Table**: название таблицы в которой мы хотим что-то изменить.



  * **ContentValues cv**: пара ключ-значение с новой информацией.



  * **String where**: строка-шаблон, определяющая условие  WHERE, которое проверяется для каждой строки таблицы. Ксли условие истинно, то в этой строке обновляется информация в соответствии с параметром cv.



  * **String[] args**: массив с аргументами, которые подставляются в строку-шаблон where.






## Удаление строк





Удалить строку в таблице можно с помощью SQL команды **DELETE**, а также с помощью метода **db.delete**. Этот метод имеет аналогичный  **update **набор параметров (за исключением cv).



	public void DeleteEmp(Employee emp)

  	{

   	SQLiteDatabase db=this.getWritableDatabase();

   	db.delete(employeeTable,colID+"=?", new String [] {String.valueOf(emp.getID())});

   	db.close();

  	}



## Выполнение SQL запросов





 Для выполнения запросов в Android используются два метода: **db.rawQuery** и **db.query**. Давайте сделаем запрос к базе, с целью получения списка всех департаментов:




	Cursor getAllDepts()

  	{

   	SQLiteDatabase db=this.getReadableDatabase();

   	Cursor cur=db.rawQuery("SELECT "+colDeptID+" as _id, "+

   	colDeptName+" from "+deptTable,new String [] {});

 

   	return cur;

  	}





 Метод **rawQuery** имеет два параметра:








  * **String query**: Строка с SQL запросом SELECT.



  * **String[] selection args**: массив аргументов where, если он используется в SELECT запросе.






  
**Замечания!** В качестве результата этого запроса возвращается объект **Cursor**. Если в качестве ключевого поля в таблице используется колонка с именем, отличным от** _id**, Вам необходимо использовать alias в форме "SELECT [Column Name] as _id". Дело в том, что объект **Cursor** всегда считает, что ключевое поле имеет имя **_id**, и если это не так, генерируется исключение.  
  
Другим способом выполнения запроса к базе является вызов метода **db.query**. Давайте напишем метод, который выдает всех сотрудников, работающих в каком-то конкретном департаменте:



	public Cursor getEmpByDept(String Dept)

  	{

   	SQLiteDatabase db=this.getReadableDatabase();

   	String [] columns=new String[]{"_id",colName,colAge,colDeptName};

   	Cursor c=db.query(viewEmps, columns, colDeptName+"=?", new String[]{Dept}, null, null, null);

   	return c;

  	}


Метод **db.query** имеет следующий набор параметров:








  * **String Table Name**: Имя таблицы, из которой осуществляется выборка.



  * **String [ ] columns**: список столбцов, которые войдут в результат.



  * **String WHERE clause**: шаблон where-условия или null.



  * **String [ ] selection args**: массив с аргументами where-условия.



  * **String Group by**: условие группировки.



  * **String Having**: условие HAVING.



  * **String Order By by**: порядок сортировки.






##  Управление объектом Cursor





В результате выполнения запросов нам возвращается объект **Cursor**, содержащий таблицу с результатами запроса. **Cursor**предполагает последовательную работу со строками результата. В каждый момент времени активна одна строка, на которую ссылается указатель. Ниже перечислены методы, которые используются для работы с этим объектом:








  * **boolean moveToNext()**- перемещает указатель на одну запись вперед. Возвращает false, если достигнут конец таблицы результата.



  * **boolean moveToFirst()**- перемещает указатель на первую строку. Возвращает false, если таблица-результат не содержит строк.



  * **boolean moveToPosition(int position)** - перемещает указатель на конкретную строку в таблице результатов. Если строки с таким номером нет - возвращает false.



  * **boolean moveToPrevious()**- перемещает указатель на одну запись назад. Возвращает false, если достигнуто начало таблицы результата.



  * **boolean moveToLast()**- перемещает указатель на последнюю строку. Возвращает false, если таблица-результат не содержит строк.



  * **int  getColumnIndex(String column)** - возвращает ссылку на колонку column в текущей строке. Для получения значения по ссылке используются методы **Cursor.getInt(int ColumnIndex), getShort,getString,getDouble, getBlob**. 






  
Для определение текущей позиции указателя можно воспользоваться методами:**boolean isAfterLast(), isBeforeFirst, isFirst, isLast и isNull(columnIndex)**. Их назначение без труда можно понять из названий.  
  
Если в результате выполнения запроса вы получили только одну строку, то извлечь из нее значения столбцов можно следующим образом:





	public int GetDeptID(String Dept)

  	{

  	SQLiteDatabase db=this.getReadableDatabase();

   	Cursor c=db.query(deptTable, new String[]{colDeptID+" as _id",colDeptName},colDeptName+"=?",

   	new String[]{Dept}, null, null, null);

   	c.moveToFirst();

   	return c.getInt(c.getColumnIndex("_id"));

  	}




В результате выполнения этого метода, мы получим значение колонки _id текущей строки.  После использования курсора его хорошо бы закрыть с помощью метода **close()**.  
   
 Вот собственно и все. Теперь вы вполне сможете использовать базы данных в своих Android проектах.





Если вам понравилась статья, пишите комментарии и рассказывайте друзьям.
Добрый день друзья.





Я продолжаю сбор интересной информации.





И сегодня я нашел статью о работе с ListFragment.





Прошу к прочтению.

<!-- more -->



Вернемся к фрагментам. В Android есть несколько полезных классов – наследников класса Fragment. Мы рассмотрим несколько из них. Начнем с [ListFragment](http://developer.android.com/reference/android/app/ListFragment.html). В принципе, это просто Fragment, в котором есть методы, упрощающие доступ к ListView и некоторым его операциям.





Тут можно провести аналогию - для Activity есть класс наследник [ListActivity](http://developer.android.com/reference/android/app/ListActivity.html). Когда мы только знакомились со списками, я не стал рассматривать этот класс, чтобы не вносить путаницы в непростую тему. Но в учебниках и хелпе о нем обычно говорят. Думаю, многие уже сталкивались с ним и примерно знают, что это такое. Если да, то ListFragment будет совсем прост для понимания.





Напишем приложение и рассмотрим основные возможности ListFragment.





Создадим класс фрагмента, наследующий не android.app.Fragment как обычно, а android.app.ListFragment.





**MainList.java**:

	import android.app.ListFragment;



	public class MainList extends ListFragment {



	}







Класс так и оставляем пока пустым. И пока что не будем создавать Layout-файл для этого фрагмента. Дело в том, что ListFragment по умолчанию уже содержит ListView и мы вполне можем обойтись им. Адаптер мы пока также никакой не создаем, посмотрим чего получится.





Редактируем layout для MainActivity





**main.xml**:


	<?xml version="1.0" encoding="utf-8"?>

	<LinearLayout

 	xmlns:android="http://schemas.android.com/apk/res/android"

 	xmlns:tools="http://schemas.android.com/tools"

 	android:id="@+id/LinearLayout1"

 	android:layout_width="match_parent"

 	android:layout_height="match_parent"

 	android:orientation="vertical">

	<fragment android:name="ru.startandroid.develop.p1091listfragment.MainList"

	android:layout_width="match_parent"

 	android:layout_height="match_parent">

	</fragment>

	</LinearLayout>







Здесь только компонент fragment, использующий наш класс.





Все сохраняем, запускаем приложение.





![](http://android-helper.com.ua/images/uploads/2012/10/L0109_010.jpg)




ListFragment показывает нам, что он ждет данных. 





Ок, давайте дадим ему данные. Перепишем **MainList.java**:



	import android.app.ListFragment;

	import android.os.Bundle;

	import android.widget.ArrayAdapter;



	public class MainList extends ListFragment {



  	String data[] = new String[] { "one", "two", "three", "four" };



  	@Override

  	public void onActivityCreated(Bundle savedInstanceState) {

    super.onActivityCreated(savedInstanceState);

    ArrayAdapter<String> adapter = new ArrayAdapter<String>(getActivity(),

        android.R.layout.simple_list_item_1, data);

    setListAdapter(adapter);

  	}



	}








Мы создаем адаптер и используем метод [setListAdapter](http://developer.android.com/reference/android/app/ListFragment.html#setListAdapter(android.widget.ListAdapter)), чтобы передать его списку. Обратите внимание - мы даже не создаем или не находим (findViewById) список (ListView), он уже есть где-то внутри фрагмента и метод setListAdapter сам знает, как до него добраться. В принципе, это и есть основная фишка ListFragment - нам не надо работать с ListView.





Все сохраним, запустим приложение.





![](http://android-helper.com.ua/images/uploads/2012/10/L0109_0201.jpg)



Данные появились.





Еще раз обращаю ваше внимание на то, что мы вообще не создавали никаких layout с ListView. ListFragment работает с каким-то своим, встроенным списком. 





Если же вас чем-то не устраивает этот дефолтный список, можно использовать свой layout-файл для фрагмента.





В **strings.xml** добавим строки


	<string name="number_list">Список чисел</string>

	<string name="empty">Нет данных</string>








И создадим layout файл **fragment.xml**:



	<?xml version="1.0" encoding="utf-8"?>

	<LinearLayout

 	xmlns:android="http://schemas.android.com/apk/res/android"

 		android:layout_width="match_parent"

 		android:layout_height="match_parent"

 		android:orientation="vertical">

		<TextView

 			android:layout_width="wrap_content"

 			android:layout_height="wrap_content"

 			android:text="@string/number_list">

		</TextView>

	<ListView

		 android:id="@id/android:list"

		 android:layout_width="match_parent"

		 android:layout_height="match_parent">

	</ListView>

	<TextView

		 android:id="@id/android:empty"

		 android:layout_width="match_parent"

		 android:layout_height="match_parent"

		 android:gravity="center"

		 android:text="@string/empty">

	</TextView>

	</LinearLayout>








Первый TextView – просто заголовок списка. Далее идет ListView. Его ID обязательно должен быть равен **@id/android:list**. Чтобы ListFragment сам его нашел и мог с ним работать. Второй TextView – будет показан, если нет данных для списка. Его ID обязательно должен быть равен **@id/android:empty**.





Допишем в **MainList.java** метод создания View.





	@Override

 	public View onCreateView(LayoutInflater inflater, ViewGroup container,

      Bundle savedInstanceState) {

    return inflater.inflate(R.layout.fragment, null);

 	 }







Фрагмент будет отображать компоненты из layout-файла, который мы только что создавали.





Все сохраняем и запускаем.





![](http://android-helper.com.ua/images/uploads/2012/10/L0109_030.jpg)





Видим заголовок и данные. Наш layout был использован.





Если не дать списку данные, то приложение будет выглядеть так





![](http://android-helper.com.ua/images/uploads/2012/10/L0109_040.jpg)





Отобразился наш второй TextView с ID = @id/android:empty. Причем, это вовсе не обязательно должен быть TextView. Главное тут именно этот ID. Компонент с этим ID будет показан вместо ListView, если нет данных.





Чтобы включать одиночный и множественный выбор, необходимо провести все те же действия, которые мы рассматривали в Уроке 43: передать в адаптер соответствующий layout-файл и включить соответствующий режим выбора для списка. В этом же 43-м Уроке можно посмотреть, как определять, какие пункты списка выбраны. Чтобы в ListFragment получить доступ к списку – используйте метод [getListView](http://developer.android.com/reference/android/app/ListFragment.html#getListView()).





Результаты включения режима выбора будут такие:





одиночный выбор





![](http://android-helper.com.ua/images/uploads/2012/10/L0109_050.jpg)





множественный выбор





![](http://android-helper.com.ua/images/uploads/2012/10/L0109_060.jpg)




Еще, как вариант, можно в адаптер передавать layout-файл **android.R.layout.simple_list_item_activated_1**.





В этом случае результаты будут такие:





![](http://android-helper.com.ua/images/uploads/2012/10/L0109_070.jpg)




![](http://android-helper.com.ua/images/uploads/2012/10/L0109_080.jpg)





Это хорошо подходит для случая, когда у вас на экране слева фрагмент-список, а справа фрагмент-содержимое и вы всегда видите какой именно пункт из списка сейчас просматриваете.





Чуть не забыл про самое главное )  Ловить нажатия можно в методе [onListItemClick](http://developer.android.com/reference/android/app/ListFragment.html#onListItemClick(android.widget.ListView, android.view.View, int, long)). 





Если добавим в MainList.java его реализацию:





	public void onListItemClick(ListView l, View v, int position, long id) {

    super.onListItemClick(l, v, position, id);

    Toast.makeText(getActivity(), "position = " + position, Toast.LENGTH_SHORT).show();

 	 }








то при нажатии на пункт списка, увидим результат:





![](http://android-helper.com.ua/images/uploads/2012/10/L0109_090.jpg)





Статья взята из сайта [startandroid.ru](http://startandroid.ru/uroki/vse-uroki-spiskom/179-urok-109-android-3-fragments-listfragment-spisok.html)





Если вам понравилась статья, пишите ваши комментарии.





Если у вас есть интересные примеры решения, пишите мне и я буду их публиковать на блоге.





Полный проект вы можете скачать на [странице с кодами](http://android-helper.com.ua/codes/).
Добрый день друзья.





Нашел сегодня интересную статью. Которая еще более детально описывает работу с actionbar.





Прошу к прочтению.


<!-- more -->


На прошлом уроке мы рассмотрели добавление элементов ActionBar. Пользователю эти элементы удобно использовать для совершения каких-либо операций в приложении. Например, в почтовой программе это может быть удаление письма, пересылка, ответ и т.д.





Теперь рассмотрим, как добавить элементы для навигации по приложению. Есть два типа элементов для навигации: табы и выпадающий список. Создадим простое приложение и реализуем в нем сначала один, затем второй способ.





Создадим проект:





**Project name**: P1081_ActionBarNavigation  
**Build Target**: Android 4.1   
**Application name**: ActionBarItems  
**Package name**: ru.startandroid.develop.p1081actionbarnavigation  
**Create Activity**: MainActivity





Никакие строки не добавляем, основной layout не трогаем.





### Табы





Кодим **MainActivity.java**:



	import android.app.ActionBar;

	import android.app.ActionBar.Tab;

	import android.app.Activity;

	import android.app.FragmentTransaction;

	import android.os.Bundle;

	import android.util.Log;



	public class MainActivity extends Activity implements ActionBar.TabListener {



  	final String LOG_TAG = "myLogs";



  	@Override

  	public void onCreate(Bundle savedInstanceState) {

    super.onCreate(savedInstanceState);

    setContentView(R.layout.main);



    ActionBar bar = getActionBar();



    bar.setNavigationMode(ActionBar.NAVIGATION_MODE_TABS);



    Tab tab = bar.newTab();

    tab.setText("tab1");

    tab.setTabListener(this);

    bar.addTab(tab);



    tab = bar.newTab();

    tab.setText("tab2");

    tab.setTabListener(this);

    bar.addTab(tab);



  	}



  	@Override

  	public void onTabReselected(Tab tab, FragmentTransaction ft) 	{

    Log.d(LOG_TAG, "reselected tab: " + tab.getText());

  	}



  	@Override

  	public void onTabSelected(Tab tab, FragmentTransaction ft) {

    Log.d(LOG_TAG, "selected tab: " + tab.getText());

  	}



  	@Override

  	public void onTabUnselected(Tab tab, FragmentTransaction ft) 	{

    Log.d(LOG_TAG, "unselected tab: " + tab.getText());

  	}

	}







Смотрим, что нам нужно, чтобы включить табы.





В **onCreate** мы получаем доступ к ActionBar и устанавливаем для него режим навигации в [NAVIGATION_MODE_TABS](http://developer.android.com/reference/android/app/ActionBar.html#NAVIGATION_MODE_TABS). Далее идет добавление табов. Тут все несложно – создаем, пишем текст, присваиваем обработчика, добавляем в ActionBar.





Обработчиком для табов мы сделали MainActivity, оно реализует методы интерфейса [ActionBar.TabListener](http://developer.android.com/reference/android/app/ActionBar.TabListener.html):





[onTabReselected](http://developer.android.com/reference/android/app/ActionBar.TabListener.html) – выбран уже выбранный таб





[onTabSelected](http://developer.android.com/reference/android/app/ActionBar.TabListener.html)– таб выбран





[onTabUnselected](http://developer.android.com/reference/android/app/ActionBar.TabListener.html)– таб более не выбран





В эти методы поместим запись в лог и посмотрим, как оно все там работает.





Все сохраняем и запускаем приложение.





Видим табы





![](http://android-helper.com.ua/images/uploads/2012/10/L0108_010.jpg)





Сейчас выбран первый таб и лог сразу об этом сообщает:





	_selected tab: tab1_





Нажмем на второй таб,





![](http://android-helper.com.ua/images/uploads/2012/10/L0108_020.jpg)




смотрим логи:





	_unselected tab: tab1  
	__selected tab: tab_2





Первый таб «развыбран», а второй выбран.





Еще раз нажмем на второй таб:





	_reselected tab: tab2_





Второй таб перевыбран. Все логично и понятно.





Я, чтобы не перегружать урок, не стал реализовывать какие-либо операции по навигации в приложении. А, вообще, подразумевается, что в методах обработчика мы кодим операции с фрагментами. Нам даже любезно предоставляют объект **FragmentTransaction** для этих целей. При этом хелп предупреждает, что в этих методах нам не надо самим вызывать метод **commit**, а также мы не можем добавлять транзакцию в **BackStack**.





### Выпадающий список





Теперь посмотрим, как работает навигация с выпадающим списком.





Перепишем **MainActivity.java**:





	import android.app.ActionBar;

	import android.app.Activity;

	import android.os.Bundle;

	import android.util.Log;

	import android.widget.ArrayAdapter;



	public class MainActivity extends Activity implements

    ActionBar.OnNavigationListener {



  	String[] data = new String[] { "one", "two", "three" };



  	final String LOG_TAG = "myLogs";



  	@Override

  	public void onCreate(Bundle savedInstanceState) {

    super.onCreate(savedInstanceState);

    setContentView(R.layout.main);



    ActionBar bar = getActionBar();

    bar.setNavigationMode(ActionBar.NAVIGATION_MODE_LIST);



    ArrayAdapter<String> adapter = new ArrayAdapter<String>(this,

        android.R.layout.simple_spinner_item, data);

    adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);

    bar.setListNavigationCallbacks(adapter, this);

  	}



  	@Override

  	public boolean onNavigationItemSelected(int itemPosition, long itemId) {

    Log.d(LOG_TAG, "selected: position = " + itemPosition + ", id = "

        + itemId + ", " + data[itemPosition]);

    return false;

  	}

	}







В **onCreate** получаем ActionBar и включаем ему режим навигации [NAVIGATION_MODE_LIST](http://developer.android.com/reference/android/app/ActionBar.html#NAVIGATION_MODE_LIST). Для выпадающего списка необходимо создать адаптер, реализующий SpinnerAdapter. Пусть это будет ArrayAdapter. При создании используем массив из трех строк. Далее вызываем метод [setListNavigationCallbacks](http://developer.android.com/reference/android/app/ActionBar.html#setListNavigationCallbacks(android.widget.SpinnerAdapter, android.app.ActionBar.OnNavigationListener)), в который передаем адаптер и обработчик.





Обработчиком у нас снова является Activity, реализует метод [onNavigationItemSelected](http://developer.android.com/reference/android/app/ActionBar.OnNavigationListener.html#onNavigationItemSelected(int, long)) интерфейса [ActionBar.OnNavigationListener](http://developer.android.com/reference/android/app/ActionBar.OnNavigationListener.html). Этот метод дает нам позицию и id выбранного из списка элемента. Выводим в лог эту инфу и соответствующий элемент массива.





В манифесте я прописал для MainActivity атрибут темы: android:theme="@android:style/Theme.Holo.Light". Иначе был темный текст на темном фоне.





Все сохраняем и запускаем.





![](http://android-helper.com.ua/images/uploads/2012/10/L0108_030.jpg)





Первый элемент сразу выбран. В логах видим:





	_selected: position = 0, id = 0, one_





Выберем какой-нить другой элемент из списка





![](http://android-helper.com.ua/images/uploads/2012/10/L0108_040.jpg)




В логах:





	_selected: position = 2, id = 2, three_





Снова все логично и понятно.





Для обоих видов навигации мы всегда можем получить текущий выбранный элемент с помощью метода [getSelectedNavigationIndex](http://developer.android.com/reference/android/app/ActionBar.html#getSelectedNavigationIndex()). А для навигации с табами есть также метод [getSelectedTab](http://developer.android.com/reference/android/app/ActionBar.html#getSelectedTab()), возвращающий текущий выбранный таб.





Разумеется, что вместе с навигацией мы можем добавлять в ActionBar и обычные элементы, которые были рассмотрены на прошлом уроке.





![](http://android-helper.com.ua/images/uploads/2012/10/L0108_050.jpg)





При этом, если места будет недостаточно, то ActionBar разделит все свои элементы на две полосы.





![](http://android-helper.com.ua/images/uploads/2012/10/L0108_060.jpg)





Начиная с четвертой версии Андроид, можно использовать атрибут **uiOptions** для Activity или Application в манифесте. Если присвоить ему значение**splitActionBarWhenNarrow**, то результат при нехватке места получится такой:





![](http://android-helper.com.ua/images/uploads/2012/10/L0108_070.jpg)




Элементы ушли вниз. Правда, при этом почему-то перестает работать withText в showAsAction.





Статья взята из сайта [startandroid.ru](http://startandroid.ru/uroki/vse-uroki-spiskom/178-urok-108-android-3-actionbar-navigatsija-taby-i-vypadajuschij-spisok.html)





Если вам понравилась статья, оставляйте свои комментарии. И не забывайте рассказать друзьям о нас.
Нашел неплохую [статью](http://findevelop.blogspot.com/2011/10/bitmapdrawable.html) как изменить размер в BitmapDrawable.





Недавно мне понадобилось получить из внешнего потока (InputStream) картинку и вывести ее на экран, но картинка была в одном размере и ее нужно было под разные экраны и условия уменьшить или увеличить.  
  

<!-- more -->

Для начала получим из потока Drawable. Например с assets каталога:







	Drawable drawable = 	Drawable.createFromStream(act.getAssets().open(fileName), null);







И для того, чтобы изменить размер, я использую следующий метод:




	public static Drawable resizeDrawable(Drawable drawable, int newWidth, int newHeight) {

    Bitmap bitmap = ((BitmapDrawable) drawable).getBitmap();

    int width = bitmap.getWidth();

    int height = bitmap.getHeight();

    float scaleWidth = ((float) newWidth) / width;

    float scaleHeight = ((float) newHeight) / height;

    Matrix matrix = new Matrix();

    matrix.postScale(scaleWidth, scaleHeight);

    Bitmap resizedBitmap = Bitmap.createBitmap(bitmap, 0, 0,

        width, height, matrix, true);

    return new BitmapDrawable(resizedBitmap);

  	}






Этот метод я запостил скорей чтобы не забыть, потому как в проекте он уже не нужен, и дабы помочь ищущему. Но я думаю есть другие варианты решения, если кто наткнулся на пост и знает, то плиз в комментарии.
Добрый день.





Сегодня нашел статью, как можно закачать файлы с сервера.





Оригинал статьи [тут](http://findevelop.blogspot.com/2012/01/android_19.html).


 <!-- more -->


Хорошо сделанное Android-приложение (кроме всего прочего) не заставляет клиента угадывать что в данный момент происходит "по ту сторону экрана". Приятное и аккуратное приложение показывает при всех продолжительных операциях прогресс-бар, который реализует, как правило, с помощью класса AsyncTask. Давайте посмотрим как правильно использовать этот замечательный инструмент на примере загрузки файла из сети:





	import java.io.File;

	import java.io.FileOutputStream;

	import java.io.IOException;

	import java.io.InputStream;

	import java.net.HttpURLConnection;

	import java.net.MalformedURLException;

	import java.net.URL;

	import android.app.Act	ivity;

	import android.app.ProgressDialog;

	import android.os.AsyncTask;

	import android.os.Bundle;

	import android.view.View;

	import android.view.ViewGroup.LayoutParams;

	import android.widget.Button;

	import android.widget.TextView;

	public class BackFLoaderActivity extends Activity {

 

 	@Override

 	public void onCreate(Bundle savedInstanceState) {

  	super.onCreate(savedInstanceState);

  	Button load = new Button(this);

  	load.setText("Load file");

  	load.setOnClickListener(new View.OnClickListener() {

   	@Override

   	public void onClick(View v) {

    	downloadFile("http://anjedi.com/api_lib/2.2_level8.jar");

   	}

  	});

  	setContentView(load, new LayoutParams(LayoutParams.WRAP_CONTENT,

   	LayoutParams.WRAP_CONTENT));

 	}

 



 	private void downloadFile(String url) {

  	final ProgressDialog progressDialog = new ProgressDialog(this);

 

  	new AsyncTask<String, Integer, File>() {

   	private Exception m_error = null;

 

   	@Override

   	protected void onPreExecute() {

    progressDialog.setMessage("Downloading ...");

    progressDialog.setCancelable(false);

    progressDialog.setMax(100);

    progressDialog

      .setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);

 

    progressDialog.show();

   	}

 

   	@Override

   	protected File doInBackground(String... params) {

    URL url;

    HttpURLConnection urlConnection;

    InputStream inputStream;

    int totalSize;

    int downloadedSize;

    byte[] buffer;

    int bufferLength;

 

    File file = null;

    FileOutputStream fos = null;

 

    try {

     url = new URL(params[0]);

     urlConnection = (HttpURLConnection) url.openConnection();

 

     urlConnection.setRequestMethod("GET");

     urlConnection.setDoOutput(true);

     urlConnection.connect();

 

     file = File.createTempFile("Mustachify", "download");

     fos = new FileOutputStream(file);

     inputStream = urlConnection.getInputStream();

 

     totalSize = urlConnection.getContentLength();

     downloadedSize = 0;

 

     buffer = new byte[1024];

     bufferLength = 0;

 

     // читаем со входа и пишем в выход, 

     // с каждой итерацией публикуем прогресс

     while ((bufferLength = inputStream.read(buffer)) > 0) {

      fos.write(buffer, 0, bufferLength);

      downloadedSize += bufferLength;

      publishProgress(downloadedSize, totalSize);

     }

 

     fos.close();

     inputStream.close();

 

     return file;

    } catch (MalformedURLException e) {

     e.printStackTrace();

     m_error = e;

    } catch (IOException e) {

     e.printStackTrace();

     m_error = e;

    }

 

    return null;

   	}

 

   	// обновляем progressDialog

   	protected void onProgressUpdate(Integer... values) {

    progressDialog

      .setProgress((int) ((values[0] / (float) values[1]) * 100));

   	};

 

   	@Override

   	protected void onPostExecute(File file) {

    // отображаем сообщение, если возникла ошибка

    if (m_error != null) {

     m_error.printStackTrace();

     return;

    }

    // закрываем прогресс и удаляем временный файл

    progressDialog.hide();

    file.delete();

   	}

  	}.execute(url);

 		}

	}






В этом маленьком приложении при нажатии на кнопку запускается загрузка файла, при этом пользователь наблюдает прогресс-бар. Не забудьте добавить в манифест запрос разрешений на доступ к интернет и файловой системе.  
Основой примера является метод, который я взял [отсюда](http://twigstechtips.blogspot.com/2011/10/android-download-file-with-progress.html) (и поправил пару ошибок).     
Этот метод принимает url файла, который нужно загрузить, загружает файл, отображая при этом горизонатальный прогресс-бар. При этом прогресс-бар реально показывает какая часть файла в данный момент загружена. По окончании загрузки файл удаляется.  
  
**Разберём работу метода подробнее:**  
  
Главная часть метода - создание AcyncTask-а и переопределение его методов.  
В методе _onPreExecute_ мы запускаем progressDialog, установив предварительно текст сообщения и максимальное значение прогресса: 100%.   
В методе _doInBackground_ - выполняем собственно загрузку файла. Файл читаем  из_urlConnection_ порциями по 1024 байт, каждый раз прибавляя размер полученной порции к общему счётчику. Счётчик и общий размер файла передаём при каждой итерации в метод _publishProgress_, благодаря чему в методе _onProgressUpdate_ мы получаем эти данные и обновляем текущий статус progressDialog-а.   
И, наконец, в методе _onPostExecute_ мы прячем диалог и удаляем временный файл.   
Особенностью использования AsyncTask-a является способ, как он объявляется и как в него передаются параметры. Типы, которыми параметризуется экземпляр AsyncTask-a определяю по порядку: тип входящего значения, тип параметра, опреляющего прогресс опреации и тип результата фоновой операции (то что возвращает _doInBackground_ и принимает _onPostExecute_). Кроме того конструктор и чаcть методов AsyncTask-а принимает _varargs, _т.е. произвольное число параметров, что весьма удобно в некоторых случаях.
Привет всем.





Сегодня изучил для себя новую тему- работу с ActionBar.





Это новый патерн который программисты могут использовать с 3 версии android.





Изучал я этот патерн по одной статье.


<!-- more -->


Оригинал [тут.](http://startandroid.ru/uroki/vse-uroki-spiskom/177-urok-107-android-3-actionbar-razmeschenie-elementov.html)





Поскольку статья, заслуживает внимания как новичков так и гуру, я ее продублирую у себя на сайте.





Еще одно нововведение третьего Андроида – [Action Bar](http://developer.android.com/guide/topics/ui/actionbar.html). Это панель в верхней части приложения.





В этом уроке попробуем размещать там свои элементы с иконками и посмотрим, как с ними взаимодействовать. Тут нам все уже будет знакомо, т.к. используется механизм, который раньше строил меню.  Т.е. мы в методе [onCreateOptionsMenu](http://developer.android.com/reference/android/app/Activity.html#onCreateOptionsMenu(android.view.Menu)) получаем на вход объект Menu и (программно или с помощью XML) наполняем его элементами.





Для элементов будем указывать id, текст, иконку и режим показа.





В **strings.xml** добавим строки:




	<string name="item1">Item1</string>

	<string name="item2">Item2</string>

	<string name="item3">Item3</string>

	<string name="item4">Item4</string>







В файл **res\menu\main.xml** напишем следующий текст:





	<?xml version="1.0" encoding="utf-8"?>

	<menu

 xmlns:android="http://schemas.android.com/apk/res/android">

	<item

 android:id="@+id/item1"

 android:showAsAction="always"

 android:title="@string/item1">

	</item>

	<item

 		android:id="@+id/item2"

 		android:icon="@android:drawable/ic_menu_call"

 		android:showAsAction="ifRoom"

 		android:title="@string/item2">

	</item>

	<item

 		android:id="@+id/item3"

 		android:icon="@android:drawable/ic_menu_info_details"

 		android:showAsAction="ifRoom|withText"

 		android:title="@string/item3">

	</item>

	<item

 		android:id="@+id/item4"

 		android:icon="@android:drawable/ic_menu_view"

 		android:showAsAction="never"

 		android:title="@string/item4">

	</item>

	</menu>






С **id**, **title** и **icon**, думаю все понятно – это идентификатор, текст и иконка элемента. Иконки системные, выбранные случайно.





Нам тут больше интересен атрибут **showAsAction**, это режим показа элемента. Он может принимать значения:





**never**– не показывать элемент





**ifRoom**– показывать, если есть место





**always**– всегда показывать





К этим значениям может быть добавлено еще одно – **withText**. Актуально для элементов с указанной иконкой. В этом случае для элемента будет показана не только иконка, но и текст из **title**. 





Кодим **MainActivity.java**:

	package ru.startandroid.develop.p1071actionbaritems;



	import android.app.Activity;

	import android.os.Bundle;

	import android.view.Menu;



	public class MainActivity extends Activity {



  @Override

  public void onCreate(Bundle savedInstanceState) {

    super.onCreate(savedInstanceState);

    setContentView(R.layout.main);

  }



  @Override

  public boolean onCreateOptionsMenu(Menu menu) {

    getMenuInflater().inflate(R.menu.main, menu);

    return true;

  }



	}







Думаю, комментарии тут особо не нужны. Все знакомое. Заполненный нами ранее xml-файл используется для создания элементов Menu. 





Все сохраняем, запускаем приложение.





Отобразился **item1 **и **item2**.





![](http://android-helper.com.ua/images/uploads/2012/09/L0107_010.jpg)



Для **item1** мы не указывали иконку, поэтому видим только текст. А в **showAsAction **мы указали **always**, т.е. система будет пытаться отобразить элемент, даже если не хватает места на ActionBar.





Для **item2** мы указали иконку ic_menu_call, ее и видим в ActionBar. В **showAsAction **мы указали **ifRoom**, т.е. отображать, если есть свободное место. Место есть – элемент виден.





Жмем на эмуляторе menu и видим два оставшихся элемента. Они не отобразились в ActionBar и теперь доступны только так.





![](http://android-helper.com.ua/images/uploads/2012/09/L0107_020.jpg)





**item3** не отобразился, т.к. ему не хватило места. Мы для него указывали **showAsAction** = **ifRoom**, т.е. отображать, если есть где. Для **item2** место нашлось, а вот **item3**не влез.





**item4** не отобразился, т.к. мы указали **showAsAction**= **never**.





Давайте увеличим место в ActionBar и посмотрим, что изменится. Для этого просто повернем экран в горизонтальную ориентацию – CTRL+F12.





![](http://android-helper.com.ua/images/uploads/2012/09/L0107_030.jpg)





Для **item1** и **item2** ничего не изменилось. А вот для **item3** теперь появилось местечко, и он вылез. Если для **item2** отображена только иконка, то для **item3** мы видим и текст. Это сказывается **withText** в атрибуте **showAsAction**.





**item4** не виден несмотря на то, что есть куча места свободного. Причина - **never** в атрибуте **showAsAction**. Чтоб добраться до него, жмем menu.





![](http://android-helper.com.ua/images/uploads/2012/09/L0107_040.jpg)




### overflow menu





Если запустить это же приложение на планшете, то увидим чуть другой интерфейс ActionBar:





![](http://android-helper.com.ua/images/uploads/2012/09/L0107_050.jpg)




Справа появляется кнопка, нажатие на которую аналогично нажатию на menu. Судя по всему, эта кнопка видна только на тех устройствах, на которых нет кнопки menu.





### Как узнать текст элемента, если видна только иконка





Если для элемента показана только иконка, то долгим нажатием на нее можно добиться показа текста. Попробуем на item2:





![](http://android-helper.com.ua/images/uploads/2012/09/L0107_060.jpg)




На AVD с 4.1 это работает. На планшете с 3.2 – почему-то нет.





### Как отключить ActionBar





Для этого в коде можно прописать:





Либо выбрать для **Activity** тему, содержащую текст _NoActionBar_.





![](http://android-helper.com.ua/images/uploads/2012/09/L0107_070.jpg)




### Где обрабатывать нажатия на элементы





Там же, где и при работе с меню – метод [onOptionsItemSelected](http://developer.android.com/reference/android/app/Activity.html#onOptionsItemSelected(android.view.MenuItem)). Все аналогично.





### О кнопке Home





В левой части ActionBar находится кнопка **Home**. По умолчанию для нее используется иконка приложения или Activity. Мы можем поставить сюда свою иконку, не трогая текущие. Для этого используется атрибут android:logo у Activity или Application.





В третьем Андроиде кнопка Home кликабельна по умолчанию. В четвертом же ее надо явно задействовать методом [setHomeButtonEnabled](http://developer.android.com/reference/android/app/ActionBar.html#setHomeButtonEnabled(boolean)).





Поймать нажатие кнопки **Home** можно также в onOptionsItemSelected. Она имеет id = **android.R.id.home**.





Насколько я понял по хелпу, назначение этой кнопки – перейти в коренное Activity программы, т.е. действительно кнопка «Домой». Также хелп говорит об еще одной логической возможности использования – как кнопка «Вверх». Т.е. не в корневое Activity, а на один логический уровень вверх. Например, из чтения письма переходим к списку писем. А для того, чтобы пользователь знал, что он попадет не Домой, а Вверх предлагается вещать на кнопку стрелочку методом [setDisplayHomeAsUpEnabled](http://developer.android.com/reference/android/app/ActionBar.html#setDisplayHomeAsUpEnabled(boolean)).





В итоге выглядит это примерно так





![](http://android-helper.com.ua/images/uploads/2012/09/L0107_080.jpg)





На кнопке появилась стрелка.





Надо понимать, что эта стрелка – это просто изображение для пользователя, чтобы он знал, какое поведение ожидать от нажатия. А кодить весь процесс перехода Вверх надо самим. Как впрочем и процесс перехода Домой.









Напоследок еще несколько полезных методов для ActionBar:





[setTitle](http://developer.android.com/reference/android/app/ActionBar.html#setTitle(java.lang.CharSequence)) – установить свой текст около кнопки Home





[setDisplayShowTitleEnabled ](http://developer.android.com/reference/android/app/ActionBar.html#setDisplayShowTitleEnabled(boolean))– скрыть/показать текст около кнопки Home





[setDisplayShowHomeEnabled](http://developer.android.com/reference/android/app/ActionBar.html#setDisplayShowHomeEnabled(boolean)) – скрыть/показать кнопку Home









Если вам понравилась статья, или вы бы хотели что бы описали что то конкретно. Пишите, мы с радостью вам поможем.
Сегодня нашел интересую статью, как можно строить диаграммы в Android.





Оригинал статьи вы можете найти [тут](http://www.mobilab.ru/androiddev/achartengineforandroid.html).





Я же в свою очередь продублирую ее у себя на блоге, так как считаю, что она заслуживает внимания.


<!-- more -->


При разработке бизнес приложений программисты часто сталкиваются с необходимостью строить большое количество различных диаграмм и графиков. Конечно, все можно делать с нуля, вручную отрисовывая все необходимое, но зачем так мучатся, если есть неплохое бесплатное решение? Сегодня я хочу рассказать Вам об open source библиотеке AChartEngine, позволяющей создавать красивые графики и диаграммы для ваших отчетов. Приятно, что библиотека распространяется под весьма мягкой лицензией Apache Version 2, так что Вы вполне можете использовать **AChartEngine **в своих коммерческих проектах.     
  
[На сайте разработчика](http://www.achartengine.org/index.html) помимо самой библиотеки можно найти подробную документацию, офермленную в стиле Javadoc pages, примеры использования библиотеки, а также ее исходный код. В разделе Demo приводится несколько диаграмм и графиков, построенных средствами AChartEngine.





![](http://android-helper.com.ua/images/uploads/2012/09/AChartEngine.jpg)





Для построения диаграммы нужно выполнить несколько довольно простых шагов








  1. Перед использованием библиотеки вам нужно подключить ее к своему проекту в Eclipse. Для этого создайте где-нибудь папку для библиотеки и поместите туда jar файл. Теперь добавьте этот jar в свой project build path. После этого добавьте строку <activity android:name="org.achartengine.GraphicalActivity"/> в файл манифеста вашего проекта.



  2. Создайте и инициализируйте три массива. В первом будут содержаться цвета, во втором - подписи, в третьем - значения. 



  3. Создайте объект CategorySeries и загрузите в него массивы строк с подписями и значения. При построении диаграмм будут использоваться именно эти данные.



  4. Создайте объект DefaultRenderer. CategorySeries и DefaultRenderer определены в библиотеке AChartEngine.



  5. Для каждого цвета в диаграмме создайте SimpleSeriesRenderer и установите его в этот цвет. Затем каждый SimpleSeriesRenderer добавьте в DefaultRenderer. Таким образом, имеем один Render на каждый Series. К слову, Render может включать другой Render, таким образом можно создавать подкатегории.



  6. Создайте объект PieChartIntent и передайте ему CategorySeries и DefaultRenderer.



  7. С помощью PieChartIntent можно показать диаграмму, как отдельную деятельность.






  
Ниже приводится исходный код, в котором реализованы все описанные выше шаги.





	package com.example.bars;

 

	import org.achartengine.ChartFactory;

	import org.achartengine.chart.PieChart;

	import org.achartengine.model.CategorySeries;

	import org.achartengine.renderer.DefaultRenderer;

	import org.achartengine.renderer.SimpleSeriesRenderer;

	import android.content.Context;

	import android.content.Intent;

	import android.graphics.Color;

	import android.app.Activity;

	import android.os.Bundle;

 

	public class MainActivity extends Activity {

 

    @Override

    public void onCreate(Bundle savedInstanceState) {

       super.onCreate(savedInstanceState);

          Intent intent = buildIntent();

        startActivity(intent);          // шаг 7

    }

 

    public Intent buildIntent() {

        int[] values = new int[] { 5, 15, 25, 50, 75 };        // шаг 2

        String[] bars = new String[] {"Francesca's",  "King of Clubs", 

                                 "Zen Lounge", "Tied House", "Molly Magees"};

        int[] colors = new int[] { Color.BLUE, Color.GREEN, Color.MAGENTA, 

                                   Color.YELLOW, Color.CYAN };

 

        CategorySeries series = new CategorySeries("Pie Chart");  // шаг 3

        DefaultRenderer dr = new DefaultRenderer();   // шаг 4

 

        for (int v=0; v<5; v++){    // шаг 5

            series.add(bars[v], values[v]);

            SimpleSeriesRenderer r = new SimpleSeriesRenderer();

            r.setColor(colors[v]);

            dr.addSeriesRenderer(r);

        }

        dr.setZoomButtonsVisible(true);

        dr.setZoomEnabled(true);

        dr.setChartTitleTextSize(20);

        return ChartFactory.getPieChartIntent(    // шаг 6

                              this, series, dr, "Pie of bars");

    }

 

	}






Мы построили диаграмму PieChartIntent, однако подобным образом можно построить и другие виды графиков. Мне библиотека показалась довольно удобной и понятной. Ее можно использовать, если необходимо быстро разработать какое-нибудь бизнес-приложение со строгим дизайном.







Если вам понравилось, пишите комментарии и подписывайтесь на наши обновления.


Добрый день друзья.





Сегодня я вам расскажу о таком android элементе как AutoCompleteTextView.





Для чего же нужен этот элемент. А нужен он для того что бы во время ввода выдавался соответствующий список возможных вариантов.





Давайте теперь рассмотрим как с этим работать.


<!-- more -->


К примеру нам нужно автозаполнение для списка месяцев года.





![](http://android-helper.com.ua/images/uploads/2012/09/ExAutoCompleteTextView.png)





Для этого подготовим нужный нам массив строк (/res/values/myvalues.xml):






	<?xml version="1.0" encoding="UTF-8"?>

	<resources>

	<array name="month">

       <item>January</item>

       <item>February</item>

       <item>March</item>

       <item>April</item>

       <item>May</item>

       <item>June</item>

       <item>July</item>

       <item>August</item>

       <item>September</item>

       <item>October</item>

       <item>November</item>

       <item>December</item>

	</array>

	</resources>







В главной активити напишем следуюющее:



	import android.app.Activity;

	import android.os.Bundle;

	import android.text.Editable;

	import android.text.TextWatcher;

	import android.widget.ArrayAdapter;

	import android.widget.AutoCompleteTextView;

 

	public class ExAutoCompleteTextView extends Activity implements TextWatcher {

  

 	AutoCompleteTextView autoCompleteTextView;

  

   	/** Called when the activity is first created. */

   	@Override

   	public void onCreate(Bundle savedInstanceState) {

       super.onCreate(savedInstanceState);

       setContentView(R.layout.main); 

       autoCompleteTextView = (AutoCompleteTextView)findViewById(R.id.input);

       String[] month = getResources().getStringArray(R.array.month);

       autoCompleteTextView.addTextChangedListener(this); 

       autoCompleteTextView.setAdapter(new ArrayAdapter<String>(this, android.R.layout.simple_dropdown_item_1line, month)); 

   	}

 

 		@Override

 		public void afterTextChanged(Editable arg0) {

  	// TODO Auto-generated method stub

   

 		}

 

 		@Override

 		public void beforeTextChanged(CharSequence arg0, int arg1, int arg2, int arg3) {

  	// TODO Auto-generated method stub

   

 		}

 

		@Override

 		public void onTextChanged(CharSequence arg0, int arg1, int arg2, int arg3) {

  	// TODO Auto-generated method stub

   

 		}

	}








Ну и сама раскладка main.xml:



	<?xml version="1.0" encoding="utf-8"?>

	<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"

   	android:orientation="vertical"

   	android:layout_width="fill_parent"

   	android:layout_height="fill_parent"

   	>

	<TextView

   	android:layout_width="fill_parent"

   	android:layout_height="wrap_content"

   	android:text="@string/hello"

   	/>

	<AutoCompleteTextView

   	android:id="@+id/input"

   	android:layout_width="fill_parent"

   	android:layout_height="wrap_content"

   	android:completionThreshold="1"

   	/>

	</LinearLayout>








Вот и все.





Жду ваших комментариев и прошу подписаться на моем блоге.
Всем привет.





С вами снова я. И сегодня мы поговорим, как показывать HTML код в TextView.





Если все готовы. Тогда приступим.


<!-- more -->


Вам необходимо вызвать функцию:







	TextView txtView = new TextView(this);

	Spanned s = Html.fromHtml("Android - это супер <font color=\"red\">android-helper.com.ua</font>");

	txtView.setText(s);









Вот полный код:






	public class TestActivity extends Activity {

 

    @Override

    public void onCreate(Bundle savedInstanceState) {

        super.onCreate(savedInstanceState);

        TextView txtView = new TextView(this);

        Spanned s = Html.fromHtml("Android - это супер <font color=\"red\">android-helper.com.ua</font>");

        txtView.setText(s);

 

        setContentView(txtView);

    }

	}







Все готово. Теперь можете наслаждаться.





Но нужно помнить, что так можно отформатировать не все HTML теги.





Вот список тегов, которые поддерживает класс **Html**.








  * a href="...",



  * b,



  * big,



  * blockquote,



  * br,



  * cite,



  * dfn,



  * div align="...",



  * em,



  * font size="..." color="..." face="...",



  * h1-h6,



  * i,



  * img src="...",



  * p,



  * small,



  * strike,



  * strong,



  * sub,



  * sup,



  * tt,



  * u



Недавно столкнулся с задачей - сделать приложение для android 4 с его интерфейсом.





Все было супер, пока я не запустил на android 2.3. И там увидел, что таких стилей нету.





Покопав просторы интернета. Я нашел такую [статью](http://findevelop.blogspot.com/2012/06/android-android-4.html#more)





Но так как я на своем блоге собираю всю полезную информацию. Я ее продублирую у себя на блоге.





Прошу к прочтению:

 <!-- more -->



![](http://android-helper.com.ua/images/uploads/2012/09/holo.jpg)




Ничто так не портит настроение программиста, как необходимость заниматься вместо программирования чем-то другим. Например, дизайном. Но приложение без дизайна в наше время  обречено на забвение избалованных пользователей. Как же быть? А давайте нашим формам и кнопочкам "выдадим" стандартный стиль Android Ice Cream Sandwich. Пусть наши пользователи, которые пока ещё не обновились до последней версии Android наслаждаются стильным дизайном и проникаются к нашему приложению тёплыми чувствами. В этом добром деле нам поможет библиотека [HoloEverywhere](https://github.com/ChristopheVersieux/HoloEverywhere). Использовать всю библиотеку мы не будем, нам хватит и одной темы, например моей любимой HoloEverywhereDark. А прикрутим к проекту мы её ручками, попутно изучив механизм "стилизации" Android-приложений.   
  
**Стили - это просто**  
  
В res/values/ нашего проекта создаём файл styles.xml, где мы будем описывать стили для всех контролов в нашей теме. Описывать - это громко сказано: мы просто скопируем аналогичный файл из библиотеки HoloEverywhere, удалив лишние стили. Картинки для HoloEverywhereDark копируем в свои каталоги drawable-mdpi, drawable-hdpi и drawable-xhdpi. Название всех нужных файлов заканчивается на "dark".   
Кроме картинок нам понадобятся xml-файлы описания ресурсов, напрмер цветов. Их складываем в каталог drawable. Больше нам из библиотеки HoloEverywhere ничего не понадобится.  
Посмотрим подробнее в наш styles.xml. Например:



	<style name="ButtonHoloDark" parent="android:style/Widget.Button">

 	<item name="android:background">@drawable/btn_default_holo_dark</item>

 	<item name="android:textColor">#ffffff</item>

	</style>








В этом фрагменте мы видим описание стиля кнопки с именем ButtonHoloDark. Тег style имеет обязательный атрибут name и необязательный parent. Именно parent позволяет нам реализовать иерархию стилей элементов интерфейса Android-приложений. В данном случае мы наследуем стиль стандартной кнопки и переопределяем в нашем новом стиле два item-а: цвет фона и цвет текста. Цвет можно задавать как комбинацией rgb (как в html), так и ссылкой на xml-ресурс. В данном случае для фона кнопки это файл btn_default_holo_dark.xml в каталоге drawable. Посмотрим в него и поймём почему используется xml-ресурс вместо обычного описания цвета:




	<selector xmlns:android="http://schemas.android.com/apk/res/android">

    <item android:drawable="@drawable/btn_default_normal_holo_dark" android:state_enabled="true" android:state_window_focused="false"/>

    <item android:drawable="@drawable/btn_default_disabled_holo_dark" android:state_enabled="false" android:state_window_focused="false"/>

    <item android:drawable="@drawable/btn_default_pressed_holo_dark" android:state_pressed="true"/>

    <item android:drawable="@drawable/btn_default_focused_holo_dark" android:state_enabled="true" android:state_focused="true"/>

    <item android:drawable="@drawable/btn_default_normal_holo_dark" android:state_enabled="true"/>

    <item android:drawable="@drawable/btn_default_disabled_focused_holo_dark" android:state_focused="true"/>

    <item android:drawable="@drawable/btn_default_disabled_holo_dark"/>

	</selector>






Тут описано несколько цветов, которые назначаются фону кнопки в зависимости от её состояния. Эти цвета уже не xml-ресурсы а обычные изображения (некоторые в формате nine-patch, оптимизированном для "растягивания").  
И так мы дошли до подножия "пирамиды стилей". А что же наверху?  
Мы, безусловно можем назначить готовый стиль кнопке в нашем xml-layout или в коде. Но зачем этот утомительный процесс? Назначить стиль всем элементам интерфейса в приложении можно одной инструкцией в AndroidManifest.xml:





	android:theme="@style/Theme.HoloEverywhereDark"






в теге application.  
Так мы устанавливаем "тему", которая описывается в том же styles.xml.  
Отличие от обычного описания стиля только в том, что стиль кнопки определяет в item-ах её свойства, а item-ами темы является сама кнопка и другие элементы интерфейса. Например:






	<style name="Theme.HoloEverywhereDark" parent="android:Theme.NoTitleBar">

       ...

       <item name="android:buttonStyle">@style/ButtonHoloDark</item>

       ...

	</style>







Вот тут мы и связываем тему с стилем отдельного элемента, который мы видели вначале. Как видите, использовать стили в приложении для Android ничуть не сложнее, чем в web-страницах. 





Надеюсь вам понравилась статья.





Если это так, тогда ваши комментарии будут кстати. :)
Добрый день друзья.





Очень много программистов сейчас сталкиваются с много язычными приложениями.





Я решил поделится опытом работы с такими приложениями.


<!-- more -->


Есть 2 подхода разработки таких приложений.








  1. Язык приложения зависит от языка системы



  2. Возможность менять язык в самом приложении






Ну что приступим.





### Язык приложения зависит от языка системы





В android для реализации данного подхода, используется следующая структура вложения папок.





![](http://android-helper.com.ua/images/uploads/2012/09/m1.png)





Тут все просто, создаем папку с расширением ru (Для России), fr - Франции и так далее.





Больше информации вы можете получить [тут](http://developer.android.com/intl/ru/training/basics/supporting-devices/languages.html).







strings.xml - с папки values





	<resources>



    <string name="app_name">multilanguage</string>

    <string name="hello_world">Hello world!</string>

    <string name="menu_settings">Settings</string>

    <string name="title_activity_main">MainActivity</string>



	</resources>










strings.xml - с папки values-ru









	<resources>



    <string name="app_name">multilanguage</string>

    <string name="hello_world">Привет Мир!</string>

    <string name="menu_settings">Настройки</string>

    <string name="title_activity_main">Главное активити</string>



	</resources>







### Возможность менять язык в самом приложении





Вот тут более интересней тема.





Для того что бы приложение на лету поменяло язык нужно сделать следующее.





Создаем файл который наследуется от Application.





	package com.example.multilanguage;



	import java.util.Locale;



	import android.app.Application;

	import android.content.res.Configuration;



	public class MyApp extends Application {



	private Locale locale = null;



	@Override

	public void onConfigurationChanged(Configuration newConfig) {

		super.onConfigurationChanged(newConfig);

		if (locale != null) {

			newConfig.locale = locale;

			Locale.setDefault(locale);

			getBaseContext().getResources().updateConfiguration(newConfig,

					getBaseContext().getResources().getDisplayMetrics());

		}

	}



	@Override

	public void onCreate() {

		super.onCreate();



		Configuration config = getBaseContext().getResources().getConfiguration();



		String lang = "ru";

		if (!"".equals(lang) && !config.locale.getLanguage().equals(lang)) {

			locale = new Locale(lang);

			Locale.setDefault(locale);

			config.locale = locale;

			getBaseContext().getResources().updateConfiguration(config,

					getBaseContext().getResources().getDisplayMetrics());

		}

	}



	}





Вот и все.





Теперь если вам нужно изменить язык при нажатии на кнопку вызываете просто:






	Configuration config = getBaseContext().getResources().getConfiguration();



		String lang = "ru";

		if (!"".equals(lang) && !config.locale.getLanguage().equals(lang)) {

			locale = new Locale(lang);

			Locale.setDefault(locale);

			config.locale = locale;

			getBaseContext().getResources().updateConfiguration(config,

					getBaseContext().getResources().getDisplayMetrics());

		}







Если вам понравилась статья пишите комментарии и рассказывайте друзьям.





Коды вы можете скачать [тут](http://android-helper.com.ua/forms)
При разработке приложения порой бывает необходимо выполнять какие-то действия в будущем. Например, вы хотите создать будильник или периодически отправлять данные на свой сайт в строго определенное время. Для решения подобных задач в Android используется класс**AlarmManager**, который позволяет выполнять код в требуемый момент времени, даже если ваше приложение не запущено. То-есть AlarmManager - аналог corn в Linux или планировщика задач Windows. Вы говорите, что такой-то кусок кода должен выполниться тогда-то и AlarmManager обеспечивает запуск кода. В англоязычный литературе таймер, который выполняет код в требуемый момент времени обозначается термином**alarm**. Давайте в рамках данной статьи называть этот таймер**будильником**, чтобы отделить это понятие от таймера.



 <!-- more -->

## Несколько слов о классе AlarmManager





Фактически класс AlarmManager обеспечивает доступ к сервису планировки задач Android. Для получения объекта этого класса нужно вызвать метод **Context.getSystemService(Context.ALARM_SERVICE)**. **AlarmManager** регистрирует в системе интент и когда наступает обозначенное время, AlarmManager запускает этот интент. Если момент вызова приложение закрыто, то оно будет вновь запущено. AlarmManager нужно использовать только в случае, если код должен быть выполнен даже при закрытом приложении, во всех других случаях рекомендуется использовать класс **Handler**.  
  
Класс AlarmManager довольно прост. В нашем распоряжении шесть методов:  
  









  * **void cancel(PendingIntent operation)** - отменяет установленный таймер для переданного в качестве параметра интента.



  * **void set (int type, long triggerAtMillis, PendingIntent operation)** - устанавливает будильник, который сработает один раз.



  * **void setInexactRepeating (int type, long triggerAtMillis, long intervalMillis, PendingIntent operation)** - установка будильника с неточным повторением.



  * **setRepeating(int type, long triggerAtMillis, long intervalMillis, PendingIntent operation)**- установка будильника с точным повторением.



  * **setTime(long millis)** - установка системного времени.



  * **setTimeZone(String timeZone)** - установка временной зоны, выбранной по-умолчанию.






  
Здесь **PendingIntent**- класс, который представляет интент и связанное с его выполнением действие. Передавая PendingIntent другому приложению Вы тем самым даете ему право запускать кусок кода из своей программы.  
  
В качестве типа будильника (параметр **type**) может быть передано одно из значений ELAPSED_REALTIME, ELAPSED_REALTIME_WAKEUP, RTC и RTC_WAKEUP. ELAPSED_REALTIME и ELAPSED_REALTIME_WAKEUP - время задается с момента загрузки устройства, а RTC и RTC_WAKEUP - системное время в UTC. Для ELAPSED_REALTIME и RTC если устройство находится в спящем режиме в момент срабатывания будильника, то связанный с ним интент будет вызван позже, когда пользователь выведет устройство из спящего режима. Для ELAPSED_REALTIME_WAKEUP и RTC_WAKEUP если устройство находится в спящем режиме, оно немедленно пробуждается и вызывается интент.





## Программируем приложение-будильник для Android





Давайте в качестве примера разработаем приложение - будильник. При запуске программы пользователю будет показано окно с тремя кнопками. С их помощью пользователь сможет: установить будильник, который срабатывает один раз; будильник, который будет срабатывать периодически; а также удалить ранее установленные будильники. 





![](http://android-helper.com.ua/images/uploads/2012/09/device-2012-09-10-172549.png)



Создадим новый проект в макет шаблона добавим три кнопки





	<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"

    xmlns:tools="http://schemas.android.com/tools"

    android:layout_width="match_parent"

    android:layout_height="match_parent"

    android:orientation="vertical" >



    <Button

        android:id="@+id/btStart"

        android:layout_width="match_parent"

        android:layout_height="wrap_content"

        android:onClick="startRepeatingTimer"

        android:padding="@dimen/padding_medium"

        android:text="Start"

        tools:context=".WidgetAlarmManagerActivity" />



    <Button

        android:id="@+id/btCancel"

        android:layout_width="match_parent"

        android:layout_height="wrap_content"

        android:onClick="cancelRepeatingTimer"

        android:padding="@dimen/padding_medium"

        android:text="Cancel"

        tools:context=".WidgetAlarmManagerActivity" />



    <Button

        android:id="@+id/btOneTime"

        android:layout_width="match_parent"

        android:layout_height="wrap_content"

        android:onClick="onetimeTimer"

        android:padding="@dimen/padding_medium"

        android:text="One Time"

        tools:context=".WidgetAlarmManagerActivity" />



	</LinearLayout>



Кнопка **btStart** устанавливает повторяющийся будильник, кнопка **btCancel**- отменяет его. Кнопка **btOneTime**- создает не повторяющийся будильник. Прямо в шаблоне мы указали методы, которые будут вызываться при нажатии на кнопки: startRepeatingTimer, cancelRepeatingTimer и onetimeTimer соответственно. Код этих методов будут приведен в классе Activity.  
   
Для работы с **AlarmManager** напишем отдельный класс. В качестве базового класса используем BroadcastReciever. Наш класс будет управлять зарегистрированным с помощью AlarmManager интентом. Мы переопределим метод **onReceive()**, который будет вызываться после получения интента. Внутри метод onReceive() мы должны попытаться получить связанные с интентом параметры. В своей программе мы будем использовать один параметр ONE_TIME, который позволяет определить, относится ли интент к однократно срабатывающему будильнику или нет. После того, как значение ONE_TIME получено, пользователю показывается соответствующее сообщение.   
   
Также в этом классе определим методы setAlarm(), cancelAlarm() и onetimeTimer(). Конечно эти методы можно было определить и в другом месте, мы включили их в данный класс из соображения простоты примера.








  * Метод setAlarm() устанавливает повторяющийся будильник с помощью метода setRepeating(). Этому методу требуется четыре параметра: тип будильника, время запуска (устанавливаем текущий момент), интервал в миллисекундах, интент, который будет вызываться при срабатывании будильника.



  * Метод cancelAlarm() отменяет зарегистрированный ранее будильник с помощью вызова метода cancel(), которому перезается в качестве параметра интент. При совпадении этого параметра с зарегистрированным ранее интентом, произойдет удаление будильника.



  * Метод onetimeTimer() создает будильник, который срабатывает один раз. Делается с помощью метода set(), которому передается три параметра: тип будильника, время запуска, вызываемый интент.


		package com.example.alarm;

		import java.text.Format;

		import java.text.SimpleDateFormat;

		import java.util.Date;

		import android.app.AlarmManager;

		import android.app.PendingIntent;

		import android.content.BroadcastReceiver;

		import android.content.Context;

		import android.content.Intent;

		import android.os.Bundle;

		import android.os.PowerManager;

		import android.widget.Toast;

		public class AlarmManagerBroadcastReceiver extends BroadcastReceiver {



		final public static String ONE_TIME = "onetime";



		@Override

		public void onReceive(Context context, Intent intent) {

		PowerManager pm = (PowerManager) context.getSystemService(Context.POWER_SERVICE);

		PowerManager.WakeLock wl = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "YOUR TAG");

		// Осуществляем блокировку

		wl.acquire();



		// Здесь можно делать обработку.

		Bundle extras = intent.getExtras();

		StringBuilder msgStr = new StringBuilder();



		if (extras != null && extras.getBoolean(ONE_TIME, Boolean.FALSE)) {

			// проверяем параметр ONE_TIME, если это одиночный будильник,

			// выводим соответствующее сообщение.

			msgStr.append("Одноразовый будильник: ");

		}

		Format formatter = new SimpleDateFormat("hh:mm:ss a");

		msgStr.append(formatter.format(new Date()));



		Toast.makeText(context, msgStr, Toast.LENGTH_LONG).show();



		// Разблокируем поток.

		wl.release();

		}



		public void SetAlarm(Context context) {

		AlarmManager am = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);

		Intent intent = new Intent(context, AlarmManagerBroadcastReceiver.class);

		intent.putExtra(ONE_TIME, Boolean.FALSE); // Задаем параметр интента

		PendingIntent pi = PendingIntent.getBroadcast(context, 0, intent, 0);

		// Устанавливаем интервал срабатывания в 5 секунд.

		am.setRepeating(AlarmManager.RTC_WAKEUP, System.currentTimeMillis(), 1000 * 5, pi);

		}



		public void CancelAlarm(Context context) {

		Intent intent = new Intent(context, AlarmManagerBroadcastReceiver.class);

		PendingIntent sender = PendingIntent.getBroadcast(context, 0, intent, 0);

		AlarmManager alarmManager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);

		alarmManager.cancel(sender); // Отменяем будильник, связанный с интентом данного класса

		}



		public void setOnetimeTimer(Context context) {

		AlarmManager am = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);

		Intent intent = new Intent(context, AlarmManagerBroadcastReceiver.class);

		intent.putExtra(ONE_TIME, Boolean.TRUE); // Задаем параметр интента

		PendingIntent pi = PendingIntent.getBroadcast(context, 0, intent, 0);

		am.set(AlarmManager.RTC_WAKEUP, System.currentTimeMillis(), pi);

		}

		}







Ниже приводится файл манифеста. Обратите внимание, для корректной работы программе необходимо дать разрешение**WAKE_LOCK**, поскольку мы используем блокировку потока в методе onReceive(). Также тут мы регистрируем AlarmManagerBroadcastReceiver, как получатель широковещательных сообщений


	<manifest xmlns:android="http://schemas.android.com/apk/res/android"

    package="com.example.alarm"

    android:versionCode="1"

    android:versionName="1.0" >



    <uses-sdk

        android:minSdkVersion="8"

        android:targetSdkVersion="15" />



    <uses-permission android:name="android.permission.WAKE_LOCK" />



    <application

        android:icon="@drawable/ic_launcher"

        android:label="@string/app_name"

        android:theme="@style/AppTheme" >

        <activity

            android:name=".MainActivity"

            android:label="@string/title_activity_main" >

            <intent-filter>

                <action android:name="android.intent.action.MAIN" />



                <category android:name="android.intent.category.LAUNCHER" />

            </intent-filter>

        </activity>



        <receiver android:name="AlarmManagerBroadcastReceiver" >

        </receiver>

    </application>



	</manifest>






Теперь давайте напишем класс, в котором реализуем обработчики кнопок. Здесь мы создадим экземпляр описанного выше класса AlarmManagerBroadcastReciever и будем вызывать методы setAlarm(), cancelAlarm() и setOnetime(). 




	package com.example.alarm;



	import android.app.Activity;

	import android.content.Context;

	import android.os.Bundle;

	import android.view.Menu;

	import android.view.View;

	import android.widget.Toast;



	public class MainActivity extends Activity {



	private AlarmManagerBroadcastReceiver alarm;



	@Override

	public void onCreate(Bundle savedInstanceState) {

		super.onCreate(savedInstanceState);

		setContentView(R.layout.activity_main);

		alarm = new AlarmManagerBroadcastReceiver();

	}



	@Override

	protected void onStart() {

		super.onStart();

	}



	public void startRepeatingTimer(View view) {

		Context context = this.getApplicationContext();

		if (alarm != null) {

			alarm.SetAlarm(context);

		} else {

			Toast.makeText(context, "Alarm is null", Toast.LENGTH_SHORT).show();

		}

	}



	public void cancelRepeatingTimer(View view) {

		Context context = this.getApplicationContext();

		if (alarm != null) {

			alarm.CancelAlarm(context);

		} else {

			Toast.makeText(context, "Alarm is null", Toast.LENGTH_SHORT).show();

		}

	}



	public void onetimeTimer(View view) {

		Context context = this.getApplicationContext();

		if (alarm != null) {

			alarm.setOnetimeTimer(context);

		} else {

			Toast.makeText(context, "Alarm is null", Toast.LENGTH_SHORT).show();

		}

	}



	@Override

	public boolean onCreateOptionsMenu(Menu menu) {

		getMenuInflater().inflate(R.menu.activity_main, menu);

		return true;

	}



	}





При надатии на кнопки будут установлен будильник.





Комментируем и подписываемся на обновления.





Коды вы можете скачать [тут](http://android-helper.com.ua/forms)
Добрый день.




Сегодня речь пойдет о Service, IntentService и Foreground.




Попробуем сегодня разобрать, что это такое и как оно работает.




Я решил не выдумывать велосипед, и взял уже готовую [статью](http://startandroid.ru/uroki/vse-uroki-spiskom/165-urok-100-service-intentservice-foreground-avtozagruzka-servisa.html).




Прошу к прочтению.

<!-- more -->


В этом уроке:




- изучаем IntentService  
- включаем режим Foreground для сервиса  
- помещаем сервис в автозагрузку




Строили мы, строили, и, наконец, построили. Урок номер 100, с чем всех нас и поздравляю )




В этом уроке рассмотрим еще несколько полезных вещей про сервисы. Выносить каждую из них в отдельный урок я не стал, вполне можно в одном все рассмотреть. Проекты здесь тоже создавать не будем, чтобы урок не получился слишком громоздким. Я просто приведу некоторые куски кода и скрины для наглядности своих рассуждений. А если у вас будет желание, вы по этим наработкам сами можете создать проекты-примеры.




 **IntentService**




 Это подкласс обычного Service. Он используется, если вам в сервисе надо выполнять какие-то тяжелые задачи, и вы не хотите сами возиться с асинхронностью. Принцип работы этого вида сервиса прост. Он создает новый поток для своей работы. Затем берет все Intent пришедшие ему в onStartCommand и отправляет их на обработку в этот поток. Как именно обрабатываются Intent – зависит от нас, т.к. мы сами кодим это в методе onHandleIntent.




Т.е. приложение сыпет в сервис вызовами startService, в которых передает Intent-ы. [IntentService ](http://developer.android.com/reference/android/app/IntentService.html)принимает эти вызовы в onStartCommand, берет Intent-ы и отправляет их в очередь на обработку. И далее они поочередно обрабатываются в отдельном процессе методом [onHandleIntent](http://developer.android.com/reference/android/app/IntentService.html#onHandleIntent(android.content.Intent)). Когда последний Intent из очереди обработан, процесс сам завершает свою работу.




Пример




В приложении делаем три вызова:


	Intent intent = new Intent(this, MyService.class);
	startService(intent.putExtra("time", 3).putExtra("label", "Call 1"));
	startService(intent.putExtra("time", 1).putExtra("label", "Call 2"));
	startService(intent.putExtra("time", 4).putExtra("label", "Call 3"));






Где **time **– это время паузы, которую будем делать в сервисе, а **label **– просто метка, чтобы отличать вызовы.




Код сервиса:


	package com.example.service;

	import java.util.concurrent.TimeUnit;

	import android.app.IntentService;
	import android.content.Intent;
	import android.util.Log;

	public class MyService extends IntentService {

	final String LOG_TAG = "myLogs";

	public MyService() {
		super("myname");
	}

	@Override
	public void onCreate() {
		super.onCreate();
		Log.d(LOG_TAG, "onCreate");
	}

	@Override
	protected void onHandleIntent(final Intent intent) {
		int tm = intent.getIntExtra("time", 0);
		String label = intent.getStringExtra("label");
		Log.d(LOG_TAG, "onHandleIntent start " + label);
		try {
			TimeUnit.SECONDS.sleep(tm);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		Log.d(LOG_TAG, "onHandleIntent end " + label);
	}

	@Override
	public void onDestroy() {
		super.onDestroy();
		Log.d(LOG_TAG, "onDestroy");
	}

	}


Здесь необходим конструктор, в котором вызываем конструктор супер-класса и указываем какое-нить имя. Оно будет использовано для наименования потока.




В методе onHandleIntent кодим обработку Intent-ов. Достаем из них time и label, запускаем паузу на time секунд и выводим в лог label в начале и в конце.




В итоге, при запуске в логах видим:




	11:07:37.880: D/myLogs(4137): onCreate  
	11:07:37.880: D/myLogs(4137): onHandleIntent start Call 1  
	11:07:40.880: D/myLogs(4137): onHandleIntent end Call 1  
	11:07:40.880: D/myLogs(4137): onHandleIntent start Call 2  
	11:07:41.880: D/myLogs(4137): onHandleIntent end Call 2  
	11:07:41.880: D/myLogs(4137): onHandleIntent start Call 3  
	11:07:45.890: D/myLogs(4137): onHandleIntent end Call 3  
	11:07:45.890: D/myLogs(4137): onDestroy_




Сервис создался, вызовы выполнились по очереди и сервис завершил работу. От нас понадобилось только накодить обработку.




### **Foreground**




Вы можете сказать системе, что ваш сервис очень важен для пользователя и его нельзя грохать при нехватке памяти. Это актуально, например, для музыкального плеера. В статус-бар при этом будет помещено уведомление.




Делается это методом [startForeground(int id, Notification notification)](http://developer.android.com/reference/android/app/Service.html#startForeground(int, android.app.Notification)).




На вход он принимает те же параметры, что и NotificationManager.notify – ID и Notification.




Т.е. вы создаете уведомление, назначаете ему ID и передаете это в startForeground. Сервис переходит в режим [IDDQD](http://lurkmore.to/IDDQD) :), а в статус-баре появилось уведомление.




![](http://android-helper.com.ua/images/uploads/2012/09/L0100_010.jpg)



Оно появилось в разделе для постоянных уведомлений (Ongoing). 




Метод [stopForeground (boolean removeNotification)](http://developer.android.com/reference/android/app/Service.html#stopForeground(boolean))  - возвращает сервису способность быть убитым системой в случае острой нехватки памяти. А на вход он принимает boolean-значение – удалять уведомление из статус-бара или нет.




Уведомление также пропадет, когда сервис будет остановлен.




Эти методы работают, начиная с Android 2.0.  Пример реализации для более ранних версий есть в [хелпе](http://developer.android.com/reference/android/app/Service.html#startForeground(int, android.app.Notification)).




Напомню, что уведомления мы научились создавать на прошлом уроке.




### **Автозагрузка**




Сервисы для получения погоды или почты имеет смысл помещать в автозагрузку. Для этого нам надо создать [BroadcastReceiver](http://developer.android.com/reference/android/content/BroadcastReceiver.html), настроить его IntentFilter на Action =**android.intent.action.BOOT_COMPLETED**, и добавить права **android.permission.RECEIVE_BOOT_COMPLETED**. Этот BroadcastReceiver будет вызван системой при старте системы и в нем мы кодим запуск сервиса.




Допустим, есть проект с сервисом MyService.




Создаем в проекте класс **MyBroadReceiv**


	package com.example.service;

	import android.content.BroadcastReceiver;
	import android.content.Context;
	import android.content.Intent;
	import android.util.Log;

	public class MyBroadReceiv extends BroadcastReceiver {

	final String LOG_TAG = "myLogs";

	@Override
	public void onReceive(final Context context, final Intent intent) {
		Log.d(LOG_TAG, "onReceive " + intent.getAction());
		context.startService(new Intent(context, MyService.class));
	}
	}


В манифесте добавляем его как **Receiver **и настраиваем фильтр

![](http://android-helper.com.ua/images/uploads/2012/09/L0100_020.jpg)




 




Добавляем права на получение сообщения о загрузке




![](http://android-helper.com.ua/images/uploads/2012/09/L0100_030.jpg)


Инсталлим проект на AVD. Закрываем AVD. Запускаем через меню в Eclipse: Window > AVD Manager. Находим там наш эмулятор и запускаем вручную.




Когда он запустился, смотрим логи




	_onReceive android.intent.action.BOOT_COMPLETED  
	MyService onCreate  
	MyService onStartCommand_




Сработал BroadcastReceiver и запустил сервис.







Если после запуска AVD логи не отображаются, то откройте DDMS и во вкладке Devices явно выберите ваш AVD.




Надеюсь вам понравилась статья.




Ожидаю ваших комментариев.




Коды вы можете скачать [тут](http://android-helper.com.ua/forms)
Добрый день друзья.





Продолжая собирать у себя на сайте различного рода ценную информацию.





Я решил продолжить описание работы с fragments.





И как всегда на помощь мне пришла статья одного известного сайта.


<!-- more -->


Оригинал статьи [тут](http://startandroid.ru/uroki/vse-uroki-spiskom/175-urok-105-android-3-fragments-dinamicheskaja-rabota.html).





Прошу к прочтению.





В этом уроке:





- динамически работаем с фрагментами





Размещать статические фрагменты мы уже умеем. Но, ясно дело, что гораздо интереснее работать с ними динамически. Система позволяет нам добавлять, удалять и заменять фрагменты друг другом. При этом мы можем сохранять все эти манипуляции в BackStack и кнопкой Назад отменять. В общем, все удобно и красиво.





Создадим простое приложение с двумя  фрагментами, которое будет уметь:





- добавлять первый фрагмент  
- удалять первый фрагмент  
- заменять первый фрагмент вторым фрагментом  
- переключать режим сохранения в BackStack операций с фрагментами





В **strings.xml** добавим строки:


		<string name="frag1_text">Fragment 1</string>

    <string name="frag2_text">Fragment 2</string>

    <string name="add">Add</string>

    <string name="remove">Remove</string>

    <string name="replace">Replace</string>

    <string name="stack">add to Back Stack</string>







Создаем фрагменты. Как мы помним из прошлого урока, для этого нам нужны будут layout-файлы и классы, наследующие android.app.Fragment





 **fragment1.xml**:




	<?xml version="1.0" encoding="utf-8"?>

	<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"

    android:layout_width="match_parent"

    android:layout_height="match_parent"

    android:background="#77ff0000"

    android:orientation="vertical" >



    <TextView

        android:layout_width="wrap_content"

        android:layout_height="wrap_content"

        android:text="@string/frag1_text" >

    </TextView>



	</LinearLayout>







**fragment2.xml:**






	<?xml version="1.0" encoding="utf-8"?>

	<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"

    android:layout_width="match_parent"

    android:layout_height="match_parent"

    android:background="#7700ff00"

    android:orientation="vertical" >



    <TextView

        android:layout_width="wrap_content"

        android:layout_height="wrap_content"

        android:text="@string/frag2_text" >

    </TextView>



	</LinearLayout>






**Fragment1.java**:






	package com.example.fragmetns2;



	import android.os.Bundle;

	import android.support.v4.app.Fragment;

	import android.view.LayoutInflater;

	import android.view.View;

	import android.view.ViewGroup;

	public class Fragment1 extends Fragment {



	@Override

	public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {

		return inflater.inflate(R.layout.fragment1, null);

	}

	}









**Fragment2.java**:


	package com.example.fragmetns2;


	import android.os.Bundle;

	import android.support.v4.app.Fragment;

	import android.view.LayoutInflater;

	import android.view.View;

	import android.view.ViewGroup;



	public class Fragment2 extends Fragment {



	@Override

	public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {

		return inflater.inflate(R.layout.fragment2, null);

	}

	}


Все почти аналогично прошлому уроку, только убрали вызовы кучи lifecycle методов с логами.









Рисуем основное Activity.





**activity_main.xml**:



	<?xml version="1.0" encoding="utf-8"?>

	<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"

    xmlns:tools="http://schemas.android.com/tools"

    android:id="@+id/LinearLayout1"

    android:layout_width="match_parent"

    android:layout_height="match_parent"

    android:orientation="vertical" >



    <LinearLayout

        android:layout_width="wrap_content"

        android:layout_height="wrap_content"

        android:orientation="vertical" >



        <Button

            android:id="@+id/btnAdd"

            android:layout_width="wrap_content"

            android:layout_height="wrap_content"

            android:onClick="onClick"

            android:text="@string/add" >

        </Button>



        <Button

            android:id="@+id/btnRemove"

            android:layout_width="wrap_content"

            android:layout_height="wrap_content"

            android:onClick="onClick"

            android:text="@string/remove" >

        </Button>



        <Button

            android:id="@+id/btnReplace"

            android:layout_width="wrap_content"

            android:layout_height="wrap_content"

            android:onClick="onClick"

            android:text="@string/replace" >

        </Button>



        <CheckBox

            android:id="@+id/chbStack"

            android:layout_width="wrap_content"

            android:layout_height="wrap_content"

            android:text="@string/stack" >

        </CheckBox>

    </LinearLayout>



    <FrameLayout

        android:id="@+id/frgmCont"

        android:layout_width="match_parent"

        android:layout_height="match_parent" >

    </FrameLayout>



	</LinearLayout>






Три кнопки для добавления, удаления и замены фрагментов. Чекбокс для включения использования BackStack. И FrameLayout – это контейнер, в котором будет происходить вся работа с фрагментами. Он должен быть типа ViewGroup. А элементы Fragment, которые мы использовали на прошлом уроке для размещения фрагментов, нам не нужны для динамической работы. 





 **MainActivity.java**:


	package com.example.fragmetns2;



	import android.os.Bundle;

	import android.support.v4.app.FragmentActivity;

	import android.support.v4.app.FragmentTransaction;

	import android.view.View;

	import android.widget.CheckBox;



	public class MainActivity extends FragmentActivity {



	Fragment1 frag1;

	Fragment2 frag2;

	FragmentTransaction fTrans;

	CheckBox chbStack;



	@Override

	public void onCreate(Bundle savedInstanceState) {

		super.onCreate(savedInstanceState);

		setContentView(R.layout.activity_main);



		frag1 = new Fragment1();

		frag2 = new Fragment2();



		chbStack = (CheckBox) findViewById(R.id.chbStack);

	}



	public void onClick(View v) {

		fTrans = getSupportFragmentManager().beginTransaction();

		switch (v.getId()) {

			case R.id.btnAdd:

				fTrans.add(R.id.frgmCont, frag1);

				break;

			case R.id.btnRemove:

				fTrans.remove(frag1);

				break;

			case R.id.btnReplace:

				fTrans.replace(R.id.frgmCont, frag2);

			default:

				break;

		}

		if (chbStack.isChecked()) {

			fTrans.addToBackStack(null);

		}

		fTrans.commit();

	}

	}






В **onCreate** создаем пару фрагментов и находим чекбокс.





В **onClick** мы получаем менеджер фрагментов с помощью метода [getFragmentManager](http://developer.android.com/reference/android/app/Activity.html#getFragmentManager()). Этот объект является основным для работы с фрагментами. Далее, чтобы добавить/удалить/заменить фрагмент, нам необходимо использовать транзакции. Они аналогичны транзакциям в БД, где мы открываем транзакцию, производим операции с БД, выполняем commit. Здесь мы открываем транзакцию, производим операции с фрагментами (добавляем, удаляем, заменяем), выполняем commit.





Итак, мы получили FragmentManager и открыли транзакцию методом [beginTransaction](http://developer.android.com/reference/android/app/FragmentManager.html#beginTransaction()). Далее определяем, какая кнопка была нажата:





если **Add**, то вызываем метод [add](http://developer.android.com/reference/android/app/FragmentTransaction.html#add(int, android.app.Fragment)), в который передаем id контейнера (тот самый FrameLayout из main.xml) и объект фрагмента. В итоге, в контейнер будет помещен Fragment1





если **Remove**, то вызываем метод [remove](http://developer.android.com/reference/android/app/FragmentTransaction.html#remove(android.app.Fragment)), в который передаем объект фрагмента, который хотим убрать. В итоге, фрагмент удалится с экрана.





если **Replace**, то вызываем метод [replace](http://developer.android.com/reference/android/app/FragmentTransaction.html#replace(int, android.app.Fragment)), в который передаем id контейнера и объект фрагмента. В итоге, из контейнера удалится его текущий фрагмент (если он там есть) и добавится фрагмент, указанный нами.





Далее проверяем чекбокс. Если он включен, то добавляем транзакцию в BackStack. Для этого используем метод [addToBackStack](http://developer.android.com/reference/android/app/FragmentTransaction.html#addToBackStack(java.lang.String)). На вход можно подать строку-тэг. Я передаю null.





Ну и вызываем [commit](http://developer.android.com/reference/android/app/FragmentTransaction.html#commit()), транзакция завершена.





Давайте смотреть, что получилось. Все сохраняем, запускаем приложение.





![](http://android-helper.com.ua/images/uploads/2012/09/L0105_010.jpg)




Жмем **Add**





![](http://android-helper.com.ua/images/uploads/2012/09/L0105_020.jpg)





появился первый фрагмент.









Жмем **Remove**





![](http://android-helper.com.ua/images/uploads/2012/09/L0105_030.jpg)




фрагмент удалился.









Еще раз добавим первый фрагмент – жмем **Add**. И жмем **Replace**





![](http://android-helper.com.ua/images/uploads/2012/09/L0105_040.jpg)




первый фрагмент заменился вторым.





Жмем кнопку **Назад**. Приложение закрылось, т.к. все эти операции с фрагментами не сохранялись в BackStack. Давайте используем эту возможность.





Снова запускаем приложение и включаем чекбокс** add to Back Stack**





![](http://android-helper.com.ua/images/uploads/2012/09/L0105_050.jpg)



Выполняем те же операции: **Add**, **Remove**, **Add**, **Replace**. У нас добавится первый фрагмент, удалится первый фрагмент, добавится первый фрагмент, заменится вторым. В итоге мы снова видим второй фрагмент. Теперь жмем несколько раз кнопку **Назад **и наблюдаем, как выполняются операции, обратные тем, что мы делали. Когда транзакции, сохраненные в стеке закончатся, кнопка Назад закроет приложение.





Т.е. все достаточно просто и понятно. Скажу еще про пару интересных моментов.





Я в этом примере выполнял всего одну операцию в каждой транзакции. Но, разумеется, их может быть больше.





Когда мы удаляем фрагмент и не добавляем транзакцию в BackStack, то фрагмент уничтожается. Если же транзакция добавляется в BackStack, то, при удалении, фрагмент не уничтожается (onDestroy не вызывается), а останавливается (onStop).









В качестве самостоятельной работы: попробуйте немного изменить приложение и добавлять в один контейнер сразу два фрагмента. Возможно, результат вас удивит ) 





Надеюсь что вам понравилась статья.





Жду ваших комментариев.





Коды вы можете скачать [тут](http://android-helper.com.ua/forms)







От себя хочу также добавить, что коды которые я предоставляю, работают до 1.6 версии.


Добрый день друзья.





Сегодня я покажу вам как можно звонить из своего приложения.





Прошу к прочтению.


 <!-- more -->


Создадим activity_main.xml:


	<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"

    xmlns:tools="http://schemas.android.com/tools"

    android:layout_width="match_parent"

    android:layout_height="match_parent" >



    <EditText

        android:id="@+id/editText1"

        android:layout_width="wrap_content"

        android:layout_height="wrap_content"

        android:layout_alignParentLeft="true"

        android:ems="10"

        android:inputType="numberSigned" >



        <requestFocus />

    </EditText>



    <Button

        android:id="@+id/button1"

        android:layout_width="wrap_content"

        android:layout_height="wrap_content"

        android:layout_alignParentTop="true"

        android:layout_toRightOf="@+id/editText1"

        android:text="Звонок" />



	</RelativeLayout>








Создаем MainActivity.java:


	package com.example.call_to_phone;



	import android.app.Activity;

	import android.content.Intent;

	import android.net.Uri;

	import android.os.Bundle;

	import android.view.Menu;

	import android.view.View;

	import android.view.View.OnClickListener;

	import android.widget.Button;

	import android.widget.EditText;



	public class MainActivity extends Activity implements OnClickListener {



	private EditText callNumber;



	@Override

	public void onCreate(Bundle savedInstanceState) {

		super.onCreate(savedInstanceState);

		setContentView(R.layout.activity_main);

		callNumber = (EditText) findViewById(R.id.editText1);

		Button callButton = (Button) findViewById(R.id.button1);

		callButton.setOnClickListener(this);



	}



	@Override

	public boolean onCreateOptionsMenu(Menu menu) {

		getMenuInflater().inflate(R.menu.activity_main, menu);

		return true;

	}



	@Override

	public void onClick(View arg0) {

		if (callNumber != null) {

			String number = String.format("tel:%s", callNumber.getText().toString());

			startActivity(new Intent(Intent.ACTION_CALL, Uri.parse(number)));

		}

	}

	}








Как вы видите при нажатии на кнопку мы сразу начинаем звонок.





Для вызова нужно писать:



	String number = String.format("tel:%s", callNumber.getText().toString());

	startActivity(new Intent(Intent.ACTION_CALL, Uri.parse(number)));







Как видите все очень быстро из без проблем.





Прошу оценить статью и дать пару комментариев.





Коды вы можете скачать [тут](http://android-helper.com.ua/forms)
Продолжим описание android программирования.





Все вы наверное видели красивые widget у себя на рабочем столе телефона.





Вы угадали, сегодня речь пойдет именно о них.





Ну что поехали.


 <!-- more -->


Оригинал статьи [тут](http://www.mobilab.ru/articles/109/).





С начала этого года (прим. автора с 2007 года) команда разработчиков **Android** упорно работала над созданием нового релиза, который получил название**Android 1.5**. В его состав входит **AppWidget framework**, предназначенный для создания виджетов, которые пользователь может размещать на своем домашнем экране. Виджеты могут импортировать и отображать в удобной для пользователя форме информацию из Ваших Android приложений. Например, можно создать виджет, который будет отображать список невыполненных дел или давать информацию об играющей в фоновом режиме музыке.





![](http://android-helper.com.ua/images/uploads/2012/09/Awidget.png)





Когда пользователь перетаскивает виждет на домашний экран, он фактически резервирует место, на котором будет отображаться контент из Вашего приложения. Кроме того, пользователь может взаимодействовать с Вашим приложением через виджет, например, приостанавливать проигрывание музыки. Если у Вас есть сервис, работающий в фоновом режиме, Вы можете обновлять виджет по собственному графику, или использовать стандартный механизм из **AppWidget framework**.





Виджет представляет собой BroadcastReceiver скрещенный с XML описанием параметров виждета. **AppWidget framework**связывается с Вашим виджетом через радиовещание, когда требуется обновление. Обновления строятся и посылаются с помощью RemoteViews, включающий контент, для отображения на домашней странице.





Вы без особого труда можете создать виджет для своего приложения. Давайте создадим виджет для Android приложения "Слово дня" ([исходники](http://code.google.com/p/wiktionary-android/source/browse/#svn/trunk/SimpleWiktionary)). Я не буду рассматривать здесь это приложение, а сосредоточусь на самом виджете.





Прежде всего нужно создать XML описание виджета, указав там область домашнего экрана, которую Вы хотели бы зарезервировать для своего виджета, начальный слой для отображения, а также частоту обновления информации. Домашний экран **Android** разбит на ячейки, так что указанные вами размеры округляются до размеров ячеек. Это может сбить с толку. Возможно вам поможет вот эта формула





Минимальный размер в dip=(Число ячеек * 74dip)-2dip





В нашем примере мы хотим создать виджет, который будет занимать 2 ячейки в ширину и 1 в высоту. Это значит, что минимальный размер должен составлять 146dip x 72dip. Мы хотим, чтобы информация обновлялась раз в день, то есть через каждые 86,400,000 миллисекунд. XML metadata имеет вид:






	<appwidget-provider

    xmlns:android="http://schemas.android.com/apk/res/android"

    android:minWidth="146dip"

    android:minHeight="72dip"

    android:initialLayout="@layout/widget_message"

    android:updatePeriodMillis="86400000"

    />




Теперь давайте сопоставим эти XML данные и BroadcastReceiver в AndroidManifest:




	<!-- Broadcast Receiver that will process AppWidget updates -->

	<receiver android:name=".WordWidget" android:label="@string/widget_name">

    <intent-filter>

        <action android:name="android.appwidget.action.APPWIDGET_UPDATE" />

    </intent-filter>

    <meta-data android:name="android.appwidget.provider" android:resource="@xml/widget_word" />

	</receiver>



	<!-- Service to perform web API queries -->

	<service android:name=".WordWidget$UpdateService" />







Давайте напишем код для BroadcastReceiver, который будет управлять **AppWidget** запросами. Чтобы помочь виджету управлять различными радиовещательными событиями, разработчики написали класс **AppWidgetProvider**. Важно отметить, что мы запустим фоновый сервис, чтобы выполнять обновления. Это связано с тем, что BroadcastReceivers - потомок Application Not Responding (ANR) таймера, который может предложить пользователю закрыть приложение, если запрос выполняется слишком долго. Выполнение веб запроса может занимать несколько секунд, поэтому мы используем именно сервисы, чтобы избежать ANR таймаутов.



	/**

	 * Определяем простой виджет, который отображает слово дня. Для обновлений

	 * мы порождаем фоновой сервис {@link Service} для выполнения API запросов.

	 */

	public class WordWidget extends AppWidgetProvider {

    @Override

    public void onUpdate(Context context, AppWidgetManager appWidgetManager,

        int[] appWidgetIds) {

        // Чтобы предотвратить любые ANR таймацты, мы выполняем обновление в сервисе.

        context.startService(new Intent(context, UpdateService.class));

    }

 

    public static class UpdateService extends Service {

        @Override

        public void onStart(Intent intent, int startId) {

            // Выполняем сегодняшнее обновление виджета.

            RemoteViews updateViews = buildUpdate(this);

 

            // Помещаем обновление этого выджета на домашний экран

            ComponentName thisWidget = new ComponentName(this, WordWidget.class);

            AppWidgetManager manager = AppWidgetManager.getInstance(this);

            manager.updateAppWidget(thisWidget, updateViews);

        }

 

        /**

                     * Строим обновление виджета, чтобы показать текущее слово.

                     * Заблокируем пока не получим online ответ.

         */

        public RemoteViews buildUpdate(Context context) {

            // Берем название месяца из ресурсов

            Resources res = context.getResources();

            String[] monthNames = res.getStringArray(R.array.month_names);

 

            // ищем текущий месяц и день

            Time today = new Time();

            today.setToNow();

 

            // Заголовок страницы в вмде "Wiktionary:Word of the day/March 21"

            String pageName = res.getString(R.string.template_wotd_title,

                monthNames[today.month], today.monthDay);

            RemoteViews updateViews = null;

            String pageContent = "";

 

            try {

                // Пытаемся послать запрос Wiktionary API для получения слова дня

                SimpleWikiHelper.prepareUserAgent(context);

                pageContent = SimpleWikiHelper.getPageContent(pageName, false);

            } catch (ApiException e) {

                Log.e("WordWidget", "Couldn't contact API", e);

            } catch (ParseException e) {

                Log.e("WordWidget", "Couldn't parse API response", e);

            }

 

            // Используем регулярное выражение для парсинга слов и их описания

            Pattern pattern = Pattern.compile(SimpleWikiHelper.WORD_OF_DAY_REGEX);

            Matcher matcher = pattern.matcher(pageContent);

            if (matcher.find()) {

                // Выполняем обновление контента виджета

                updateViews = new RemoteViews(context.getPackageName(), R.layout.widget_word);

 

                String wordTitle = matcher.group(1);

                updateViews.setTextViewText(R.id.word_title, wordTitle);

                updateViews.setTextViewText(R.id.word_type, matcher.group(2));

                updateViews.setTextViewText(R.id.definition, matcher.group(3).trim());

 

                // Когда пользователь кликает на виджет, запускается страница Wiktionary.

                String definePage = res.getString(R.string.template_define_url,

                        Uri.encode(wordTitle));

                Intent defineIntent = new Intent(Intent.ACTION_VIEW, Uri.parse(definePage));

                PendingIntent pendingIntent = PendingIntent.getActivity(context,

                        0 /* no requestCode */, defineIntent, 0 /* no flags */);

                updateViews.setOnClickPendingIntent(R.id.widget, pendingIntent);

 

            } else {

                // Слово дня не найдено, показываем ошибку

                updateViews = new RemoteViews(context.getPackageName(), R.layout.widget_message);

                CharSequence errorMessage = context.getText(R.string.widget_error);

                updateViews.setTextViewText(R.id.message, errorMessage);

            }

            return updateViews;

        }

 

        @Override

        public IBinder onBind(Intent intent) {

            // Мы не хотим привязываться к этому сервису

            return null;

        }

    }

	}

 


Все. Мы написали виджет для приложения Wiktionary "Слово дня". Когда требуется обновление, мы с помощью online API получаем новые данные. **AppWidget framework** автоматически запрашивает у нас обновления, например в момент добавления виджета на экран или согласно своему расписанию - раз в день.





Вообще виджеты стоит создавать для отображения не очень часто обновляемых данных (не чаще чем раз в час). Старайтесь обновлять информацию как можно реже и предусмотрите возможность ручного обновления.





Созданные таким образом виджеты можно размещать на любом домашнем экране, поддерживающим **AppWidget framework**.





Спасибо вам, за то что вы с нами.





Ожидаем ваших комментариев.







Коды вы можете скачать [тут](http://android-helper.com.ua/forms)
Добрый день друзья.





Я продолжаю собирать информацию по android программированию у себя на сайте.





Сегодня я нашел достойную статью. Которую следует прочесть как экспертам так и начинающим.





Речь сегодня пойдет о Push-notification.


<!-- more -->


Оригинал статьи [тут](http://startandroid.ru/uroki/vse-uroki-spiskom/164-urok-99-service-uvedomlenija-notifications.html).





Читаем, комментируем.









В принципе, **уведомления **– отдельная от **сервисов **тема. Но чаще всего уведомления используются именно в сервисах, поэтому я решил дать эту тему сейчас.





В андроид (версии < 3) есть строка вверху экрана. Называется она статус-бар. Туда обычно в виде иконок сваливаются различные уведомления для пользователя (новые письма, смс и прочие). Пользователь открывает статус бар – видит там чуть более подробную инфу о событии. Дальше он может либо стереть это уведомление, либо нажать на него и перейти непосредственно к событию.





В этом уроке научимся все это проделывать. Для начала разберем уведомление на логические составляющие, чтобы проще было понять как его создавать и отправлять.





**Первая часть** – то, что видно в статус-баре, когда уведомление только приходит – иконка и текст. Текст потом исчезает и остается только иконка.





**Вторая часть** – то, что мы видим, когда открываем статус бар (тянем вниз). Там уже полноценный View с иконкой и двумя текстами, т.е. более подробная информация о событии.





**Третья часть** – то, что произойдет, если мы нажмем на View из второй части. Тут обычно идет вызов Activity, где мы можем просмотреть полную информацию и обработать событие.





Кроме этого есть еще несколько возможностей, по которым совсем кратко пробежимся в конце урока.





Создадим приложение и сервис. Сервис, как будто загружает файл и посылает уведомление, по нажатию на которое будет открываться приложение и отображать имя файла.









**activity_main.xml**:


	<?xml version="1.0" encoding="utf-8"?>

	<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"

    android:layout_width="fill_parent"

    android:layout_height="fill_parent"

    android:orientation="vertical" >



    <Button

        android:id="@+id/btnStart"

        android:layout_width="wrap_content"

        android:layout_height="wrap_content"

        android:onClick="onClickStart"

        android:text="Start" >

    </Button>



    <Button

        android:id="@+id/btnStop"

        android:layout_width="wrap_content"

        android:layout_height="wrap_content"

        android:onClick="onClickStop"

        android:text="Stop" >

    </Button>



    <TextView

        android:id="@+id/tv"

        android:layout_width="fill_parent"

        android:layout_height="wrap_content"

        android:text="" >

    </TextView>



	</LinearLayout>


Кнопки для старт/стопа сервиса и TextView для отображения результата





Создаем сервис **MyService**.java и прописываем его в манифесте. В манифесте же настроим сервис так, чтобы он работал в отдельном процессе. Для этого надо в его атрибуте process написать двоеточие и какое-нить слово. В итоге у вас должен получится следующий файл манифест:



	<manifest xmlns:android="http://schemas.android.com/apk/res/android"

    package="com.example.push_notification"

    android:versionCode="1"

    android:versionName="1.0" >



    <uses-sdk

        android:minSdkVersion="8"

        android:targetSdkVersion="15" />



    <application

        android:icon="@drawable/ic_launcher"

        android:label="@string/app_name"

        android:theme="@style/AppTheme" >

        <activity

            android:name=".MainActivity"

            android:label="@string/title_activity_main" >

            <intent-filter>

                <action android:name="android.intent.action.MAIN" />



                <category android:name="android.intent.category.LAUNCHER" />

            </intent-filter>

        </activity>



        <service

            android:name="MyService"

            android:process=":myservice" >

        </service>

    </application>



	</manifest>








Система эту строку добавит к package сервиса и, тем самым, получит название нового процесса, в котором и запустит сервис





 ![](http://android-helper.com.ua/images/uploads/2012/09/L0099_020.jpg)




**MainActivity.java**:



	package com.example.push_notification;



	import android.app.Activity;

	import android.content.Intent;

	import android.os.Bundle;

	import android.text.TextUtils;

	import android.view.View;

	import android.widget.TextView;



	public class MainActivity extends Activity {



	public final static String FILE_NAME = "filename";



	/** Called when the activity is first created. */

	@Override

	public void onCreate(Bundle savedInstanceState) {

		super.onCreate(savedInstanceState);

		setContentView(R.layout.activity_main);



		TextView tv = (TextView) findViewById(R.id.tv);



		Intent intent = getIntent();



		String fileName = intent.getStringExtra(FILE_NAME);

		if (!TextUtils.isEmpty(fileName)) {

			tv.setText(fileName);

		}

	}



	public void onClickStart(View v) {

		startService(new Intent(this, MyService.class));

	}



	public void onClickStop(View v) {

		stopService(new Intent(this, MyService.class));

	}



	}








В onCreate мы вытаскиваем из intent и кладем в TextView текст. Этот текст мы будем отправлять из сервиса через уведомление.



**onClickStart** и **onClickStop** – это обработчики кнопок. Стартуют и останавливают сервис.







**MyService.java**:




	package com.example.push_notification;



	import java.util.concurrent.TimeUnit;

	import android.app.Notification;

	import android.app.NotificationManager;

	import android.app.PendingIntent;

	import android.app.Service;

	import android.content.Intent;

	import android.os.IBinder;



	public class MyService extends Service {



	NotificationManager nm;



	@Override

	public void onCreate() {

		super.onCreate();

		nm = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);

	}



	@Override

	public int onStartCommand(Intent intent, int flags, int startId) {

		try {

			TimeUnit.SECONDS.sleep(5);

		} catch (InterruptedException e) {

			e.printStackTrace();

		}

		sendNotif();

		return super.onStartCommand(intent, flags, startId);

	}



	void sendNotif() {

		// 1-я часть

		Notification notif = new Notification(R.drawable.ic_launcher, "Text in status bar", System.currentTimeMillis());



		// 3-я часть

		Intent intent = new Intent(this, MainActivity.class);

		intent.putExtra(MainActivity.FILE_NAME, "somefile");

		PendingIntent pIntent = PendingIntent.getActivity(this, 0, intent, 0);



		// 2-я часть

		notif.setLatestEventInfo(this, "Notification's title", "Notification's text", pIntent);



		// ставим флаг, чтобы уведомление пропало после нажатия

		notif.flags |= Notification.FLAG_AUTO_CANCEL;

		notif.number = 3;



		// отправляем

		nm.notify(1, notif);

	}



	@Override

	public IBinder onBind(Intent arg0) {

		return null;

	}

	}







В **onCreate **получаем менеджер уведомлений – [NotificationManager](http://developer.android.com/reference/android/app/NotificationManager.html). Он нам понадобится, чтобы отправить уведомление.





В **onStartCommand **запускаем паузу на 5 секунд (эмулируем закачку файла) и после этого отправляем уведомление. Именно из-за этой паузы мы и используем другой процесс, чтобы не тормозило основное приложение.





В **sendNotif **мы создаем и отправляем уведомление. Правда, немного в иной последовательности, что я описывал выше. Сначала первая часть, потом третья, потом вторая.





Первая часть – создаем [Notification](http://developer.android.com/reference/android/app/Notification.html). В конструкторе указываем иконку и текст, которые будут видны в статус-баре. Также мы здесь указываем время. Обычно это текущее время. Но можно указать и прошлое и будущее. По этому времени уведомления будут отсортированы в статус-баре и в его раскрытой части.





Третья часть – создаем Intent, который мы бы использовали для вызова нашего Activity. Туда помещаем имя загруженного файла. Activity его достанет и поместит в TextView. Далее мы оборачиваем этот Intent в PendingIntent, с помощью метода [getActivity](http://developer.android.com/reference/android/app/PendingIntent.html#getActivity(android.content.Context, int, android.content.Intent, int)). На вход ему передаем контекст и Intent. Второй параметр не используется (так написано в хелпе). А четвертый – это флаги, влияющие на поведение PendingIntent. Они не относятся к теме урока, мы их не используем.





Теперь этот созданный PendingIntent содержит информацию о том, что надо вызывать Activity, а также объект Intent, который для этой цели надо использовать. Это будет использовано при нажатии на уведомлении.





Вторая часть – вызываем метод [setLatestEventInfo](http://developer.android.com/reference/android/app/Notification.html#setLatestEventInfo(android.content.Context, java.lang.CharSequence, java.lang.CharSequence, android.app.PendingIntent)). Передаем на вход контекст, текст-заголовок, подробный текст и PendingIntent. Теперь, когда мы откроем статус-бар, мы увидим два этих текста (заголовок и подробный). А, когда нажмем на уведомление, система использует PendingIntent для запуска Activity.





Далее мы для созданного уведомления ставим флаг [FLAG_AUTO_CANCEL](http://developer.android.com/reference/android/app/Notification.html#FLAG_AUTO_CANCEL), чтобы оно исчезло из статус-бара после нажатия. По умолчанию оно не исчезает и продолжает висеть.





Далее вызываем метод [notify](http://developer.android.com/reference/android/app/NotificationManager.html#notify(int, android.app.Notification)) для менеджера уведомлений и передаем туда ID и созданное уведомление. ID используется, если мы хотим изменить или удалить уведомление.





Все сохраним, запустим.





![](http://android-helper.com.ua/images/uploads/2012/09/device-2012-09-05-163359.png)




Жмем **Start **и сразу закрываем приложение кнопкой **Назад**.





Проходит 5 сек и появляется уведомление (первая часть)





![](http://android-helper.com.ua/images/uploads/2012/09/device-2012-09-05-163430.png)







Жмем на уведомление.





Открывается наше приложение (третья часть) и в TextView появляется текст, переданный из сервиса.





![](http://android-helper.com.ua/images/uploads/2012/09/device-2012-09-05-163441.png)




Теперь вкратце пробежимся по остальным интересным возможностям уведомлений.





### Обновление старого или новое уведомление





Если вы создадите новое уведомление и отправите его (notify) с тем же ID, что и у уже существующего уведомления, то новое заменит старое. Таким образом, вы можете уведомления обновлять.





Если же надо показать новое уведомление, то используйте другой ID.





### Удаление





Чтобы убрать уведомление из статус-бара, используется метод [cancel](http://developer.android.com/reference/android/app/NotificationManager.html#cancel(int)) у менеджера уведомлений. На вход подается ID. Либо используйте метод [cancelAll](http://developer.android.com/reference/android/app/NotificationManager.html#cancelAll()), чтобы удалить все уведомления.





### Звук





Если хотите, чтобы уведомление появилось со стандартным звуком, добавьте флаг [Notification.DEFAULT_SOUND](http://developer.android.com/reference/android/app/Notification.html#DEFAULT_SOUND) в поле уведомления [defaults](http://developer.android.com/reference/android/app/Notification.html#defaults).





А для использования своих звуков используется поле [sound](http://developer.android.com/reference/android/app/Notification.html#sound).





Чтобы проиграть файл с **SD**:





_notif.sound = Uri.parse("file:///sdcard/notification/ringer.mp3");_





Чтобы использовать какую-либо из стандартных мелодий, используем **Content Provider**:





_notif.sound = Uri.withAppendedPath(Audio.Media.INTERNAL_CONTENT_URI, "6");_





Подробнее [здесь](http://developer.android.com/guide/topics/ui/notifiers/notifications.html#Sound).





### Вибра





Если хотите, чтобы уведомление появилось со стандартной виброй, добавьте флаг [Notification.DEFAULT_VIBRATE](http://developer.android.com/reference/android/app/Notification.html#DEFAULT_VIBRATE) в поле уведомления defaults.





А для использования своей комбинации вибры используется поле [vibrate](http://developer.android.com/reference/android/app/Notification.html#vibrate). В это поле помещается массив long-чисел. Первое – длительность паузы (в миллисекундах) перед началом вибрирования, второе – длительность вибрирования, третье – длительность паузы, четвертое – длительность вибрирования … и т.д. Т.е. создаете свою комбинацию пауз и вибрирования. И мобила при получении уведомления вам ее провибрирует.





Подробнее [здесь](http://developer.android.com/guide/topics/ui/notifiers/notifications.html#Vibration).





Для работы вибры необходимо прописать права [VIBRATE](http://developer.android.com/reference/android/Manifest.permission.html#VIBRATE) в манифесте.





### Индикатор





Если хотите, чтобы уведомление появилось с миганием индикатора, добавьте флаг [Notification.DEFAULT_LIGHTS](http://developer.android.com/reference/android/app/Notification.html#DEFAULT_LIGHTS) в поле уведомления defaults.





А для использования своей комбинации мигания индикатора используются поля





[ledARGB](http://developer.android.com/reference/android/app/Notification.html#ledARGB) – здесь задается цвет





[ledOnMS](http://developer.android.com/reference/android/app/Notification.html#ledOnMS) – время «горения»





[ledOffMS](http://developer.android.com/reference/android/app/Notification.html#ledOffMS) – время «не горения»





И в поле [flags](http://developer.android.com/reference/android/app/Notification.html#flags) надо добавить флаг [Notification.FLAG_SHOW_LIGHTS](http://developer.android.com/reference/android/app/Notification.html#FLAG_SHOW_LIGHTS).





В итоге индикатор будет мигать с заданными значениями и с заданным цветом. В хелпе написано, что не все девайсы поддерживают разные цвета. Поэтому выбранный вами цвет не гарантируется.





Подробнее [здесь](http://developer.android.com/guide/topics/ui/notifiers/notifications.html#Lights).





### Число





У Notification есть поле [number](http://developer.android.com/reference/android/app/Notification.html#number). Вы можете поместить туда число больше нуля и оно отобразится на уведомлении.





Например, при notif.number = 3 уведомление будет выглядеть так:





![](http://android-helper.com.ua/images/uploads/2012/09/L0099_070-300x210.jpg)





### Флаги





Добавляются в поле flags





[FLAG_INSISTENT](http://developer.android.com/reference/android/app/Notification.html#FLAG_INSISTENT) – звук уведомления будет повторяться, пока не откроют статус-бар





[FLAG_ONGOING_EVENT](http://developer.android.com/reference/android/app/Notification.html#FLAG_ONGOING_EVENT) – уведомление появляется не в обычной секции, а в ongoing (постоянные). Уведомления из этой секции не удаляются при нажатии кнопки очистки уведомлений.





[![](http://android-helper.com.ua/images/uploads/2012/09/L0099_080-300x210.jpg)](http://android-helper.com.ua/images/uploads/2012/09/L0099_080.jpg)





[FLAG_NO_CLEAR ](http://developer.android.com/reference/android/app/Notification.html#FLAG_NO_CLEAR)– уведомление не удалится при очистке всех уведомлений





Не очень понимаю, в чем разница между ongoing и тем, что уведомление не удалится после нажатия на кнопку очистки всех уведомлений. Но флаги такие есть, и я о них упомянул.





Надеюсь вам статья понравилась.





Ожидаю ваших комментариев!





Коды вы можете скачать [тут](http://android-helper.com.ua/forms)
Добрый день друзья.





Сегодня один из моих товарищей, посоветовал один хороший сайт.





Некоторые материалы, я буду брать от туда.





Сегодня я бы хотел поделиться информацией о Screen Density и чем отличаются dp от px.


<!-- more -->


Прошу к прочтению. Оригинал статьи [тут](http://startandroid.ru/materialy/pamjatka/40-edinitsy-izmerenija-chem-otlichaetsja-dp-dip-ot-px-screen-density.html).





Для указания ширины, высоты и отступов View-элементов используются различные [единицы измерения](http://developer.android.com/guide/topics/resources/more-resources.html#Dimension) (ЕИ):





**dp** или **dip** - Density-independent Pixels. Абстрактная ЕИ, позволяющая приложениям выглядеть одинаково на различных экранах и разрешениях.





**sp** - Scale-independent Pixels. То же, что и dp, только используется для размеров шрифта в View элементах





**pt** - 1/72 дюйма, определяется по физическому размеру экрана. Эта ЕИ [из типографии](http://en.wikipedia.org/wiki/Point_(typography)).





**px** – пиксел, не рекомендуется использовать т.к. на разных экранах приложение будет выглядеть по-разному.





**mm** – миллиметр, определяется по физическому размеру экрана





**in** – дюйм, определяется по физическому размеру экрана





Давайте разбираться, чем они отличаются друг от друга.





in, mm и pt – неизменны относительно друг друга. Всегда **1 in = 25,4 mm** и **1 in = 72 pt**. Это классические единицы измерения. Т.е. задаете, например, кнопке ширину = 1 in и она должна отобразиться шириной в один дюйм, независимо от разрешения и диагонали экрана.





Что такое px, думаю, тоже понятно. Если у вас есть устройство с экраном шириной 480 px и вы создали кнопку шириной 240 px, то эта кнопка займет в ширину ровно пол-экрана. Но если вы откроете ваше приложение на устройстве с экраном с меньшим разрешением, то соотношение  изменится, например:  
- если разрешение 320х240, ширина экрана = 240 px. Кнопка займет уже не пол-экрана в ширину, а весь экран  
- если же разрешение 1280х800, ширина = 800 px. Кнопка опять же будет занимать в ширину не пол-экрана, а чуть меньше трети





![](http://android-helper.com.ua/images/uploads/2012/09/20110811_L0007_L_differentResolutions.jpg)





А ведь экран приложения – это обычно не одна кнопка, а набор из многих элементов и все они будут расползаться или сжиматься на разных разрешениях. Поэтому использовать px при разработке НЕ рекомендуется.





Для того, чтобы избежать таких ситуаций на разных разрешениях рекомендуется использовать dp (и sp). Его можно определить, как масштабируемый px. За степень масштабируемости отвечает **[Screen Density](http://developer.android.com/guide/practices/screens_support.html)**. Это коэффициент, который используется системой для вычисления значения dp.  На текущий момент есть 5 значений этого коэффициента:  
- low (**ldpi**) = 0,75  
- medium (**mdpi**) = 1  
- tv (**tvdpi**) = 1,33  
- high (**hdpi**) = 1,5  
- extra high (**xhdpi**) = 2





Т.е. когда для экрана стоит режим **mdpi**, то **1 dp = 1 px**. Т.е. кнопка шириной 100 dp будет выглядеть также как и кнопка шириной 100 px.





Если, например, у нас экран с низким разрешением, то используется режим **ldpi**. В этом случае **1 dp = 0,75 px**. Т.е. кнопка шириной 100 dp будет выглядеть так же как кнопка шириной 75 px.





Если у нас экран с высоким разрешением, то используется режим **hdpi **или **xhdpi**. **1 dp = 1, 5 px** или **2 px**. И кнопка шириной 100 dp будет выглядеть так же как кнопка шириной 150 px или 200 px.





Т.е. при различных разрешениях используются различные Density режимы, которые позволяют приложениям масштабироваться и выглядеть если не одинаково, то, по крайне мере, похоже на всех экранах.





Рассмотрим пример. Предположим у нас есть три устройства (характеристики реальны и взяты из спецификаций):





HTC **Wildfire **S: 3,2 inch, 480x320 px, 180 dpi  
HTC **Desire**: 3,7 inch, 800x480 px, 252 dpi  
HTC **Flyer**: 7 inch, 1280x800 px, 170 dpi





Я создам такой экран:





![](http://android-helper.com.ua/images/uploads/2012/09/20110811_L0007_L_DesireScreen.jpg)





Это несколько кнопок, в которых ширина и размер шрифта определены с использованием разных единиц измерения. На каждой кнопке для наглядности я написал ее ширину (**layout_width**) и размер шрифта (**textSize**) через запятую. Обратите внимание, что ширина всех кнопок кроме последней одинакова. Так происходит потому, что 1 in = 72 pt = 25,4 mm в любом случае, а для данного экрана также 1 in = 252 px = 252 dp. Шрифты также везде одинаковы, т.к. размер шрифта по умолчанию равен 14 sp и в данном случае равен 14 px.





xml-код:

	<?xml version="1.0" encoding="utf-8"?> 

	<LinearLayout 

	xmlns:android="http://schemas.android.com/apk/res/android" 

	android:orientation="vertical" 

	android:layout_width="fill_parent" 

	android:layout_height="fill_parent"> 

	<Button 

	android:id="@+id/button1" 

	android:layout_height="wrap_content" 

	android:layout_width="1in" 

	android:text="1 inch, default"> 

	</Button> 

	<Button 

	android:id="@+id/button2" 

	android:layout_height="wrap_content" 

	android:layout_width="72pt" 

	android:text="72 pt, default"> 

	</Button> 

	<Button 

	android:id="@+id/button3" 

	android:layout_height="wrap_content" 

	android:layout_width="25.4mm" 

	android:text="25.4 mm, default"> 

	</Button> 

	<Button 

	android:id="@+id/button4" 

	android:layout_height="wrap_content" 

	android:layout_width="252px" 

	android:text="252 px, 14 px" 

	android:textSize="14px"> 

	</Button> 

	<Button 

	android:id="@+id/button5" 

	android:layout_height="wrap_content" 

	android:layout_width="252dp" 

	android:textSize="14sp" 

	android:text="252 dp, 14 sp"> 

	</Button> 

	<Button 

	android:id="@+id/button6" 

	android:layout_width="wrap_content" 

	android:layout_height="wrap_content" 

	android:text="wrap_content, default"> 

	</Button> 

	</LinearLayout>


  




Посмотрим, как это будет выглядеть на экранах других устройств:





![](http://android-helper.com.ua/images/uploads/2012/09/20110811_L0007_L_ALLScreensMDI.jpg)





Для всех экранов я поставил режим **mdpi**. Скриншоты экранов смасштабированы к одному размеру для наглядности. Надо понимать, что на самом деле диагонали экранов существенно отличаются, а наша цель – добиться, чтобы приложение выглядело одинаково на различных устройствах.





Мы видим, что на всех экранах 1 px остался равен 1 dp (т.к. режим mdpi). И in, pt и mm сохранили свои пропорции (1; 72; 25,4) относительно друг друга. Но обратите внимание, что 1 in уже не равен 252 px на экранах Wildfire и Flyer. Это потому, что у этих устройств другое соотношение диагонали экрана и разрешения:  
- у **Wildfire **экран с** dpi = 180**, т.е. 1 in = 180 px, поэтому первая кнопка (с шириной = 1 inch) теперь короче, чем кнопка с шириной 252 px.   
- для **Flyer**, соответственно,** dpi = 170**.





Видно, что приложение выглядит достаточно по разному на трех экранах. Так было бы, если бы не существовало коэфициента Screen Density. Но он есть и давайте смотреть, чем он полезен. Я включу режим **ldpi **для **Wildfire **и **xhdpi **для **Flyer**. **Desire **оставляю в **mdpi**.





![](http://android-helper.com.ua/images/uploads/2012/09/20110811_L0007_L_ALLScreensSMHDI.jpg)





Ширина кнопок указанная в in, mm, pt неизменна, на эти единицы измерения режимы Density влияния не имеют. Нам интересны четвертая и пятая кнопки. Видим, что на экранах Wildfire и Flyer отличаются размеры px и dp, т.к. мы сменили mdpi на ldpi и xhdpi. Для Wildfire 1 dp стал равен 0,75 px, а для Flyer 1 dp = 2 px. Также видим, что изменился шрифт на кнопках, где размер шрифта был указан по умолчанию или в sp-единицах. Он так же, как и dp смасштабировался благодаря Density режимам. А шрифт, размер которого был указан в px (четвертая кнопка) оставался неизменным и на Wildfire выглядит крупным, а на Flyer – мелким.





Отлично видно, что адекватнее всего перенос на другие экраны перенесли пятая и шестая кнопки. Для пятой кнопки используются dp и sp. Для шестой кнопки – ширина = wrap_content и размер шрифта по умолчанию. А кнопки с in, mm, pt и px статичны и на разных экранах выглядят по-разному. Наверняка, есть случаи, когда необходимо использовать именно эти единицы измерения. Но в основном старайтесь использовать dp (для ширины, высоты и т.д.) и sp (для размера шрифта).





Конечно Density не дает масштабирования абсолютно пропорциального разнице в разрешениях экрана. Погрешность есть, но она невелика и является вполне приемлемой платой за способность приложения «сохранять форму» на разных устройствах.





Кем именно устанавливаются Density режимы для различных экранов – я не знаю. Но подозреваю, что производителями устройств/экранов. Еще мне интересно, можно ли эти режимы переключать при работе устройства. Думаю, чуть позже я найду ответы на эти вопросы.





Для создания этого материала я использовал различные конфигурации экранов, которые можно создавать самому:





![](http://android-helper.com.ua/images/uploads/2012/09/20110811_L0007_L_ScreenConfigs.jpg)





Вы наверно обратили внимание, что в папке Андроид-проекта в Eclipse есть папки **drawable **c суффиксами hdpi, ldpi, mdpi:





![](http://android-helper.com.ua/images/uploads/2012/09/20110811_L0007_L_drawable.jpg)





Папка drawable используется для хранения изображений, а суффиксы дают понять системе из какой именно drawable использовать картинки при текущем Density режиме. Подробнее об этом можно почитать в [хелпе](http://developer.android.com/guide/topics/resources/providing-resources.html). Кстати, там же вы найдете уже изученный нами **–****land**, который связан с горизонтальной ориентацией экрана. Будем по мере изучения Андроид знакомиться с остальными.





Спасибо, что вы с нами.





Ваши комментарии будут уместны :)





Также не забудьте подписаться на бесплатный курс.
Добрый день друзья.  
В одном из проэктов я столкнулся с задачей обрабатывать нажатия на сенсорный экран.  
Долго искал материалы, и мои поиски увенчались успехом.  
Ниже я приведу статью, которая описывает как с этим работать.  
Прошу к прочтению.





  






Занимаясь программированием под Android необходимо знать, как взаимодействовать с сенсорным экраном — главным устройством ввода на большинстве Android устройств. В этой статье будет рассмотрено:



<!-- more -->




  * Низкоуровневое взаимодействие с тачскрином, нужное прежде всего для разработки игр.




  * Класс MotionEvent



  * Обработка MotionEvent'ов




  * Работа с MultiTouch.



  * Некоторые высокоуровневые методы обработки прикосновений.






Также будут приведены различные примеры…





#### Отступление по поводу Лога





Так как в дальнейшем в этой статье мы будем активно использовать Log, я кратко расскажу про него(те, кто уже знаком с логом Андроида, могут благополучно пропустить этот раздел статьи).  
В Android имеется собственный лог, куда могут писать все желающие приложения от Dvalvik VM до вашего приложения. Все сообщения в логе разделяются по приоритету (право выбирать приоритет сообщения, посылаемого в лог остается за вами)   
Для записи в лог достаточно вызвать один из статических методов класса Log, различающихся только приоритетом отсылаемых ими сообщений.  
Эти методы приведены ниже, по возрастанию приоритета:








  * Log.v(String tag, String msg) — VERBOSE



  * Log.d(String tag, String msg) — DEBUG



  * Log.i(String tag, String msg) — INFO



  * Log.w(String tag, String msg) — WARNING



  * Log.e(String tag, String msg) — ERROR



  * Log.wtf(String tag, String msg) — What a Terrible Failure






Также есть возможность отправлять в лог исключения. В этом случае добавляется еще один аргумент — Throwable tr. Например:








  * Log.v(String tag, String msg, Throwable tr)






Вывести окно Log'а в Eclipse можно так:  
**Window -> Show View -> Other -> Android -> LogCat**





#### Понятие о MotionEvent





Класс MotionEvent служит хранилищем данных о прикосновении (touch event). Каждый раз, когда пользователь проводит пальцем по экрану, или даже просто тапает, создается целая последовательность экземпляров класса **MotionEvent**: последовательность начинается, когда пользователь дотрагивается до экрана, продолжается, пока пользователь двигает палец по экрану, и кончается, когда пользователь поднимает палец. Таким образом получается три основных типа действия, которые описывает MotionEvent: опускание пальца, его передвижение и поднятие. Каждый MotionEvent хранит в себе информацию о типе действия, которое он описывает. Для этого в классе MotionEvent предусмотрены константы:








  * int MotionEvent.ACTION_DOWN — пользователь опускает палец на экран.



  * int MotionEvent.ACTION_MOVE — пользователь передвигает пальцем по экрану.



  * int MotionEvent.ACTION_UP — пользователь поднимает палец с экрана.






Узнать какое действие описывает данный MotionEvent можно с помощью метода **getAction()**.  
Стоит отметить, что существует еще один тип действия — MotionEvent.ACTION_CANCEL, который по сути является обозначением того, что последовательность завершена некорректно, то есть без MotionEvent.ACTION_UP. Все это будет объяснено подробнее на примере, но чуть позже.





#### Получение и обработка MotionEvent'ов





Теперь, когда мы получили общее представление о MotionEvent'ах, необходимо разобраться с тем, откуда нам их «брать». Существует 2 способа, разберем их по отдельности.








  * Первый способ является оптимальным, когда вы используете один из стандартных View. У класса View существует метод SetOnTouchListener(View.OnTouchListener l), аргументом которого является класс, реализующий интерфейс OnTouchListener. Этот метод позволяет назначить «слушателя» MotionEvent'ов. Интерфейс OnTouchListener обязует класс реализовывать метод public boolean OnTouch(View v,MotionEvent event), вторым аргументом которого и является нужный нам MotionEvent. Теперь каждый раз, когда пользователь будет прикасаться к экрану, Android будет вызывать наш метод OnTouch, давая ему в аргумент описание произошедшего действия, то есть MotionEvent. Рассмотрим подробнее на примере:  
Вот наш файл res/layout/main.xml:  
  
		<?xml version="1.0" encoding="utf-8"?> 
	
		<LinearLayout xmlns:android="schemas.android.com/apk/res/android" 
    	android:orientation="vertical" 
    	android:layout_width="fill_parent" 
    	android:layout_height="fill_parent" 
    	android:id="@+id/ll" 
	 	/> 


  
  
  
А вот наш Activity класс:  
	
	import android.app.Activity;
	import android.os.Bundle;
	import android.util.Log;
	import android.view.MotionEvent;
	import android.view.View;
	import android.view.View.OnTouchListener;
	import android.widget.LinearLayout; 
	
	  public class main extends Activity implements OnTouchListener{// Заставляем наш Activity класс воплощать интерфейс OnTouchListener

      /** Called when the activity is first created. */

      @Override

      public void onCreate(Bundle savedInstanceState) {

          super.onCreate(savedInstanceState);

          setContentView(R.layout.main);

          LinearLayout ll =(LinearLayout)this.findViewById(R.id.ll);//Достаем нужный View

          ll.setOnTouchListener(this);// Устанавливаем данный класс в качестве слушателя MotionEvent'ов для нашего LinearLayout

      } 

      @Override

      public boolean onTouch(View v, MotionEvent event)// Вот, собственно, метод, который и будет обрабатывать MotionEvent'ы.

      {

          int Action=event.getAction();

		  // С помощью метода getAction() получаем тип действия(ACTION_DOWN,ACTION_MOVE или ACTION_UP)

          StringBuilder str=new StringBuilder();

          str.append("\nActrion type: ");

		  //Дальше для лучшего восприятия(т.к. константы ACTION_DOWN,ACTION_MOVE и ACTION_UP числовые)

          //проводим switch по переменной Action и добавляем в наш StringBuilder название константы

          switch(Action)

         {

              case MotionEvent.ACTION_DOWN: str.append("ACTION_DOWN\n");break;

              case MotionEvent.ACTION_MOVE: str.append("ACTION_MOVE\n");break;

              case MotionEvent.ACTION_UP: str.append("ACTION_UP\n");break;

         }

          //С помощью методов getX() и getY() получаем координаты по оси x и y соответственно

          //Следует отметить, что точка 0 располагается в левом верхнем углу экрана.

          //Ось x направлена вправо

          //Ось y направлена вниз(чем ниже, тем больше координата).

          str.append("Location: ").append(event.getX()).append(" x ").append(event.getY()).append("\n");//Узнаем координаты

          str.append("Edge flags: ").append(event.getEdgeFlags()).append("\n");// Метод getEdgeFlags возвращает информацию о пересечении краев экрана

          str.append("Pressure: ").append(event.getPressure()).append("\n");// Узнаем давление

          str.append("Size: ").append(event.getSize()).append("\n"); // Узнаем размер указателя(места соприкосновения пальца с экраном)

          str.append("Down time: ").append(event.getDownTime()).append("ms\n");// Узнаем время, когда палец был опущен на экран в миллисекундах

          str.append("Event time: ").append(event.getEventTime()).append("ms");//узнаем текущее время(соответствующее обрабатываемому MotionEvent'у) в миллисекундах

          str.append(" Elapsed: ").append(event.getEventTime()-event.getDownTime());//Узнаем сколько времени прошло с момента опускания пальца, до текущего MotionEvent'а

          Log.v("Mytag", str.toString());//Для того, чтобы можно было отслеживать эти действия, записываем всю информацию о них в лог.

          return true;// Почему мы возвращаем true будет рассмотрено потом

      }

  	}







  
  
  
Понятно, что один класс может быть слушателем у нескольких View. Чтобы это учитывать метод onTouch принимает в аргумент View.



  * Второй способ является оптимальным, когда вы пишете свой View класс, который должен реагировать на прикосновения. У View есть метод onTouchEvent(MotionEvent event), который, собственно, и позволяет обрабатывать MotionEvent'ы. Рассмотрим на примере:  
Напишем свой класс SomeView:  
  

		package com.example.MotionEventExample1;

		import android.content.Context;
		import android.util.AttributeSet;
		import android.view.View;

		public class SomeView extends View {

    	// Сначала необходимо реализовать конструктор.

    	// Тут все просто - просто вызываем конструктор суперкласса

    	public SomeView(Context context, AttributeSet attrs) {

        super(context, attrs);

    	}
		}



	// Теперь приступаем непосредственно к обработке MotionEvent'ов.

	// Для этого нужно переписать метод onTouchEvent

		@Override

		public boolean onTouchEvent(MotionEvent event) {

			Float X = (Float) event.getX();

			Float Y = (Float) event.getY();

			int Action = event.getAction();

			String ActionString = "";

			switch (Action) {

			case MotionEvent.ACTION_DOWN:

				ActionString = "ACTION_DOWN";

				break;

			case MotionEvent.ACTION_MOVE:

				ActionString = "ACTION_MOVE";

				break;

			case MotionEvent.ACTION_UP:

				ActionString = "ACTION_UP";

				break;

			}

			Log.v("MyTag", "View OnTouchListener:\n" + "Coords: " + X.toString() + " x " + Y.toString() + "\nAction type: " +  ActionString);

			return true;

			}

		}
  


  
  
И наш /res/layout/main.xml:  
  


   	<?xml version="1.0" encoding="utf-8"?>

   	<LinearLayout xmlns:android="schemas.android.com/apk/res/android"

       android:orientation="vertical"

       android:layout_width="fill_parent"

       android:layout_height="fill_parent"

       >

   	<com.example.MotionEventExample1.SomeView

       android:layout_width="fill_parent"

       android:layout_height="fill_parent"

      android:id="@+id/sv"

  	/>

  	</LinearLayout>





  
Activity класс:  
   


	package com.example.MotionEventExample1;

	import android.app.Activity;
	import android.os.Bundle;

	public class main extends Activity {

	/** Called when the activity is first created. */

	@Override

	public void onCreate(Bundle savedInstanceState) {

		super.onCreate(savedInstanceState);

		setContentView(R.layout.main);

	}

	}


  






#### О том, что возвращают обработчики MotionEvent'ов





Как вы могли заметить, обработчики MotionEvent'ов должны возвращать boolean'овское значение. В примерах до этого мы просто всегда возвращали true. Так для чего же этим методам вообще нужно возвращать значение? Дело в том, что у одного View может быть несколько слушателей (например onTouchEvent в самом View и OnTouch у внешнего слушателя) и они имеют некоторый приоритет: OnTouch вызывается первым (если он вообще имеется), а уже после него может вызываться onTouchEvent. Вызов следующего по приоритету обработчика как раз зависит от возвращаемого текущим обработчиком значения (true — ничто не вызывается, false — вызывается следующий по приоритету, если таковой имеется). Таким образом Android позволяет нам разделять обязанности по обработке touch event'ов на несколько слушателей.





##### Drag and Drop





Вот мы и разобрались с основами обработки MotionEvento'ов. Для закрепления навыков напишем приложение, реализующее простенький Drag and Drop.  
  
Вот наш /res/layout/main.xml:  
  


   	<?xml version="1.0" encoding="utf-8"?>

  	<LinearLayout xmlns:android="schemas.android.com/apk/res/android"

       android:orientation="vertical"

       android:layout_width="fill_parent"

       android:layout_height="fill_parent"

       >

   	<com.example.dragdrop.SomeView

       android:layout_width="fill_parent"

       android:layout_height="fill_parent"

      android:id="@+id/sv"

  	/>

  	</LinearLayout>







 





Вот наш Activity класс:


	package com.example.dragdrop;
	
	import android.app.Activity;
	import android.os.Bundle;

	public class main extends Activity {

	/** Called when the activity is first created. */

	@Override

	public void onCreate(Bundle savedInstanceState) {

		super.onCreate(savedInstanceState);

		setContentView(R.layout.main);

	}

	}






А вот наш основной класс SomeView:

	package com.example.dragdrop;

	import android.content.Context;
	import android.graphics.Canvas;
	import android.graphics.Color;
	import android.graphics.Paint;
	import android.graphics.Paint.Style;
	import android.util.AttributeSet;
	import android.view.MotionEvent;
	import android.view.View;
	
	public class SomeView extends View {

	Paint paint;

	int X;

	int Y;

	final static int Radius = 20;



	public SomeView(Context context, AttributeSet attrs) {

		super(context, attrs);

		paint = new Paint();

		paint.setColor(Color.YELLOW);

		paint.setStyle(Style.FILL);

		X = 30;

		Y = 30;

	}



	@Override

	public boolean onTouchEvent(MotionEvent event) {

		X = (int) event.getX();

		Y = (int) event.getY();

		return true;

	}



	@Override

	protected void onDraw(Canvas canvas)// метод OnDraw вызвается Андроидом

										// тогда, когда нужно отрисовать данный

										// View

	{

		canvas.drawCircle(X, Y, Radius, paint);

		invalidate();// invalidate() нужен для того, чтобы оповестить Android,

						// что нужно выполнить метод OnDraw снова, без него View

						// не будет перериcовываться.

	}

	}





**Multitouch**





 





В Android, сколько-бы вы пальцев ни использовали, информация о всех них хранится в одном MotionEvent'е. Первый метод, который нужно узнать, если вы собираетесь использовать мультитач — getPointerCount(), который возвращает количество пальцев, зафиксированных на экране(Не всегда совпадает с реальным количеством из-за ограничений в железе). Каждому пальцу, находящемуся на экране, присваивается индекс и id. Индексы всегда начинаются с 0, id — не обязательно. Для понятности рассмотрим на примере.  
Первый палец опускается — ему присваивается index=0 и id=0  
Второй палец опускается — ему присваивается index=1 и id=1  
Первый палец поднимается — Второму пальцу присваивается index=0 (Индексы всегда начинаются с нуля), а id остается тем же  
Второй палец поднимается — MotionEvent'ов больше нет, вплоть до следушего прикосновения.  
Id всегда сохраняется за указателем(пальцем), так что мы всегда можем отследить какой угодно указатель.  
Когда мы разобрались с id и индексами, рассмотрим как получать свойства (координаты, величину и т. п. ) у конкретного указателя, когда их много. Для этого в классе MotionEvent существуют методы:getX(int Index)getY(int Index)getSize(int Index)и т. д., мы уже их рассматривали  
В аргумент эти методы принимают **индекс** указателя.  
Но так как индексы указателя могут меняться, а часто требуется отследить конкретный палец, то существует очень важный метод  getPointerId(int index), который позволяет по указанному индексу узнать id указателя.





 





Рассмотрим пример: перепишем наше приложение (Drag and Drop) так, чтобы оно воспринимало мультитач.  
(Важно: На эмуляторе мультитач не проверить, это можно сделать только на настоящем девайсе)  
Вот наш res/layout/main.xml  
   


   	<?xml version="1.0" encoding="utf-8"?>

   	<LinearLayout xmlns:android="schemas.android.com/apk/res/android"

       android:orientation="vertical"

       android:layout_width="fill_parent"

       android:layout_height="fill_parent"

       >

   	<com.example.multitouch.SomeView

       android:layout_width="fill_parent"

       android:layout_height="wrap_content"

      android:id="@+id/view"

      />

  	</LinearLayout> 

    
Наш Activity класс:


	package com.example.multitouch;

	import android.app.Activity;
	import android.os.Bundle;

	public class main extends Activity {

	/** Called when the activity is first created. */

	@Override

	public void onCreate(Bundle savedInstanceState) {

		super.onCreate(savedInstanceState);

		setContentView(R.layout.main);

	}

	}


А вот основной класс — SomeView:


	package com.example.multitouch;

	import android.content.Context;
	import android.graphics.Canvas;
	import android.graphics.Color;
	import android.graphics.Paint;
	import android.graphics.Paint.Style;
	import android.util.AttributeSet;
	import android.util.Log;
	import android.view.MotionEvent;
	import android.view.View;

	//Будем рисовать желтые круги под пальцами

	public class SomeView extends View {

	Paint paint;// нужен чтобы установить цвет.

	int[] X;

	int[] Y;

	final static int Radius = 20;

	int PointerCount;



	public SomeView(Context context, AttributeSet attrs) {

		super(context, attrs);

		paint = new Paint();

		paint.setColor(Color.YELLOW);

		paint.setStyle(Style.FILL);

		PointerCount = 0;

		X = new int[10];// Это будут массивы координат(будем воспринимать до 10

						// пальцев)

		Y = new int[10];

	}



	@Override

	public boolean onTouchEvent(MotionEvent event) {

		StringBuilder result = new StringBuilder(300);

		PointerCount = event.getPointerCount();

		for (int i = 0; i < PointerCount; i++) {

			int ptrId = event.getPointerId(i);

			X[i] = (int) event.getX(i);// Запоминаем координаты

			Y[i] = (int) event.getY(i);

			result.append("Pointer Index: ").append(i);

			result.append(", Pointer Id: ").append(ptrId).append("\n");

			result.append("Location: ").append(event.getX(i));

			result.append(" x ").append(event.getX(i)).append("\n");

			result.append("Pressure: ").append(event.getPressure(i));

			result.append("Size: ").append(event.getSize(i)).append("\n");

		}

		Log.v("Mytag", result.toString());// Выводим всю информацию в лог

		return true;

	}



	@Override

	protected void onDraw(Canvas canvas) {

		for (int i = 0; i < PointerCount; i++)// Смотрим сколько пальцев было на

												// экране и отрисовываем View

		{

			canvas.drawCircle(X[i], Y[i], Radius, paint);

		}

		invalidate();// invalidate() нужен для того, чтобы оповестить Android,

						// что нужно выполнить метод OnDraw снова, без него View

						// не будет перериовываться. }

	}

	}




**Другие способы взаимодействия с тачскрином**





 





Взаимодействие с экраном через MotionEvent'ы является довольно низкоуровневым, нужно это прежде всего для разработки игр. Для более узких, повседневных ситуаций в Android предусмотрен ряд интерфейсов, которые позволяют распознавать наиболее «популярные» touch event'ы:

- **OnClickListener** — onClick(View v)
- **OnFocusChangeListener** — onFocusChange(View v, boolean hasFocus)
- **OnKeyListener** — onKey(View v, int keyCode, KeyEvent event)
- **OnLongClickListener** — onLongClick(View v)
- и т. д.





 





Обрабатываются они аналогично, так что в пояснении не нуждаются.  
Больше информации о таких методах можно узнать здесь:  
[developer.android.com/reference/android/view/View.html ](http://developer.android.com/reference/android/view/View.html)





#### Для написания статьи использовались:








  * [developer.android.com](http://developer.android.com/)



  * Pro Android 2 — глава TouchScreens.






Спасибо за внимание.









Если вам понравилась статья. Прошу вас оставить комментарии и подписаться на рассылку.  
Всегда ваш, Андрей
Сегодня нашел очень интересную статью.





Вот ее содержание:





Всегда интересно знать, как пользователи работают с вашим приложением: какие функции наиболее востребованы, какие кнопки нажимаются, какие настройки меняются, какие ошибки совершаются. Неплохо так же представлять себе, что это за пользователи - какая версия прошивки у их девайсов, где они географически расположены и т.д. 





Такая информация неоценима для разработчика, ведь с ее помощью можно оптимизировать юзабилити, определиться с приоритеностью функционала, найти пути повышения продаж. Вопрос только как такую статистику собирать.


<!-- more -->


Самый простой путь - воспользоваться готовой системой сбора аналитической информации. Таких систем сейчас более чем достаточно ([1](http://www.foundersspace.com/tech/whats-the-best-analytics-service-for-apps/), [2](http://www.quora.com/What-is-the-best-Mobile-Analytics-service-for-iOS-apps-and-why)). Например:У каждой системы есть свои изюминки: real-time обновление статистики (Localitics), суперточность с отслеживанием уникальных ID каждого пользователя (Bango), наличие средств для проведения опроса пользователей (Apsalar), наличие средств для регулярной отправки уведомлений пользователям (BuzzBox) и т.д. Естественно, есть и море отличий: в интерфейсе, в средствах анализа, в наличии дополнительных API, в стоимости, в наборе поддерживаемых платформ и т.п. 





Принцип работы у всех систем примерно одинаков. Регистрируемся на сайте системы, получаем SDK и уникальный ключ. В приложение подключаем стороннюю библиотеку (единственный jar-файл из SDK). Добавляем код вызова функций, регистрирующих события в приложении. Релизим приложение. Ждем некоторое время, пока пользователи поработают в программе. Заходим на сайт системы и смотрим разнообразные аналитические отчеты. 





Вот, например, как ведется сбор данных в Apsalar:


	import com.apsalar.sdk.Apsalar;



	public void onCreate(Bundle savedInstanceState) {

	...

		Apsalar.startSession(this, "myapikey", "mypassword");

	..

	}



	/** уровень level пройден за countSeconds */

	public void onLevelPassed(int level, int countSeconds) {

	...

  	Apsalar.event("passed", "level", level, "duration", countSeconds);

	...

	}



API, как видите, тривиальное, так что технически добавить код для фиксации событий в приложении совсем не сложно. Количество событий и количество атрибутов у каждого события не ограничено, поэтому детализация собираемой информации может быть весьма высокой. 





Конечно, подобные системы сбора информации - это, прежде всего, инструмент аналитика, желающего увеличить доход от продажи приложения. И накапливаемая статистика событий в приложении - всего лишь первичный материал для анализа. Тот же Apsalar позволяет, например, проводить [Funnel Analysis, Engagment Analysis, Trending Analysis, Path Analysis, Event Analysis, Operational Analysis ](http://apsalar.com/apscience/features/).





Взять к примеру Funnel Analysis (воронку продаж). Если в вашем приложении пользователь должен сделать несколько шагов к совершению покупки (последовательно открыть несколько страниц, нажать несколько кнопок), то Funnel Analysis позволит увидеть, сколько пользователей (и каких именно) отсеивается на каждом шаге. Любопытно, что существуют системы монетизации, активно [использующие ](http://moneynews.ru/AuthorsArticle/14844/)подобную информацию.





Резюме. Готовых систем сбора аналитической информации для Android приложений сейчас множество, выбор широк. Многие из них бесплатные и, одновременно, обладают достойным функционалом. Подключаются подобные системы тривиально, весят "копейки" (10-30 kb), а пользу разработчику могут принести немалую. Единственное но: не у всех пользователей неограниченный трафик. Так что пользователи должны иметь возможность сбор статистики отключать.





**Update**: Полезная статья на хабре [Flurry Analytics. Как держать руку на пульсе приложения ](http://habrahabr.ru/blogs/android_development/122510/)





[Блог](http://apsalar.com/blog/)компании Apsalar.   
Еще пара сервисов: [Appoxee ](http://www.appoxee.com/), [AppFiguers ](http://www.appfigures.com/). По поводу Appoxee см. так же [how to create post app download engagement.](http://appsmarketing.mobi/deliver-post-app-download-engagement-appoxee-mobile/)





Спасибо [DV](http://derevyanko.blogspot.com/2011/07/android.html)
Добрый день друзья.





В предыдущих записях я писал как можно отправлять сообщения с помощью встроенной системы.





Сегодня же я решил поделится опытом отправки и приема сообщений без участия стандартных программ.





Приступим.


<!-- more -->


### Отправка сообщений





## 1. Дадим права отправки сообщений



	<uses-permission android:name="android.permission.SEND_SMS"></uses-permission>


## 2. Базовая функция отправки сообщений


	SmsManager sms = SmsManager.getDefault();

	sms.sendTextMessage("1-212-555-1212", null, "Привет, Android-helper.com.ua", null, null);








## 3. Опишем Activity для отправки.





Хочу отметить, что для получения статуса сообщение мы создадим BroadcastReceiver и зарегистрируем его.




	import android.app.Activity;

	import android.app.PendingIntent;

	import android.content.BroadcastReceiver;

	import android.content.Context;

	import android.content.Intent;

	import android.content.IntentFilter;

	import android.os.Bundle;

	import android.telephony.SmsManager;

	import android.util.Log;

	import android.view.View;

	import android.view.View.OnClickListener;

	import android.widget.Button;

	import android.widget.Toast;

	public class SMSFun extends Activity {

	// Button to trigger sending the SMS

	Button aButton;

	// PendingIntent to tell the SMS app to notify us

	PendingIntent sentPI;

	// The intent action we are using

    String SENT = "SMS_SENT";

    // The BroadcastReceiver that we use to listen for the notification back

    BroadcastReceiver br;

    @Override

	public void onCreate(Bundle savedInstanceState) {

        super.onCreate(savedInstanceState);

        setContentView(R.layout.main);

        // Create the Pending Intent

	sentPI = PendingIntent.getBroadcast(this, 0,

                new Intent(SENT), 0);

	aButton = (Button) this.findViewById(R.id.Button01);

        aButton.setOnClickListener(new OnClickListener() {

	public void onClick(View v) {

	SmsManager sms = SmsManager.getDefault();

	// send the message, passing in the pending intent, sentPI

        sms.sendTextMessage("1-212-555-1212", null, "Привет android-helper.com.ua", sentPI, null);  

        registerReceiver(br, new IntentFilter(SENT));       

	}});  

          

        // In order to receive the results via the pending intent we need

	// to register a new BroadcastReceiver and pay attention to the various

	// values we could get back

	br = new BroadcastReceiver(){

                @Override

	public void onReceive(Context ctx, Intent intent) {

                    switch (getResultCode())

                    {

                        case Activity.RESULT_OK:

                            Toast.makeText(getBaseContext(), "SMS sent", 

                                    Toast.LENGTH_SHORT).show();

                            break;

                        case SmsManager.RESULT_ERROR_GENERIC_FAILURE:

                            Toast.makeText(getBaseContext(), "SMS: Generic failure", 

                                    Toast.LENGTH_SHORT).show();

                            break;

                        case SmsManager.RESULT_ERROR_NO_SERVICE:

                            Toast.makeText(getBaseContext(), "SMS: No service", 

                                    Toast.LENGTH_SHORT).show();

                            break;

                        case SmsManager.RESULT_ERROR_NULL_PDU:

                            Toast.makeText(getBaseContext(), "SMS: Null PDU", 

                                    Toast.LENGTH_SHORT).show();

                            break;

                        case SmsManager.RESULT_ERROR_RADIO_OFF:

                            Toast.makeText(getBaseContext(), "SMS: Radio off", 

                                    Toast.LENGTH_SHORT).show();

                            break;

                    }

                    unregisterReceiver(br);

                }

            };    }

	}








###  Получение сообщений 





## 1. Права доступа







	<uses-permission android:name="android.permission.RECEIVE_SMS"></uses-permission>








## 2. Для того что бы получать сообщения, нужно создать BroadcastReceiver







	<receiver android:name=".SMSFunReceive">

     <intent-filter>

                <action android:name=

                   "android.provider.Telephony.SMS_RECEIVED" />

     </intent-filter>

	</receiver>

**Java**

	import android.content.BroadcastReceiver;

	import android.content.Context;

	import android.content.Intent;

	import android.os.Bundle;

	import android.telephony.SmsMessage;

	import android.util.Log;

	// This will run when an SMS message comes in.

	// We can see if we want to do something based upon the message

	// Perhaps launch an activity

	public class SMSFunReceive extends BroadcastReceiver 

	{

	@Override

	public void onReceive(Context ctx, Intent intent) 

	{

	Bundle bundle = intent.getExtras();        

	Object[] pdus = (Object[]) bundle.get("pdus");

	SmsMessage[] messages = new SmsMessage[pdus.length];

        

	for (int i = 0; i < messages.length; i++)
	{

	messages[i] = SmsMessage.createFromPdu((byte[])pdus[i]);

        

	Log.v("SMSFun","Body: " + messages[i].getDisplayMessageBody());

	Log.v("SMSFun","Address: " + messages[i].getDisplayOriginatingAddress());

	//If say we wanted to do something based on who sent it

	if (messages[i].getDisplayOriginatingAddress().contains("2125551212"))

         {

	// we could launch an activity and pass the data

	Intent newintent = new Intent(ctx, SecretMessage.class);
	newintent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);         // Pass in data

	newintent.putExtra("address", messages[i].getDisplayOriginatingAddress());

	newintent.putExtra("message", messages[i].getDisplayMessageBody());

	ctx.startActivity(newintent);         

	}

	}

	}

	}








## 5. Финальный аккорд. Создадим Activity для отображения сообщения.


	import android.app.Activity;

	import android.os.Bundle;

	import android.widget.TextView;

	public class SecretMessage extends Activity {

    public void onCreate(Bundle savedInstanceState) {

        super.onCreate(savedInstanceState);

        setContentView(R.layout.secret);

        // Get the extra data

        Bundle extras = getIntent().getExtras(); 

        String address = extras.getString("address");

        String message = extras.getString("message");

        

        TextView addresstv = (TextView) findViewById(R.id.addresstv);

        TextView messagetv = (TextView) findViewById(R.id.messagetv);

        

        messagetv.setText(message);

        addresstv.setText(address);

    }

	}



**xml**

	<?xml version="1.0" encoding="utf-8"?>

	<LinearLayout 
		xmlns:android="http://schemas.android.com/apk/res/android" 
		android:layout_width="wrap_content" 
		android:layout_height="wrap_content">

		<TextView 
			android:layout_height="wrap_content" 
			android:id="@+id/addresstv" 
			android:text="address" 
			android:layout_width="fill_parent"
			android:layout_gravity="fill_horizontal" />

		<TextView 
			android:layout_height="wrap_content" 
			android:id="@+id/messagetv" 
			android:text="message" 
			android:layout_width="fill_parent" 
			android:layout_gravity="fill_horizontal" />

	</LinearLayout>

Если понравилась статья, нажми рассказать друзьям.


Полный код программы [тут](http://android-helper.com.ua/forms).


Добрый день друзья.





Многие разработчики сталкиваются с проблемой проектирования пользовательского интерфейса.





Все ищут идеи у других программ, которые скачивают с [Google Play](https://play.google.com/store)


<!-- more -->


Я же в своей статье хочу дать несколько полезных ссылок на сайты где вы сможете черпнуть идей для своего приложения.





#### [Проектируя для кончиков пальцев.](http://justnotes.ru/proektiruya-dlya-konchikov-palcev.html)





Использование пальцев перевернуло устоявшиеся представления о настольных приложениях. Дизайнер интерактивной среды Джош Кларк объясняет, о чём важно помнить при проектировании интерфейсов для мобильных сенсорных экранов, и сравнивает удобные для пальцев тач-интерфейсы iPhone, iPad и Android.





#### [Дизайн пользовательского интерфейса приложения для iPhone](http://justnotes.ru/dizayn-polzovatelskogo-interfeysa-prilozheniya-dlya-iphone.html)





Необходимые знания: ничего кроме внимания к деталям и основ Photoshop  
Инструменты: ручка, бумага, Photoshop (или другой графический редактор, позволяющий экспортировать png-файлы)  
Продолжительность работы: 2-5 часов.  
  
Проектирование для устройств на платформе iOS4 сильно отличается от разработки сайтов. Сара Парментер объясняет, как создать качественный пользовательский интерфейс приложения.





### [Очень много различных примеров](http://pttrns.com/)









Если у вас есть еще какие то статьи или сайты пишите, я с радость буду их добавлять.
Добрый день всем.





В предыдущем посте я писал о возможности отправки писем с вашего приложения.





Сегодня я бы хотел написать, как же можно отправлять SMS с вашего приложения.


 <!-- more -->


Вот код:


	Intent smsIntent = new Intent(Intent.ACTION_VIEW);

	smsIntent.setType("vnd.android-dir/mms-sms");

	smsIntent.putExtra("address", "12125551212,121212121212"); // C версии 2.2 можно отправлять множеству получателей

	smsIntent.putExtra("sms_body","Body of Message");

	startActivity(smsIntent);



Несколько дней наз столкнулся с задачей отправки почты с приложения.





И как оказалось и тут google позаботился о нас.


 <!-- more -->


Пример кода:







	Intent it = new Intent(Intent.ACTION_SEND);   

	it.putExtra(Intent.EXTRA_EMAIL, "me@abc.com");   

	it.putExtra(Intent.EXTRA_TEXT, "The email body text");   

	it.setType("text/plain");   

	context.startActivity(Intent.createChooser(it, "Choose Email Client")); 










После этого будет вызван диалог выбора почтового клиента.


Добрый день друзья.





Сегодня нашел очень увлекательную [статью](http://derevyanko.blogspot.com/2012/01/android.html) которая помогает проанализировать коды вашей программы.





Надеюсь, что вам понравится!


<!-- more -->


А вот и описание:

























Одним из путей улучшения качества кода приложения является [регулярное](http://habrahabr.ru/blogs/code_review/135234/#habracut)применение статических анализаторов кода. Статический анализ кода позволяет находить ошибки в коде, отслеживать несоблюдение стандарта кодирования, находить "плохой" код, который может привести к проблемам в будущем, а так же неэффективный код, негативно сказывающийся на производительности в настоящем, строить метрики кода, находить полностью или частично одинаковые фрагменты кода и так далее. 





Для разработчиков, ведущих кодирование в одиночку, статические анализаторы вещь вообще неоценимая. Ведь им некому показать код своего приложения. Так что "электронный помощник", способный грамотно выполнить "code review", может им здорово пригодится.





Вопрос - какие статические анализаторы кода доступны разработчику Android приложений? Для Java статических анализаторов существует множество (см. список [lint ](http://en.wikipedia.org/wiki/Lint_(software))приложений для Java в википедии), но не все они умеют работать с Android-приложениями и, тем более, учитывать их специфику.





Мне удалось отыскать следующие статические анализаторы кода, которые умеют работать с Android-приложениями:








  * [Lint ](http://tools.android.com/tips/lint). "Родной" анализатор кода для Android, входит в состав Android SDK начиная с r16.



  * [FindBugs ](http://findbugs.sourceforge.net/)(бесплатный).



  * [Checkstyle ](http://checkstyle.sourceforge.net/)(бесплатный).



  * [CodePro Analytix ](http://code.google.com/intl/ru-RU/javadevtools/codepro/doc/index.html)(бесплатный).



  * [PMD ](http://pmd.sourceforge.net/)(бесплатный)



  * Motodev App Validator (бесплатный). Входит в состав среды разработки[MOTODEV Studio for Android ](http://developer.motorola.com/docstools/motodevstudio/). Есть [online ](http://developer.motorola.com/testing/app-validator/)вариант.



  * [Klocwork Solo ](http://www.klocwork.com/products/solo/)(платный). Доступна триальная версия



  * [JTest ](http://www.parasoft.com/jsp/products/jtest.jsp)от Parasoft (платный).



  * [Julia ](http://juliasoft.com/)(платный). Доступен бесплатный [online ](http://julia.scienze.univr.it/)вариант.






Далее представлены результаты сравнения всех этих анализаторов - какой анализатор что умеет, для чего предназначен, насколько удобно пользоваться, какие ошибки находит, насколько он полезен на практике. 





Чтобы было интереснее сравнивать, я "натравил" каждый из этих анализаторов на одно и то же тестовое приложение. В качестве такового я взял код одной из ранних версий моего приложения [Animated Widget Contact Launcher ](https://market.android.com/details?id=com.mobilityflow.awidget&hl=ru). Версию я выбрал годичной давности, багов и проблем в ней было вагон (с FindBugs на тот момент я был не знаком). Так что "что поискать" в ней точно было.





### Lint





[Lint ](http://tools.android.com/tips/lint)- анализатор кода, который поставляется вместе с Android SDK. Он появился совсем недавно, в версии r16. 





Lint нацелен на поиск проблем, связанных с ресурсами. Неиспользуемые ресурсы, ненужные или наоборот, отсутствующие, аттрибуты, неоптимальные конструкции в layout и т.д. Список проблем, которые ищет Lint, приведен [здесь ](http://tools.android.com/tips/lint-checks). 





Работать с Lint очень удобно. Вызывать и настраивать его можно прямо из Eclipse. Для найденных ошибок показывается объяснение - в чем состоит ошибка и как ее исправить. Ошибки делятся на 3 уровня (error, warning, information). 





При проверке тестового приложения был выдан 101 warning. Все по существу - ложных срабатываний не было, за исключением пары сообщений об неиспользуемости ресурсов (и это при отсутствии библиотек; если же библиотеки используются, то разработчики прямо предупреждают о возможности ложных сообщений, так что будьте осторожны при чистке кода).









![](http://3.bp.blogspot.com/-UJ2JPXSVb9s/TwVtraTmfMI/AAAAAAAAAFQ/R32F2qPO1uk/s320/lint2.png)









###  





### FindBugs





FindBugs я пользуюсь уже почти год и очень доволен. Находит реальные ошибки в коде. Вот полный [список проблем ](http://findbugs.sourceforge.net/bugDescriptions.html), которые он умеет находить.





В декабре 2011, после длительного перерыва, FindBugs обновился с версии 1.3.9 до 2.0. Субъективно новая версия стала точнее, удобнее и быстрее предыдущей. Настраивается она теперь прямо из Eclipse (важно: в свойствах проекта, а не в свойствах workspace). Плагин для eclipse устанавливается с помощью location URL: `http://findbugs.cs.umd.edu/eclipse/` (в Eclipse выбрать `Help\Install new software`, ввести location URL в поле Work with).









![](http://2.bp.blogspot.com/-dKUxauuPo5s/TwV0S48r2zI/AAAAAAAAAFc/0cjP_W2wTuM/s320/findbugs_settings.jpg)









FindBugs нашел в тестовом приложении 12 ошибок при дефолтном уровне чувствительности. При максимальной чувствительности ошибок нашлось 137. При этом ложных срабатываний было всего 10 (анализатору не понравился способ именования классов в автоматические генерируемом файле ресурсов; этот файл нужно просто исключить из обработки в настройках FindBugs). Подавляющее большинство остальных ошибок я исправил в более поздних версиях.









![](http://4.bp.blogspot.com/-hybSpfAErHs/TwV0q3gJQhI/AAAAAAAAAFo/Q_9jti2d1oI/s320/findbugs_sample.jpg)









Приведу примеры ошибок, которые нашел FindBugs:








  * `Should be a static inner class` (вложенный класс не сделан статичным, хотя доступ к внешнему классу ему не нужен).



  * `Should this field be static?` (константа не объявлена как static)



  * `Switch statement found where one case falls through to the next case`(пропущен break)



  * `Comparison of String parameter using == or != in` (строки в Java небходимо сравнивать через equal)






Специфичных для Android правил в FindBugs пока нет. Но, возможно, со временем они появятся - разработчики [готовы идти навстречу пожеланиям пользователей.](http://groups.google.com/group/openintents/browse_thread/thread/b3a520a90254ce7f?pli=1)





###  





### Checkstyle





[Checkstyle ](http://checkstyle.sourceforge.net/)нацелен на проверку соблюдения стандарта кодирования. Проверка соблюдения правил именования, правил расстановки скобочек, правил оформления кода и т.д. - вот цель этого анализатора. Полный список правил можно посмотреть в [документации ](http://checkstyle.sourceforge.net/config_coding.html). Плагин для eclipse устанавливается с помощью location URL: `http://eclipse-cs.sf.net/update/`





После анализа тестового приложения Checkstyle выдал 8741(!) ворнинг. Я внимательно просмотрел все типы ворнингов.. и не нашел для себя ничего полезного. На мой взгляд - это совершенно не тот инструмент, который необходим индивидуальным разработчикам и небольшим командам. С другой стороны, его активно используют и [дорабатывают ](http://sevntu-checkstyle.github.com/sevntu.checkstyle/), так что видимо область применения у него все же есть.









![](http://3.bp.blogspot.com/-2S9FFxInHYo/TwV4wSDKRhI/AAAAAAAAAF0/xlOO_lzrCSc/s320/checkstyle_settings.png)









###  





### CodePro Analytix





[CodePro Analytix ](http://code.google.com/intl/ru-RU/javadevtools/codepro/doc/index.html)- разработка компании Instantiations. Google купил эту компанию и [сделал эти продукт бесплатным ](http://googlewebtoolkit.blogspot.com/2010/09/google-relaunches-instantiations.html), за что ему большое спасибо.





Заявленные [возможности CodePro Analytix ](http://code.google.com/intl/ru-RU/javadevtools/codepro/doc/index.html)впечатляют. [Аудит кода ](http://code.google.com/intl/ru-RU/javadevtools/codepro/doc/features/audit/audit.html)на основе нескольких различных наборов правил ("The Elements of Java Style", "Effective Java", "Potential Errors and Refactoring", "Security" и т.д.). Измерение кода с помощью различных метрик. Поиск "дублей" в коде - результатов копипаста. И т.д.





Провел аудит кода тестового приложения используя все возможные наборы правил. Получил: 152 предупреждения с уровнем серьезности High, 1246 - medium, 1062 - low. Для сравнения - анализ с помощью единственного набора правил "Code Pro Core" выдал 64 medium и 4 low предупреждения.









![](http://4.bp.blogspot.com/-RD18joLpJgo/TwWG7-5R8EI/AAAAAAAAAGM/l3WFRuLTkG8/s320/codepro_audit.png)









Что-же нашел Code Pro? Частично, результаты поиска пересеклись с результатами FindBugs и Lint. Но только частично. Большую часть ошибок составили минорные проблемы в коде, которые не были обнаружены другими анализаторами. Например:








  * `String literal can be replaced by a character literal`. В StringBuilder вместо append("\n") использовать append('\n').



  * `Badly located array declarators`. Массив объявлен как "String abc[]" вместо "String[] abc".



  * `Constant on right side of comparison`. Код "if (a == 5) { .. }" следует переписать так "if (5 == a") { .. }"



  * `Switch statements should include all possible enumeration constants`. В перечислимом типе 3 возможных значения, а в switch задействовано только 2 из них.



  * `Do not divide by powers of 2: use ">> 1" rather than "/ 2"`



  * `Invalid string literal: "Yes"`. Строки следует хранить в ресурсах, а не кодировать их жестко в код.



  * `Use charAt() rather than startsWith() when the constant is a single character string`. Код skinName.startsWith("/") можно переписать skinName.charAt(0) == '/'



  * `Define the initial capacity of StringBuilder instances`






Если не полениться и настроить Code Pro под себя, то инструмент оказывается весьма полезным. Возможно, некоторые рекомендации похожи на "ловлю блох".. но почему бы не привыкнуть писать более оптимальный код, если это возможно?





Кстати, юзабилити у Code Pro на высоте. Находясь в списке ошибок можно:








  * автоматически исправить ошибку (естестенно, автоматический рефакторинг кода поддерживается не для всех типов правил);



  * проигнорировать ошибку - она перестанет появляться в списке ошибок;



  * отключить правило, по которому была найдена ошибка;



  * настроить (!) параметры правила,






и так далее.





Кроме аудита, очень понравилось, как Code Pro ищет дубли. Незаменимая функция.









![](http://4.bp.blogspot.com/-yKmH44qnn_o/TwWG1iYOocI/AAAAAAAAAGA/6Feo9xpPQ9Y/s320/codepro_compare.png)









### PMD





[PMD ](http://pmd.sourceforge.net/)- еще один анализатор кода, типа Code Pro. Основное назначение - поиск неоптимального кода, проблем с производительностью, нарушений стиля кодирования, дублей в коде и т.д. Плагин PMD устанавливается с помощью location URL: `http://pmd.sourceforge.net/rules/android.html`





Примечательно, что в PMD реализовано [несколько правил, специфичных для Android ](http://pmd.sourceforge.net/rules/android.html)





Для тестового приложения PMD выдал около 2000 предупреждений. Примеры:








  * `Substitute calls to size() == 0 (or size() != 0) with calls to isEmpty()`



  * `Private field ''{0}'' could be made final; it is only initialized in the declaration or constructor.`



  * `UnnecessaryCaseChange: Using equalsIgnoreCase() is cleaner than using toUpperCase/toLowerCase().equals()`



  * `UnusedFormalParameter: Avoid unused {0} parameters such as ''{1}''. Avoid passing parameters to methods or constructors and then not using those parameters.`



  * `InefficientEmptyStringCheck: String.trim().length()==0 is an inefficient way to validate an empty String.`



  * `UseIndexOfChar: String.indexOf(char) is faster than String.indexOf(String).`



  * `BooleanInversion: Use bitwise inversion to invert boolean values`






Несмотря на то, что PMD генерирует множество лишних предупреждений, следует отметить, что и полезных подсказок он выдает множество. Так же как и Code Pro, PMD следует тщательно настраивать.





В PMD, так же как в Code Pro, реализована функция поиска повторяющихся участков кода. Визуализация найденных фрагментов, правда, похуже. Зато результаты поиска - другие, так что программы дополняют друг друга.









![](http://1.bp.blogspot.com/-07qFCT9CevQ/TwWOUNRVzfI/AAAAAAAAAGY/EBMZ6YGA2-U/s320/pmd.jpg)









###  





### Motodev App Validator





Motodev App Validator входит в состав среды разработки [MOTODEV Studio for Android ](http://developer.motorola.com/docstools/motodevstudio/). Прочитать про него можно в презентации [Static Analysis For Improved Application Performance And Quality Presentation (PDF) ](http://assets.en.oreilly.com/1/event/68/Static%20Analysis%20For%20Improved%20Application%20Performance%20And%20Quality%20Presentation.pdf)





Те, кто не использует MOTODEV Studio, могут попробовать [online вариант Motodev App Validator ](http://developer.motorola.com/testing/app-validator/)(требуется зарегистрироваться на сайте). 





Online вариант Motodev App Validator принимает на вход apk-файл приложения. К сожалению, 400 килобайтную apk-шку тестового приложения online вариант не заглотил - выдал ошибку. Мелкие приложение в 30-40 кб анализирует, а с "крупным" не работает. Пришлось [качать Motodev Studio ](http://developer.motorola.com/docstools/motodevstudio/download/)





Скачал, запустил. Для тестового приложения Application Validator выдал 101 предупреждение. Из них:








  * 75 - `"Drawable "XXX.png" does not exist in the "drawable-ldpi" folder. Add the appropriate "XXX.png" drawable to the "drawable-ldpi" folder."` - ничего нового.



  * 13 - `"Default layout file YYY.xml does not have an xlarge-specific version. This app may not have the look and feel expected on devices with extra large screens. Define an xlarge layout for YYY.xml or add <supports-screens android:xlargeScreens="false"> to the manifest file."` - так же ничего нового.



  * 4 - `"The import android.util.DisplayMetrics is never used ZZZ.java"` - ошибка, на которую умеет указывать сам Eclipse.



  * 1 - `"The value of the local variable AAA is not used"` - эту ошибку умеют находить многие анализаторы.



  * 3 - `"The static field A.B should be accessed in a static way ClassA.B"` - и эту тоже.






Интересным оказалось лишь одно сообщение - `"The application declares the permission android.permission.CALL_PHONE which implies the unsupported feature android.hardware.telephony..."`. Честно говоря, результаты работы не впечатлили.









![](http://1.bp.blogspot.com/-NHo6NN7u7ZY/TwZeDM5UqkI/AAAAAAAAAGw/EfpMA2g-Ong/s320/motodev_settings.png)









Впрочем, судя по списку правил, Application Validator умеет находить и более интересные вещи: незакрытые курсоры, недочеты Android Manifest, отсутствие перевода строки в локализованных ресурсах, ненужные или наоборот, пропущенные permissions и т.д.





###  





### Klocwork Solo for Java





[Klocwork Solo ](http://www.klocwork.com/products/solo/)- платный статический анализатор кода. По заверениям разработчиков, способен находить более 200 типов проблем, связанных с уязвимостью и надежностью кода. Анализатор умеет находить проблемы, специфичные для Android-приложений. Интегрируется с EClipse. Триальная 30-дневная версия доступна после регистрации на сайте. У триальной версии ограничение - не более 300 файлов в проекте.





Полный список правил, которые проверяет Kockwork Solo, можно посмотреть в[документации ](http://download.klocwork.com/docs/issuehelp/index.html). На настоящий момент правил, специфичных для Android, всего девять.









![](http://2.bp.blogspot.com/-EX-wZ8D7340/TwWqBFoC-LI/AAAAAAAAAGk/aaRqJPj4WPM/s320/klocwork_settings.png)









Для тестового приложения Kockwork Solo выдал 240 предупреждений. Неожиданно, очень интересных. Примеры:








  * `NPE.RET : Null pointer dereference of 'xy' where null is returned from a method`. В приложении имеется такой код: `Point xy = m_SA.getShortcutPosition(); Rect r = new Rect(0, 0, xy.x, xy.y);`. Функция getShortcutPosition() в отдельных случаях может возвращать null. Но в вызывающей функции проверки на null нет. Это типичная ошибка.



  * `NPE.COND : Null pointer dereference of 'xxx' where null comes from condition`. Объект xxx используется без проверки на null, а между тем, он запросто может быть равен null.



  * `RTC.CALL : Type cast from 'android.view.View' to 'android.widget.ImageButton' is redundant because method 'setTag' is defined in 'android.view.View'`. В приложении код такой:`((ImageButton)findViewById(R.id.hs_image)).setTag(combination)`. Т.е. анализатор обнаружил ненужное приведение типа.



  * `REDUN.FINAL : Redundant 'final' modifier` - приватный метод объявлен как final. Приватные методы всегда final, так что объявление излишне.



  * `JD.SYNC.IN : Field 'VarName' synchronized inconsistently.` - доступ к переменной VarName синхронизирован частично. Это ошибка - доступ должен либо всегда синхронизироваться, либо никогда.



  * `ANDROID.NPE : Null pointer dereference of 'window' in an Android application`. Код в приложении следующий: `Window window = activity.getWindow(); window.getDecorView().getWindowVisibleDisplayFrame(rect)` Т.е. не выполняется проверка window на null






Так что Kockwork Solo находит реальные ошибки, причем иные, чем FindBugs (списки дефектов, которые они обнаруживают, пересекаются незначительно). Лично меня очень заинтересовали ошибки типа NPE.RET и Android.NPE. Такие ошибки, судя по всему, не находит ни один другой анализатор.





Юзабилити у продукта не понравилось. В списке ошибок есть фильтрация, есть возможность указать статус ошибки. Но если указать статус "Ignored", то ошибка пропадает и не ясно, как ее вернуть. Если отфильтровать список, то часть ошибок из списка пропадает и опять же не ясно, как сбросить фильтр. Не интуитивно все как-то. В CodePro сделано удобнее.









![](http://1.bp.blogspot.com/-Lmwoy5r95EE/TwZ1c_3J7AI/AAAAAAAAAG8/YJ0REyWSlCQ/s320/klocwok_screen.jpg)









###  





### JTest от Parasoft





Триальную версию [Jtest ](http://www.parasoft.com/jsp/products/jtest.jsp)просто так скачать не дают. Так что этот анализатор я в работе проверить не смог. Судя по описанию - функциональность очень интересная. Например, JTest, так же как и Code Pro, умеет самостоятельно рефакторить код.





###  





### Julia





Julia - коммерческий анализатор кода Java / Android приложений. "Семантический инструмент, основанный на [математической теории ](http://www.juliasoft.com/public/Biblioteca/cade11.pdf)". 





Как указано на сайте разработчика, протестировать работу анализатора можно[online ](http://julia.scienze.univr.it/), загрузив в него jar-файл. У android приложения нет jar файла, есть apk (бинарный формат - другой). APK-файл анализатор принял.. но ни один из доступных способов анализа (Nullness, Termination, Check) ничего не выдал. Пишет - "there are no warnings". 





Загрузил первый попавшийся JAR - работает. Судя по всему, там неплохой анализ на "отсутствие проверки на null". Жаль, что apk-шки не грузятся.





**Update**: Написал разработчикам. Они мне подсказали, что можно экспортировать Android приложение в JAR-файл прямо из Eclipse. Экспортировал, загрузил в Julia.





Nullness analysis и Termination analysis результатов не выдали. Дело в том, что в демонстрационной online-версии для данных типов анализа существует ограничение: общее количество методов не должно превышать 10000 и 8500 соответственно. В тестовом приложении количество методов оказалось большим, так что процедура анализа принудительно останавливалась до завершения работы.





Третий тип анализа - "Checks", - выдал 286 предупреждений. По большей части, вот таких:








  * `[Classcast] A you sure that this cast from classA into classB is always legal?`



  * `[BadNames] Method XXX has a bad name`



  * `[Deadcode] Methos XXX is not reachable`



  * `[BadEq] Inefficient comparison with the empty string. Use isEmpty() instead`



  * `[Approximation] Unsafe comparison beween non-integral numbers.`



  * `[StaticFieldAccess] Modification of static field from a non-static context`(это что-то новенькое; другие анализаторы на такие ошибки не ругались).



  * `[Unused class] Class YYY is not used.`



  * `[Field access] Field XXX is never reach in reachable code.`



  * `[Useless call] Useless call toString()`



  * `[BadEq] Suspicious use of == rather then equals() to compare two java.lang.String`






В принципе, кое что интересно есть. Но: пользоваться очень неудобно (результаты выдаются в виде странички на флеш), поскольку сервис online, приходится "отдавать" исходники приложения в виде jar, что не всегда приемлемо.





**Update2**. Попросил разработчиков Julia провести анализ тестового приложения и прислать мне результаты. Они любезно согласились.





Termination analysis - это анализ кода на наличие бесконечных циклов и рекурсий в коде. Он выдал одно предупреждение. Анализатору не понравился код   
 
	private void expungeStaleEntries() {  
	Reference sv;  
	while ((sv = queue.poll()) != null) {  
	hash.remove(reverseLookup.remove(sv));  
	}  
	}  
  
из реализации SoftHashMap, взятой [отсюда ](http://www.javaspecialists.eu/archive/Issue098.html). Опасения анализатора понятны. Тем не менее, код правильный.





Nullness analysis проверяет в коде отсутствие необходимых и наличие излишних проверок на null. Таких предупреждений было выдано 187. Примеры ошибок:








  * `X1.java:57: is the return value of getY1 non-null?`



  * `X2.java:57: is the 0th actual parameter of parseInt non-null?`



  * `X3.java:69,70,72,78,105,109,178: is the return value of getY2 non-null?`



  * `X4.java:227,261,309: is the value of field mX1 non-null?`



  * `X5.java:84: is this nullness check useless?`



  * `X6.java:318,361: is the receiver of the call to iterator non-null?`



  * `X7.java:34: is the formal parameter srcRect non-null?`






Отмечу, что Kockwork Solo выдал всего 43 предупреждения, связанных с проверкой на null. Подробнее результаты, полученные Julia и Kockwork Solo, сравниваются ниже.





###  





### Напоследок. Сравнительные тесты





Ну как же без тестов... Многие анализаторы обнаруживают одни и те же типы проблемы в коде. Сравним, кто что находит.





#### Неверное сравнение строк





В Java строки надо сравнивать через equal. Между тем, по старой сишной привычке, можно сравнить строки через != и == и получить ошибку. Этот баг настолько распространен, что его ищут чуть ли не все анализаторы.





В тестовом приложении оказалось семь таких багов. Вот они:  
 
	1. widget_name == ""  
	2. title != adapter.getItem(i).Title  
	3. srcStr == "S"  
	4. m_K != ""  
	5. contact_name != m_B.getB().GetR(this)  
	6. contact_name == ""  
	7. name == "" ? "" : name + ": "  







#### Проблемы со switch





Для switch характерны следующие проблемы:








  * 1. Отсутствие default



  * 2. Пропущен break



  * 3. Switch выполняется по значению перечислимого типа. В "case" используются не все значения, входящие в перечислимый тип.



  * 4. Switch слишком маленький - например, в нем одно или два значения. Можно обойтись if/else.



  * 5. В двух case используется одинаковый код.






Далеко не всегда эти проблемы являются реальными ошибками. Тем не менее, анализаторы кода как правило считают своим долгом о них сообщить.





Разные анализаторы работают с разными типами проблем. Итак, вот как отработали анализаторы на тестовом приложении.







#### NP-анализ





Отсутствие проверки на null и, как результат, "NUll pointer exception" - одна из наиболее частых ошибок при разработке под Android. Другая сторона медали - излишние проверки. 





К слову сказать, FindBugs успешно отлавливает такую ошибку: вначале у объекта вызывается функция, а затем объект проверяется на null. 





Klocwork и Julia "заточены" под Android. И эта "заточенность" проявляется, прежде всего, в возможности NP-анализа. Как я писал вышел, Klocwork для тестового приложения выдал 43 NP-предупреждения, Julia - 187. Сравним, кто что нашел.





##### NP анализ. Файл 1





Проблема 1.1. `String action = intent.getAction(); if (action.equals("abc")) {..};` Переменная action может быть null. Проблему обнаружили обе программы.  
Проблема 1.2. `intent.getExtras().getInt(...);` Результат getExtras() не проверяется на null. Проблему обнаружили обе программы.   
Проблема 1.3. `Uri uri = intent.getData(); Integer.parseInt(uri.getQueryParameter("widget_id"))`. Оба анализатора сообщили об использовании uri без проверки uri на null. Julia дополнительно сообщила о том, что результаты работы uri.getQueryParameter на null не проверяются и в parseInt может быть передан null.  
Проблема 1.4. `WidgetContent wc = WidgetFabric.getWidgetContent(); wc.getFlagValue();`. Оба анализатора сообщили, что wc может быть null. В реализации getWidgetContent() действительно есть ветка кода, которая возвращает null.  
Проблема 1.5. `((Singleton)context.getApplicationContext()).getABC().Register();`Об этой проблеме сообщила только Julia. Функция getABC() может вернуть null и вызывать Register() нельзя. На самом деле, объект ABC создается в [синглетоне, реализованном поверх класса Application. ](http://derevyanko.blogspot.com/2010/12/android_26.html)Инициализируется он в момент запуска приложения и null быть не может. Однако, инициализация ABC проводится не в конструкторе синглетона, а в функции onCreate. Анализатор не знает про тонкости создания синглетона и предупреждает об ошибке, которая вряд ли возможна.





##### NP анализ. Файл 2





Проблема 2.1. `CheckBoxPreference pref = (CheckBoxPreference)getPreferenceScreen().findPreference("pref_name");`. findPreference может возвращать null.  
Проблема 2.2. `List list_skins = ((Singleton)this.getApplicationContext()).getSkinManager().getListSkins("skin_name");`Проблема аналогична 1.5. Функция getSkinManager может возвращать null, но только теоретически.  
Проблема 2.3. `int len_skins = list_skins.size();` Переменная list_skins действительно может быть null.  
Проблема 2.4. `for (int j = 0; j < len_skins; ++j) { array_skins[j] = list_skins.get(j).SkinTag; }` Результаты get не проверяются на null. Такая проверка необходима, если list_skins может содержать null. В приложении такого быть не может, так что проверка не нужна.  
Проблема 2.5. `String skin_name = (String) p.getEntries()[p.findIndexOfValue(skin_tag)];` Результат работы getEntries() не проверяется на null.  
Проблема 2.6. `CharSequence[] titles = res.getTextArray(idTitles); if (values[0].equals(svalue)) {...};` Значение values[0] не проверяется на null.  
Julia сообщила обо всех этих проблемах. Klocwork - только о 2.3.





##### NP анализ. Файл 3





Проблема 3.1. `m_AsyncTask = new AppInfoReceiverTask(mUtils.getList());` Эту ошибка нашла только Julia - переменная mUtils может быть null. На самом деле, mUtils инициализируется в onCreate (речь идет о наследнике Activity) и null быть не может.  
Проблема 3.2. `protected void onActivityResult(int requestCode, int resultCode, Intent data) { data.getExtras().getString(...);` Эту проблему нашли оба анализатора: data.getExtra может вернуть null.  
Проблема 3.3. `(LauncherContent)WidgetFabric.getWidgetContent()` Эту проблему нашел Klocwork. Julia ее пропустила.  
Проблема 3.4. `SpinnerItem selected_item = (SpinnerItem)spinner.getSelectedItem(); String s = selected_item.Title;`Функция getSelectedItem может вернуть null согласно документации. Проблему нашла только Julia  
Проблема 3.5. `ListView list_view = (ListView) dialog.findViewById(R.id.listview); list_view.setAdapter(new SelectImageAdapter(list_images) );` Теоретически, findViewById может вернуть null. На проблему указала только Julia.  
Проблема 3.6. `private final void remove_shortcut(AppInfo appInfo) { m_List.remove(appInfo); }` В функцию может быть передан null, appInfo на null не проверяется. Проблему нашла только Julia.  
Проблема 3.7. `for (SkinManager.SkinInfo skin : skins) { ... }` Переменная skins может содержать null. Проблему нашли оба анализатора.





Резюме. Julia находит почти все NP-ошибки, которые обнаруживает Klocwork, плюс еще ряд дополнительных. Одновременно, она генерирует довольно много ложных сообщений, которые на практике придется просто игнорировать. Самая большая проблема на мой взгляд - она не учитывает, что в Activity переменные инициализируются в onCreate, а не в конструкторе.





### Итоги





В итоге получается следующая картина. В настоящее время существует восемь доступных статических анализаторов кода для Android приложений: Lint, FindBugs, Checkstyle, CodePro, PMD, Motodev App Validator, Klocwork Solo, Julia. Основная специализация у них следующая:








  * Lint и Motodev App Validator - поиск проблем в ресурсах Android приложения;



  * FindBugs, Klocwork Solo и Julia - поиск ошибок в коде приложения;



  * Checkstyle - проверка соблюдения правил оформления кода и стандарта кодирования;



  * CodePro и PMD - поиск неоптимального кода, проблемного кода, поиск дублей.






FindBugs и Lint прекрасно работают "с нуля" - настраивать их практически не требуется. CodePro и PMD требуют тонкой настройки. Но если отключить в них ненужные проверки, они приносят реальную пользу. Motodev App Validator и Checkstyle мне показались не слишком полезными - на любителя. Klocwork Solo - находит ряд ошибок, которые не находят другие анализаторы. Он платный, но и триальную версию можно вполне успешно использовать для небольших приложений. Julia находит ряд NP-ошибок, которые не находит Klocwork, но при этом генерирует еще и множество ложных предупреждений (ошибка возможна, но только теоретически). К сожалению, воспользоваться бесплатной версией практически не возможно.

























 





 





 









 




Добрый день друзья.





Сегодня я бы хотел поделится с вами одной интересной темой.





Если вы когда нибудь использовали приложение Twitter у себя на устройстве, то видели, что если потянуть список вниз то появится что то типа этого:





[![](http://android-helper.com.ua/images/uploads/2012/07/device-2012-07-19-155609.jpg)](http://android-helper.com.ua/images/uploads/2012/07/device-2012-07-19-155609.jpg)


 <!-- more -->


[![](http://android-helper.com.ua/images/uploads/2012/07/device-2012-07-19-155634.jpg)](http://android-helper.com.ua/images/uploads/2012/07/device-2012-07-19-155634.jpg)





[![](http://android-helper.com.ua/images/uploads/2012/07/device-2012-07-19-155646.jpg)](http://android-helper.com.ua/images/uploads/2012/07/device-2012-07-19-155646.jpg)





Попробуем это написать сами.





Должно получится что то вроде этого:





[![](http://android-helper.com.ua/images/uploads/2012/07/device-2012-07-19-162848.png)](http://android-helper.com.ua/images/uploads/2012/07/device-2012-07-19-162848.png)





[![](http://android-helper.com.ua/images/uploads/2012/07/device-2012-07-19-162904.png)](http://android-helper.com.ua/images/uploads/2012/07/device-2012-07-19-162904.png)





[![](http://android-helper.com.ua/images/uploads/2012/07/device-2012-07-19-162911.png)](http://android-helper.com.ua/images/uploads/2012/07/device-2012-07-19-162911.png)





[![](http://android-helper.com.ua/images/uploads/2012/07/device-2012-07-19-162918.png)](http://android-helper.com.ua/images/uploads/2012/07/device-2012-07-19-162918.png)





Создадим разметку нашего загрузчика:







[xml]

<?xml version="1.0" encoding="utf-8"?>

<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"

    android:id="@+id/pull_to_refresh_header"

    android:layout_width="fill_parent"

    android:layout_height="fill_parent"

    android:gravity="center"

    android:paddingBottom="15dip"

    android:paddingTop="10dip" >



    <ProgressBar

        android:id="@+id/pull_to_refresh_progress"

        style="?android:attr/progressBarStyleSmall"

        android:layout_width="wrap_content"

        android:layout_height="wrap_content"

        android:layout_centerVertical="true"

        android:layout_marginLeft="30dip"

        android:layout_marginRight="20dip"

        android:layout_marginTop="10dip"

        android:indeterminate="true"

        android:visibility="gone" />



    <ImageView

        android:id="@+id/pull_to_refresh_image"

        android:layout_width="wrap_content"

        android:layout_height="wrap_content"

        android:layout_gravity="center"

        android:layout_marginLeft="30dip"

        android:layout_marginRight="20dip"

        android:gravity="center"

        android:src="@drawable/ic_pulltorefresh_arrow"

        android:visibility="gone" />



    <TextView

        android:id="@+id/pull_to_refresh_text"

        android:layout_width="fill_parent"

        android:layout_height="wrap_content"

        android:layout_gravity="center"

        android:gravity="center"

        android:paddingTop="5dip"

        android:text="@string/pull_to_refresh_tap_label"

        android:textAppearance="?android:attr/textAppearanceMedium"

        android:textStyle="bold" />



    <TextView

        android:id="@+id/pull_to_refresh_updated_at"

        android:layout_width="fill_parent"

        android:layout_height="wrap_content"

        android:layout_below="@+id/pull_to_refresh_text"

        android:layout_gravity="center"

        android:gravity="center"

        android:textAppearance="?android:attr/textAppearanceSmall"

        android:visibility="gone" />



</RelativeLayout>

[/xml]







Реализуем ListView (полный код):



[java]

package com.ua.androidhelper.widget;



import android.content.Context;

import android.util.AttributeSet;

import android.util.Log;

import android.view.LayoutInflater;

import android.view.MotionEvent;

import android.view.View;

import android.view.ViewGroup;

import android.view.animation.LinearInterpolator;

import android.view.animation.RotateAnimation;

import android.widget.AbsListView;

import android.widget.AbsListView.OnScrollListener;

import android.widget.ImageView;

import android.widget.ListAdapter;

import android.widget.ListView;

import android.widget.ProgressBar;

import android.widget.RelativeLayout;

import android.widget.TextView;



public class PullToRefreshListView extends ListView implements OnScrollListener {



	private static final int TAP_TO_REFRESH = 1;

	private static final int PULL_TO_REFRESH = 2;

	private static final int RELEASE_TO_REFRESH = 3;

	private static final int REFRESHING = 4;



	private static final String TAG = "PullToRefreshListView";



	private OnRefreshListener mOnRefreshListener;



	/**

	 * Listener that will receive notifications every time the list scrolls.

	 */

	private OnScrollListener mOnScrollListener;

	private LayoutInflater mInflater;



	private RelativeLayout mRefreshView;

	private TextView mRefreshViewText;

	private ImageView mRefreshViewImage;

	private ProgressBar mRefreshViewProgress;

	private TextView mRefreshViewLastUpdated;



	private int mCurrentScrollState;

	private int mRefreshState;



	private RotateAnimation mFlipAnimation;

	private RotateAnimation mReverseFlipAnimation;



	private int mRefreshViewHeight;

	private int mRefreshOriginalTopPadding;

	private int mLastMotionY;



	private boolean mBounceHack;



	public PullToRefreshListView(Context context) {

		super(context);

		init(context);

	}



	public PullToRefreshListView(Context context, AttributeSet attrs) {

		super(context, attrs);

		init(context);

	}



	public PullToRefreshListView(Context context, AttributeSet attrs, int defStyle) {

		super(context, attrs, defStyle);

		init(context);

	}



	private void init(Context context) {

		// Load all of the animations we need in code rather than through XML

		mFlipAnimation = new RotateAnimation(0, -180, RotateAnimation.RELATIVE_TO_SELF, 0.5f,

				RotateAnimation.RELATIVE_TO_SELF, 0.5f);

		mFlipAnimation.setInterpolator(new LinearInterpolator());

		mFlipAnimation.setDuration(250);

		mFlipAnimation.setFillAfter(true);

		mReverseFlipAnimation = new RotateAnimation(-180, 0, RotateAnimation.RELATIVE_TO_SELF, 0.5f,

				RotateAnimation.RELATIVE_TO_SELF, 0.5f);

		mReverseFlipAnimation.setInterpolator(new LinearInterpolator());

		mReverseFlipAnimation.setDuration(250);

		mReverseFlipAnimation.setFillAfter(true);



		mInflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);



		mRefreshView = (RelativeLayout) mInflater.inflate(R.layout.pull_to_refresh_header, this, false);

		mRefreshViewText = (TextView) mRefreshView.findViewById(R.id.pull_to_refresh_text);

		mRefreshViewImage = (ImageView) mRefreshView.findViewById(R.id.pull_to_refresh_image);

		mRefreshViewProgress = (ProgressBar) mRefreshView.findViewById(R.id.pull_to_refresh_progress);

		mRefreshViewLastUpdated = (TextView) mRefreshView.findViewById(R.id.pull_to_refresh_updated_at);



		mRefreshViewImage.setMinimumHeight(50);

		mRefreshView.setOnClickListener(new OnClickRefreshListener());

		mRefreshOriginalTopPadding = mRefreshView.getPaddingTop();



		mRefreshState = TAP_TO_REFRESH;



		addHeaderView(mRefreshView);



		super.setOnScrollListener(this);



		measureView(mRefreshView);

		mRefreshViewHeight = mRefreshView.getMeasuredHeight();

	}



	@Override

	protected void onAttachedToWindow() {

		setSelection(1);

	}



	@Override

	public void setAdapter(ListAdapter adapter) {

		super.setAdapter(adapter);



		setSelection(1);

	}



	/**

	 * Set the listener that will receive notifications every time the list scrolls.

	 * 

	 * @param l

	 *            The scroll listener.

	 */

	@Override

	public void setOnScrollListener(AbsListView.OnScrollListener l) {

		mOnScrollListener = l;

	}



	/**

	 * Register a callback to be invoked when this list should be refreshed.

	 * 

	 * @param onRefreshListener

	 *            The callback to run.

	 */

	public void setOnRefreshListener(OnRefreshListener onRefreshListener) {

		mOnRefreshListener = onRefreshListener;

	}



	/**

	 * Set a text to represent when the list was last updated.

	 * 

	 * @param lastUpdated

	 *            Last updated at.

	 */

	public void setLastUpdated(CharSequence lastUpdated) {

		if (lastUpdated != null) {

			mRefreshViewLastUpdated.setVisibility(View.VISIBLE);

			mRefreshViewLastUpdated.setText(lastUpdated);

		} else {

			mRefreshViewLastUpdated.setVisibility(View.GONE);

		}

	}



	@Override

	public boolean onTouchEvent(MotionEvent event) {

		final int y = (int) event.getY();

		mBounceHack = false;



		switch (event.getAction()) {

			case MotionEvent.ACTION_UP:

				if (!isVerticalScrollBarEnabled()) {

					setVerticalScrollBarEnabled(true);

				}

				if (getFirstVisiblePosition() == 0 && mRefreshState != REFRESHING) {

					if ((mRefreshView.getBottom() >= mRefreshViewHeight || mRefreshView.getTop() >= 0)

							&& mRefreshState == RELEASE_TO_REFRESH) {

						// Initiate the refresh

						mRefreshState = REFRESHING;

						prepareForRefresh();

						onRefresh();

					} else if (mRefreshView.getBottom() < mRefreshViewHeight || mRefreshView.getTop() <= 0) {

						// Abort refresh and scroll down below the refresh view

						resetHeader();

						setSelection(1);

					}

				}

				break;

			case MotionEvent.ACTION_DOWN:

				mLastMotionY = y;

				break;

			case MotionEvent.ACTION_MOVE:

				applyHeaderPadding(event);

				break;

		}

		return super.onTouchEvent(event);

	}



	private void applyHeaderPadding(MotionEvent ev) {

		// getHistorySize has been available since API 1

		int pointerCount = ev.getHistorySize();



		for (int p = 0; p < pointerCount; p++) {

			if (mRefreshState == RELEASE_TO_REFRESH) {

				if (isVerticalFadingEdgeEnabled()) {

					setVerticalScrollBarEnabled(false);

				}



				int historicalY = (int) ev.getHistoricalY(p);



				// Calculate the padding to apply, we divide by 1.7 to

				// simulate a more resistant effect during pull.

				int topPadding = (int) (((historicalY - mLastMotionY) - mRefreshViewHeight) / 1.7);



				mRefreshView.setPadding(mRefreshView.getPaddingLeft(), topPadding, mRefreshView.getPaddingRight(),

						mRefreshView.getPaddingBottom());

			}

		}

	}



	/**

	 * Sets the header padding back to original size.

	 */

	private void resetHeaderPadding() {

		mRefreshView.setPadding(mRefreshView.getPaddingLeft(), mRefreshOriginalTopPadding,

				mRefreshView.getPaddingRight(), mRefreshView.getPaddingBottom());

	}



	/**

	 * Resets the header to the original state.

	 */

	private void resetHeader() {

		if (mRefreshState != TAP_TO_REFRESH) {

			mRefreshState = TAP_TO_REFRESH;



			resetHeaderPadding();



			// Set refresh view text to the pull label

			mRefreshViewText.setText(R.string.pull_to_refresh_tap_label);

			// Replace refresh drawable with arrow drawable

			mRefreshViewImage.setImageResource(R.drawable.ic_pulltorefresh_arrow);

			// Clear the full rotation animation

			mRefreshViewImage.clearAnimation();

			// Hide progress bar and arrow.

			mRefreshViewImage.setVisibility(View.GONE);

			mRefreshViewProgress.setVisibility(View.GONE);

		}

	}



	private void measureView(View child) {

		ViewGroup.LayoutParams p = child.getLayoutParams();

		if (p == null) {

			p = new ViewGroup.LayoutParams(ViewGroup.LayoutParams.FILL_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT);

		}



		int childWidthSpec = ViewGroup.getChildMeasureSpec(0, 0 + 0, p.width);

		int lpHeight = p.height;

		int childHeightSpec;

		if (lpHeight > 0) {

			childHeightSpec = MeasureSpec.makeMeasureSpec(lpHeight, MeasureSpec.EXACTLY);

		} else {

			childHeightSpec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED);

		}

		child.measure(childWidthSpec, childHeightSpec);

	}



	@Override

	public void onScroll(AbsListView view, int firstVisibleItem, int visibleItemCount, int totalItemCount) {

		// When the refresh view is completely visible, change the text to say

		// "Release to refresh..." and flip the arrow drawable.

		if (mCurrentScrollState == SCROLL_STATE_TOUCH_SCROLL && mRefreshState != REFRESHING) {

			if (firstVisibleItem == 0) {

				mRefreshViewImage.setVisibility(View.VISIBLE);

				if ((mRefreshView.getBottom() >= mRefreshViewHeight + 20 || mRefreshView.getTop() >= 0)

						&& mRefreshState != RELEASE_TO_REFRESH) {

					mRefreshViewText.setText(R.string.pull_to_refresh_release_label);

					mRefreshViewImage.clearAnimation();

					mRefreshViewImage.startAnimation(mFlipAnimation);

					mRefreshState = RELEASE_TO_REFRESH;

				} else if (mRefreshView.getBottom() < mRefreshViewHeight + 20 && mRefreshState != PULL_TO_REFRESH) {

					mRefreshViewText.setText(R.string.pull_to_refresh_pull_label);

					if (mRefreshState != TAP_TO_REFRESH) {

						mRefreshViewImage.clearAnimation();

						mRefreshViewImage.startAnimation(mReverseFlipAnimation);

					}

					mRefreshState = PULL_TO_REFRESH;

				}

			} else {

				mRefreshViewImage.setVisibility(View.GONE);

				resetHeader();

			}

		} else if (mCurrentScrollState == SCROLL_STATE_FLING && firstVisibleItem == 0 && mRefreshState != REFRESHING) {

			setSelection(1);

			mBounceHack = true;

		} else if (mBounceHack && mCurrentScrollState == SCROLL_STATE_FLING) {

			setSelection(1);

		}



		if (mOnScrollListener != null) {

			mOnScrollListener.onScroll(view, firstVisibleItem, visibleItemCount, totalItemCount);

		}

	}



	@Override

	public void onScrollStateChanged(AbsListView view, int scrollState) {

		mCurrentScrollState = scrollState;



		if (mCurrentScrollState == SCROLL_STATE_IDLE) {

			mBounceHack = false;

		}



		if (mOnScrollListener != null) {

			mOnScrollListener.onScrollStateChanged(view, scrollState);

		}

	}



	public void prepareForRefresh() {

		resetHeaderPadding();



		mRefreshViewImage.setVisibility(View.GONE);

		// We need this hack, otherwise it will keep the previous drawable.

		mRefreshViewImage.setImageDrawable(null);

		mRefreshViewProgress.setVisibility(View.VISIBLE);



		// Set refresh view text to the refreshing label

		mRefreshViewText.setText(R.string.pull_to_refresh_refreshing_label);



		mRefreshState = REFRESHING;

	}



	public void onRefresh() {

		Log.d(TAG, "onRefresh");



		if (mOnRefreshListener != null) {

			mOnRefreshListener.onRefresh();

		}

	}



	/**

	 * Resets the list to a normal state after a refresh.

	 * 

	 * @param lastUpdated

	 *            Last updated at.

	 */

	public void onRefreshComplete(CharSequence lastUpdated) {

		setLastUpdated(lastUpdated);

		onRefreshComplete();

	}



	/**

	 * Resets the list to a normal state after a refresh.

	 */

	public void onRefreshComplete() {

		Log.d(TAG, "onRefreshComplete");



		resetHeader();



		// If refresh view is visible when loading completes, scroll down to

		// the next item.

		if (mRefreshView.getBottom() > 0) {

			invalidateViews();

			setSelection(1);

		}

	}



	/**

	 * Invoked when the refresh view is clicked on. This is mainly used when there's only a few items in the list and

	 * it's not possible to drag the list.

	 */

	private class OnClickRefreshListener implements OnClickListener {



		@Override

		public void onClick(View v) {

			if (mRefreshState != REFRESHING) {

				prepareForRefresh();

				onRefresh();

			} else {

				onRefreshComplete();

			}

		}



	}



	/**

	 * Interface definition for a callback to be invoked when list should be refreshed.

	 */

	public interface OnRefreshListener {

		/**

		 * Called when the list should be refreshed.

		 * <p>

		 * A call to {@link PullToRefreshListView #onRefreshComplete()} is expected to indicate that the refresh has

		 * completed.

		 */

		public void onRefresh();

	}

}

[/java]



Добавим ListView на наш Activity:



[java]

public class MainActivity extends Activity {

	private final String[] values = { "Test 1", "Test 2", "Test 3", "Test 4", "Test 5", "Test 6", "Test 7", "Test 8",

			"Test 1", "Test 2", "Test 3", "Test 4", "Test 5", "Test 6", "Test 7", "Test 8", "Test 1", "Test 2",

			"Test 3", "Test 4", "Test 5", "Test 6", "Test 7", "Test 8", "Test 1", "Test 2", "Test 3", "Test 4",

			"Test 5", "Test 6", "Test 7", "Test 8" };



	@Override

	public void onCreate(Bundle savedInstanceState) {

		super.onCreate(savedInstanceState);

		// setContentView(R.layout.activity_main);



		ListAdapter adapter = new ArrayAdapter<String>(this, R.layout.list_item, values);

		PullToRefreshListView listView = new PullToRefreshListView(this);

		listView.setAdapter(adapter);

		setContentView(listView, new LayoutParams(LayoutParams.FILL_PARENT, LayoutParams.FILL_PARENT));

	}



}

[/java]



Все готово.





Коды как всегда [тут](http://android-helper.com.ua/forms).
Добрый день друзья.





Как и обещал выкладываю информацию о Fragments.





Пошарил немного по Интернету и нашел увлекательную статью на [Habrahabr.ru](http://habrahabr.ru/post/113196/)





Поэтому было решено вставить ее сюда полностью + со своей доработкой


<!-- more -->


_В Android 3.0 введена новая концепция фрагментов, которая служит для упрощения работы с интерфейсом под разные размеры экранов. Данный топик является переводом статьи с android-developers.blogspot.com. В ней рассмотрены преимущества фрагментов, а также приведен простой, но законченный пример приложения, работающего по этому принципу._





Важная цель Android 3.0 — упростить написание программ, которые должны масштабироваться в зависимости от размеров экрана. Для этого в платформе Android уже доступны следующие средства:








  * С самого начала, UI-фреймворк был спроектирован для использования layout managers, которые позволяют описывать интерфейс так, чтобы он «подгонялся» к размерам. Примером этого является ListView, высота которого изменяется в зависимости от размера экрана, который варьируется между соотношениями QVGA, HVGA, and WVGA.



  * В Android 1.6 была введена новая концепция плотности экрана, позволяющая приложениям легче масштабировать размеры между разными разрешениями, в то время как экраны имеют почти один и тот же физический размер. Разработчики незамедлительно начали использовать эту особенность, когда были введены телефоны с высоким разрешением, такие как Droid.



  * Также в Android 1.6 разработчикам стали доступны размеры экрана, при помощи их классификации: «small» для соотношения QVGA, «normal» для HVGA и WVGA, и «large» для более больших экранов. Разработчики могут использовать систему ресурсов для выбора между различными layout'ами, в зависимости от размера экрана






Комбинация layout managers и выбора различных ресурсов представляет долгий путь для создания масштабируемого интерфейса. В итоге многие приложения для хэндсетов не используют специальный интерфейс для планшетов, работающих под Honeycomb.





#### Введение во фрагменты





В Android 3.0 введена поддержка новых классов, которые помогают приложениям масштабировать их интерфейс, называемых фрагментами (Fragment). Фрагмент — это независимый компонент со своим интерфейсом и жизненным циклом; он может быть неоднократно использован в разных частях пользовательского интерфейса, в зависимости от нужного UI потока для определенного устройства или экрана.





В некотором смысле можно рассматривать фрагмент как мини-Activity, хотя он не может запускаться независимо и должен размещаться внутри Activity. На самом деле введение Fragment API дало нам возможность решать многие проблемы, с которыми сталкивались разработчики, при работе с Activity, так как полезность фрагмента простирается далеко за пределы обычных настроек для разных разрешений экрана:








  * Activity, вложенные через ActivityGroup были хорошей идеей, однако с ними было не так просто работать, так как Activity изначально разработан как независимый компонент. Fragment API — намного лучшее решение для этого, его стоит рассматривать как замену для вложенных Activity.



  * Сохранение данных для экземпляров Activity может быть выполнено через Activity.onRetainNonConfigurationInstance(), но это неуклюже само по себе и не очевидно. Фрагменты заменяют этот механизм, позволяя сохранять целый экземпляр фрагмента простой установкой флага.



  * Одна из конкретизаций фрагмента — DialogFragment, она упрощает отображение диалога, который управляется как часть жизненного цикла Activity. Он заменяет API Activity, используемые для управления диалогами.



  * Еще одна конкретизация фрагмента — ListFragment, она упрощает отображение списка данных. ListFragment похож на ListActivity (с несколькими дополнительными особенностями), его использование упростит отображение данных в списке.



  * Информация по всем фрагментам, прикрепленным к Activity, сохраняется фреймворком в сохраненное состояние той же Activity и восстанавливается при рестарте. Таким образом уменьшается количество сохраняемых состояний.



  * У фреймворка есть встроенная поддержка для управления стеком фрагментов, она упрощает поддержку поведения кнопки BACK внутри Activity, причем это поведение интегрируется с существующим стеком Activities.






#### Приступая к работе





Вот простой, но полный пример реализации множественных потоков UI, с помощью фрагментов. Начнем с проектирования ландшафтного layout'a, содержащего список элементов слева и данные по ним справа. Так выглядит нужный нам layout:





![](http://android-helper.com.ua/images/uploads/2012/07/device-fragment-land_new.png)




Код для Activity не особенно интересен, он просто вызывает setContentView() со следующим макетом:







	<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"

    android:layout_width="match_parent"

    android:layout_height="match_parent"

    android:orientation="horizontal" >



    <fragment

        android:id="@+id/titles"

        android:layout_width="0px"

        android:layout_height="match_parent"

        android:layout_weight="1"

        class="com.example.androidhelper.fragments.TitlesFragment" />



    <FrameLayout

        android:id="@+id/details"

        android:layout_width="0px"

        android:layout_height="match_parent"

        android:layout_weight="1" />



	</LinearLayout>


Вы можете заметить первую особенность: тег

	<fragment>

позволяет устанавливать фрагмент в вашу иерархию интерфейса. Вышеописанный фрагмент наследует свойства ListFragment, который отображает данные по элементу в текущем месте, или в отдельном Activity, в зависимости от layout'a. Обратите внимание на то, как сохраняются изменения в состоянии фрагмента.

	public class TitlesFragment extends ListFragment {

	boolean mDualPane;

	int mCurCheckPosition = 0;



	@Override

	public void onActivityCreated(Bundle savedState) {

		super.onActivityCreated(savedState);



		// Populate list with our static array of titles.

		setListAdapter(new ArrayAdapter<String>(getActivity(), R.layout.list_item, Shakespeare.TITLES));



		// Check to see if we have a frame in which to embed the details

		// fragment directly in the containing UI.

		View detailsFrame = getActivity().findViewById(R.id.details);

		mDualPane = detailsFrame != null && detailsFrame.getVisibility() == View.VISIBLE;



		if (savedState != null) {

			// Restore last state for checked position.

			mCurCheckPosition = savedState.getInt("curChoice", 0);

		}



		if (mDualPane) {

			// In dual-pane mode, list view highlights selected item.

			getListView().setChoiceMode(ListView.CHOICE_MODE_SINGLE);

			// Make sure our UI is in the correct state.

			showDetails(mCurCheckPosition);

		}

	}



	@Override

	public void onSaveInstanceState(Bundle outState) {

		super.onSaveInstanceState(outState);

		outState.putInt("curChoice", mCurCheckPosition);

	}



	@Override

	public void onListItemClick(ListView l, View v, int pos, long id) {

		showDetails(pos);

	}



	/**

	 * Helper function to show the details of a selected item, either by displaying a fragment in-place in the current

	 * UI, or starting a whole new activity in which it is displayed.

	 */

	void showDetails(int index) {

		mCurCheckPosition = index;



		if (mDualPane) {

			// We can display everything in-place with fragments.

			// Have the list highlight this item and show the data.

			getListView().setItemChecked(index, true);



			// Check what fragment is shown, replace if needed.

			DetailsFragment details = (DetailsFragment) getFragmentManager().findFragmentById(R.id.details);

			if (details == null || details.getShownIndex() != index) {

				// Make new fragment to show this selection.

				details = DetailsFragment.newInstance(index);



				// Execute a transaction, replacing any existing

				// fragment with this one inside the frame.

				FragmentTransaction ft = getFragmentManager().beginTransaction();

				ft.replace(R.id.details, details);

				ft.setTransition(FragmentTransaction.TRANSIT_FRAGMENT_FADE);

				ft.commit();

			}



		} else {

			// Otherwise we need to launch a new activity to display

			// the dialog fragment with selected text.

			Intent intent = new Intent();

			intent.setClass(getActivity(), DetailsActivity.class);

			intent.putExtra("index", index);

			startActivity(intent);

		}

	}

	}


Также необходимо реализовать DetailsFragment, который будет отображать данные по элементу в обычном TextView.

	public class DetailsFragment extends Fragment {

	/**

	 * Create a new instance of DetailsFragment, initialized to show the text at 'index'.

	 */

	public static DetailsFragment newInstance(int index) {

		DetailsFragment f = new DetailsFragment();



		// Supply index input as an argument.

		Bundle args = new Bundle();

		args.putInt("index", index);

		f.setArguments(args);



		return f;

	}



	public int getShownIndex() {

		return getArguments().getInt("index", 0);

	}



	@Override

	public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {

		if (container == null) {

			// Currently in a layout without a container, so no

			// reason to create our view.

			return null;

		}



		ScrollView scroller = new ScrollView(getActivity());

		TextView text = new TextView(getActivity());

		int padding = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 4, getActivity().getResources()

				.getDisplayMetrics());

		text.setPadding(padding, padding, padding, padding);

		scroller.addView(text);

		text.setText(Shakespeare.DIALOGUE[getShownIndex()]);

		return scroller;

	}

	}

Настало время для добавления еще одного потока UI в наше приложение. Когда экран находится в портретном режиме, то недостаточно места для отображения двух фрагментов бок о бок. То есть мы хотим, чтобы отображался только список:





![](http://android-helper.com.ua/images/uploads/2012/07/device-fragment-port1_new.png)





Напишем новый layout для портретной ориентации:


	<?xml version="1.0" encoding="utf-8"?>

	<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"

    android:layout_width="match_parent"

    android:layout_height="match_parent" >



    <fragment

        android:id="@+id/titles"

        android:layout_width="match_parent"

        android:layout_height="match_parent"

        class="com.example.androidhelper.fragments.TitlesFragment" />



	</FrameLayout>



Теперь у нас нет контейнера для отображения данных для TitlesFragment, отображается только список. При нажатии на элемент списка теперь нужно вызывать отдельное Activity, в котором и будут отображаться данные:





![](http://android-helper.com.ua/images/uploads/2012/07/device-fragment-port2_new.png)





Теперь, всё что от нас требуется — использовать уже готовый DetailsFragment:
	
	public class DetailsActivity extends FragmentActivity {



	@Override

	protected void onCreate(Bundle savedInstanceState) {

		super.onCreate(savedInstanceState);



		if (getResources().getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPE) {

			// If the screen is now in landscape mode, we can show the

			// dialog in-line so we don't need this activity.

			finish();

			return;

		}



		if (savedInstanceState == null) {

			// During initial setup, plug in the details fragment.

			DetailsFragment details = new DetailsFragment();

			details.setArguments(getIntent().getExtras());

			getSupportFragmentManager().beginTransaction().add(android.R.id.content, details).commit();

		}

	}



	}



Соединив Activity, мы получаем полностью работающий пример приложения, использующего радикальное изменение UI потока, основанное на том, какая конфигурация используется в данный момент. Также приложение автоматически подгоняется под требования размеров экрана при смене конфигурации.





Этот пример иллюстрирует всего лишь один способ использования фрагментов для подгонки вашего UI. В зависимости от дизайна, вы можете предпочесть другие. Например, вы можете поместить всё ваше приложение в одно Activity, в котором будет изменяться структура фрагментов.





Как обычно, больше информации можно найти в документации по SDK. Также можно найти примеры в ApiDemos.





#### Фрагментация для всех





Fragment API будет полезен для разработчиков, начинающих работать с приложениями, ориентированными на планшеты, которые спроектированы под Android 3.0, во многих случаях, связанных с большим экраном. Также использование фрагментов должно сделать проще настройку UI для приложений под новые устройства на Android, например, телевизоры.





Однако, сейчас Fragment API будет наиболее востребован для улучшения интерфейса существующих приложений для телефонов под планшеты.





Также планируется сделать статическую библиотеку для использования Fragment API (_Ура!!!_), чтобы использовать вышеописанный метод на ранних версиях Android. На самом деле, весь код в примере использует как раз статическую библиотеку классов, причем выполняется на Android 2.3 (можете сравнить с примерами в Android 3.0 SDK, они почти не отличаются). Наша цель — сделать эти API как можно более похожими, чтобы вы могли начать работать с ними сейчас, независимо от того, когда вы перейдете на Android 3.0.





Пока нет точной даты, когда библиотека будет доступна, но она точно будет скоро. Пока вы можете начать работать с фрагментами на Android 3.0.





#### Дополнения





Это была первая статья которая описывала фрагменты. На данный момент выпущена библиотека с обратной совместимостью (см. мои предыдущие посты) до версии андроид 1.6.





Для подключения фрагментов в приложения с обратной совместимостью вам нужно сделать следующее:





Наследоватся не от Activity, а от FragmentActivity. Это самое главное требование.





Пример как всегда вы сможете скачать [тут](http://android-helper.com.ua/forms/).
Добрый день друзья.





В предыдущих статьях я писал о использовании [Swipe](http://android-helper.com.ua/%D1%81%D0%BB%D0%B0%D0%B9%D0%B4%D0%B8%D0%BD%D0%B3-%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%BE%D0%B2-%D1%81-%D0%BF%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%D1%8E-viewpager/) и своих [Tabs](http://android-helper.com.ua/%D0%BA%D0%B0%D0%BA-%D1%81%D0%B4%D0%B5%D0%BB%D0%B0%D1%82%D1%8C-%D1%81%D0%B2%D0%BE%D0%B8-tabs-%D0%B2-android/)





Тогда у меня возник вопрос, как же их можно объединить. 





![](http://android-helper.com.ua/images/uploads/2012/07/device-2012-07-17-084758.png)


<!-- more -->


### 1. Подготовка проекта





Перед тем как приступить к реализации этой задачи, нам нужно подключить библиотеку обратной совместимости.





Как это сделать, вы можете прочесть [тут](http://android-helper.com.ua/%D1%81%D0%BB%D0%B0%D0%B9%D0%B4%D0%B8%D0%BD%D0%B3-%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%BE%D0%B2-%D1%81-%D0%BF%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%D1%8E-viewpager/) (предварительная настройка).





### 2. Подготовка ресурсов





Откройте файл main.xml и пропишите туда следующий код:

	<?xml version="1.0" encoding="utf-8"?>

	<TabHost xmlns:android="http://schemas.android.com/apk/res/android"

	android:id="@android:id/tabhost"

	android:layout_width="match_parent"

	android:layout_height="match_parent" >



		<LinearLayout

		android:layout_width="match_parent"

		android:layout_height="match_parent"

		android:orientation="vertical" >



		<FrameLayout

			android:id="@android:id/tabcontent"

			android:layout_width="0dp"

			android:layout_height="0dp"

			android:layout_weight="0" />



		<android.support.v4.view.ViewPager

			android:id="@+id/pager"

			android:layout_width="match_parent"

			android:layout_height="0dp"

			android:layout_weight="1" />



		<TabWidget

			android:id="@android:id/tabs"

			android:layout_width="match_parent"

			android:layout_height="wrap_content"

			android:layout_weight="0"

			android:orientation="horizontal" />

	</LinearLayout>



	</TabHost>


### 3. Подготовка Activity





Для реализации данного примера мы будем наследоваться не от Activity, а от **FragmentActivity** (о фрагментах мы поговорим в следующей статье):



	public class MainActivity extends FragmentActivity 
  




В метод onCreate пишем следующее:



	private TabHost mTabHost;

	private ViewPager mViewPager;

	private TabsAdapter mTabsAdapter;



	@Override

	public void onCreate(final Bundle savedInstanceState) {

		super.onCreate(savedInstanceState);

		setContentView(R.layout.activity_main);

		mTabHost = (TabHost) findViewById(android.R.id.tabhost);

		mTabHost.setup();



		mViewPager = (ViewPager) findViewById(R.id.pager);



		mTabsAdapter = new TabsAdapter(this, mTabHost, mViewPager);



		mTabsAdapter.addTab(mTabHost.newTabSpec("simple").setIndicator("Android"), AndroidFragment.class, null);

		mTabsAdapter.addTab(mTabHost.newTabSpec("contacts").setIndicator("IOs"), IOsFragment.class, null);

		mTabsAdapter.addTab(mTabHost.newTabSpec("custom").setIndicator("Windows"), WindowsFragment.class, null);

		mTabsAdapter.addTab(mTabHost.newTabSpec("throttle").setIndicator("DOS"), DOSFragment.class, null);



		if (savedInstanceState != null) {

			mTabHost.setCurrentTabByTag(savedInstanceState.getString("tab"));

		}

	}


  




### 4. Реализация Adapter





Вот тут начинается самое интересное.





Создаем adapter который у нас будет унаследован от **FragmentPagerAdapter**, а также для обработки нажатий на Tabs мы подпишемся на обработчик событий **TabHost.OnTabChangeListener** и для скролинга страниц также подписываемся на **ViewPager.OnPageChangeListener**





Полный код вы можете увидеть ниже:



	public static class TabsAdapter extends FragmentPagerAdapter implements TabHost.OnTabChangeListener,

			ViewPager.OnPageChangeListener {

		private final Context mContext;

		private final TabHost mTabHost;

		private final ViewPager mViewPager;

		private final ArrayList<TabInfo> mTabs = new ArrayList<TabInfo>();



		static final class TabInfo {

			private final String tag;

			private final Class<?> clss;

			private final Bundle args;



			TabInfo(final String _tag, final Class<?> _class, final Bundle _args) {

				tag = _tag;

				clss = _class;

				args = _args;

			}

		}



		static class DummyTabFactory implements TabHost.TabContentFactory {

			private final Context mContext;



			public DummyTabFactory(final Context context) {

				mContext = context;

			}



			@Override

			public View createTabContent(final String tag) {

				View v = new View(mContext);

				v.setMinimumWidth(0);

				v.setMinimumHeight(0);

				return v;

			}

		}



		public TabsAdapter(final FragmentActivity activity, final TabHost tabHost, final ViewPager pager) {

			super(activity.getSupportFragmentManager());

			mContext = activity;

			mTabHost = tabHost;

			mViewPager = pager;

			mTabHost.setOnTabChangedListener(this);

			mViewPager.setAdapter(this);

			mViewPager.setOnPageChangeListener(this);

		}



		public void addTab(final TabHost.TabSpec tabSpec, final Class<?> clss, final Bundle args) {

			tabSpec.setContent(new DummyTabFactory(mContext));

			String tag = tabSpec.getTag();



			TabInfo info = new TabInfo(tag, clss, args);

			mTabs.add(info);

			mTabHost.addTab(tabSpec);

			notifyDataSetChanged();

		}



		@Override

		public int getCount() {

			return mTabs.size();

		}



		@Override

		public Fragment getItem(final int position) {

			TabInfo info = mTabs.get(position);

			return Fragment.instantiate(mContext, info.clss.getName(), info.args);

		}



		@Override

		public void onTabChanged(final String tabId) {

			int position = mTabHost.getCurrentTab();

			mViewPager.setCurrentItem(position);

		}



		@Override

		public void onPageScrolled(final int position, final float positionOffset, final int positionOffsetPixels) {

		}



		@Override

		public void onPageSelected(final int position) {

			// Unfortunately when TabHost changes the current tab, it kindly

			// also takes care of putting focus on it when not in touch mode.

			// The jerk.

			// This hack tries to prevent this from pulling focus out of our

			// ViewPager.

			TabWidget widget = mTabHost.getTabWidget();

			int oldFocusability = widget.getDescendantFocusability();

			widget.setDescendantFocusability(ViewGroup.FOCUS_BLOCK_DESCENDANTS);

			mTabHost.setCurrentTab(position);

			widget.setDescendantFocusability(oldFocusability);

		}



		@Override

		public void onPageScrollStateChanged(final int state) {

		}

	}
 
  




### 5. Финальная стадия





Из пункта 2 видно что у нас есть 4 новых фрагмента. Так давайте их создадим.





**AndroidFragment**:




	import android.os.Bundle;

	import android.support.v4.app.Fragment;

	import android.view.LayoutInflater;

	import android.view.View;

	import android.view.ViewGroup;



	public class AndroidFragment extends Fragment {



	@Override

	public View onCreateView(final LayoutInflater inflater, final ViewGroup container, final Bundle savedInstanceState) {

		View view = inflater.inflate(R.layout.android_fragment, container, false);

		return view;

	}



	}




**IOsFragment**:



	public class IOsFragment extends Fragment {



	@Override

	public View onCreateView(final LayoutInflater inflater, final ViewGroup container, final Bundle savedInstanceState) {

		View view = inflater.inflate(R.layout.ios_fragment, container, false);

		return view;

	}



	}

  




**WindowsFragment:**



	public class WindowsFragment extends Fragment {



	@Override

	public View onCreateView(final LayoutInflater inflater, final ViewGroup container, final Bundle savedInstanceState) {

		View view = inflater.inflate(R.layout.windows_fragment, container, false);

		return view;

	}



	}

 
  




**DOSFragment:**



	public class DOSFragment extends Fragment {



	@Override

	public View onCreateView(final LayoutInflater inflater, final ViewGroup container, final Bundle savedInstanceState) {

		View view = inflater.inflate(R.layout.dos_fragment, container, false);

		return view;

	}



	}
  
  




Теперь нам нужно создать еще 4 xml файла которые мы используем в фрагментах





**android_fragment.xml**




	<?xml version="1.0" encoding="utf-8"?>
	
	<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"

	android:layout_width="match_parent"

	android:layout_height="match_parent"

	android:orientation="vertical" >



	<TextView

		android:id="@+id/textView1"

		android:layout_width="wrap_content"

		android:layout_height="wrap_content"

		android:text="Android" />



	</LinearLayout>

  
  




**dos_fragment.xml**



	<?xml version="1.0" encoding="utf-8"?>

	<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"

	android:layout_width="match_parent"

	android:layout_height="match_parent"

	android:orientation="vertical" >



	<TextView

		android:id="@+id/textView1"

		android:layout_width="wrap_content"

		android:layout_height="wrap_content"

		android:text="DOS" />



	</LinearLayout>


  




**ios_fragment.xml**




	<?xml version="1.0" encoding="utf-8"?>

	<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"

	android:layout_width="match_parent"

	android:layout_height="match_parent"

	android:orientation="vertical" >



	<TextView

		android:id="@+id/textView1"

		android:layout_width="wrap_content"

		android:layout_height="wrap_content"

		android:text="IOs" />



	</LinearLayout>
  
  




**windows_fragment.xml**



	<?xml version="1.0" encoding="utf-8"?>

	<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"

	android:layout_width="match_parent"

	android:layout_height="match_parent"

	android:orientation="vertical" >



	<TextView

		android:id="@+id/textView1"

		android:layout_width="wrap_content"

		android:layout_height="wrap_content"

		android:text="Windows" />



	</LinearLayout>

  




Ну вот и все. 





Коды можно скачать [тут](http://android-helper.com.ua/forms/).
Добрый день друзья.





Сегодня я бы хотел поделится с вами информацией о создании и использовании своих Tabs.





![](http://android-helper.com.ua/images/uploads/2012/07/custom_tabs_view.png)




<!-- more -->
  






### 1. Создадим layout





  






Самое первое что нужно сделать, это открыть main.xml и добавить туда TabHost и TabWidget







	<?xml version="1.0" encoding="utf-8"?>

	<TabHost xmlns:android="http://schemas.android.com/apk/res/android"

	android:id="@android:id/tabhost" android:layout_width="fill_parent"

	android:layout_height="fill_parent">

	<LinearLayout android:orientation="vertical"

		android:layout_width="fill_parent" android:layout_height="fill_parent">

		<TabWidget android:id="@android:id/tabs"

			android:layout_width="fill_parent" android:layout_height="wrap_content" />

		<FrameLayout android:id="@android:id/tabcontent"

			android:layout_width="fill_parent" android:layout_height="fill_parent">

		</FrameLayout>

	</LinearLayout>

	</TabHost>








### 2. Пишем код в Activity





  






У нас есть main.xml , теперь нам нужно добавить код для привязки нашего activity с нашим файлом







	setContentView(R.layout.main);

	mTabHost = (TabHost) findViewById(android.R.id.tabhost);









Ну вот после этого мы можем добавлять tabs на наше activty







	@Override

	public void onCreate(Bundle savedInstanceState) {

	super.onCreate(savedInstanceState);

	setContentView(R.layout.main);

	mTabHost = (TabHost) findViewById(android.R.id.tabhost);

	setupTab(new TextView(this), "Tab 1");

	setupTab(new TextView(this), "Tab 2");

	setupTab(new TextView(this), "Tab 3");

	}

	private void setupTab(final View view, final String tag) {

	View tabview = createTabView(mTabHost.getContext(), tag);

        TabSpec setContent = mTabHost.newTabSpec(tag).setIndicator(tabview).setContent(new TabContentFactory() {

		public View createTabContent(String tag) {return view;}

	});

	mTabHost.addTab(setContent);

	}



	private static View createTabView(final Context context, final String text) {

	View view = LayoutInflater.from(context).inflate(R.layout.tabs_bg, null);

	TextView tv = (TextView) view.findViewById(R.id.tabsText);

	tv.setText(text);

	return view;

	}








### 3. Создаем свой tabs layout





Создадим новый xml файл и назовем его tabs_bg.xml. Этот файл как раз и будет служить заполнением нашего tab.





На него можно добавлять любые элементы.








	<?xml version="1.0" encoding="utf-8"?>

	<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"

	android:id="@+id/tabsLayout" android:layout_width="fill_parent"

	android:layout_height="fill_parent"

	android:padding="10dip" android:gravity="center" android:orientation="vertical">



	<TextView android:id="@+id/tabsText" android:layout_width="wrap_content"

		android:layout_height="wrap_content" android:text="Title"

		android:textSize="15dip" />

	</LinearLayout>








### 4. Меняем вид и поведение





Создадим еще несколько файлов tab_text_selector.xml и tab_bg_selector.xml (их нужно создать в папке layout), а также tab_bg_selected.xml и tab_bg_unselected.xml (эти 2 файла создаем в папке drawable). Эти файлы служат для того что при изменении статуса tab с активного на неактивный соответственно меняется его внешний вид.





**tab_bg_selected.xml:**







	<?xml version="1.0" encoding="utf-8"?>

	<shape xmlns:android="http://schemas.android.com/apk/res/android"

	android:shape="rectangle">

	<gradient android:startColor="#A8A8A8" android:centerColor="#7F7F7F"

		android:endColor="#696969" android:angle="-90" />

	</shape>







**tab_bg_unselected.xml:**







	<?xml version="1.0" encoding="utf-8"?>

	<shape xmlns:android="http://schemas.android.com/apk/res/android"

	android:shape="rectangle">

	<gradient android:startColor="#5C5C5C" android:centerColor="#424242"

		android:endColor="#222222" android:angle="-90" />

	</shape>







 **tab_text_selector.xml:**







	<?xml version="1.0" encoding="utf-8"?>

	<selector xmlns:android="http://schemas.android.com/apk/res/android">

    <item android:state_selected="true" android:color="@android:color/white" />

    <item android:state_focused="true" android:color="@android:color/white" />

    <item android:state_pressed="true" android:color="@android:color/white" />

    <item android:color="#f8f8f8" />

	</selector>








**tab_bg_selector.xml:**







	<?xml version="1.0" encoding="utf-8"?>

	<selector xmlns:android="http://schemas.android.com/apk/res/android">

    <!--  Active tab -->

	<item android:state_selected="true" android:state_focused="false"

		android:state_pressed="false" android:drawable="@drawable/tab_bg_selected" />

	<!--  Inactive tab -->

	<item android:state_selected="false" android:state_focused="false"

		android:state_pressed="false" android:drawable="@drawable/tab_bg_unselected" />

	<!--  Pressed tab -->

	<item android:state_pressed="true" android:drawable="@android:color/transparent" />

	<!--  Selected tab (using d-pad) -->

	<item android:state_focused="true" android:state_selected="true"

		android:state_pressed="false" android:drawable="@android:color/transparent" />

	</selector>







И теперь поменяем внешний вид нашего tabs_bg.xml









	<?xml version="1.0" encoding="utf-8"?>

	<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"

	android:id="@+id/tabsLayout" android:layout_width="fill_parent"

	android:layout_height="fill_parent" android:background="@drawable/tab_bg_selector"

	android:padding="10dip" android:gravity="center" android:orientation="vertical">



	<TextView android:id="@+id/tabsText" android:layout_width="wrap_content"

		android:layout_height="wrap_content" android:text="Title"

		android:textSize="15dip" android:textColor="@drawable/tab_text_selector" />

	</LinearLayout>









### 5. Заключительная стадия 





  






В заключительной стадии нам нужно добавить разделитель между tabs.





Этот код нужно добавить пере вызовом функции setupTab.








	mTabHost.getTabWidget().setDividerDrawable(R.drawable.tab_divider);









Ну вот и все.





В следующей статье я продолжу тему своих tabs. И с нее вы сможете узнать как скомпоновать tabs и swipe экранов.




Всем привет.





Я долго думал как же мне поскорее помочь вам разобраться в android. И решил, что я буду собирать очень интересные статьи на своем сайте.





Сегодня речь пойдет о горизонтальной прокрутке экранов. (статья из [Хабрахабр](http://habrahabr.ru/post/131889/))

<!-- more -->



##### Вступление





Горизонтальная прокрутка экранов — удобная и модная вещь. На Хабре уже был [топик ](http://habrahabr.ru/blogs/android_development/118482/), посвященный данной теме. Однако использование ViewFlipper не позволяет с легкостью добиться эффекта привязки, когда экраны двигаются вместе с пальцем. Также нужен механизм автоматической доводки экранов в ту или иную сторону. Примера, где это было бы хорошо разъяснено и реализовано, так и не нашел. В комментариях [предлагали](http://habrahabr.ru/blogs/android_development/118482/#comment_3863174) посмотреть исходники гугловского кода, где это реализовано. Однако удобнее было бы воспользоваться готовым решением. Такой механизм реализован в Android [Support Package ](http://developer.android.com/sdk/compatibility-library.html). Использовать эту библиотеку можно для версий Android 1.6 и старше. Конкретно нам понадобятся классы ViewPager и PagerAdapter.





##### Предварительная настройка





Чтобы подключить библиотеку к проекту, выполняем следующие действия.  
Идем в директорию, куда установлен Android SDK, запускаем SDK Manager и в списке доступных к установке компонентов выбираем Android Support package. Устанавливаем его. Все что нужно будет находиться в следующей директории: <директория с sdk>/extras/android/support/. В папке v4 будет лежать .jar файл, который и нужно подключить к проекту. Если вы работаете в Eclipse, то в Package Explorer щелкаем правым кликом по проекту, выбираем Build Path -> Add External Archives. В появившемся диалоговом окне переходим к скачанному .jar файлу, выбираем его и щелкаем OK. Всё, библиотека подключена к проекту и готова к использованию.  
Хочется заметить, что могут возникнуть проблемы, если вы используете старую версию SDK Manager. У меня указанный Support Package не появлялся в списке доступных загрузок. После обновления SDK проблема решилась.





##### Разработка





Выполнив инструкции, приведенные по указанной выше ссылке, и установив библиотеку, можно приступать к реализации поставленной задачи.  
ViewPager по принципу работы похож на ListView. Данные для отображения он берет из PagerAdapter. Нам потребуется унаследовать свой класс от PagerAdapter и реализовать в нем некоторые методы. Добавление и удаление экранов реализуется с помощью методов instantiateItem() и destroyItem() соответственно. View для отображения можно создавать прямо в адаптере. Такой подход хорош тем, что ViewPager можно настраивать так, чтобы в адаптере не хранились все экраны сразу. По умолчанию адаптер хранит текущий экран, и по одному слева и справа от него. Это может сэкономить память, если содержание экранов слишком сложное. Однако в данном примере создадим все экраны в activity приложения, добавим их в список, и передадим затем этот список адаптеру. Адаптер же не будет сам создавать view, а будет брать их их списка.  
Код адаптера получился следующим. 








	public class SamplePagerAdapter extends PagerAdapter{

    

    List<View> pages = null;

    

    public SamplePagerAdapter(List<View> pages){

        this.pages = pages;

    }

    

    @Override

    public Object instantiateItem(View collection, int position){

        View v = pages.get(position);

        ((ViewPager) collection).addView(v, 0);

        return v;

    }

    

    @Override

    public void destroyItem(View collection, int position, Object view){

        ((ViewPager) collection).removeView((View) view);

    }

    

    @Override

    public int getCount(){

        return pages.size();

    }

    

    @Override

    public boolean isViewFromObject(View view, Object object){

        return view.equals(object);

    }



    @Override

    public void finishUpdate(View arg0){

    }



    @Override

    public void restoreState(Parcelable arg0, ClassLoader arg1){

    }



    @Override

    public Parcelable saveState(){

        return null;

    }



    @Override

    public void startUpdate(View arg0){

    }

	}









В адаптере нам потребовалось определить свою реализацию для методов instantiateItem(), destroyItem(), getCount() и isViewFromObject(). Для остальных методов тела можно оставить пустыми.  
  
Создадим файл разметки page.xml и опишем в нем содержимое экрана следующим образом:









	<?xml version="1.0" encoding="utf-8"?>

	<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"

    android:layout_width="fill_parent"

    android:layout_height="fill_parent"

    android:padding="10dip"

    android:background="#ddd">



    <TextView

        android:id="@+id/text_view"

        android:layout_width="fill_parent"

        android:layout_height="fill_parent"

        android:layout_centerInParent="true"

        android:gravity="center"

        android:background="#888"

        android:textColor="#fff"

        android:textSize="30dip"/>

	</RelativeLayout>












В activity приложения, как было указано выше, создадим несколько View, которые и будут нашими экранами, добавим их в список и передадим список адаптеру. Затем создадим ViewPager и установим для него полученный адаптер.  
  
Код activity:












	public class ViewPagerSampleActivity extends Activity {

    /** Called when the activity is first created. */

    @Override

    public void onCreate(Bundle savedInstanceState) {

        super.onCreate(savedInstanceState);

        

        LayoutInflater inflater = LayoutInflater.from(this);

        List<View> pages = new ArrayList<View>();

        

        View page = inflater.inflate(R.layout.page, null);

        TextView textView = (TextView) page.findViewById(R.id.text_view);

        textView.setText("Страница 1");

        pages.add(page);

        

        page = inflater.inflate(R.layout.page, null);

        textView = (TextView) page.findViewById(R.id.text_view);

        textView.setText("Страница 2");

        pages.add(page);

        

        page = inflater.inflate(R.layout.page, null);

        textView = (TextView) page.findViewById(R.id.text_view);

        textView.setText("Страница 3");

        pages.add(page);

        

        SamplePagerAdapter pagerAdapter = new SamplePagerAdapter(pages);

        ViewPager viewPager = new ViewPager(this);

        viewPager.setAdapter(pagerAdapter);

        viewPager.setCurrentItem(1);     

        

        setContentView(viewPager);

    }

	}













Как видно из кода, мы создали три экрана. Для каждого из них мы указали какой он по счету. Установив адаптер для ViewPager, укажем что сейчас будет показываться экран с индексом 1, т.е. на котором написано «Страница 2».   
Скриншот приложения, во время прокручивания экрана:









![](http://android-helper.com.ua/images/uploads/2012/06/Image.png)












##### Заключение



Как видно из примера, использовать ViewPager и PagerAdapter достаточно легко. При слайдинге экранов, изображения привязывается к положению пальца. Работает автоматическая доводка в какую либо из сторон. Нажатия на дочерние элементы (различные кнопки, элементы списка, если таковой присутствует) обрабатываются корректно.  
  
И в заключение, ссылка на [статью ](http://android-developers.blogspot.com/2011/08/horizontal-view-swiping-with-viewpager.html), в которой рассказывается о ViewPager.




Сегодня мы продолжим цикл изучения ScrollView.





Из прошлых уроков вы узнали, что в ScrollView можно  добавить текст.





Сегодня же мы добавим кнопки :).


<!-- more -->


main.xml:








    <?xml version="1.0" encoding="utf-8"?>

    <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"

        android:id="@+id/LinearLayout01"

        android:layout_width="fill_parent"

        android:layout_height="fill_parent" >



        <ScrollView

            android:id="@+id/ScrollView01"

            android:layout_width="fill_parent"

            android:layout_height="110px" >



            <LinearLayout

                android:id="@+id/LinearLayout02"

                android:layout_width="wrap_content"

                android:layout_height="30px"

                android:orientation="vertical" >



                <Button

                    android:id="@+id/Button01"

                    android:layout_width="wrap_content"

                    android:layout_height="wrap_content"

                    android:text="1" />



                <Button

                    android:id="@+id/Button02"

                    android:layout_width="wrap_content"

                    android:layout_height="wrap_content"

                    android:text="2" />



                <Button

                    android:id="@+id/Button03"

                    android:layout_width="wrap_content"

                    android:layout_height="wrap_content"

                    android:text="3" />

            </LinearLayout>

        </ScrollView>



    </LinearLayout>








Результат:





 [![](http://android-helper.com.ua/images/uploads/2012/05/device-2012-05-29-105334.png)](http://android-helper.com.ua/images/uploads/2012/05/device-2012-05-29-105334.png)
Сегодня мы поговорим о ListView.





Этот елемент служит для того что бы показывать разного рода елементы в списке с возможностью прокрутки.





Меньше слов, больше кода.



<!-- more -->

main.xml:









	<?xml version="1.0" encoding="utf-8"?>

	<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"

    	android:id="@+id/LinearLayout01"

    	android:layout_width="fill_parent"

    	android:layout_height="fill_parent" >



    <ListView

        android:id="@+id/ListView01"

        android:layout_width="wrap_content"

        android:layout_height="wrap_content" />



	</LinearLayout>

	







Java код:









	package com.in.androidhelper;



	import android.app.Activity;

	import android.os.Bundle;

	import android.widget.ArrayAdapter;

	import android.widget.ListView;



	public class Example1Activity extends Activity {

		private ListView lv1;

		private final String lv_arr[] = { "Android", "iPhone", "BlackBerry", "Android Helper :)" };



		@Override

		public void onCreate(Bundle icicle) {

			super.onCreate(icicle);

			setContentView(R.layout.main);

			lv1 = (ListView) findViewById(R.id.ListView01);

			// С использованием setAdpater mетода в listview вы добавляете строки в

			// список

			lv1.setAdapter(new ArrayAdapter<String>(this, android.R.layout.simple_list_item_1, lv_arr));

		}

	}









Скриншоты:





![](http://android-helper.com.ua/images/uploads/2012/05/device-2012-05-23-191439.png)Добрый день друзья.





Сегодня мы поговорим о таком android елементе как ScrollView.





И не только поговорим, я вам покажу как можно большой текст двигать в маленьком окне.


<!-- more -->


Откроем файл main.xml





И заменим:








	<TextView

        android:layout_width="fill_parent"

        android:layout_height="wrap_content"

        android:text="Привет Android" />









на:








	<ScrollView

        android:id="@+id/ScrollView01"

        android:layout_width="fill_parent"

        android:layout_height="70px" >



        <TextView

            android:id="@+id/TEXT_VIEW"

            android:layout_width="wrap_content"

            android:layout_height="wrap_content"

            android:text="Второе задание мы с вами успешно прошли.

	Если у вас есть вопросы вы всегда можете задать их на сайте либо в соц. сетях.

	Подписывайтесь на рассылку и получайте только самое свежее.

	Планируется проведение тренинга по Android. Если вы хотите повысить свои знания тогда вам к нам  .

	Все вопросы задавайте в соц. сетях."

            android:textSize="17sp" />

    </ScrollView>









И вот что у нас получилось:





![](http://android-helper.com.ua/images/uploads/2012/05/device-2012-05-23-182038.png)
![](http://android-helper.com.ua/images/uploads/2012/05/device-2012-05-23-182049.png)
Добрый день уважаемые читатели.





Сегодня мы с вами напишем первое приложение для Android.


<!-- more -->


1. Первое что нужно сделать, это выкачать последний Android SDK.





У себя я использую версию 2.2 и 4.0.3. (Скачать вы их можете с SDK Android Manager)





![](http://android-helper.com.ua/images/uploads/2012/05/AndroidSDK.jpg)





2. Указать в Eclipse где у вас android sdk





Window - Preference





![](http://android-helper.com.ua/images/uploads/2012/05/android1.jpg)





 





После того как все это сделано, мы можем приступить к созданию своего первого приложения.





New - Android Project.





Дальше все по скринам.





![](http://android-helper.com.ua/images/uploads/2012/05/android2.jpg)




![](http://android-helper.com.ua/images/uploads/2012/05/android3.jpg)




![](http://android-helper.com.ua/images/uploads/2012/05/android4.jpg)





После нажатия на Finish, у вас должно получиться следующее дерево вашего проекта:





![](http://android-helper.com.ua/images/uploads/2012/05/android5.jpg)



Открыв файл Example1Activity.java вы увидите следующий код.






	package com.in.androidhelper;



	import android.app.Activity;

	import android.os.Bundle;



	public class Example1Activity extends Activity {

 	/** Called when the activity is first created. */

	@Override

	public void onCreate(Bundle savedInstanceState) {

    	super.onCreate(savedInstanceState);

    	setContentView(R.layout.main);</p>

   	}

	}






Но у нас с вами задача написать "Привет Android".  
Для этого откройте файл main.xml  
И измените текст текстового поля.  
Должно получиться так:






	<?xml version="1.0" encoding="utf-8"?>

	<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"

		android:layout_width="fill_parent"

		android:layout_height="fill_parent"

		android:orientation="vertical" >



		<TextView

			android:layout_width="fill_parent"

			android:layout_height="wrap_content"

			android:text="Привет Android" />



	</LinearLayout>







Первое задание мы с вами успешно прошли.





Если у вас есть вопросы вы всегда можете задать их на сайте либо в соц. сетях.





Подписывайтесь на рассылку и получайте только самое свежее.





Планируется проведение тренинга по Android. Если вы хотите повысить свои знания тогда вам к нам :).





Все вопросы задавайте в соц. сетях.




Добрый день друзья.





Сегодня у нас стартует рубрика программирования для начинающих.





Освоив эту рубрику, вы станете не только понимать Android, но и быть неким гуру в разработке.



 <!-- more -->

 





Перед началом программирования, нужно подготовить ваш компьютер.












  1. Устанавливаем [Java](http://www.oracle.com/technetwork/java/javase/downloads/jdk-6u32-downloads-1594644.html)



  2. Установим [Android SDK](http://developer.android.com/sdk/index.html)



  3. Скачаем [Eclipse](http://eclipse.org/downloads/) (рекомендую Classic)



  4. Установим [Android плагин для Eclipse (ADT)](http://developer.android.com/sdk/eclipse-adt.html#downloading)



  5. Подключим ваше устройство, [устанавливаем драйвера](http://developer.android.com/sdk/win-usb.html). Если драйверов нету, тогда добавляйте его как ADT Interface (Android устройство)



  6. Научимся пользоваться эмулятором










 





Если есть вопросы, задавайте их в соц. сетях или в Twitter.





 





После завершения этих задач, можно будет приступить к написанию вашей первой программы.




</li>&ndash;&gt;-->
    <!--&lt;!&ndash;&ndash;&gt;-->
    <!--&lt;!&ndash;<li>Android для профессионаловДрузья всем привет.

Я очень рад, что некоторые из ребят в коучинге пишут замечательные топики!

Вот с какой проблемой мы столкнулись в коучинге и как ее решали!

<!-- more -->


В процессе коучинга, создавая своё первое приложение - калькулятор, научился использовать кастомные шрифты. Спешу безвозмездно поделиться своим опытом!

**Какие шрифты подходят?**

Можно использовать шрифты TrueType (TTF)

**Куда положить шрифт?**

В корневой директории (на одном уровне с директориями java и res и файлом AndroidManifest.xml) создать папку assets, а внутри неё можно создать отдельную папку для шрифтов fonts
В эту папку бросить свой файл со шрифтом Custom.ttf

**Как Android узнает, где находятся кастомные шрифты?**

В файле **<project_name>.iml** в разделе configuration необходимо добавить строчку

	<configuration>
	...
	<option name="ASSETS_FOLDER_RELATIVE_PATH" value="/src/	main/assets" />
	</configuration>

а в файле **res/values/strings.xml** - строчку

	<string name="digit_keyboard_font">fonts/Custom.ttf</string>

**Как назначить шрифт своим View-элементам?**

Теперь в коде, в методе onCreate можно использовать свой шрифт. Обратите внимание на код, в котором скрывается первая секретная фишка!

	Typeface keys = Typeface.createFromAsset(getAssets(), 	getString(R.string.digit_keyboard_font));
	TextView key = (TextView)findViewById(R.id.button_about_ok);
	key.setTypeface(keys);


Как видите, таким способом можно применить шрифт к надписям на кнопках и других **View**, которые можно явно привести типу **TextView**.


Ещё одна супер-полезная и очень секретная фишка
Допустим, требуется применить шрифт к группе элементов, которые располагаются в layout-файле внутри корневого элемента типа **ViewGroup** с присвоенным ему уникальным **id**


	<LinearLayout
    android:id="@+id/digit_keyboard_layout"
    android:layout_width="wrap_content"
    android:layout_height="match_parent"
    android:layout_gravity="center_horizontal"
    android:orientation="vertical">

    <TableLayout
        android:id="@+id/table1"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content">

        <TableRow
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_weight="3">

            <Button
                android:id="@+id/button_one"
                style="@style/calc_button_style"
                android:layout_width="@dimen/button_width"
                android:text="@string/one"
                android:layout_alignParentStart="false"
                android:layout_alignParentEnd="false"
                android:layout_weight="1"/>

            <Button
                android:id="@+id/button_two"
                style="@style/calc_button_style"
                android:layout_width="@dimen/button_width"
                android:text="@string/two"
                android:layout_weight="1"/>

            <Button
                android:id="@+id/button_three"
                android:text="@string/three"
                style="@style/calc_button_style"
                android:layout_width="@dimen/button_width"
                android:layout_weight="1"
                />
        </TableRow>
    </TableLayout>
	</LinearLayout>


Используйте в коде приложения вот такой метод


	// Sets the font on all TextViews in the ViewGroup.
    public void setFont(ViewGroup group, Typeface font) {
        int count = group.getChildCount();
        View v;
        for(int i = 0; i < count; i++) {
            v = group.getChildAt(i);
            if(v instanceof TextView) {
                ((TextView)v).setTypeface(font);
            } else if(v instanceof ViewGroup) {
                setFont((ViewGroup) v, font);
            }
        }
    }

Метод рекурсивно вызывает сам себя пока не доберётся до нужного элемента в любой сложной xml-структуре **layout**. 

Вызывая этот метод устанавливаем шрифт группе элементов.

	Typeface keys = Typeface.createFromAsset(getAssets(), 	getString(R.string.digit_keyboard_font));
	ViewGroup keyboardArea = (ViewGroup)findViewById(R.id.digit_keyboard_layout);
	setFont(keyboardArea, keys);

У кого есть какие то наработки или идеи, пишите в комментариях. Мы обязательно добавим статью на блог!

Жду ваших комментариев!Добрый день друзья.
Сегодня наша статья будет полезна не только гуру android программирования, но и тем кто только стал на этот не легкий тернистый путь.

Сегодня мы поговорим о том как с помощь Intent намерений можно выполнять самые различные операции.

Ну что поехали?

<!-- more -->

**Открыть браузер**

	Uri uri = Uri.parse("http://www.google.com");
	Intent it  = new Intent(Intent.ACTION_VIEW,uri);
	startActivity(it);

**Открыть карту с координатами**

	Uri uri = Uri.parse("geo:38.899533,-77.036476");
	Intent it = new Intent(Intent.Action_VIEW,uri);
	startActivity(it); 

**Показать путь**

	Uri uri = Uri.parse("http://maps.google.com/maps?f=d&saddr=startLat%20startLng&daddr=endLat%20endLng&hl=en");
	Intent it = new Intent(Intent.ACTION_VIEW,URI);
	startActivity(it);

**Позвонить с программы**

	Uri uri = Uri.parse("tel:xxxxxx");
	Intent it = new Intent(Intent.ACTION_DIAL, uri);  
	startActivity(it);  

	Uri uri = Uri.parse("tel.xxxxxx");
	Intent it =new Intent(Intent.ACTION_CALL,uri);

Не забудьте добавить разрешение в манифесте.

	<uses-permission id="android.permission.CALL_PHONE" />

**Отправка сообщения с помощью встроенной программы**

	Intent it = new Intent(Intent.ACTION_VIEW);   
	it.putExtra("sms_body", "The SMS text");   
	it.setType("vnd.android-dir/mms-sms");   
	startActivity(it);  

**Отправка сообщения на номер телефона**

	Uri uri = Uri.parse("smsto:0800000123");   
	Intent it = new Intent(Intent.ACTION_SENDTO, uri);   
	it.putExtra("sms_body", "The SMS text");   
	startActivity(it);  

**Отправка MMS**

	Uri uri = Uri.parse("content://media/external/images/media/23");   
	Intent it = new Intent(Intent.ACTION_SEND);   
	it.putExtra("sms_body", "some text");   
	it.putExtra(Intent.EXTRA_STREAM, uri);   
	it.setType("image/png");   
	startActivity(it); 

**Отправка почты**
 
	Uri uri = Uri.parse("mailto:xxx@abc.com");
	Intent it = new Intent(Intent.ACTION_SENDTO, uri);
	startActivity(it);

	Intent it = new Intent(Intent.ACTION_SEND);   
	it.putExtra(Intent.EXTRA_EMAIL, "me@abc.com");   
	it.putExtra(Intent.EXTRA_TEXT, "The email body text");   
	it.setType("text/plain");   
	startActivity(Intent.createChooser(it, "Choose Email Client"));  

	Intent it=new Intent(Intent.ACTION_SEND);     
	String[] tos={"me@abc.com"};     
	String[] ccs={"you@abc.com"};     
	it.putExtra(Intent.EXTRA_EMAIL, tos);     
	it.putExtra(Intent.EXTRA_CC, ccs);     
	it.putExtra(Intent.EXTRA_TEXT, "The email body text");     
	it.putExtra(Intent.EXTRA_SUBJECT, "The email subject text");     
	it.setType("message/rfc822");     
	startActivity(Intent.createChooser(it, "Choose Email Client"));   


**Добавление файлов**

	Intent it = new Intent(Intent.ACTION_SEND);   
	it.putExtra(Intent.EXTRA_SUBJECT, "The email subject text");   
	it.putExtra(Intent.EXTRA_STREAM, "file:///sdcard/mysong.mp3");   
	sendIntent.setType("audio/mp3");   
	startActivity(Intent.createChooser(it, "Choose Email Client"));

**Проигрывание музыки**

	Intent it = new Intent(Intent.ACTION_VIEW);
	Uri uri = Uri.parse("file:///sdcard/song.mp3");
	it.setDataAndType(uri, "audio/mp3");
	startActivity(it);

	Uri uri = Uri.withAppendedPath(MediaStore.Audio.Media.INTERNAL_CONTENT_URI, "1");   
	Intent it = new Intent(Intent.ACTION_VIEW, uri);   
	startActivity(it);  

**Удаление программы**

	Uri uri = Uri.fromParts("package", strPackageName, null);   
	Intent it = new Intent(Intent.ACTION_DELETE, uri);   
	startActivity(it);

	Uri uninstallUri = Uri.fromParts("package", "xxx", null);
	returnIt = new Intent(Intent.ACTION_DELETE, uninstallUri);

**Установка программы**

	Uri installUri = Uri.fromParts("package", "xxx", null);
	returnIt = new Intent(Intent.ACTION_PACKAGE_ADDED, installUri);

**Поиск на маркете**

	Uri uri = Uri.parse("market://search?q=pname:pkg_name");  
	Intent it = new Intent(Intent.ACTION_VIEW, uri);  
	startActivity(it);  


**Показать детали программы**

	Uri uri = Uri.parse("market://details?id=app_id");  
	Intent it = new Intent(Intent.ACTION_VIEW, uri);  
	startActivity(it);  

**Поиск в Google**

	Intent intent = new Intent();
	intent.setAction(Intent.ACTION_WEB_SEARCH);
	intent.putExtra(SearchManager.QUERY,"searchString")
	startActivity(intent);


Ну вот и все, расскажи своим друзьям. Нажимай лайки и пиши свои комментарии.В этой статье я расскажу как как установить среду разработки Android используя Android Studio и Genymotion. При переходе от Eclispe/ADT к Android Studio я исследовал альтернативные конфигурации для улучшения сборочной среды. Нашел неплохой эмулятор Genymotion. Интересный, довольно быстрый и очень простой.





**Что нам нужно?**




<!-- more -->



  * [Android Studio](http://android-helper.com.ua/android-studio/)



  * [Oracle VM VirtualBox](https://www.virtualbox.org/wiki/Downloads)



  * [Genymotion Android emulator](http://www.genymotion.com/)



  * [Genymotion Android studio plugin](http://www.genymotion.com/)






**Установка Oracle VM VirtualBox** Если вы используете Windows в загруженном вами пакете будет все необходимое, в противном случае вам нужно будет скачать и установить ее самостоятельно. Процесс простой и прямолинейный но эти действия необходимо выполнить иначе Android Emulator не запуститься.





**Установка Genymotion Android device emulator** Первое что нужно это сделать создать аккаунт, чтобы иметь возможность скачать эмулятор. Вы можете выбирать среди платформ, в моем случае это Mac OS X. Когда вы его скачали и установили у вас должно получиться что-то такое:



![Genymotion Android device emulator](https://lh4.googleusercontent.com/-XTLtY_Lu-uo/UdZ1ohxTDpI/AAAAAAAAIxU/UHNpDYatWSE/w878-h549-no/emulator1.png)  
  
Genymotion Android device emulator



У вас может быть доступно множество эмуляторов. Вы выбираете и грузите его с сети. Как результат у вас готовый эмулятор.



![Genymotion Android device emulator](https://lh3.googleusercontent.com/-bSICk3KwvT0/UdZ1oresDZI/AAAAAAAAIxE/VXQYFWzmdBs/w878-h549-no/emulator2.png)  
  
Genymotion Android device emulator



**Установка Android Studio Plugin** Чтобы интегрировать средство разработки с эмулятором вам необходимо установить плагин для Android Studio. Зайдите в Preferences там Plugin, выбираем нужный нам. Добавляем плагин который мы уже скачали и видим:



![Genymotion Android Studio Plugin](https://lh3.googleusercontent.com/-7ESa9bvI8oY/UdZ1ouyWdyI/AAAAAAAAIxQ/cod9TPdH1Qc/w878-h549-no/emulator3.png)  
  
Genymotion Android Studio Plugin



**Результат**





Теперь вы можете запустить Android проект и вы увидите:



![Genymotion Android Studio Plugin](https://lh4.googleusercontent.com/-pu_27RpWvZI/UdZ1pYXK1xI/AAAAAAAAIxM/qk4W1XYDUw4/w878-h549-no/emulator4_1.png)  
  
Genymotion Android Studio Plugin



Эмулятор полностью интегрирован в вашу среду разработки . Первый раз когда вы запустите эмулятор вы можете увидеть диалог который спросит путь к Android SDK:



![Genymotion Android Studio Plugin](https://lh3.googleusercontent.com/-kJdXolrj9RQ/UdZ1pOHCHFI/AAAAAAAAIxI/L8cSs1wTSNk/w878-h549-no/emulator4.png)  
  
Genymotion Android Studio Plugin



Как-только все настроено можно запускать свой проект. ![Genymotion Android Studio Plugin](https://lh4.googleusercontent.com/-vvfjkEI4RRw/UdZ1ph1p7II/AAAAAAAAIxc/n31dDQvUqj4/w878-h549-no/emulator5.png)





**Видео**



{% youtube 63T-8YRlFmE %}





Надеюсь статья была для вас полезной. Если да нажимайте рассказать друзьям :)
Всем привет.





За этих 2 дня мы посомтрели очень много полезной информации.





Сегодня же стартует не менее важная презентация.


<!-- more -->




**Google I/O Pitch Night**





Что вы можете тут взять для себя?





Как делать стартапы и правильно их презентовать.





Ну что смотрим?


{% youtube 9yZ6KpZ6y44 %}

Срочно!





Все трансляции в одном месте!<!-- more -->





**Google I/O 2013: Day 2 Android Sessions**





**Google I/O 2013 Technical Sessions 2**





**Google I/O 2013 Chrome Sessions**




{% youtube hXPAXKb-LQE %}Всем привет.





Сегодня стартует очень популярная конференция **Google I/O 2013**.





И наш сайт ведет онлайн трансляцию.



 <!-- more -->

Что будет и сама трансляция








  * на ней будет представлена новая версия операционной системы Android 4.3



  * новые планшеты семейства Nexus



  * умные очки Google Glass






**Онлайн трансляция:**


{% youtube 9pmPa_KxsAM %}






Расскажите друзьям.
> 


> 
> Привет друзья. Я очень рад, приветствовать вас на нашем блоге. Сегодня мы рассмотрим следующую задачу.
> 
> 







### Задача





Нужно сделать вывод сообщения поверх ActionBar.


 <!-- more -->

![device-2013-05-03-234631](http://android-helper.com.ua/images/uploads/2013/05/device-2013-05-03-234631.png)]
![device-2013-05-03-234636](http://android-helper.com.ua/images/uploads/2013/05/device-2013-05-03-234636.png)
![device-2013-05-03-234643](http://android-helper.com.ua/images/uploads/2013/05/device-2013-05-03-234643.png)
![device-2013-05-03-234657](http://android-helper.com.ua/images/uploads/2013/05/device-2013-05-03-234657.png)




### Краткое описание





И так наша задача вывести нотификацию поверх ActionBar. Ну скажем это одно из требований дизайна и заказчика.





### Видео


{% youtube xIuhouqkX8E %}






### Коды для реализации





**MainActivity.java**




    
    @Override
    
    public void onCreate(Bundle savedInstanceState) {
    
        super.onCreate(savedInstanceState);
    
        ActionBar actionBar = getActionBar();
    
        actionBar.setDisplayOptions(ActionBar.DISPLAY_SHOW_HOME
    
                | ActionBar.DISPLAY_SHOW_TITLE | ActionBar.DISPLAY_SHOW_CUSTOM);
    
    
    
        setContentView(R.layout.main);
    
    
    
        prepareNotificationBar();
    
    
    
        initButtons();
    
    }
    
    
    
    private void prepareNotificationBar() {
    
        android.view.Window window = getWindow();
    
    
    
        // Получаем полное строенние вашего приложения
    
        ViewGroup decor = (ViewGroup) window.getDecorView();
    
        // Берем первый элемент, это то что было построенно
    
        View allcontent = decor.getChildAt(0);
    
        // Удаляем его что бы очистить строение
    
        decor.removeView(allcontent);
    
    
    
        LayoutInflater li = getLayoutInflater();
    
        // загружаем части элементов
    
        FrameLayout main = (FrameLayout) li.inflate(R.layout.content_frame, null);
    
        FrameLayout notificationFrame = (FrameLayout) li.inflate(R.layout.notification_frame, null);
    
        // находим нужные нам фреймы
    
        notificationBar = (ViewGroup) main.findViewById(R.id.notificationLayout);
    
        content = (ViewGroup) main.findViewById(R.id.contentLayout);
    
    
    
        // ВАЖНО! получаем высоту статус бара
    
        // -----
    
        int resourceId = getResources().getIdentifier("status_bar_height", "dimen", "android");
    
    
    
        statusBarHeight = 0;
    
    
    
        if (resourceId > 0) {
    
            statusBarHeight = getResources().getDimensionPixelSize(resourceId);
    
        }
    
        // -----
    
    
    
        // Сдвигаем наши фреймы на высоту статус бара
    
        notificationBar.setPadding(notificationBar.getPaddingLeft(), statusBarHeight, notificationBar.getPaddingRight(),
    
                0);
    
        notificationBar.addView(notificationFrame);
    
    
    
        content.setPadding(content.getPaddingLeft(), statusBarHeight, content.getPaddingRight(),
    
                0);
    
    
    
        // добавляем фреймы
    
        content.addView(allcontent);
    
        decor.addView(main);
    
    }
    
    







### Скачать коды





Скачать коды программы вы можете на нашей [странице](http://android-helper.com.ua/codes/)





### Скачать приложение





Также мы выложили на [Play Market](https://play.google.com/store/apps/details?id=com.android_helper.ActionBarNotification) наше приложение. Установив его, вы сможете посмотреть как оно работает. (Не забудьте поставить +1 и написать позитивный комментарий :) ).





[![Android app on Google Play](https://developer.android.com/images/brand/en_app_rgb_wo_45.png)](https://play.google.com/store/apps/details?id=com.android_helper.ActionBarNotification)





### Оценка статьи





Надеюсь, что вам понравилась статья. Жду ваши комментарии и несколько лайков.
### Задача





Красочный переход между Activity.


 <!-- more -->


### Краткое описание





Многие из вас видели как красиво в некоторых приложениях идут переходы между Activity. Если взять простые примеры от Google, то вы увидите только плавное смещение с лева на право. А у нас с вами задача сделать так, что бы из первого Activity появлялось второе.





### Видео урок



{% youtube Bfh0cJBOASQ %}





### Коды





**Activity1.java**




    
    	SplitAnimation.startActivity(Activity1.this, new Intent(Activity1.this, Activity2.class));





**Activity2.java**




    
    
		@Override
    
    protected void onCreate(Bundle savedInstanceState) {
    
        super.onCreate(savedInstanceState);
    
    
    
        // Preparing the 2 images to be split
    
        SplitAnimation.prepareAnimation(this);
    
    
    
        setContentView(R.layout.act_two);
    
    
    
        // Animating the items to be open, revealing the new activity
    
        SplitAnimation.animate(this, 1000);
    
    }
    
    
    
    @Override
    
    protected void onStop() {
    
        // If we're currently running the entrance animation - cancel it
    
        SplitAnimation.cancel();
    
    
    
        super.onStop();    //To change body of overridden methods use File | Settings | File Templates.
    
    }
    
    



**SplitAnimation.java**




    
    	public static void startActivity(Activity currActivity, Intent intent) {
    
        // Подготовка acticity
    
        prepare(currActivity);
    
    
    
        currActivity.startActivity(intent);
    
        // Чистка анимаций текущей activity
    
        currActivity.overridePendingTransition(0, 0);
    
    }
    
    
    
    private static void prepare(Activity currActivity) {
    
    
    
        // Получаем content activity и делаем из него bitmap
    
        View root = currActivity.getWindow().getDecorView().findViewById(android.R.id.content);
    
        root.setDrawingCacheEnabled(true);
    
        Bitmap bmp = root.getDrawingCache();
    
    
    
        // Указываем в какой части экрана будет делится activity
    
        splitYCoord = bmp.getHeight() / 2;
    
    
    
        // Разделяем экран
    
        mBmp1 = Bitmap.createBitmap(bmp, 0, 0, bmp.getWidth(), splitYCoord);
    
        mBmp2 = Bitmap.createBitmap(bmp, 0, splitYCoord, bmp.getWidth(), bmp.getHeight() - splitYCoord);
    
    
    
        // Указываем координаты положения частей activity
    
        mLoc1 = new int[]{0, root.getTop()};
    
        mLoc2 = new int[]{0, root.getTop() + splitYCoord};
    
    }
    
    
    
    public static void prepareAnimation(final Activity destActivity) {
    
        mTopImage = createImageView(destActivity, mBmp1, mLoc1);
    
        mBottomImage = createImageView(destActivity, mBmp2, mLoc2);
    
    }
    
    
    
    private static ImageView createImageView(Activity destActivity, Bitmap bmp, int loc[]) {
    
        ImageView imageView = new ImageView(destActivity);
    
        imageView.setImageBitmap(bmp);
    
    
    
        WindowManager.LayoutParams windowParams = new WindowManager.LayoutParams();
    
        windowParams.gravity = Gravity.TOP;
    
        windowParams.x = loc[0];
    
        windowParams.y = loc[1];
    
        windowParams.height = ViewGroup.LayoutParams.WRAP_CONTENT;
    
        windowParams.width = ViewGroup.LayoutParams.WRAP_CONTENT;
    
        windowParams.flags =
    
                WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN
    
        ;
    
        windowParams.format = PixelFormat.TRANSLUCENT;
    
        windowParams.windowAnimations = 0;
    
        destActivity.getWindowManager().addView(imageView, windowParams);
    
    
    
        return imageView;
    
    }
    
    
    
    public static void animate(final Activity destActivity, final int duration) {
    
        animate(destActivity, duration, new DecelerateInterpolator());
    
    }
    
    
    
    public static void animate(final Activity destActivity, final int duration, final TimeInterpolator interpolator) {
    
    
    
        // Post this on the UI thread's message queue. It's needed for the items to be already measured
    
        new Handler().post(new Runnable() {
    
    
    
            @Override
    
            public void run() {
    
                mSetAnim = new AnimatorSet();
    
                mTopImage.setLayerType(View.LAYER_TYPE_HARDWARE, null);
    
                mBottomImage.setLayerType(View.LAYER_TYPE_HARDWARE, null);
    
                mSetAnim.addListener(new Animator.AnimatorListener() {
    
                    @Override
    
                    public void onAnimationStart(Animator animation) {
    
                    }
    
    
    
                    @Override
    
                    public void onAnimationEnd(Animator animation) {
    
                        clean(destActivity);
    
                    }
    
    
    
                    @Override
    
                    public void onAnimationCancel(Animator animation) {
    
                        clean(destActivity);
    
                    }
    
    
    
                    @Override
    
                    public void onAnimationRepeat(Animator animation) {
    
    
    
                    }
    
                });
    
    
    
                // Animating the 2 parts away from each other
    
                Animator anim1 = ObjectAnimator.ofFloat(mTopImage, "translationY", mTopImage.getHeight() * -1);
    
                Animator anim2 = ObjectAnimator.ofFloat(mBottomImage, "translationY", mBottomImage.getHeight());
    
    
    
                if (interpolator != null) {
    
                    anim1.setInterpolator(interpolator);
    
                    anim2.setInterpolator(interpolator);
    
                }
    
    
    
                mSetAnim.setDuration(duration);
    
                mSetAnim.playTogether(anim1, anim2);
    
                mSetAnim.start();
    
            }
    
        });
    
    }
    


### Скачать коды





Скачать коды программы вы можете на нашей [странице](http://android-helper.com.ua/codes/)





### Скачать приложение





Также мы выложили на [Play Market](https://play.google.com/store/apps/details?id=com.android_helper.SplitActivityAnimation) наше приложение. Установив его, вы сможете посмотреть как оно работает. (Не забудьте поставить +1 и написать позитивный комментарий :) ).





[![Android app on Google Play](https://developer.android.com/images/brand/en_app_rgb_wo_45.png)](https://play.google.com/store/apps/details?id=com.android_helper.SplitActivityAnimation)





### Оценка статьи





Надеюсь, что вам понравилась статья. Жду ваши комментарии и несколько лайков.




Всем привет.





Сегодня один из моих читателей попросил написать статью как можно изменять цвет елементам.





В своем примере я покажу, как можно менять цвет выбранной кнопки.




 <!-- more -->




А теперь части кода:





**colors.xml**





	<color name="widget_button_pressed">#FFFF00</color>

	<color name="widget_button">#00000000</color>

	<color name="widget_background">#FF000000</color>



	<?xml version="1.0" encoding="utf-8"?>

	<selector xmlns:android="http://schemas.android.com/apk/res/android">



		<item android:drawable="@color/widget_button_pressed" android:state_pressed="true"/>

		<item android:drawable="@color/widget_button_pressed" android:state_selected="true"/>

		<item android:drawable="@color/widget_button_pressed" android:state_focused="true"/>

		<item android:drawable="@color/widget_button"/>

	</selector>



	<Button

		android:layout_width="wrap_content"

		android:layout_height="wrap_content"

		android:background="@drawable/button_selector"

		android:text="@string/hello_world" />





Полный проект вы можете скачать на нашей [странице с кодами](http://android-helper.com.ua/codes/).
Всем привет друзья.





Сегодня я подготовил для вас видео урок.





Как использовать Switch елемент для android 4.0+, а для версий ниже использовать CheckBox.

 <!-- more -->

{% youtube Ifs96nSYUlg %}






**Коды**





**/layout-v14/switch_for_include.xml**



	<?xml version="1.0" encoding="utf-8"?>

	<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"

    android:layout_width="match_parent"

    android:layout_height="match_parent"

    android:orientation="horizontal" >



    <Switch

        android:id="@+id/checkBox1"

        android:layout_width="fill_parent"

        android:layout_height="wrap_content"

        android:text="Android-helper.com.ua" />



	</LinearLayout>


**/layout/switch_for_include.xml**



	<?xml version="1.0" encoding="utf-8"?>

	<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"

    android:layout_width="match_parent"

    android:layout_height="match_parent"

    android:orientation="horizontal" >



    <TextView

        android:layout_width="fill_parent"

        android:layout_height="wrap_content"

        android:layout_weight="1"

        android:text="Android-helper.com.ua" />



    <CheckBox

        android:id="@+id/checkBox1"

        android:layout_width="wrap_content"

        android:layout_height="wrap_content"

        android:layout_weight="0" />



	</LinearLayout>


**/layout/activity_main.xml**


	<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"

    xmlns:tools="http://schemas.android.com/tools"

    android:layout_width="match_parent"

    android:layout_height="match_parent"

    android:orientation="vertical"

    tools:context=".MainActivity" >



    <TextView

        android:layout_width="wrap_content"

        android:layout_height="wrap_content"

        android:gravity="center"

        android:paddingBottom="30dp"

        android:text="Пример того как использовать Swich на разных устройствах" />



    <include layout="@layout/switch_for_include" />



	</LinearLayout>




**MainActivity.java**



	public class MainActivity extends Activity implements OnCheckedChangeListener {



    @Override

    protected void onCreate(Bundle savedInstanceState) {

        super.onCreate(savedInstanceState);

        setContentView(R.layout.activity_main);

        CompoundButton compoundButton = (CompoundButton) findViewById(R.id.checkBox1);

        compoundButton.setOnCheckedChangeListener(this);

    }



    @Override

    public void onCheckedChanged(CompoundButton arg0, boolean arg1) {

        Toast.makeText(this, "Все работает сейчас у нас " + arg1, Toast.LENGTH_LONG).show();

    }



	}


Коды программы вы можете скачать [тут](http://android-helper.com.ua/codes/)




Очень познавательная статья.





Читать всем разработчикам!





Перед любым начинающим Android-разработчиком рано или поздно встает вопрос о том, где и как удобнее запускать и отлаживать свои программы.













Самый верный способ — через Android Debug Bridge на реальном Android-устройстве. Но если, по каким то причинам, этот способ не подходит, то остается два варианта — воспользоваться штатным эмулятором Android Virtual Device (AVD) из Android SDK, или установить Android на виртуальную машину.  Про второй вариант я и хочу рассказать в этой статье. Android на виртуальной машине серьезно превосходит AVD по быстродействию и времени загрузки, но есть и недостатки — сложнее эмулировать телефонию (возможно, при помощи дополнительных программ), пока не разобрался как смонтировать SD-карту.







 <!-- more -->





**Итак! Нам понадобится**:





1. Готовая к работе среда разработки и Android SDK Tools - см. StartAndroid.ru урок 2.  
[http://startandroid.ru/uroki/vse-uroki-spiskom/9-urok-2-ustanovka-i-nastrojka-sredy-razrabotki.html](http://startandroid.ru/uroki/vse-uroki-spiskom/9-urok-2-ustanovka-i-nastrojka-sredy-razrabotki.html)





2. VirtualBox последней версии.  
[https://www.virtualbox.org/](https://www.virtualbox.org/).





3. Образ Android. Выбираем любую версию с сайта проекта Android-x86.  
[http://code.google.com/p/android-x86/](http://code.google.com/p/android-x86/)









### Шаг 1 — устанавливаем Virtual Box.





![](http://startandroid.ru/images/stories/articles/A0002/A0002_050.png)





![](http://startandroid.ru/images/stories/articles/A0002/A0002_060.png)





![](http://startandroid.ru/images/stories/articles/A0002/A0002_070.png)





![](http://startandroid.ru/images/stories/articles/A0002/A0002_080.png)





![](http://startandroid.ru/images/stories/articles/A0002/A0002_090.png)





![](http://startandroid.ru/images/stories/articles/A0002/A0002_100.png)













### Шаг 2 — Создаем виртуальную машину с Android.





![](http://startandroid.ru/images/stories/articles/A0002/A0002_110.png)





![](http://startandroid.ru/images/stories/articles/A0002/A0002_120.png)





![](http://startandroid.ru/images/stories/articles/A0002/A0002_130.png)





![](http://startandroid.ru/images/stories/articles/A0002/A0002_140.png)





![](http://startandroid.ru/images/stories/articles/A0002/A0002_150.png)





![](http://startandroid.ru/images/stories/articles/A0002/A0002_160.png)





![](http://startandroid.ru/images/stories/articles/A0002/A0002_170.png)













### Шаг 3 — настройка виртуальной машины и её запуск.





![](http://startandroid.ru/images/stories/articles/A0002/A0002_180.png)





![](http://startandroid.ru/images/stories/articles/A0002/A0002_190.png)





![](http://startandroid.ru/images/stories/articles/A0002/A0002_200.png)





![](http://startandroid.ru/images/stories/articles/A0002/A0002_210.png)





![](http://startandroid.ru/images/stories/articles/A0002/A0002_220.png)





Система не может найти диск для загрузки и останавливается. Монтируем скачанный образ Android.





![](http://startandroid.ru/images/stories/articles/A0002/A0002_230.png)





![](http://startandroid.ru/images/stories/articles/A0002/A0002_240.png)









Выбрать можно любой, но я советую работать с версией для EEEPC, например  
[android-x86-3.2-RC2-eeepc.iso](http://code.google.com/p/android-x86/downloads/detail?name=android-x86-3.2-RC2-eeepc.iso&can=4&q=). В других может возникнуть проблема — из под Android не будет виден виртуальный сетевой адаптер.





Перегружаем машину.





![](http://startandroid.ru/images/stories/articles/A0002/A0002_250.png)





![](http://startandroid.ru/images/stories/articles/A0002/A0002_260.png)





![](http://startandroid.ru/images/stories/articles/A0002/A0002_270.png)





Нажимаем ENTER и ждет загрузки Android.





![](http://startandroid.ru/images/stories/articles/A0002/A0002_280.png)





Закрываем обучающие подсказки. И выключаем функцию интеграции мыши, которая некорректно работает с нашей ОС, скрывая курсор.





![](http://startandroid.ru/images/stories/articles/A0002/A0002_290.png)













### Шаг 4 — настройка сети в виртуальном Android.





Щелкаем внутри окна и оказываемся в пространстве виртуальной машины.   
(чтобы вернуть курсор нужно нажать **правый CTRL**)





![](http://startandroid.ru/images/stories/articles/A0002/A0002_300.png)









Нажимаем **Alt+F1** и оказываемся в консоли.





![](http://startandroid.ru/images/stories/articles/A0002/A0002_310.png)









Присваиваем адрес сетевому адаптеру командой **ifconfig**:  
**ifconfig eth0 192.168.56.2 netmask 255.255.255.0**









Проверяем или переходим к следующему шагу. Основной комп пингуется по адресу 192.168.56.1 ("VirtualBox Host-Only Ethernet Adapter" в диспетчере устройств).  
Команда **ping**:  
**ping 192.168.56.1**  
**Ctrl+C**









Если все сработало нормально то увидим:





![](http://startandroid.ru/images/stories/articles/A0002/A0002_320.png)













### Шаг 5 — подсоединяем Android Debug Bridge (ADB) к виртуальной ОС.





Нажимаем **Alt+F7**, чтобы вернуться к графическому интерфейсу. Нажимаем **правый CTRL** и возвращаемся к реальной ОС. Не закрываем виртуальную машину.





Создаем на рабочем столе ярлык на **adb.exe**





![](http://startandroid.ru/images/stories/articles/A0002/A0002_330.png)





Нужный нам файл находится в папке Android SDK "platform-tools".





![](http://startandroid.ru/images/stories/articles/A0002/A0002_340.png)





Дописываем команду текстом "**connect 192.168.56.2**":





![](http://startandroid.ru/images/stories/articles/A0002/A0002_360.png)





![](http://startandroid.ru/images/stories/articles/A0002/A0002_370.png)









Запускаем ярлык.





Теперь ADB соединен с виртуальным Android, а он, в свою очередь, доступен для запуска и отладки программ из Eclipse. Цель достигнута. :)





Пересоединять ADB придется в том случае, когда вы закрыли или перезагрузили виртуальную машину.





**Так-же в случае, если вы перезагрузили виртуальный Android, придется возвращаться к шагу 4, так как настройки сетевого адаптера будут сброшены**. Поэтому я рекомендую не выключать виртуальную машину, а погружать её в сон, но ярлычек потом запустить все равно придется.





![](http://startandroid.ru/images/stories/articles/A0002/A0002_380.png)





![](http://startandroid.ru/images/stories/articles/A0002/A0002_390.png)













Заходим в Eclipse и проверяем как работает





![](http://startandroid.ru/images/stories/articles/A0002/A0002_400.png)





![](http://startandroid.ru/images/stories/articles/A0002/A0002_410.png)





![](http://startandroid.ru/images/stories/articles/A0002/A0002_420.png)













![](http://startandroid.ru/images/stories/articles/A0002/A0002_430.png)





Благодарности:





**renton** с habrahabr.ru — его идея.  
[http://habrahabr.ru/post/119599/](http://habrahabr.ru/post/119599/)





 Источник [startandroid.ru](http://startandroid.ru/ru/articles/listofarticles/206-bystraja-alternativa-android-virtual-device.html)
Всем привет.





Есть много программ с которых программисты и дизайнеры берут свои идеи.





И вот одна из которых это приложение facebook для android.





С этой программы дизайнеры взяли такую вещь как sliding menu.





Давайте посмотрим, что это такое.

 <!-- more -->



![Screenshot_2013-01-17-19-47-11](http://android-helper.com.ua/images/uploads/2013/01/Screenshot_2013-01-17-19-47-11.png)




 





![Screenshot_2013-01-02-02-24-31](http://android-helper.com.ua/images/uploads/2013/01/Screenshot_2013-01-02-02-24-31.png)





 





### Задача





Сделать что то подобное.





### Реализация





Для реализации данной задачи, мы будем использовать открытую библиотеку [SlidingMenu](https://github.com/jfeinstein10/SlidingMenu).





Также как она работает можете посмотреть, скачав приложение с [маркета](https://play.google.com/store/apps/details?id=com.slidingmenu.example).





### Коды





**MainActivity.java**



	public class MainActivity extends Activity {



    @Override

    protected void onCreate(Bundle savedInstanceState) {

        super.onCreate(savedInstanceState);

        setContentView(R.layout.activity_main);



        setTitle("Attach");

        // configure the SlidingMenu

        SlidingMenu menu = new SlidingMenu(this);

        menu.setMode(SlidingMenu.LEFT);

        menu.setTouchModeAbove(SlidingMenu.TOUCHMODE_FULLSCREEN);

        menu.setShadowWidthRes(R.dimen.shadow_width);

        menu.setShadowDrawable(R.drawable.shadow);

        menu.setBehindOffsetRes(R.dimen.slidingmenu_offset);

        menu.setFadeDegree(0.35f);



        // ///////////

        menu.attachToActivity(this, SlidingMenu.SLIDING_CONTENT);

        // //////////



        menu.setMenu(R.layout.menu);

    }



    @Override

    public boolean onCreateOptionsMenu(Menu menu) {

        // Inflate the menu; this adds items to the action bar if it is present.

        getMenuInflater().inflate(R.menu.activity_main, menu);

        return true;

    }



	}


**drawable/shadow.xml**


	<?xml version="1.0" encoding="utf-8"?>

	<shape xmlns:android="http://schemas.android.com/apk/res/android" >



    <gradient

        android:centerColor="#11000000"

        android:endColor="#33000000"

        android:startColor="#00000000" />



	</shape>


**layout/menu.xml**


	<?xml version="1.0" encoding="utf-8"?>

	<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"

    android:layout_width="match_parent"

    android:layout_height="match_parent"

    android:orientation="vertical" >



    <TextView

        android:id="@+id/textView1"

        android:layout_width="wrap_content"

        android:layout_height="wrap_content"

        android:text="Menu 1"

        android:textAppearance="?android:attr/textAppearanceLarge" />



    <TextView

        android:id="@+id/textView2"

        android:layout_width="wrap_content"

        android:layout_height="wrap_content"

        android:text="Menu 2"

        android:textAppearance="?android:attr/textAppearanceLarge" />



    <TextView

        android:id="@+id/textView3"

        android:layout_width="wrap_content"

        android:layout_height="wrap_content"

        android:text="Menu 3"

        android:textAppearance="?android:attr/textAppearanceLarge" />



    <TextView

        android:id="@+id/textView4"

        android:layout_width="wrap_content"

        android:layout_height="wrap_content"

        android:text="Menu 4"

        android:textAppearance="?android:attr/textAppearanceLarge" />



	</LinearLayout>


**values/dimens.xml**



	<?xml version="1.0" encoding="utf-8"?>

	<resources>



    <dimen name="slidingmenu_offset">60dp</dimen>

    <dimen name="list_padding">10dp</dimen>

    <dimen name="shadow_width">15dp</dimen>



	</resources>


### Видео


{% youtube eHWNIS64I0Q %}






Рабочий код на странице с [кодами](http://android-helper.com.ua/codes/).
Привет друзья.





После выхода android 4. Все дизайнеры как будто сговорились и прикручивают actionbar кругом.





И заказчик говорит, что именно так должно быть и для старых версий.





И что же делать? Писать свой actionbar?


 <!-- more -->


Нам на помощь приходит очень классная и бесплатная библиотека [ActionBarSherlock](http://actionbarsherlock.com/)





Я думаю, что большая часть из вас будет ее использовать.





Но могут быть и такие которые скажут, мы не используем сторонние библиотеки.





Это вам решать, но от себя добавлю, что эту библиотеку рекомендует google.





Пришло время писать код.





### Задача





Сделать actionbar меню для всех телефонов.





### Ресурсы





ActionBarSherlock





### Примеры реализации





![feature_02](http://android-helper.com.ua/images/uploads/2013/01/feature_02.png)





 





![feature_03](http://android-helper.com.ua/images/uploads/2013/01/feature_03.png)



 





![feature_01](http://android-helper.com.ua/images/uploads/2013/01/feature_01.png)





 





 





### Реализация








  1. Подключаем проект Sherlock в eclipse. Скачать можно [тут](https://api.github.com/repos/JakeWharton/ActionBarSherlock/zipball/4.2.0).



  2. Создаем свой проект



  3. Подключаем библиотеку sherlock к вашему проекту



  4. Делаем файл меню



  5. ВАЖНО! Все активити и фрагменты должны наследоваться от SherlockActivity и SherlockFragment






### Коды





#### menu/activity_main.xml





	<menu xmlns:android="http://schemas.android.com/apk/res/android" >



    <item

        android:id="@+id/item1"

        android:icon="@android:drawable/ic_menu_agenda"

        android:orderInCategory="100"

        android:showAsAction="always|withText"

        android:title="Item 1"/>

    <item

        android:id="@+id/item2"

        android:icon="@android:drawable/ic_menu_call"

        android:orderInCategory="200"

        android:showAsAction="always|withText"

        android:title="Item 2"/>

    <item

        android:id="@+id/item3"

        android:icon="@android:drawable/ic_menu_camera"

        android:orderInCategory="300"

        android:showAsAction="ifRoom|withText"

        android:title="Item3"/>

    <item

        android:id="@+id/menu_settings"

        android:orderInCategory="400"

        android:showAsAction="never"

        android:title="@string/menu_settings"/>



	</menu>





#### MainActivity.java



	package com.ua.android_helper.testactionbar;



	import android.os.Bundle;

	import com.actionbarsherlock.app.SherlockActivity;

	import com.actionbarsherlock.view.Menu;



	public class MainActivity extends SherlockActivity {



    @Override

    protected void onCreate(Bundle savedInstanceState) {

        super.onCreate(savedInstanceState);

        setContentView(R.layout.activity_main);

    }



    @Override

    public boolean onCreateOptionsMenu(Menu menu) {

        getSupportMenuInflater().inflate(R.menu.activity_main, menu);

        return true;

    }



	}


#### AndroidManifest.xml


	<?xml version="1.0" encoding="utf-8"?>

	<manifest xmlns:android="http://schemas.android.com/apk/res/android"

    package="com.ua.android_helper.testactionbar"

    android:versionCode="1"

    android:versionName="1.0" >



    <uses-sdk

        android:minSdkVersion="8"

        android:targetSdkVersion="17" />



    <application

        android:allowBackup="true"

        android:icon="@drawable/ic_launcher"

        android:label="@string/app_name"

        android:theme="@style/Theme.Sherlock" >

        <activity

            android:name="com.ua.android_helper.testactionbar.MainActivity"

            android:label="@string/app_name" >

            <intent-filter>

                <action android:name="android.intent.action.MAIN" />



                <category android:name="android.intent.category.LAUNCHER" />

            </intent-filter>

        </activity>

    </application>



	</manifest>



**Видео**

{% youtube GOB72vWY_5s %}


Друзья всем привет.





Сегодня я бы хотел поведать вам о замечательном поведении в ActionBar.





C Android 3.0 в ActionBar добавили классное поведение для выбранных элементов.





Но давайте это посмотрим на примере.

 <!-- more -->



#### Задача





Дать возможность в ListView выбрать несколько элементов и например скопировать их названия. И эти названия вывести в диалог.





#### Результат урока





[![device-2013-01-25-092939](http://android-helper.com.ua/images/uploads/2013/01/device-2013-01-25-092939-180x300.png)](http://android-helper.com.ua/images/uploads/2013/01/device-2013-01-25-092939.png)[![device-2013-01-25-093344](http://android-helper.com.ua/images/uploads/2013/01/device-2013-01-25-093344-180x300.png)](http://android-helper.com.ua/images/uploads/2013/01/device-2013-01-25-093344.png)





#### [![device-2013-01-25-093353](http://android-helper.com.ua/images/uploads/2013/01/device-2013-01-25-093353-180x300.png)](http://android-helper.com.ua/images/uploads/2013/01/device-2013-01-25-093353.png)





####  





####  





####  





####  





####  





####  





####  





####  





####  





#### [![device-2013-01-25-093405](http://android-helper.com.ua/images/uploads/2013/01/device-2013-01-25-093405-180x300.png)](http://android-helper.com.ua/images/uploads/2013/01/device-2013-01-25-093405.png)





#### [![device-2013-01-25-093431](http://android-helper.com.ua/images/uploads/2013/01/device-2013-01-25-093431-180x300.png)](http://android-helper.com.ua/images/uploads/2013/01/device-2013-01-25-093431.png)





####  





####  





####  





####  





####  





####  





####  





####  





####  





#### Реализация





Создаем проект с минимальным значением android - 11.





Activity наследуем от ListActivity.



[java]public class MainActivity extends ListActivity {



    String[] data = { "one", "two", "three", "four", "five" };



    @Override

    protected void onCreate(Bundle savedInstanceState) {

        super.onCreate(savedInstanceState);

        prepareListView();

    }

[/java]  
  




Заполняем ListView



[java] private void prepareListView() {



        ArrayAdapter<String> adapter = new ArrayAdapter<String>(this, android.R.layout.simple_list_item_activated_1,

                data);

        getListView().setAdapter(adapter);[/java]  
  




Создаем menu для action mode



[xml]<?xml version="1.0" encoding="utf-8"?>

<menu xmlns:android="http://schemas.android.com/apk/res/android" >



	<item

		android:id="@+id/copy"

		android:icon="@android:drawable/ic_menu_save"

		android:showAsAction="always|withText"

		android:title="@string/copy">

	</item>



</menu>[/xml]  
  




Добавляем обработчики для action mode и показываем диалог



[java]private final MultiChoiceModeListener callback = new MultiChoiceModeListener() {



        private final StringBuilder message = new StringBuilder();



        @Override

        public boolean onPrepareActionMode(ActionMode mode, Menu menu) {

            return false;

        }



        @Override

        public void onDestroyActionMode(ActionMode mode) {



        }



        @Override

        public boolean onCreateActionMode(ActionMode mode, Menu menu) {

            mode.getMenuInflater().inflate(R.menu.context, menu);

            return true;

        }



        @Override

        public boolean onActionItemClicked(ActionMode mode, MenuItem item) {

            if (item.getItemId() == R.id.copy) {

                AlertDialog.Builder builder = new AlertDialog.Builder(MainActivity.this);

                builder.setTitle("Action Mode").setMessage(message.toString()).create().show();

            }

            mode.finish();

            return false;

        }



        @Override

        public void onItemCheckedStateChanged(ActionMode mode, int position, long id, boolean checked) {

            if (checked) {

                String title = data[position];

                message.append("\n" + title);

            }

        }

    };[/java]  
  




Добавляем возможность вызова action mode из ListView и множественный выбор.



[java]//

        getListView().setChoiceMode(ListView.CHOICE_MODE_MULTIPLE_MODAL);

        //

        getListView().setMultiChoiceModeListener(callback);[/java]  
  




Все готово.





Для того что бы скачать исходники вам необходимо перейти на [страницу с исходниками](http://android-helper.com.ua/codes/)
Всем привет.





Прошу простить меня, что очень долго не радовал своих читателей блога, хорошими примерами.





Вот недавно я лазил по просторах инета и нашел замечательную [статью](http://habrahabr.ru/post/166351/).





О том как можно сделать разметку html в обычном TextView.

 <!-- more -->



Автор довольно хорошо высветел эту тему. Хотел переработать для вас, но все что тут написано, действительно нужно.





Ну что ж господа. Прошу к прочтению.





Недавно мне понадобилось сделать довольно хитроумный чат в приложении под Android. Помимо собственно информации требовалось передавать пользователям дополнительную функциональность в контексте определенного сообщения: имя автора сообщения по нажатию на него должно вставляться в текстовое поле ответа, а если это сообщение о только что созданном игровом сеансе, пользователи должны иметь возможность присоединиться к игре по клику и так далее. Одним из главных требований была возможность создавать сообщение, содержащее несколько ссылок, что и задало направление исследований.  
  
**WebView**, обладая нужной функциональностью, был отвергнут по причине тяжести решения: я даже не стал создавать 100 или сколько-нибудь там экземпляров в тестовых целях, по одному на каждое сообщение, поскольку сразу было понятно, что это расточительство нормально работать не будет.





К счастью, самый обычный [**TextView**](http://developer.android.com/reference/android/widget/TextView.html) обладает неожиданно потрясающей функциональностью по разметке текста и может использоваться как в качестве отдельного элемента, так и служить целой страницей, будучи несравненно легковеснее, чем **WebView**.





Я реализовал весь, необходимый мне функционал и выяснил ещё несколько довольно интересных вещей, столкнувшись с некоторым количеством подводных камней (впрочем, не очень острых). Можно сказать, всё нижеописанное — руководство по созданию достаточно мощной справочной системы в своём приложении практически даром.





### Задачи





В данном примере мы создадим приложение с двумя **Activity**, одна из которых содержит **TextView**, исполняющий роль браузера, из которого, в частности, можно вызвать вторую **Activity**, демонстрирующую работу с параметрами вызова. Мы выясним, каким образом можно создавать страницы текста с разметкой и изображениями и связывать их ссылками. 





Содержимое страниц берётся из строк в ресурсах приложения, а изображения являются drawable-ресурсами. Небольшие изменения в коде позволят использовать другие расположения.





![](http://habrastorage.org/storage2/a04/b2e/d4b/a04b2ed4b25633dfdc13fe3927e3c859.jpg)





### Создание приложения





Любым удобным нам способом создаём обычное приложение:









**AndroidManifest.xml**



	<manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.example.markup.tutorial" android:versionCode="1" android:versionName="1.0">

 	<uses-sdk android:minSdkVersion="7" android:targetSdkVersion="15" /> 

 	<application android:icon="@drawable/ic_launcher" android:label="@string/app_name" android:theme="@style/AppTheme">

  	<activity android:name=".MainActivity" android:label="@string/title_activity_main">

   	<intent-filter>

    	<action android:name="android.intent.action.MAIN" /> 

    	<category android:name="android.intent.category.LAUNCHER" /> 

   	</intent-filter>

  	</activity>

  	<activity android:name=".AnotherActivity" android:exported="false">

   	<intent-filter>

    <data android:scheme="activity-run" android:host="AnotherActivityHost" /> 

    <action android:name="android.intent.action.VIEW" /> 

    <category android:name="android.intent.category.DEFAULT" /> 

   	</intent-filter>

  	</activity>

 	</application>

	</manifest> 
  








Немного пояснений к манифесту. Если с первой **Activity** всё понятно, вторая (**AnotherActivity**) содержит некие дополнительные описатели.





**android:exported=«false»** необходимо для того, чтобы компилятор не выдавал предупреждения о том, что мы забыли что-то прописать в экспортируемом компоненте. На мой взгляд, чисто декоративный момент, но чем меньше жёлтых треугольничков — тем спокойнее.





Раздел **intent-filter** содержит описатели того, каким образом и при каких обстоятельствах будет происходить запуск **Activity**.





 означает, что можно запустить **Activity** ссылкой вида **activity-run://AnotherActivityHost?params...**





Значения **action** и **category** необходимы системе для того чтобы обнаружить и запустить **Activity**.









**MainActivity.java**

	package com.example.markup.tutorial;

	import org.xml.sax.XMLReader;

	import android.os.Bundle;

	import android.app.Activity;

	import android.graphics.drawable.Drawable;

	import android.text.Editable;

	import android.text.Html;

	import android.text.Spannable;

	import android.text.Spanned;

	import android.text.method.LinkMovementMethod;

	import android.widget.TextView;



	public class MainActivity extends Activity {



    TextView tvContent;

    

    @Override

    public void onCreate(Bundle savedInstanceState) {

        super.onCreate(savedInstanceState);

        setContentView(R.layout.activity_main);

        

        tvContent = (TextView)findViewById(R.id.tvContent);

        tvContent.setLinksClickable(true);

        tvContent.setMovementMethod(new LinkMovementMethod());

        

        setArticle("article_main");

    }



    void setArticle(String strArticleResId) {

    	int articleResId = getResources().getIdentifier(strArticleResId, "string", getPackageName());

    	String text = getString(articleResId);

    	if (text == null) text = "Article not found";

    	

    	Spanned spannedText = Html.fromHtml(text, htmlImageGetter, htmlTagHandler);

    	Spannable reversedText = revertSpanned(spannedText);

    	

    	tvContent.setText(reversedText);

    }

    

    final Spannable revertSpanned(Spanned stext) {

        Object[] spans = stext.getSpans(0, stext.length(), Object.class);

        Spannable ret = Spannable.Factory.getInstance().newSpannable(stext.toString());

        if (spans != null && spans.length > 0) {

            for(int i = spans.length - 1; i >= 0; --i) {

                ret.setSpan(spans[i], stext.getSpanStart(spans[i]), stext.getSpanEnd(spans[i]), stext.getSpanFlags(spans[i]));

            }

        }



        return ret;

    }

    

    Html.ImageGetter htmlImageGetter = new Html.ImageGetter() {

        public Drawable getDrawable(String source) {

            int resId = getResources().getIdentifier(source, "drawable", getPackageName());

            Drawable ret = MainActivity.this.getResources().getDrawable(resId);

            ret.setBounds(0, 0, ret.getIntrinsicWidth(), ret.getIntrinsicHeight());

            return ret;

        }

    };



    Html.TagHandler htmlTagHandler = new Html.TagHandler() {

        public void handleTag(boolean opening, String tag, Editable output,	XMLReader xmlReader) {

            Object span = null;

            if (tag.startsWith("article_")) span = new ArticleSpan(MainActivity.this, tag);

            else if ("title".equalsIgnoreCase(tag)) span = new AppearanceSpan(0xffff2020, AppearanceSpan.NONE, 20, true, true, false, false);

            else if (tag.startsWith("color_")) span = new ParameterizedSpan(tag.substring(6));

            if (span != null) processSpan(opening, output, span);

        }

    };

    

    void processSpan(boolean opening, Editable output, Object span) {

        int len = output.length();

        if (opening) {

            output.setSpan(span, len, len, Spannable.SPAN_MARK_MARK);

        } else {

            Object[] objs = output.getSpans(0, len, span.getClass());

            int where = len;

            if (objs.length > 0) {

                for(int i = objs.length - 1; i >= 0; --i) {

                    if (output.getSpanFlags(objs[i]) == Spannable.SPAN_MARK_MARK) {

                        where = output.getSpanStart(objs[i]);

                        output.removeSpan(objs[i]);

                        break;

                    }

                }

            }

            

            if (where != len) {

                output.setSpan(span, where, len, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);

            }

        }

    }

    

	}   








**AnotherActivity.java**



	package com.example.markup.tutorial;



	import android.app.Activity;

	import android.app.AlertDialog;

	import android.content.DialogInterface;

	import android.net.Uri;

	import android.os.Bundle;



	public class AnotherActivity extends Activity {



    @Override

    public void onCreate(Bundle savedInstanceState) {

        super.onCreate(savedInstanceState);

    

        Uri uri = getIntent().getData();

        

        String caption = uri.getQueryParameter("caption");

        String text = uri.getQueryParameter("text");

        

        new AlertDialog.Builder(this)

        	.setTitle(caption)

        	.setMessage(text)

        	.setPositiveButton("OK", dioclOK)

        	.setCancelable(false)

        	.create().show();

    }

    

    DialogInterface.OnClickListener dioclOK = new DialogInterface.OnClickListener() {

        

        public void onClick(DialogInterface dialog, int which) {

            dialog.dismiss();

            finish();

        }

    };

    

	}  












**AppearanceSpan.java**



	package com.example.markup.tutorial;



	import android.text.TextPaint;

	import android.text.style.CharacterStyle;



	public class AppearanceSpan extends CharacterStyle {

    

    public static final int NONE = -1;

    

    final int color, bgColor, textSize;

    final boolean boldText, italicText, strikeThruText, underlineText;

    

    public AppearanceSpan(int color, int bgColor, int textSize, boolean boldText, boolean italicText, 

            boolean strikeThruText, boolean underlineText) {

        this.color = color;

        this.bgColor = bgColor;

        this.textSize = textSize;

        this.boldText = boldText;

        this.italicText = italicText;

        this.strikeThruText = strikeThruText;

        this.underlineText = underlineText;

    }

    

    @Override

    public void updateDrawState(TextPaint tp) {

        if (color != NONE) tp.setColor(color);

        if (bgColor != NONE) tp.bgColor = bgColor;

        tp.setFakeBoldText(boldText);

        tp.setStrikeThruText(strikeThruText);

        if (textSize != NONE) tp.setTextSize(textSize);

        tp.setUnderlineText(underlineText);

        tp.setTextSkewX(italicText ? -0.25f : 0);

    }



	} 
  












**ArticleSpan.java**


	package com.example.markup.tutorial;



	import android.text.style.ClickableSpan;

	import android.view.View;



	public class ArticleSpan extends ClickableSpan {



    final MainActivity activity;

    final String articleId;

    

    public ArticleSpan(MainActivity activity, String articleId) {

        super();

        this.activity = activity;

        this.articleId = articleId;

    }

    

    @Override

    public void onClick(View arg0) {

        activity.setArticle(articleId);

    }



	}
  












**ParameterizedSpan.java**


	package com.example.markup.tutorial;



	import android.graphics.Color;

	import android.text.TextPaint;

	import android.text.style.CharacterStyle;



	public class ParameterizedSpan extends CharacterStyle {



    int color = 0;

    

    public ParameterizedSpan(String param) {

        try {

            color = Color.parseColor("#" + param);

        } catch(Exception ex) { }

    }



    @Override

    public void updateDrawState(TextPaint tp) {

        tp.setColor(color);

    }



	}
  








### Подготовка ресурсов









**layout/activity_main.xml"**

	<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"

    xmlns:tools="http://schemas.android.com/tools"

    android:layout_width="fill_parent"

    android:layout_height="fill_parent" >



    <ScrollView 

        android:id="@+id/sv"

        android:layout_width="fill_parent"

        android:layout_height="fill_parent"

        >

        <TextView

            android:id="@+id/tvContent"

            android:layout_width="wrap_content"

            android:layout_height="wrap_content"

            android:text="Content" />

    </ScrollView>

	</RelativeLayout>  
  












**values/strings.xml"**


	<resources>

    <string name="app_name">MarkupTutor</string>

    <string name="hello_world">Hello world!</string>

    <string name="menu_settings">Settings</string>

    <string name="title_activity_main">MainActivity</string>

    

    <string name="article_main" formatted="false"><![CDATA[

		<title>Главная страница</title><br/>

		<br/>

		<img src="res_pushkin_little"> <article_pushkin_stih>А.С. 	Пушкин "Как пить мы станем"</article_pushkin_stih><br/>

		<img src="res_activity_little"> <a href="activity-run://	AnotherActivityHost?caption=Another%20Activity&text=Hello%20from%20markup!">Вызвать другую Activity</a><br/>

		<br/>

		<color_ff00ff00>Тест параметризированного тэга <color_ffff00ff>и вложенных спанов</color_ffff00ff>.</color_ff00ff00><br/>

		Тест анимированного GIF-а:<br/>

		<img src="res_alien_anim">

    ]]></string>

        	

    <string name="article_pushkin_stih" formatted="false"><![CDATA[

		<br/><article_main>На главную</article_main><br/><br/>

		<img src="res_pushkin" /><br/><br/>

		Сват Иван, как пить мы станем,<br/>

		Непременно уж помянем<br/>

		Трех Матрен, Луку с Петром,<br/>

		Да Пахомовну потом.<br/>

		Мы живали с ними дружно,<br/>

		Уж как хочешь - будь что будь -<br/>

		Этих надо помянуть,<br/><br/>



		Помянуть нам этих нужно.<br/>

		Поминать, так поминать,<br/>

		Начинать, так начинать,<br/>

		Лить, так лить, разлив разливом.<br/>

		Начинай-ка, сват, пора.<br/>

		Трех Матрен, Луку, Петра<br/>

		В первый раз помянем пивом,<br/>

		А Пахомовну потом<br/>

		Пирогами да вином,<br/>

		Да еще ее помянем:<br/>

		Сказки сказывать мы станем -<br/>

		Мастерица ведь была<br/>

		И откуда что брала.<br/>

		А куды разумны шутки,<br/>

		Приговорки, прибаутки,<br/>

		Небылицы, былины<br/>

		Православной старины!..<br/>

		Слушать, так душе отрадно.<br/>

		И не пил бы и не ел,<br/>

		Всё бы слушал да сидел.<br/>

		Кто придумал их так ладно?<br/>

		Стариков когда-нибудь<br/>

		(Жаль, теперь нам не досужно)<br/>

		Надо будет помянуть -<br/>

		Помянуть и этих нужно...<br/>

		Слушай, сват, начну первой,<br/>

		Сказка будет за тобой.<br/>

    ]]></string>

	</resources>
  








Строки, содержащие разметку, должны иметь аттрибут **formatted** со значением **false**, а содержимое должно передаваться в блоке **CDATA**, чтобы у компилятора не было претензий к разметке и специальным символам. В данном примере признаком статьи будет префикс **article_** в названии строки.





Также замечен странный глюк, проявляющийся в том, что если текст начинается с тега, то заканчивается он этим же тегом. Если у вас в начале статьи ссылка, советую ставить перед ней либо пробел, либо`  
`.





Изображения могут быть формата jpg, png или gif без анимации. Анимированный gif отображается статичной картинкой. Расположение стандартное для ресурсов, для дисплеев разной плотности можно подготовить свой вариант картинки. В данном примере все изображения находятся в **drawable-nodpi**





![](http://habrastorage.org/storage2/a2c/313/a58/a2c313a588ebcbd9f6d257576518d942.png)





### Как всё работает





Рассмотрим некоторые части кода подробно.

	public void onCreate(Bundle savedInstanceState) {

    super.onCreate(savedInstanceState);

    setContentView(R.layout.activity_main);

    

    tvContent = (TextView)findViewById(R.id.tvContent);

    tvContent.setLinksClickable(true);

    tvContent.setMovementMethod(new LinkMovementMethod());

    

    setArticle("article_main");

	} 
  




**TextView** используемый нами в качестве браузера, требует особой инициализации:





**tvContent.setLinksClickable(true);** указывает на то, что ссылки в данном элементе реагируют на нажатие.





**tvContent.setMovementMethod(new LinkMovementMethod());** назначает способ навигации по элементу. Использованный нами [**LinkMovementMethod**](http://developer.android.com/reference/android/text/method/LinkMovementMethod.html) интересен сам по себе и, возможно, заслуживает отдельной статьи. Я лишь скажу, что при необходимости более полного контроля можно создать его наследника, переопределенные методы которого позволят отслеживать все действия со ссылками в элементе.



	void setArticle(String strArticleResId) {

    int articleResId = getResources().getIdentifier(strArticleResId, "string", getPackageName());

    String text = getString(articleResId);

    if (text == null) text = "Article not found";

    

    Spanned spannedText = Html.fromHtml(text, htmlImageGetter, htmlTagHandler);

    Spannable reversedText = revertSpanned(spannedText);

    

    tvContent.setText(reversedText);

	} 
  




В данном методе происходит получение строки по идентификатору из строковых ресурсов, её преобразование из HTML в специальный объект **Spanned**, затем ещё одно преобразование в **Spannable** и установка в **TextView** в качестве содержимого. Всё это кажется довольно громоздким, но тому есть причины.





В **TextView**, на мой взгляд, странный порядок обработки спанов — с конца списка. При естественном расположении спанов после преобразования строки из HTML, изменения внешнего вида вложенных спанов перекрываются свойствами спанов, их содержащих. Для нормального отображения приходится буквально выворачивать маркировку наизнанку с помощью метода **revertSpanned**:



	final Spannable revertSpanned(Spanned stext) {

    Object[] spans = stext.getSpans(0, stext.length(), Object.class);

    Spannable ret = Spannable.Factory.getInstance().newSpannable(stext.toString());

    if (spans != null && spans.length > 0) {

        for(int i = spans.length - 1; i >= 0; --i) {

            ret.setSpan(spans[i], stext.getSpanStart(spans[i]), stext.getSpanEnd(spans[i]), stext.getSpanFlags(spans[i]));

        }

    }



    return ret;

	}  
  




Определение обработчика ссылок на изображения минималистично и призвано загружать только картинки из ресурсов. Поскольку мы рассматриваем вариант справочной системы, я посчитал, что этого будет достаточно. С вашего позволения, я не буду цитировать его. Если вы хотите большего, можно обратиться, например, к [данной статье](http://habrahabr.ru/post/155879/).





Более интересен нам будет **Html.TagHadler**:



	Html.TagHandler htmlTagHandler = new Html.TagHandler() {

    public void handleTag(boolean opening, String tag, Editable output,	XMLReader xmlReader) {

        Object span = null;

        if (tag.startsWith("article_")) span = new ArticleSpan(MainActivity.this, tag);

        else if ("title".equalsIgnoreCase(tag)) span = new AppearanceSpan(0xffff2020, AppearanceSpan.NONE, 20, true, true, false, false);

        else if (tag.startsWith("color_")) span = new ParameterizedSpan(tag.substring(6));

        if (span != null) processSpan(opening, output, span);

    }

	};
  




Здесь у нас происходит несколько интересных вещей.





При преобразовании из **HTML** в **Spanned** методом **Html.fromHtml**, обрабатываются тэги 





`br`, `p`, `div`, `em`, `b`,`strong`, `cite`, `dfn`, `i`, `big`, `small`, 





`font`, `blockquote`, `tt`, `a`, `u`, `sup`, `sub`, `h1...h6` и `img`.





В случае, если тэг не опознан, вызывается Html.TagHandler (если, конечно, он передан в вызов).





Мы проверяем, не является ли переданный тэг «нашим» и если это так, создаём соответствующий **Span** — элемент разметки, а затем накладываем его на текст. Я создал несколько собственных **Span**-ов, они будут рассмотрены далее. Как правило, **Span**-ы наследуются от [**android.text.style.CharacterStyle**](http://developer.android.com/reference/android/text/style/CharacterStyle.html).





К сожалению, у меня не получилось малой кровью добиться центрования отдельных строк или абзацев, а встроенной возможности для этого не существует. Также, нельзя прочесть атрибуты тэга из **xmlReader**, поскольку он реализован не полностью. По этой причине пришлось изобретать свой способ передачи параметров: значение является частью тега. В нашем примере таким образом передаётся значение цвета в тэге **color**, преобразовываемом в **ParameterizedSpan**. Получается что-то вроде``





<color_ffff0000>красный. Это достаточно ограниченный и не очень удобный способ, но иногда лучше такой, чем никакого.



	void processSpan(boolean opening, Editable output, Object span) {

        int len = output.length();

        if (opening) {

            output.setSpan(span, len, len, Spannable.SPAN_MARK_MARK);

        } else {

            Object[] objs = output.getSpans(0, len, span.getClass());

            int where = len;

            if (objs.length > 0) {

                for(int i = objs.length - 1; i >= 0; --i) {

                    if (output.getSpanFlags(objs[i]) == Spannable.SPAN_MARK_MARK) {

                        where = output.getSpanStart(objs[i]);

                        output.removeSpan(objs[i]);

                        break;

                    }

                }

            }

            

            if (where != len) {

                output.setSpan(span, where, len, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);

            }

        }

    } 
  




Этот код делает следующее: В случае, если передан открывающий **Span**, он добавляется к концу строки в текущем её виде. В случае, если **Span** закрывающий, мы находим в строке его открывающий аналог, запоминаем его положение, затем удаляем и добавляем новый, но уже с информацией о начальном положении и длине. 





Мы завершили рассмотрение класса Activity, являющегося основным модулем нашего приложения. Теперь рассмотрим вспомогательные классы.



	package com.example.markup.tutorial;



	import android.text.TextPaint;

	import android.text.style.CharacterStyle;



	public class AppearanceSpan extends CharacterStyle {

    

    public static final int NONE = -1;

    

    final int color, bgColor, textSize;

    final boolean boldText, italicText, strikeThruText, underlineText;

    

    public AppearanceSpan(int color, int bgColor, int textSize, boolean boldText, boolean italicText, 

            boolean strikeThruText, boolean underlineText) {

        this.color = color;

        this.bgColor = bgColor;

        this.textSize = textSize;

        this.boldText = boldText;

        this.italicText = italicText;

        this.strikeThruText = strikeThruText;

        this.underlineText = underlineText;

    }

    

    @Override

    public void updateDrawState(TextPaint tp) {

        if (color != NONE) tp.setColor(color);

        if (bgColor != NONE) tp.bgColor = bgColor;

        tp.setFakeBoldText(boldText);

        tp.setStrikeThruText(strikeThruText);

        if (textSize != NONE) tp.setTextSize(textSize);

        tp.setUnderlineText(underlineText);

        tp.setTextSkewX(italicText ? -0.25f : 0);

    }

	}
  




Это Span общего назначения и с его помощью можно задать большинство параметров стиля текста. Его можно использовать как базу для создания стилей текста из собственных тэгов.







	package com.example.markup.tutorial;

	import android.text.style.ClickableSpan;

	import android.view.View;



	public class ArticleSpan extends ClickableSpan {



    final MainActivity activity;

    final String articleId;

    

    public ArticleSpan(MainActivity activity, String articleId) {

        super();

        this.activity = activity;

        this.articleId = articleId;

    }

    

    @Override

    public void onClick(View arg0) {

        activity.setArticle(articleId);

    }

	}







Этот класс описывает элемент, который по нажатию на него обеспечивает переход к статье, чей идентификатор является его параметром. Здесь я применил производное от способа, описанного мной ранее: сам тэг является собственным параметром, а его класс определяется префиксом article_. Поднимемся выше, к описанию **Html.TagHandler**:








	if (tag.startsWith("article_")) span = new ArticleSpan(MainActivity.this, tag);






Обработчик тэгов, увидев тэг, начинающийся на article_, создаёт ArticleSpan, задавая ему в качестве параметра название тэга. Элемент, при нажатии на него, вызывает метод MainActivity.setArticle, после чего в TextView устанавливается новый текст.







	package com.example.markup.tutorial;


	import android.graphics.Color;

	import android.text.TextPaint;

	import android.text.style.CharacterStyle;



	public class ParameterizedSpan extends CharacterStyle {



    int color = 0;

    

    public ParameterizedSpan(String param) {

        try {

            color = Color.parseColor("#" + param);

        } catch(Exception ex) { }

    }



    @Override

    public void updateDrawState(TextPaint tp) {

        tp.setColor(color);

    }

	}




Здесь реализован элемент, получающий параметр явно и отдельно от своего имени. Претензия на своего рода стандарт именования тэгов, раз уж нельзя передавать атрибуты. 





Конечно, всё описанное является вариациями одного принципа, каждый выберёт то, что ему удобнее.





### Вызов Activity





Здесь всё очень просто. Вызов осуществляется посредством использования обычного тэга `` с заданием схемы и хоста, которые описаны в **AndroidManifest.xml** для вызываемой **Activity**.





В HTML мы видим следующее:

	<a href="activity-run://AnotherActivityHost?caption=Another%20Activity&text=Hello%20from%20markup!">Вызвать другую Activity</a> 
  




При нажатии на ссылку, происходит вызов AnotherActivity с передачей параметров в Intent. Эти параметры можно получить и использовать:

	Uri uri = getIntent().getData();
	String caption = uri.getQueryParameter("caption");
	String text = uri.getQueryParameter("text");
  




### Использованные материалы





Следующие материалы очень ускорили создание данной статьи, да и, чего уж там, сделали его вообще возможным:





[www.sherif.mobi/2011/09/html-and-activity-links-in-textview.html](http://www.sherif.mobi/2011/09/html-and-activity-links-in-textview.html)  
[stackoverflow.com/questions/3874999/alignment-in-html-fromhtml](http://stackoverflow.com/questions/3874999/alignment-in-html-fromhtml)  
[stackoverflow.com/questions/11865334/how-to-use-xmlreader-in-taghandler-handletag](http://stackoverflow.com/questions/11865334/how-to-use-xmlreader-in-taghandler-handletag)  
[stackoverflow.com/questions/4044509/android-how-to-use-the-html-taghandler](http://stackoverflow.com/questions/4044509/android-how-to-use-the-html-taghandler)  
[stackoverflow.com/questions/1792604/html-imagegetter](http://stackoverflow.com/questions/1792604/html-imagegetter)





Я очень рад, что существует на свете [StackOverflow.com](http://stackoverflow.com/).





Надеюсь статья вам пригодится и вы теперь не будете плодить много елементов.





Рабочий код на странице с [кодами](http://android-helper.com.ua/codes/).




Продолжая тему своего маркета.





Нашел еще одну интересную статью.





Хорошая новость для пользователей [Google Apps for Business](http://www.google.com/enterprise/apps/business/#utm_medium=blog&utm_source=en-na-us-entblog-playprivatechannel12042012&utm_campaign=launch), [Education](http://www.google.com/enterprise/apps/education/#utm_medium=blog&utm_source=en-na-us-entblog-playprivatechannel12042012&utm_campaign=launch) и [Government](http://www.google.com/enterprise/apps/government/#utm_medium=blog&utm_source=en-na-us-entblog-playprivatechannel12042012&utm_campaign=launch) была опубликована в[блоге Google](http://googleenterprise.blogspot.com/2012/12/a-new-way-to-distribute-your-internal.html). Отныне в Google Play можно создавать корпоративные каналы обновлений и распространять через них внутренние приложения для своих работников.  
  
![](http://habrastorage.org/storage2/cc9/d98/20b/cc9d9820bcd9d9662370983f3c2e6b97.png)  
  
  
  






##### Как это работает





  
Каждый домен Google Apps for Business теперь может иметь приватный канал в Play Store. Администраторы домена могут давать пользователем права на публикацию приложений в консоли разработчика, а также настраивать доступ к каналу в Play Store для отдельных пользователей и групп.  
  
Чтобы увидеть этот канал на девайсе, пользователям нужно войти в Play с помощью своего корпоративного аккаунта.  
  






##### Как включить





  
Администраторы Google Apps могут включить канал в панели управления:








  * В разделе **Organizations & users > Services** нужно включить **Google Play Developer Console**.



  * Для группы пользователей, которым следует разрешить публикацию, нужно:  





    * В **Settings > Mobile** разрешить обновлять **Google Play Private Channel**



    * В **Organizations & users > Services** включить для них **Google Play Developer Console**








  * Остальным пользователям нужно дать доступ к Google Play Private Channel






  
  






##### Дополнительная информация












  * Канал виден только из девайсов и пока что недоступен для веб-интерфейса



  * Каждый девелопер должен проходить обычную регистрацию в консоли разработчика (за $25)



  * Для приложений в приватном канале доступны рейтинги, отзывы, цены и таргетирование



  * Организация может иметь лишь один приватный канал






  
  
Официальная документация: [http://support.google.com/a/bin/answer.py?hl=en&answer=2494992](http://support.google.com/a/bin/answer.py?hl=en&answer=2494992)
Сегодня что то мне не спится.





Хочу побольше дать интересных тем.





Не так много разработчиков выкладывают свои приложения на маркет.


<!-- more -->


Много приложений остается закрытыми в офисной рутине.





Но вот нашел статью, как можно и в офисе организовать свой маркет. Может кому будет полезной.





В рамках работы над большим количеством android приложений появилось желание создать свой Android Market на локальном сервере (с шахматами и поэтессами).  
Свой маркет должен решать две простые задачи:








  * Распространение и обновление корпоративных приложений. У нас есть набор внутри корпоративных приложений, которые нельзя публиковать на Google Play. Сейчас пользователи оповещаются о новых версиях по емайлу, что не удобно.



  * Бета тестирование заказных приложений на большой группе коллег, с обратной связью.






  
  
И так, нам необходимо реализовать небольшое Android приложение, которое будет скачивать список доступных приложений, проверять наличие обновлений для уже установленных, устанавливать/удалять приложения.  






#### Серверная часть





  
Серверной частью приложения может быть как сервис с широким функционалом (регистрация пользователей, отчеты, разграничение доступа к приложениям), так и просто xml файл:



	<MyMarket>

    <application name="TestApp1" 

    package="com.example.testapp1"

    versionCode="1"

    versionName="1.0" 

    url="http://mobile...../android/download/TestApp1.apk"/>

		.....

	</MyMarket>





  
В моем случае серверной частью фактически выступает http шара.  
Данный xml файл в приложении трансформируется в список приложений, доступных для установки.  
  






#### Установка





  
Пользователь выбирает нужное ему приложение и устанавливает,   
Маркет скачивает apk файл на флешку устройства и инициирует установку приложения, конечно, должна быть разрешена установка из сторонних источников.  
Установить незаметно в фоне мы не можем, поэтому после выполнения данного кода:




	URL url = new URL(apkurl);

            HttpURLConnection c = (HttpURLConnection) url.openConnecвленtion();

            c.setRequestMethod("GET");

            c.setDoOutput(true);

            c.connect();



            File file = this.getExternalFilesDir("download");

            File outputFile = new File(file, "app.apk");

            FileOutputStream fos = new FileOutputStream(outputFile);

            InputStream is = c.getInputStream();



            byte[] buffer = new byte[1024];

            int len1 = 0;

            while ((len1 = is.read(buffer)) != -1) {

                fos.write(buffer, 0, len1);

            }

            fos.close();

            is.close();

            

            Intent intent = new Intent(Intent.ACTION_VIEW);

            intent.setDataAndType(Uri.fromFile(outputFile),

                    "application/vnd.android.package-archive");

            startActivity(intent);





  
Пользователь увидит стандартное окно установки приложений:  
![image](http://img-fotki.yandex.ru/get/4117/1154545.a5/0_7d3c3_bd08d241_L)  
  






#### Обновление





  
Приложение Market может по определенному интервалу проверять наличие новых версий, делается это достаточно просто, так как доступен список всех установленных приложений:




	private boolean checkNewVersion(String packageName, int versionCodeNew) {

        List<ApplicationInfo> apps = getPackageManager()

                .getInstalledApplications(0);

        for (int i = 0; i < apps.size(); i++) {

            ApplicationInfo app = apps.get(i);

            if (packageName.equals(app.packageName)) {

                PackageManager manager = getPackageManager();

                PackageInfo info;

                try {

                    info = manager.getPackageInfo(app.packageName, 0);

                    int versionCode = info.versionCode;

                    if (versionCodeNew > versionCode) {

                        Toast.makeText(this, "New Version!", Toast.LENGTH_LONG)

                                .show();

                        return true;

                    }

                } catch (NameNotFoundException e) {

                    e.printStackTrace();

                }

            }

        }

        return false;

    }



  
В случае необходимости обновления приложения, повторяем процесс Установки, приложение будет обновлено.  
  






#### Удаление





  
Удалить программу лучше из интерфейса нашего маркета, чтобы не заставлять пользователя выискивать тестируемое приложение среди всех его программ, для этого достаточно вызвать этот код:



	 Uri packageURI = Uri.parse("package:"+packageName);

        Intent intent = new Intent(Intent.ACTION_DELETE, packageURI);

        startActivity(intent);





  
![image](http://img-fotki.yandex.ru/get/4134/1154545.a5/0_7d3c5_830496a8_L)  
  






#### Обратная связь





  
Получение сообщений об ошибках, вместе с логом ошибки, очень важно для разработчика, особенно на этапе тестирования приложения, добавим функцию автоматического сбора этой информации через Маркет.  
  
Для этого в каждое приложение, распространяемое через наш Маркет добавляем следующий класс




	public class CustomExceptionHandler implements UncaughtExceptionHandler {

    private File logsFolder = null;

    public static final String ERROR_INTENT = "com.example.markettestapp1.SEND_ERROR";

    public CustomExceptionHandler(File logsFolder) {

        this.logsFolder = logsFolder;

    }

    @Override

    public void uncaughtException(Thread thread, Throwable ex) {

        final Writer result = new StringWriter();

        final PrintWriter printWriter = new PrintWriter(result);

        ex.printStackTrace(printWriter);

        String stacktrace = result.toString();

        printWriter.close();

        try {

            if (!logsFolder.exists()) {

                logsFolder.createNewFile();

            }

            BufferedWriter writer = new BufferedWriter(new FileWriter(logsFolder, true));

            writer.write(""+new Date()+"\n"+stacktrace);

            writer.close();

        } catch (IOException e) {

            e.printStackTrace();

        }

        

        Intent intent = new Intent();

        intent.setAction(ERROR_INTENT);

        intent.putExtra("packageName", Test1Application.getApplication().getPackageName());

        intent.putExtra("stacktrace", stacktrace);

        Test1Application.getInstanceApplication().sendBroadcast(intent);

        

        android.os.Process.killProcess(android.os.Process.myPid());

    }

	}


  
Как видно из кода, это хендлер, который получает ошибки (Exception), генерит строку со стеком, сохраняет ее в локальный файл и отправляет ошибку в виде броадкаст сообщения.  
  
А в Application классе включаем переадресацию всех сообщений об ошибках в этот хендлер



	public class Test1Application extends Application {

    @Override

    public void onCreate() {

        super.onCreate();

        application = this;

        Thread.setDefaultUncaughtExceptionHandler(new CustomExceptionHandler(new File(this.getApplicationContext().getExternalFilesDir(null),"exceptions.log")));

    }




  
Таким образом, если в тестируемои приложении происходит ошибка, то перед смертью пишется сообщение в лог и посылается броадкаст сообщение в маркет.,  
Перед передачей приложения заказчику, этот код удаляется (комментируется).  
  
В самом Маркете мы просто отлавливаем данное сообщение:


	public class SendErrorReceiver  extends BroadcastReceiver {

    public static final String ERROR_INTENT = "com.example.markettestapp1.SEND_ERROR";

    @Override

    public void onReceive(Context context, Intent intent) {

        Intent i = new Intent(context, SendErrorActivity.class);

        i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);

        i.putExtra("stacktrace", intent.getStringExtra("stacktrace"));

        i.putExtra("packageName", intent.getStringExtra("packageName"));

        context.startActivity(i);

    }

	}




  
AndroidManifest.xml:


	<receiver android:name="com.example.markettestapp1.SendErrorReceiver" android:enabled="true" >

            <intent-filter>

                <action android:name="com.example.markettestapp1.SEND_ERROR" >

                </action>

            </intent-filter>

        </receiver>





  
  
И дальше маркет уже может переслать это сообщение на почту разработчику, загрузить в какой нибудь веб-сервис или попросить пользователя добавить комментарий к ошибке  
![image](http://img-fotki.yandex.ru/get/4121/1154545.a5/0_7d3c4_5b504bb_L)  
  
Я надеюсь, данный пример поможет многим начинающим разработчикам, разобраться, как написать свой универсальный велосипед для бета тестирования приложений и централизованному сбору статистики ошибок.  
  
ps: В статье использован исходный код и картинки взятые из прототипа приложения.




Привет друзья.





Собирался написать статью по анимации фрагментов, но к счастью она уже написана.





Думаю вам понравится.

 <!-- more -->



Всем доброго времени суток. Этот пост хочу посвятить теме фрагментов для Android. На Хабре есть уже переводы и некоторые статьи, которые упоминают о том, как начать работать с фрагментами под Android. Например, статья [Fragments API в Android 3.0](http://habrahabr.ru/post/113196/). В ней находится описание того, что такое фрагменты и в какой версии Android они доступны, поэтому те, кто ещё не добрался до неё могут при желании ознакомиться, я же не буду пересказывать этого в своём посте. Поэтому сразу перейду к делу.   
  
  






#### Начало работы





  
Скажу только кратко, что фрагменты — это компоненты UI пользователя, которые могут использоваться с помощью класса Activity для отображение пользовательских данных, но их жизненный цикл от него не зависит. Функционал, которым наделены фрагменты имеет более широкий функционал для работы с ними, чем Activity, поэтому их использование для разработчиков имеет не малое значение, если они хотят, чтобы их приложение имело более современный по нынешним нормам интерфейс пользователя.  
  
Теперь перейдём к сути поста. Разработчиками Google фрагменты были наделены, на мой взгляд, отличной поддержкой анимации отображения самого фрагмента. Об этом и пойдёт далее речь. Я искал по Хабру посты на данную тематику, но так ничего и не нашёл, поэтому сейчас поделюсь своими знаниями.   
  






#### Создаём проект





  
Давайте создадим небольшой проект. Я создал проект под свой Samsung Nexus S, там у меня стоит версия Android 4.1.2, собственно её я и использовал (Api Level 16). Сам проект я назвал FragmentsAnimationTest.  
  
Для демонстрации нам понадобится главное активити и его лейаут, пара фрагментов, каждый также со своим лейаутом и ещё пара xml-файлов для самой анимации, о которых я расскажу позже.  
  
Приложение будет выглядеть следующим образом: на экране будет отображаться один из фрагментов, переключение между ними будет осуществляться с помощью обычной кнопки, и, соответственно, само переключение фрагментов будет сопровождаться анимационными эффектами.   
  
Сначала расположим элементы главного активити в файле activity_main.xml:







	<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"

    xmlns:tools="http://schemas.android.com/tools"

    android:layout_width="match_parent"

    android:layout_height="match_parent"

    tools:context=".MainActivity" >



    <FrameLayout

        android:id="@+id/fragCont"

        android:layout_width="wrap_content"

        android:layout_height="match_parent"

        android:layout_weight="1" >

    </FrameLayout>

    

    <Button

        android:id="@+id/btn"

        android:layout_width="wrap_content"

        android:layout_height="wrap_content"

        android:text="SWITCH FRAGMENTS" 

        android:layout_toRightOf="@id/fragCont"/>



	</RelativeLayout>





  
  
Из кода видно, что используется главный лейаут — RelativeLayout, достаточно удобный при работе с фрагментами, в него помещаются два стандартных элемента FrameLayout — собственно, он и будет являться контейнером для фрагментов и кнопка, которой будем переключать фрагменты между собой. Пока что всё должно быть предельно просто.  
  
Дальше займёмся нашими фрагментами. Создадим для них разметки и сами классы:  
fragment1.xml 




	<?xml version="1.0" encoding="utf-8"?>

	<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"

    android:layout_width="match_parent"

    android:layout_height="match_parent"

    android:orientation="vertical" 

    android:background="#5A4">

    

    <TextView 

        android:layout_width="200dp"

        android:layout_height="fill_parent"

        android:text="fragment 1"/>



	</LinearLayout>



  
  
fragment2.xml



	<?xml version="1.0" encoding="utf-8"?>

	<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"

    android:layout_width="match_parent"

    android:layout_height="match_parent"

    android:orientation="vertical" 

    android:background="#A55">

    

    <TextView 

        android:layout_width="200dp"

        android:layout_height="fill_parent"

        android:text="fragment 2"/>



	</LinearLayout>



  
  
Для обоих фрагментов код практически одинаков, отличаются только текстом, который будет отображаться в самом фрагменте для его идентификации и цветом фона, чтобы хорошо было видно анимацию.  
  
Fragment1.java



	public class Fragment1 extends Fragment {



    @Override

    public View onCreateView(LayoutInflater inflater, ViewGroup container, 

                                Bundle savedInstanceState) {

        return inflater.inflate(R.layout.fragment_1, null);

    }

	}





  
  
Fragment2.java



	public class Fragment2 extends Fragment{



    @Override

    public View onCreateView(LayoutInflater inflater, ViewGroup container, 

                                Bundle savedInstanceState) {

        return inflater.inflate(R.layout.fragment_2, null);

    }

	}




  
  
В классах также должно быть всё понятно, если знакомы с темой фрагментов. В них просто указывается какой именно леаут будет использоваться при отображении конкретного фрагмента и всё.  
  
Теперь приступим к самому вкусному. Поработаем с классом главной активити, вот её код:


	public class MainActivity extends Activity {



    private Fragment fragment2;

    private Fragment fragment1;

    private FragmentTransaction ft;



    @Override

    protected void onCreate(Bundle savedInstanceState) {

    super.onCreate(savedInstanceState);

    setContentView(R.layout.activity_main);

    

    fragment1 = new Fragment1();

    fragment2 = new Fragment2();

    ft = getFragmentManager().beginTransaction();

    ft.setCustomAnimations(R.animator.slide_in_left, R.animator.slide_in_right);

//	ft.setTransition(FragmentTransaction.TRANSIT_FRAGMENT_OPEN);

    

    ft.replace(R.id.fragCont, fragment1);

    ft.addToBackStack(null);

    

    ft.commit();

    

    Button btn = (Button) findViewById(R.id.btn);

    btn.setOnClickListener(new OnClickListener() {

        

        @Override

        public void onClick(View v) {

        ft = getFragmentManager().beginTransaction();

        ft.setCustomAnimations(R.animator.slide_in_left, R.animator.slide_in_right);

//		ft.setTransition(FragmentTransaction.TRANSIT_FRAGMENT_OPEN);

        if(fragment1.isVisible()){

            ft.replace(R.id.fragCont, fragment2);

        }else{

            ft.replace(R.id.fragCont, fragment1);

        }

        ft.commit();

        }

    });

    }

	}




  
  
Разберём что именно происходит в нашей активити. Сначала создаются оба фрагмента, которые, как уже говорилось, будут поочерёдно менять друг друга. Далее указываем строкой ft = getFragmentManager().beginTransaction() получаем FragmentTransaction, с помощью которой мы сможем взаимодействовать с нашими фрагментами, но это всё есть в статье, которую я указывал ранее. Прежде, чем перейти к разбору следующего кода, сделаю небольшое отступление.   
  
Существует две возможности создавать анимацию для отображения фрагментов: 








  * 1ый способ — это подключение стандартной анимации с помощью метода setTransition(int transit). В классе FragmentTransaction есть несколько уже предописанных анимаций.



  * 2ой способ — это именно то, что нас интересует в данной теме, реализация кастомной анимации. Осуществляется с помощью метода setCustomAnimations()






  
Теперь вернёмся к разбору нашего кода. Посмотрим на следующую строку ft.setCustomAnimations(R.animator.slide_in_left, R.animator.slide_in_right), тут происходит подключение анимации ко всем фрагментам, с которыми будет происходить работа до завершения транзакции, до строки ft.commit(). Что же именно происходит? В setCustomAnimations передаётся два параметра. Первый параметр описывает анимацию, для отображения фрагмента, который появляется, а второй — описывает анимацию для фрагмента, который сменяется, т.е. убирается с экрана устройства. Важно упомянуть, что данный метод следует вызвать до появления фрагментов, в противном случае, анимация не будет применена.  
  
Пара сток-комментариев — это для того, чтобы можно было попробовать поиграться с предописанной анимацией, достаточно их раскомментировать и закомментировать предыдущую строку — ft.setCustomAnimations(R.animator.slide_in_left, R.animator.slide_in_right), в обоих случаях, хотя это и необязательно.  
  
Давайте разберём код активити до конца и перейдём к созданию самой анимации.  
  
После установки анимации, происходит показ фрагмента, добавление его в стек и завершение транзакции для отображения всех изменений. Потом инициализируем нашу кнопку и прикрепляем к ней слушатель события нажатия кнопки, внутри которого находится код для смены фрагментов, по нажатию кнопки начинаем транзакцию, подключаем анимацию и меняем фрагмент на противоположный показываемому в настоящий момент. Код прост, поэтому глубокого объяснения не требует.  
  






#### Создаём анимацию





  
Перейдём к главной части нашей темы. Научимся создавать саму анимацию. Способ создания анимации здесь немного отличается от того, как мы привыкли это делать в ранних версиях Android. Реализация проходит следующим образом. Для на чала нужно создать папку animator в папке ресурсов приложения, это будет выглядеть так — res/animator/. Сюда мы должны положить xml-файлы, которые будут описывать как именно должна проигрываться анимация. Поместим их туда:  
slide_in_left.xml



	<?xml version="1.0" encoding="utf-8"?>

	<set xmlns:android="http://schemas.android.com/apk/res/android">

  <objectAnimator xmlns:android="http://schemas.android.com/apk/res/android"

    android:interpolator="@android:anim/accelerate_decelerate_interpolator"

    android:propertyName="y" 

    android:valueType="floatType"

    android:valueTo="0" 

    android:valueFrom="-1280"

    android:duration="1500"/>

	</set>


  
  
и slide_in_right.xml


	<?xml version="1.0" encoding="utf-8"?>

	<set xmlns:android="http://schemas.android.com/apk/res/android"

     android:ordering="together">

  

  	<objectAnimator 

      android:interpolator="@android:anim/accelerate_interpolator"

      android:propertyName="alpha"

      android:valueType="floatType"

      android:valueTo="0"

      android:duration="300"/>

    

  	<objectAnimator xmlns:android="http://schemas.android.com/apk/res/android"

    android:interpolator="@android:anim/accelerate_decelerate_interpolator"

    android:propertyName="x" 

    android:valueType="floatType"

    android:valueTo="1280" 

    android:valueFrom="0"

    android:duration="1500"/>  

  

	</set>




  
  
Теперь подробно их разберём. Элементы самих визуальных эффектов описываются в теге objectAnimator, каждый такой тег говорит об описании нового эффекта анимации. Теперь посмотрим на сами атрибуты. Первый атрибут в файле slide_in_left.xml — это interpolator, у него имеется несколько значений, о них можно более подробно узнать из документации [Property Animation](http://developer.android.com/guide/topics/graphics/prop-animation.html#object-animator). Interpolator отвечает за то, чтобы отобразить определённым способом в течении определённого времени наш фрагмент. Далее у нас следует атрибут propertyName, в нём указывается с какое именно свойство фрагмента мы будем изменять при анимации, в нашем примере первым идёт y, а valueType указывает какого типа у нас именяемый параметр. В книге Pro Android 4 аргументируется эта ситуация тем, что если посмотреть на метод setX() в классе View, то станет понятно, что он принимает значение типа float, с методом setY() дело обстоит также, отсюда и значение floatType.   
  
Далее идут не маловажные атрибуты valueFrom и valueTo, они указывают от какого до какого значания изменять значение указаннное в propertyName, в нашем первом случае это y. Если параметр valueFrom не указан, то значение берётся равное текущему. В нашем случае valueFrom равен -1280, это означает, что движение фрагмента по оси y будет начинаться со значения -1280, это значение было выбрано из-за того, что оно находится за пределами экрана устройства и перемещение будет происходить пока значение y не станет равным 0 для верхнего левого угла нашего фрагмента в течении 1500 миллисекунд. И, наконец, duration — атрибут указывает сколько именно будет длиться наш анимированный эффект в миллисекундах.  
  
И последний нюанс, который я хочу описать. Глядя в какой-либо из файлов описания анимации, можно заметить тэг set, в который помещены все эффекты анимации, он служит для объединения эффектов либо их разделения. В файле slide_in_right.xml используется атрибут ordering в теге set, в нашем случае он имеет значение together, что означает проигрывать эффекты одновременно, в противовес ему существует значение sequentially, которое требует последовательного отображения эффектов в анимации, что очень удобно в некоторых случаях.  
  
Собственно и всё. В файле slide_in_right.xml приведен пример как можно использовать другие свойства для анимирования, например alpha-канал. Надеюсь данная статья пригодится тем, кому не всё равно как будет выглядеть его приложение.  
  
Как вы сами понимаете, уважаемые хабраюзеры, скрины не смогут отобразить результат работы.  
  
Литература и источники, которые использовались при написании поста были упомянуты в ходе самой статьи.





Статья из сайта [habrahabr.ru](http://habrahabr.ru/post/162389/)
Друзья всем привет.





Поздравляю всех с Новым годом.





Но не стоит долго отдыхать. И новые статьи уже ждут вас.


<!-- more -->


Сегодня нашел хорошую статью которая упростит вам работу, по внедрению социальных сетей к себе в приложение.





При разработке игрушки для Android'а у меня появилась идея добавить в нее немного социального взаимодействия для охвата большей аудитории. Сама игрушка не располагала к тому, чтобы распространятся «вирусным» способом, поэтому я решил ограничится публикацией результатов игры в социальных сетях в случае выигрыша и при условии попадания результата в локальную таблицу рекордов, и я стал искать решение этого вопроса.  
  
  






##### Выбор социальной сети





  
Я себе поставил задачу публиковать сообщения не во всех социальных сетях сразу, а хотя бы в одной. Выбор встал между соц. сетями «ВКонтакте», «Facebook» и «Twitter». Так как хотелось распространять игру по всему миру, а не только на просторах СНГ, сеть «ВКонтакте» практически сразу была исключена из списка. Выбор между «Facebook» и «Twitter» был сделан просто, и может быть, не совсем объективно — «Facebook» мне не очень нравится, пользоваться я им не люблю из-за, на мой взгляд, крайне неудачного интерфейса, поэтому я решил использовать «Twitter», тем более, что в нем существует возможность интегрировать аккаунт с «Facebook» и дублировать туда сообщения.  
  






##### Поиск способа реализации





  
Искать способ реализовать свою идею я начал с [Twitter4j SDK](http://twitter4j.org/en/index.html). К сожалению, кроме сухой javadoc документации, представляющей собой простое справочное руководство, и отрывочных примеров, там ничего больше не обнаружилось. Также было просмотрено немало тем на stackoverflow.com, но и там ничего подходящего не нашлось (если честно, не хотелось сильно углубляться в дебри TwitterAPI, да и к тому же мои знания Java и платформы Android оставляют желать лучше).  
  






##### Есть идея, есть решение





  
Наконец блуждание в гугле навело меня на статью [Интеграция Android-приложения с Twitter](http://idev.by/android/20828/). Некоторые идеи были не совсем понятны, но код показался достаточно простым, и его автор утверждал, что его решение работает. Потратив немного времени, я адаптировал код автора для своего приложения, и стал проверять его работоспособность. Процедура авторизации проходила (хотя и показалась мне довольно непонятной для обычного, далекого от IT пользователя), но дальше дело не двигалось. Как отсылать сообщения (вернее, в какой момент), я так и не разобрался.  
Также не понравилось, что остается висеть открытый браузер, который вылезает после закрытия моего приложения. Поковырявшись денек, я оставил идею использовать TwitterAPI и стал искать более простое и приятное решение.  
  






##### Самое простое решение





  
Самое простое решение, которое меня вполне удовлетворило, было найдено, более того, оно было в некоторых аспектах даже лучше, чем предыдущее.  
Суть идеи в том, чтобы просто отсылать данные, а куда они будут реально отправлены, решает система и пользователь. Из плюсов — то, что пользователю предоставляется возможность выбрать, куда он хочет отправить сообщение — SMS/MMS, твиттер, фейсбук, в вконтакте, или что-то еще. Я решил, что пользователь наиболее активно пользуется скорее всего только одной из социальных сетей, и ему не понадобится размещать пост в нескольких сетях, к тому же это решение в данном аспекте соответствовало первому варианту. Из минусов данного решения можно отметить то, что у пользователя должно быть установлено соответствующее клиентское приложение (для твиттера в маркете, помимо официального клиента, есть много сторонних). Существование клиента для Фейсбук я не проверял, но полагаю, что оно либо есть, либо появится в довольно ближайшем будущем. Клиент для в ВКонтакте, насколько я в курсе, уже создан (где-то тут была новость о конкурсе на его разработку), и его официальное появление тоже вопрос ближайшего будущего. Также я решил, что пользователь, который достаточно активен в соц. сети для того, чтобы опубликовать там результаты игры, уже озаботился установкой клиента для нее.  
Собственно, само решение — это пять строчек кода, и мне уже стыдно, что я томил читателя своими нудными рассуждениями, вместо того, чтобы сразу опубликовать его:  
  








		// в коде моей Activity

    void shareTextInSocialMedia(String msg)

    {

    	//canShareText();

    	Intent share = new Intent(Intent.ACTION_SEND);

        share.putExtra(Intent.EXTRA_TEXT, msg);

        share.setType("text/plain");

        //startActivity(Intent.createChooser(share, "Share this via"));

        startActivityForResult(Intent.createChooser(share, "Share this via"), 0);

    }    



  
При выполнении приведенного кода возникает список приложений, способных произвести отправку (у меня это Send SMS/MMS и Post to Twitter при установленном твиттер-клиенте), пользователь выбирает нужное приложение, и продолжает работу уже в нем.   
Большой минус — мое приложение закрывается после выполнения этого кода, причем не сразу — в случае твиттер-клиента там сначала можно отредактировать сообщение, и в это время моя программа висела в фоне и играла музыку, и пропала только после нажатия кнопки «Твитнуть». Я попробовал использовать startActivityForResult вместо startActivity, но ничего не изменилось. В случае отправки SMS мое приложение тоже пропало, хотя момент я не засек так же точно. На stackoverflow.com мне сказали, что проблема в твиттер-клиенте («Ah, I see. This is a classic example of application does not respecting Android lifecycle (shame on Twitter)»). Я сначала удовлетворился тем, что от меня тут ничего не зависит, но потом проверил SMS способ, и несколько засомневался, так как он тоже не работал корректно.  
  






##### Бонус для самых упорных





  
Меня несколько напрягало то, что в случае отсутствия приложений, способных обработать отправку сообщения, пользователю будет показано противное сообщение об этом, и я захотел проверить, нужно ли показывать кнопку «Share» в своем приложении, и StackOverflow подсказал мне решение:  
  





		boolean canShareText( boolean allowSmsMms)

    {

        PackageManager manager = getPackageManager();

        List&lt;ResolveInfo&gt; list = manager.queryIntentActivities(createShareIntent(""), 0);



        if (list != null &amp;&amp; list.size() &gt; 0) 

        {

    		if (allowSmsMms) return true;

    		int handlersCount = 0;

    		for (ResolveInfo li : list)

    		{

    			if (li!=null &amp;&amp; li.activityInfo!=null &amp;&amp; li.activityInfo.packageName!=null &amp;&amp; li.activityInfo.packageName=="com.android.mms") {}

    			else

    				++handlersCount;

    		}

    		if (handlersCount&gt;0) return true;

        } 

    	return false;

    }




  
В данном коде перечисляются все доступные способы отправки сообщения, в том числе и с использованием СМС.  
Я решил не показывать кнопку «Share», если доступна отсылка только SMS/MMS, и добавил опциональную возможность проигнорировать это приложение. Имя пакета «com.android.mms» получил во время прогона на эмуляторе, так что возможно не везде будет срабатывать.





Статья из сайта [habrahabr.ru](http://habrahabr.ru/post/164187/)
Всем привет.





Сегодня набрел на Google Play Service. И мне стало интересно, что это такое.





И как его можно применить в разработке.


 <!-- more -->


Нашел очень хорошую статью на [Хабре](http://habrahabr.ru/post/153341/).





На Google I/O 2012 было объявлено о скором появлении на свет некоей «платформы Google Play Services». Платформы для разработчиков, которые жаждут интегрировать сервисы Google в свои приложения.  
  
26 сентября в [блоге на G+](https://plus.google.com/+AndroidDevelopers/posts/J1A5hc1ZnS1) было объявлено о запуске Google Play Services v.1.0  
  






#### Что это?





  
Сервисы Google Play (Google Play Services) — это платформа, предназначенная для интеграции продуктов Google, таких как Google+, в ваши Android-приложения. Платформа Google Play Services состоит из системного сервиса, работающего на устройстве, и тонкого клиента. Тонким клиентом выступает ваше приложение с подключенной клиентской библиотекой. Можно изобразить это так:  
![](http://habrastorage.org/storage2/725/647/caf/725647caf708eb37b4480dddfa7b5c7e.png)  
Google Play Services распространяется в виде обычного приложения через Google Play Store и поэтому независима от вашего оператора связи или производителя устройства. Новые девайсы имеют подержку Google Play Services «с завода». Устройства на платформе Android 2.2 (Froyo) или выше, имеющие доступ к Google Play Store получат обновления в течение ближайших нескольких дней. Это позволит вам использовать новейшие API на подавляющем большинстве устройств в экосистеме Android. Устройства с Android ниже версии 2.2 или не подключенные к Google Play Store не поддерживаются.  
  
Платформа Google Play services содержит бо́льшую часть логики взаимодействия с продуктами Google. Доступ к использованию возможностей платформы предоставляется через простую процедуру аутентификации, которая проста как для разработчика так и для пользователя. Для разработчика процедура заключается в вызове пары методов клиентской библиотеки, а остальную работу за него выполнят компоненты Google Play services. Для пользователя приложения процедура аутентификации — это несколько кликов.  
  






#### Компоненты Google Play services





  
Google Play services 1.0 включает в себя следующие компоненты и API:








  * OAuth 2.0 аутентификация в сервисах Google



  * Google+ sign-in — аутентификация с помощью аккаунта G+



  * Гугло-кнопка +1 в вашем приложении






  
Не густо, конечно, но обещают развивать и дополнять платформу новыми сервисами и API  
  
Подробности по установке, использованию и вообще есть [здесь](https://developers.google.com/android/google-play-services/).





Сейчас думаю как же его можно использовать в своих программах.





Жду предложений в комментариях.
Всем привет.





Как истинный программист, не сижу на месте, а постоянно развиваюсь.





И что бы доносить вам ценную информацию, я читаю много сайтов.





Но к сожалению, не могу все переработать сам.

<!-- more -->



Поэтому просто выставляю интересные статьи на блоге.





Речь пойдет о PhoneGap.





![](http://android-helper.com.ua/images/uploads/2012/12/завантаження.jpg)



Что это такое и для чего оно надо. Спросите вы.





Но постойте, ведь много программистов никогда не писали на java. А свои приложения хотят показать всему миру.





И тут на помощь им приходить движек PhoneGap.





На этом движке пишут приложения на HTML5 + JavaScript + CSS.





Не буду вас долго мучат. Сразу к делу.





1. Создаем проект





2. Подготавливаем проект





Из архива, который можно скачать [тут](http://phonegap.com/download), нам понадобится:








  1. Файл cordova-2.2.0.jar из lib/android копируем в libs



  2. Файл cordova-2.2.0.js из lib/android копируем в assets/www



  3. Каталог xml из lib/android копируем в res






3. Теперь меняем код главного Activity:


	package com.android_helper.phonegap1;

	import org.apache.cordova.DroidGap;

	import android.os.Bundle;

	public class MainActivity extends DroidGap {



	@Override

	public void onCreate(Bundle savedInstanceState) {

		super.onCreate(savedInstanceState);

		super.loadUrl("file:///android_asset/www/index.html");

	}

	}








Тут мы изменили имя абстрактного предка на DroidGap, убрали метод setContentView, который устанавливал "андроидную" разметку и выполнили загрузку локальной html-страницы, в которой дальше все и будет происходить. Кстати и создадим её в каталоге assets/www/index.html:


	<!DOCTYPE html>

	<html>

  	<head>

   	 <title>Device Properties Example</title>



    	<script type="text/javascript" charset="utf-8" src="cordova-2.0.0.js"></script>

    	<script type="text/javascript" charset="utf-8">



    	// Wait for Cordova to load

    	//

    	document.addEventListener("deviceready", onDeviceReady, false);



    	// Cordova is ready

    	//

   	 function onDeviceReady() {

        var element = document.getElementById('deviceProperties');



        element.innerHTML = 'Device Name: '     + device.name     + '<br />' + 

                            'Device Cordova: '  + device.cordova  + '<br />' + 

                            'Device Platform: ' + device.platform + '<br />' + 

                            'Device UUID: '     + device.uuid     + '<br />' + 

                            'Device Version: '  + device.version  + '<br />';

    	}



    	</script>

 	 </head>

  	<body>

    	<p id="deviceProperties">Loading device properties...</p>

  	</body>

	</html>





4. Добавляем разрешения (permission) в AndroidManifest.xml



		<manifest xmlns:android="http://schemas.android.com/apk/res/android"

		package="com.android_helper.phonegap1"

		android:versionCode="1"

		android:versionName="1.0" >



		<supports-screens

		android:anyDensity="true"

		android:largeScreens="true"

		android:normalScreens="true"

		android:resizeable="true"

		android:smallScreens="true" />



		<uses-sdk

		android:minSdkVersion="8"

		android:targetSdkVersion="15" />



		<uses-permission android:name="android.permission.VIBRATE" />

		<uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />

		<uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />

		<uses-permission android:name="android.permission.ACCESS_LOCATION_EXTRA_COMMANDS" />

		<uses-permission android:name="android.permission.READ_PHONE_STATE" />

		<uses-permission android:name="android.permission.INTERNET" />

		<uses-permission android:name="android.permission.RECEIVE_SMS" />

		<uses-permission android:name="android.permission.RECORD_AUDIO" />

		<uses-permission android:name="android.permission.MODIFY_AUDIO_SETTINGS" />

		<uses-permission android:name="android.permission.READ_CONTACTS" />

		<uses-permission android:name="android.permission.WRITE_CONTACTS" />

		<uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />

		<uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />

		<uses-permission android:name="android.permission.GET_ACCOUNTS" />

		<uses-permission android:name="android.permission.BROADCAST_STICKY" />



		<application

		android:icon="@drawable/ic_launcher"

		android:label="@string/app_name"

		android:theme="@style/AppTheme" >

		<activity

			android:name=".MainActivity"

			android:configChanges="orientation|keyboardHidden"

			android:label="@string/title_activity_main" >

			<intent-filter>

				<action android:name="android.intent.action.MAIN" />



				<category android:name="android.intent.category.LAUNCHER" />

			</intent-filter>

		</activity>

	</application>



	</manifest>





Рекомендую убрать те которыми не пользуетесь. Ведь при установке приложения пользователь уйдет в астрал. И подумает, что ваше приложение шпион. :)





Ну вот и все.





Запускаем и смотрим.





![](http://android-helper.com.ua/images/uploads/2012/12/Screenshot-5554-dev22-1.png)



Рабочий код на странице с [кодами](http://android-helper.com.ua/codes/).





Понравилось, нажми лайк и расскажи своим друзьям.




Всем привет.





Когда разрабатываешь хорошее приложение. Часто бывает нужно сделать красивые отделения между элементами.





Что бы долго не говорить посмотрите ниже:





![](http://android-helper.com.ua/images/uploads/2012/12/img-1024x564.jpg)


 <!-- more -->
 





Каждый программист ищет свои пути решения данной задачи.





Я же хочу показать вам как это делать с помощью обычного adapter.





Смотрим результат:



{% youtube GHpLuRLujOk %}





Приступим:





**MultipleItemsList**:

		@Override

    public void onCreate(Bundle savedInstanceState) {

        super.onCreate(savedInstanceState);

        mAdapter = new MyCustomAdapter();

        for (int i = 1; i < 50; i++) {

            mAdapter.addItem("item " + i);

            if (i % 4 == 0) {

                mAdapter.addSeparatorItem("separator " + i);

            }

        }

        setListAdapter(mAdapter);

    }




Сам адаптер **MyCustomAdapter:**

	private class MyCustomAdapter extends BaseAdapter {



        private static final int TYPE_ITEM = 0;

        private static final int TYPE_SEPARATOR = 1;

        private static final int TYPE_MAX_COUNT = TYPE_SEPARATOR + 1;



        private ArrayList<String> mData = new ArrayList<String>();

        private LayoutInflater mInflater;



        private TreeSet<Integer> mSeparatorsSet = new TreeSet<Integer>();



        public MyCustomAdapter() {

            mInflater = (LayoutInflater)getSystemService(Context.LAYOUT_INFLATER_SERVICE);

        }



        public void addItem(final String item) {

            mData.add(item);

            notifyDataSetChanged();

        }



        public void addSeparatorItem(final String item) {

            mData.add(item);

            // save separator position

            mSeparatorsSet.add(mData.size() - 1);

            notifyDataSetChanged();

        }



        @Override

        public int getItemViewType(int position) {

            return mSeparatorsSet.contains(position) ? TYPE_SEPARATOR : TYPE_ITEM;

        }



        @Override

        public int getViewTypeCount() {

            return TYPE_MAX_COUNT;

        }



        @Override

        public int getCount() {

            return mData.size();

        }



        @Override

        public String getItem(int position) {

            return mData.get(position);

        }



        @Override

        public long getItemId(int position) {

            return position;

        }



        @Override

        public View getView(int position, View convertView, ViewGroup parent) {

            ViewHolder holder = null;

            int type = getItemViewType(position);

            System.out.println("getView " + position + " " + convertView + " type = " + type);

            if (convertView == null) {

                holder = new ViewHolder();

                switch (type) {

                    case TYPE_ITEM:

                        convertView = mInflater.inflate(R.layout.item1, null);

                        holder.textView = (TextView)convertView.findViewById(R.id.text);

                        break;

                    case TYPE_SEPARATOR:

                        convertView = mInflater.inflate(R.layout.item2, null);

                        holder.textView = (TextView)convertView.findViewById(R.id.textSeparator);

                        break;

                }

                convertView.setTag(holder);

            } else {

                holder = (ViewHolder)convertView.getTag();

            }

            holder.textView.setText(mData.get(position));

            return convertView;

        }



    }



    public static class ViewHolder {

        public TextView textView;

    }


Вот и все.





Понравилось? Расскажи своим друзьям.





Рабочий код на странице с [кодами](http://android-helper.com.ua/codes/).
Всем привет.





К одной статье мне прислали комментарий.





Благодаря ему, я написал данную статью.





Как видно из названия, то речь пойдет о **WebView**


 <!-- more -->


Кода много не будет, так как вы всегда можете скачать готовый проект на нашей странице с кодами.





Рассмотрим два варианта загрузки html страницы в WebView








  1. **Локальный файл**



  2. **Веб-страница (на примере http://android-helper.com.ua/)**






#### Локальный файл





		WebView mWebView = (WebView) myView.findViewById(R.id.web);



		WebSettings settings = mWebView.getSettings();

		settings.setJavaScriptEnabled(true);

		settings.setDefaultTextEncodingName("utf-8");

		settings.setDefaultZoom(WebSettings.ZoomDensity.MEDIUM);



		mWebView.loadUrl("file:///android_asset/www/index.html");





#### Веб-страница (на примере http://android-helper.com.ua/)






		WebView mWebView = (WebView) myView.findViewById(R.id.web);



		WebSettings settings = mWebView.getSettings();

		settings.setJavaScriptEnabled(true);

		settings.setDefaultTextEncodingName("utf-8");

		settings.setDefaultZoom(WebSettings.ZoomDensity.MEDIUM);

		mWebView.loadUrl("http://android-helper.com.ua");







Напомню, что скачать полный пример вы можете на странице с [кодами](http://android-helper.com.ua/codes/).
Всем привет.





Пока я готовлюсь к вебинару. Времени на написание статей не хватает.





Именно это меня провоцирует брать готовый материал из чужих сайтов.





Сегодня речь пойдет о динамическом размещении элементов на action bar.


 <!-- more -->


В этом уроке:





- программно размещаем элементы в ActionBar  
- используем элементы из фрагментов





Недавно на форуме был вопрос о том, как во время работы программы менять содержимое ActionBar. Тема действительно интересная, и незаслуженно мною пропущенная. В этом уроке будем с ней разбираться.





Опробуем три способа работы с элементами:





1) Добавление/удаление MenuItem в объект Menu





2) Показ/скрытие группы в Menu





3) Элементы, относящиеся к фрагментам





С первыми двумя пунктами все понятно, эти механизмы мы рассматривали еще в Уроке 14.





Более интересен третий пункт. Фрагмент может реализовать в себе метод[onCreateOptionsMenu](http://developer.android.com/reference/android/app/Fragment.html#onCreateOptionsMenu(android.view.Menu, android.view.MenuInflater)) и, тем самым, создать свои элементы для ActionBar. Как только фрагмент будет добавлен на экран, эти элементы добавятся в ActionBar. А когда фрагмент с экрана уберут, элементы исчезнут.





Создадим приложение, которое реализует три этих варианта.





Добавим строки в **strings.xml**:



	<?xml version="1.0" encoding="utf-8"?>

	<resources>



    <string name="add_del">Добавить/удалить</string>

    <string name="visible">Показать/скрыть</string>

    <string name="fragment">Фрагмент</string>

    <string name="frag1_text">Fragment 1</string>

    <string name="frag2_text">Fragment 2</string>

    <string name="menu_item1">Item 1</string>

    <string name="menu_item2">Item 2</string>

    <string name="menu_item31">Item 31</string>

    <string name="menu_item32">Item 32</string>



	</resources>


Создадим два фрагмента. Начнем с layout-файлов.





**fragment1.xml**:


	<?xml version="1.0" encoding="utf-8"?>

	<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"

    android:layout_width="match_parent"

    android:layout_height="match_parent"

    android:background="#77ff0000"

    android:orientation="vertical" >



    <TextView

        android:layout_width="wrap_content"

        android:layout_height="wrap_content"

        android:text="@string/frag1_text" >

    </TextView>



	</LinearLayout>





**fragment2.xml**:


	<?xml version="1.0" encoding="utf-8"?>

	<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"

    android:layout_width="match_parent"

    android:layout_height="match_parent"

    android:background="#7700ff00"

    android:orientation="vertical" >



    <TextView

        android:layout_width="wrap_content"

        android:layout_height="wrap_content"

        android:text="@string/frag2_text" >

    </TextView>



	</LinearLayout>


Файлы с пунктами меню (они же - элементы ActionBar):





**res/menu/fragment1.xml**:



	<?xml version="1.0" encoding="utf-8"?>

	<menu xmlns:android="http://schemas.android.com/apk/res/android" >



    <item

        android:id="@+id/frag1_item"

        android:icon="@android:drawable/ic_dialog_info"

        android:showAsAction="ifRoom|withText"

        android:title="@string/menu_item31">

    </item>



	</menu>



**res/menu/fragment2.xml**:



	<?xml version="1.0" encoding="utf-8"?>

	<menu xmlns:android="http://schemas.android.com/apk/res/android" >



    <item

        android:id="@+id/frag2_item"

        android:icon="@android:drawable/ic_dialog_email"

        android:showAsAction="ifRoom|withText"

        android:title="@string/menu_item32">

    </item>



	</menu>




По одному элементу для каждого фрагмента. Эти элементы будут появляться в ActionBar при выводе фрагмента на экран.





Классы.





**Fragment1.java**:



	public class Fragment1 extends Fragment {

		public void onCreate(Bundle savedInstanceState) {

		setHasOptionsMenu(true);

		super.onCreate(savedInstanceState);

		}



	public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {

		return inflater.inflate(R.layout.fragment1, null);

	}



	public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {

		inflater.inflate(R.menu.fragment1, menu);

		super.onCreateOptionsMenu(menu, inflater);

	}



	}





**Fragment2.java**:



	public class Fragment2 extends Fragment {

	public void onCreate(Bundle savedInstanceState) {

		setHasOptionsMenu(true);

		super.onCreate(savedInstanceState);

	}



	public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {

		return inflater.inflate(R.layout.fragment2, null);

	}



	public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {

		inflater.inflate(R.menu.fragment2, menu);

		super.onCreateOptionsMenu(menu, inflater);

	}

	}



В **onCreate **с помощью [setHasOptionsMenu](http://developer.android.com/reference/android/app/Fragment.html#setHasOptionsMenu(boolean)) включаем режим вывода элементов фрагмента в ActionBar.





В **onCreateView **создаем View, в **onCreateOptionsMenu **– меню. Все как обычно.





Фрагменты готовы.





Теперь займемся Activity. Перепишем **res/layout/main.xml**:




	<?xml version="1.0" encoding="utf-8"?>

	<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"

    xmlns:tools="http://schemas.android.com/tools"

    android:id="@+id/LinearLayout1"

    android:layout_width="match_parent"

    android:layout_height="match_parent"

    android:orientation="vertical" >



    <CheckBox

        android:id="@+id/chbAddDel"

        android:layout_width="wrap_content"

        android:layout_height="wrap_content"

        android:onClick="onClick"

        android:text="@string/add_del" >

    </CheckBox>



    <CheckBox

        android:id="@+id/chbVisible"

        android:layout_width="wrap_content"

        android:layout_height="wrap_content"

        android:onClick="onClick"

        android:text="@string/visible" >

    </CheckBox>



    <Button

        android:id="@+id/btnFrag"

        android:layout_width="wrap_content"

        android:layout_height="wrap_content"

        android:onClick="onClick"

        android:text="@string/fragment" >

    </Button>



    <FrameLayout

        android:id="@+id/cont"

        android:layout_width="match_parent"

        android:layout_height="match_parent" >

    </FrameLayout>



	</LinearLayout>





Два чекбокса и кнопка. Чекбоксы отвечают за работу с элементами с помощью первого и второго способов. Кнопка будет показывать поочередно два фрагмента в контейнере cont.





**res/menu/main.xml**:


	<menu xmlns:android="http://schemas.android.com/apk/res/android" >



    <group android:id="@+id/groupVsbl" >

        <item

            android:id="@+id/item2"

            android:icon="@android:drawable/ic_menu_call"

            android:showAsAction="always|withText"

            android:title="@string/menu_item2">

        </item>

    </group>



	</menu>




Создаем группу, а в ней элемент. Эту группу будем скрывать и показывать.





**MainActivity.java**:

	
	public class MainActivity extends FragmentActivity {



	final int MENU_ID = 1;



	CheckBox chbAddDel;

	CheckBox chbVisible;



	Fragment frag1;

	Fragment frag2;

	Fragment frag;



	@Override

	public void onCreate(Bundle savedInstanceState) {

		super.onCreate(savedInstanceState);

		setContentView(R.layout.activity_main);



		chbAddDel = (CheckBox) findViewById(R.id.chbAddDel);

		chbVisible = (CheckBox) findViewById(R.id.chbVisible);



		frag = frag1 = new Fragment1();

		frag2 = new Fragment2();



	}



	@Override

	public boolean onCreateOptionsMenu(Menu menu) {

		getMenuInflater().inflate(R.menu.activity_main, menu);

		menu.setGroupVisible(R.id.groupVsbl, chbVisible.isChecked());

		if (chbAddDel.isChecked()) {

			menu.add(0, MENU_ID, 0, R.string.menu_item1).setIcon(android.R.drawable.ic_delete)

					.setShowAsAction(MenuItem.SHOW_AS_ACTION_ALWAYS | MenuItem.SHOW_AS_ACTION_WITH_TEXT);

		} else {

			menu.removeItem(MENU_ID);

		}

		return true;

	}



	public void onClick(View view) {

		switch (view.getId()) {

			case R.id.chbAddDel:

			case R.id.chbVisible:

				invalidateOptionsMenu();

				break;

			case R.id.btnFrag:

				frag = (frag == frag1) ? frag2 : frag1;

				getSupportFragmentManager().beginTransaction().replace(R.id.cont, frag).commit();

				break;

			default:

				break;

		}



	}

	}


В **onCreateOptionsMenu **настраиваем видимость группы groupVsbl в зависимости от значения чекбокса chbVisible.





В зависимости от значения чекбокса chbAddDel создаем или удаляем элемент.





В **onСlick **для чекбоксов вызываем метод [invalidateOptionsMenu](http://developer.android.com/reference/android/app/Activity.html#invalidateOptionsMenu()) - перерисовка меню/ActionBar. А по нажатию на кнопку поочередно выводим на экран Fragment1 или Fragment2.





Все сохраняем и запускаем приложение.





![](http://startandroid.ru/images/stories/lessons/L0112/L0112_010.JPG)





Жмем галку **Добавить/удалить**. Появляется элемент. Мы добавили MenuItem в Menu.





![](http://startandroid.ru/images/stories/lessons/L0112/L0112_020.JPG)





Жмем галку **Показать/скрыть**. Появляется элемент. Мы показали группу меню, в которой один пункт.





![](http://startandroid.ru/images/stories/lessons/L0112/L0112_030.JPG)





Соответственно, убирая галки - убираете элементы.





Понажимаем кнопку **Фрагмент**. Появляется элемент то одного, то другого фрагмента.





![](http://startandroid.ru/images/stories/lessons/L0112/L0112_040.JPG)





![](http://startandroid.ru/images/stories/lessons/L0112/L0112_050.JPG)





Еще, как вариант, можно играться с видимостью не всей группы, а конкретного элемента - метод [setVisible](http://developer.android.com/reference/android/view/MenuItem.html#setVisible(boolean)).





Если в ActionBar нажать на overflow-кнопку, будет вызван метод onPrepareOptionsMenu для Activity и для фрагмента, который сейчас отображен. 





Надеюсь статья вам поможет.





Полный проект вы можете скачать на [странице с кодами](http://android-helper.com.ua/codes/).
Всем привет.





Как много мы с вами видим разного рода красивых дизайнов, где с помощью пальца, можно менять не только экран но и Tabs.





Более подробно мы с вами остановимся на реализации данной задачи.


  <!-- more -->


Как вы поняли из названия статьи, мы будем использовать **PagerTabStrip**





Решил долго ничего не придумывать и записал видео как это сделать:









Теперь сам код:





**activity_main.xml**



	<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"

		xmlns:tools="http://schemas.android.com/tools"

		android:layout_width="fill_parent"

		android:layout_height="fill_parent"

		android:orientation="vertical" >



		<android.support.v4.view.ViewPager

			android:id="@+id/viewpager"

			android:layout_width="fill_parent"

			android:layout_height="fill_parent" >



			<android.support.v4.view.PagerTabStrip

				android:id="@+id/pagerTabStrip"

				android:layout_width="wrap_content"

				android:layout_height="wrap_content"

				android:layout_gravity="top"

				android:background="#a22c2e" />

		</android.support.v4.view.ViewPager>



	</RelativeLayout>


**fragment_default.xml**


	<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"

	android:layout_width="fill_parent"

	android:layout_height="fill_parent" >



	<TextView

		android:id="@+id/text"

		android:layout_width="wrap_content"

		android:layout_height="wrap_content"

		android:layout_gravity="center"

		android:text="Test" />



	</FrameLayout>



**MainActivity**



	public class MainActivity extends FragmentActivity {



		private ViewPager mViewPager;



		@Override

		public void onCreate(Bundle savedInstanceState) {

			super.onCreate(savedInstanceState);

			setContentView(R.layout.activity_main);



			mViewPager = (ViewPager) findViewById(R.id.viewpager);

			PagerTabStrip pagerTabStrip = (PagerTabStrip) findViewById(R.id.pagerTabStrip);

			// pagerTabStrip.setTextColor(color.white);

			// pagerTabStrip.setTabIndicatorColor(color.holo_red_dark);



			TitleAdapter titleAdapter = new TitleAdapter(getSupportFragmentManager());

			mViewPager.setAdapter(titleAdapter);

			mViewPager.setCurrentItem(0);

		}



		@Override

		public boolean onCreateOptionsMenu(Menu menu) {

			getMenuInflater().inflate(R.menu.activity_main, menu);

			return true;

		}

	}







**TitleAdapter**


	public class TitleAdapter extends FragmentPagerAdapter {

	private final String titles[] = new String[] { "View1", "View2", "View3" };

	private final Fragment frags[] = new Fragment[titles.length];



	public TitleAdapter(FragmentManager fm) {

		super(fm);

		frags[0] = new FragmentView1();

		frags[1] = new FragmentView2();

		frags[2] = new FragmentView3();

	}



	@Override

	public CharSequence getPageTitle(int position) {

		Log.v("TitleAdapter - getPageTitle=", titles[position]);

		return titles[position];

	}



	@Override

	public Fragment getItem(int position) {

		Log.v("TitleAdapter - getItem=", String.valueOf(position));

		return frags[position];

	}



	@Override

	public int getCount() {

		return frags.length;

	}

	}


**FragmentView1**


	public class FragmentView1 extends Fragment {

	@Override

	public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {

		View myView = inflater.inflate(R.layout.fragment_default, container, false);

		TextView text = (TextView) myView.findViewById(R.id.text);

		text.setText("Fragment View 1\n - Пример для android-helper.com.ua");

		return myView;

	}



}


**FragmentView2**


	public class FragmentView2 extends Fragment {

	@Override

	public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {

		View myView = inflater.inflate(R.layout.fragment_default, container, false);

		TextView text = (TextView) myView.findViewById(R.id.text);

		text.setText("Fragment View 2\n - Пример для android-helper.com.ua");

		return myView;

	}



	}




**FragmentView3**




	public class FragmentView2 extends Fragment {

	@Override

	public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {

		View myView = inflater.inflate(R.layout.fragment_default, container, false);

		TextView text = (TextView) myView.findViewById(R.id.text);

		text.setText("Fragment View 3\n - Пример для android-helper.com.ua");

		return myView;

	}



	}


Полный проект вы можете скачать на [странице с кодами](http://android-helper.com.ua/codes/).





Надеюсь вам понравилась статья.





Пишите ваши комментарии и подписывайтесь на обновления.
Всем привет.





Очень часто у разработчика встает вопрос - "Как же просмотреть какие запросы идут на сервер?".





Сегодня я постараюсь на него ответить.


 <!-- more -->


1. Для мониторинга трафика используйте программу [Fiddler](http://www.fiddler2.com/fiddler2/). Скачиваем и устанавливаем его.





2. Запускаем Fiddler. Заходим в Tools/Fiddler options/Connections. И ставим галочку "allow remote computers to connect". И перегружаем Fiddler.





![](http://android-helper.com.ua/images/uploads/2012/11/blog_fiddler.jpg)





3. Смотрим ваш внутренний IP адрес. Для этого открываем cmd и там пишем ipconfig





4. Для того что бы все работало. Компьютер и телефон должны быть в одной сети.





Не обязательно что бы ноутбук раздавал WiFi. У меня все работает через точку доступа.





5. Заходим в настройки WiFi. И прописываем прокси (IP вашего компьютера) и порт 8888 (такой как на картинке выше)





6. Наслаждаемся просмотром.





Короткий видео ролик, как это работает.

{% youtube Aoa38hbneSs %}


Всем привет.





Продолжаю собирать полезную информацию по программированию.





Сегодня хотел поделиться с вами работой DialogFragment.


<!-- more -->


Продолжаем рассматривать наследников Fragment. [DialogFragment](http://developer.android.com/reference/android/app/DialogFragment.html) – отличается от обычного фрагмента тем, что отображается как диалог и имеет соответствующие методы.





Построить диалог можно двумя способами: используя свой layout-файл и через AlertDialog.Builder. Нарисуем приложение, которое будет вызывать два диалога, построенных разными способами.









Создадим проект:





**Project name**: P1101_DialogFragment  
**Build Target**: Android 4.1   
**Application name**: DialogFragment  
**Package name**: ru.startandroid.develop.p1101dialogfragment  
**Create Activity**: MainActivity









Добавим строки в **strings.xml**:




	<string name="dialog_1">Dialog 1</string>

	<string name="dialog_2">Dialog 2</string>

	<string name="message_text">Text of your message</string>

	<string name="yes">Yes</string>

	<string name="no">No</string>

	<string name="maybe">Maybe</string>








Мы будем создавать два диалога, соответственно нам понадобятся два фрагмента.





Создадим layout-файл для первого фрагмента.





**dialog1.xml**:


	<?xml version="1.0" encoding="utf-8"?>

	<LinearLayout

 	xmlns:android="http://schemas.android.com/apk/res/android"

 	android:layout_width="wrap_content"

 	android:layout_height="match_parent"

 	android:orientation="vertical">

	<TextView

 	android:id="@+id/textView1"

 	android:layout_width="wrap_content"

 	android:layout_height="wrap_content"

 	android:layout_gravity="center"

 	android:layout_margin="20dp"

 	android:text="@string/message_text"

 	android:textAppearance="?android:attr/textAppearanceLarge">

	</TextView>

	<LinearLayout

 	android:layout_width="wrap_content"

 	android:layout_height="wrap_content">

	<Button

 	android:id="@+id/btnYes"

 	android:layout_width="wrap_content"

 	android:layout_height="wrap_content"

 	android:layout_margin="10dp"

 	android:text="@string/yes">

	</Button>

	<Button

 	android:id="@+id/btnNo"

 	android:layout_width="wrap_content"

 	android:layout_height="wrap_content"

 	android:layout_margin="10dp"

 	android:text="@string/no">

	</Button>

	<Button

 	android:id="@+id/btnMaybe"

 	android:layout_width="wrap_content"

 	android:layout_height="wrap_content"

 	android:layout_margin="10dp"

 	android:text="@string/maybe">

	</Button>

	</LinearLayout>

	</LinearLayout>




Так будет выглядеть наш диалог – текст сообщения и три кнопки.









Создаем класс **Dialog1.java**:

	package com.example.dialogfragments;



	import android.content.DialogInterface;

	import android.os.Bundle;

	import android.support.v4.app.DialogFragment;

	import android.util.Log;

	import android.view.LayoutInflater;

	import android.view.View;

	import android.view.View.OnClickListener;

	import android.view.ViewGroup;

	import android.widget.Button;



	public class Dialog1 extends DialogFragment implements OnClickListener {



		final String LOG_TAG = "myLogs";



		@Override

		public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {

		getDialog().setTitle("Title!");

		View v = inflater.inflate(R.layout.dialog1, null);

		v.findViewById(R.id.btnYes).setOnClickListener(this);

		v.findViewById(R.id.btnNo).setOnClickListener(this);

		v.findViewById(R.id.btnMaybe).setOnClickListener(this);

		return v;

		}



		public void onClick(View v) {

		Log.d(LOG_TAG, "Dialog 1: " + ((Button) v).getText());

		dismiss();

		}



		@Override

		public void onDismiss(DialogInterface dialog) {

		super.onDismiss(dialog);

		Log.d(LOG_TAG, "Dialog 1: onDismiss");

		}



		@Override

		public void onCancel(DialogInterface dialog) {

		super.onCancel(dialog);

		Log.d(LOG_TAG, "Dialog 1: onCancel");

		}

	}





В **onCreateView** мы получаем объект Dialog с помощью метода [getDialog](http://developer.android.com/reference/android/app/DialogFragment.html#getDialog()) и устанавливаем заголовок диалога. Далее мы создаем view из layout, находим в нем кнопки и ставим им текущий фрагмент в качестве обработчика.





В **onClick** выводим в лог текст нажатой кнопки и сами явно закрываем диалог методом [dismiss](http://developer.android.com/reference/android/app/DialogFragment.html#dismiss()).





Метод [onDismiss](http://developer.android.com/reference/android/app/DialogFragment.html#onDismiss(android.content.DialogInterface)) срабатывает, когда диалог закрывается. Пишем об этом в лог.





Метод [onCancel](http://developer.android.com/reference/android/app/DialogFragment.html#onCancel(android.content.DialogInterface)) срабатывает, когда диалог отменяют кнопкой Назад. Пишем об этом в лог.









Создаем второй фрагмент. Здесь мы будем строить диалог с помощью билдера, поэтому layout-файл не понадобится. Создаем только класс **Dialog2.java**:


	package com.example.dialogfragments;



	import android.app.AlertDialog;

	import android.app.Dialog;

	import android.content.DialogInterface;

	import android.content.DialogInterface.OnClickListener;

	import android.os.Bundle;

	import android.support.v4.app.DialogFragment;

	import android.util.Log;



	public class Dialog2 extends DialogFragment implements OnClickListener {



	final String LOG_TAG = "myLogs";



	@Override

	public Dialog onCreateDialog(Bundle savedInstanceState) {

		AlertDialog.Builder adb = new AlertDialog.Builder(getActivity()).setTitle("Title!")

				.setPositiveButton(R.string.yes, this).setNegativeButton(R.string.no, this)

				.setNeutralButton(R.string.maybe, this).setMessage(R.string.message_text);

		return adb.create();

	}



	public void onClick(DialogInterface dialog, int which) {

		int i = 0;

		switch (which) {

			case Dialog.BUTTON_POSITIVE:

				i = R.string.yes;

				break;

			case Dialog.BUTTON_NEGATIVE:

				i = R.string.no;

				break;

			case Dialog.BUTTON_NEUTRAL:

				i = R.string.maybe;

				break;

		}

		if (i > 0) {

			Log.d(LOG_TAG, "Dialog 2: " + getResources().getString(i));

		}

	}



	@Override

	public void onDismiss(DialogInterface dialog) {

		super.onDismiss(dialog);

		Log.d(LOG_TAG, "Dialog 2: onDismiss");

	}



	@Override

	public void onCancel(DialogInterface dialog) {

		super.onCancel(dialog);

		Log.d(LOG_TAG, "Dialog 2: onCancel");

	}

	}




Обычно для заполнения фрагмента содержимым мы использовали метод onCreateView. Для создания диалога с помощью билдера используется [onCreateDialog](http://developer.android.com/reference/android/app/DialogFragment.html#onCreateDialog(android.os.Bundle)). Создаем диалог с заголовком, сообщением и тремя кнопками. Обработчиком для кнопок назначаем текущий фрагмент.





В **onClick** определяем, какая кнопка была нажата и выводим соответствующий текст в лог. В случае создания диалога через билдер, диалог сам закроется по нажатию на кнопку, метод dismiss здесь не нужен.





Методы **onDismiss** и **onCancel** – это закрытие и отмена диалога, аналогично первому фрагменту.









Меняем layout-файл для MainActivity - **main.xml**:


	<?xml version="1.0" encoding="utf-8"?>

	<LinearLayout

 	xmlns:android="http://schemas.android.com/apk/res/android"

	xmlns:tools="http://schemas.android.com/tools"

	 android:id="@+id/LinearLayout1"

	 android:layout_width="match_parent"

	 android:layout_height="match_parent"

	 android:orientation="vertical">

	<Button

	 android:id="@+id/btnDlg1"

	 android:layout_width="wrap_content"

	 android:layout_height="wrap_content"

	 android:onClick="onClick"

	 android:text="@string/dialog_1">

	</Button>

	<Button

	 android:id="@+id/btnDlg2"

	 android:layout_width="wrap_content"

	 android:layout_height="wrap_content"

	 android:onClick="onClick"

	 android:text="@string/dialog_2">

	</Button>

	</LinearLayout>







Здесь только две кнопки.









Кодим **MainActivity.java**:



	package com.example.dialogfragments;



	import android.os.Bundle;

	import android.support.v4.app.DialogFragment;

	import android.support.v4.app.FragmentActivity;

	import android.view.View;



	public class MainActivity extends FragmentActivity {



	DialogFragment dlg1;

	DialogFragment dlg2;



	@Override

	public void onCreate(Bundle savedInstanceState) {

		super.onCreate(savedInstanceState);

		setContentView(R.layout.activity_main);

		dlg1 = new Dialog1();

		dlg2 = new Dialog2();

	}



	public void onClick(View v) {

		switch (v.getId()) {

			case R.id.btnDlg1:

				dlg1.show(getSupportFragmentManager(), "dlg1");

				break;

			case R.id.btnDlg2:

				dlg2.show(getSupportFragmentManager(), "dlg2");

				break;

			default:

				break;

		}



	}

	}




Создаем диалоги и запускаем их методом [show](http://developer.android.com/reference/android/app/DialogFragment.html#show(android.app.FragmentManager, java.lang.String)), который на вход требует FragmentManager и строку-тэг. Транзакция и коммит происходят внутри этого метода, нам об этом думать не надо.





Все сохраняем и запускаем приложение.





![](http://startandroid.ru/images/stories/lessons/L0110/L0110_010.JPG)









Жмем **Dialog1**





![](http://startandroid.ru/images/stories/lessons/L0110/L0110_020.JPG)





Отобразился наш простенький диалог.





Жмем какую-нибудь кнопку, например, **Yes **- диалог закрылся. Смотрим логи:





_Dialog 1: Yes  
Dialog 1: onDismiss_





Все верно.









Снова запустим первый диалог и нажмем клавишу **Назад **(**Back**). Смотрим лог:





_Dialog__ 1: __onCancel__  
Dialog 1: onDismiss_





Сработал onCancel – диалог был отменен, и onDismiss – диалог закрылся.





Если мы будем поворачивать экран, то каждый раз будет отрабатывать onDismiss, но диалог снова будет отображен после поворота.









Запустим второй диалог – нажмем кнопку **Dialog 2**.





![](http://startandroid.ru/images/stories/lessons/L0110/L0110_030.JPG)





Отобразился стандартный сконструированный нами диалог. Жмем, например, **No **– диалог закрылся. В логах:





_Dialog 2: No  
Dialog 2: onDismiss_









Снова запустим второй диалог и нажмем **Назад**. В логах:





_Dialog__ 2: __onCancel__  
Dialog 2: onDismiss_





Все так же, как и в первом случае.









Еще несколько слов по теме.





Если вы не хотите, чтобы ваш диалог можно было закрыть кнопкой, используйте для вашего диалог-фрагмента метод [setCancelable](http://developer.android.com/reference/android/app/DialogFragment.html#setCancelable(boolean)) с параметром false.





Есть еще один вариант вызова диалога. Это метод [show](http://developer.android.com/reference/android/app/DialogFragment.html#show(android.app.FragmentTransaction, java.lang.String)), но на вход он уже принимает не FragmentManager, а FragmentTransaction. В этом случае система также сама вызовет commit внутри show, но мы можем предварительно поместить в созданную нами транзакцию какие-либо еще операции или отправить ее в BackStack.





Вы можете использовать диалог-фрагменты, как обычные фрагменты и отображать их на Activity, а не в виде диалога. Но при этом будьте аккуратнее с использованием **getDialog**. Я так понял, что он возвращает null в этом случае.





Если **AlertDialog.Builder** вам незнаком, то посмотрите Урок 60 и несколько следующих за ним. Там достаточно подробно описано, как создавать различные диалоги.





Статья из сайта [startandroid.ru](http://startandroid.ru/uroki/vse-uroki-spiskom/180-urok-110-android-3-fragments-dialogfragment-dialog.html)





Полный проект вы можете скачать на [странице с кодами](http://android-helper.com.ua/codes/).





Пишите ваши комментарии.
Сегодня просматривая свои записи, нашел интересную статью.





В этой статье автор описывает базовые компоненты android.





Думаю, что она будет интересна не только новичкам но и бывалым программерам, которые просто хотят освежить свои знания.





Тогда прошу к прочтению.


 <!-- more -->


Маленькая схема:





![](http://android-helper.com.ua/images/uploads/2012/10/f3ea651c-e042-4c34-b2fc-964b4cd7ae0f.png)








* Приложения для Android состоят из одного или нескольких компонентов: Activities (Деятельности), Services (Службы), Content Providers (Поставщики данных), а также Broadcast Receivers (Получатели широковещательных сообщений).  
  
* Каждый компонент выполняет свою роль в приложении и может быть активирован отдельно от других (причём активирован может быть даже сторонним приложением).  
  
* В AndroidManifest.xml (файл манифеста) должны быть объявлены все компоненты приложения и системные требования, такие как необходимая минимальная версия Android или определённая аппаратная конфигурация.  
  
* Необходимые для приложения ресурсы (изображения, файлы разметки, строки и т.д.) должны содержать альтернативные варианты для различных конфигураций устройств (например, строки на разных языков или различные разметки и изображения для возможных размеров экрана).  
  
  
Данный текст является переводом (хотя и немного вольным) статьи из [официальной документации по Android](http://developer.android.com/guide/topics/fundamentals.html).  
  
Примечание: некоторые слова в тексте оставлены по-английски, потому что, эти термины совпадают с названиями классов с помощью которых они реализуются и их перевод только усложняет понимание (в скобках написан их буквальный перевод).  
  
  
**Основы**  
Android-приложения написаны на языке программирования Java. Инструмент Android SDK (Software Development Kit — комплект разработки программного обеспечения) компилирует код вместе со всеми данными и файлами ресурсов в пакет Android - архивный файл с расширением .apk. Этот файл позволяет установить приложение на любом устройстве под управлением системы Android.  
  
После установки на устройстве, каждое приложение живёт в своей собственной изолированной программной среде:








  * Операционная система Android является многопользовательской Linux-системой, в которой каждое приложение это отдельный пользователь.



  * По умолчанию, система присваивает каждому приложению уникальный идентификатор пользователя userid (который используется только системой). Система устанавливает разрешения для всех файлов приложения таким образом, чтобы только определённый пользователь (с определённым userid) мог получить к ним доступ.



  * Каждый процесс имеет свою собственную виртуальную машину, так что код приложения запускается изолированно от других приложений.



  * По умолчанию каждое приложение выполняется в отдельном процессе Linux. Android начинает процесс, когда одному из компонентов приложения необходимо запуститься, а затем завершает процесс, когда он больше не нужен или когда системе требуется память для других приложений.






Таким образом, система Android реализует принцип наименьших привилегий. То есть, каждое приложение по умолчанию имеет доступ только к компонентам, которые необходимы для его работы и не более того. Однако, существуют способы обмена данными между приложениями и получения доступа к системным сервисам:








  * Возможно раздать двум приложениям одинаковые идентификаторы пользователей (userid), в этом случае они могут получить доступ к файлам друг друга. Для экономии системных ресурсов приложения с тем же идентификатором также могут быть запущены в одном процессе и использовать одну виртуальную машину. Такие приложения должны быть подписаны на один и тот же сертификат.



  * Приложение может запросить разрешение на доступ к системным данным, таким как контакты пользователя, SMS сообщения, карточка хранения (SD), камера, Bluetooth и многое другое. Все запросы доступа должны быть разрешены пользователем во время установки.






**Компоненты приложений **  
Компоненты — кирпичики, из которых состоит любое приложение. Каждый компонент предоставляет отдельную точку входа в приложение для системы, хотя не каждая такая точка является актуальной для пользователя. Компоненты могут зависеть друг от друга, но каждый из них это отдельная сущность, которая играет особую роль и помогает определить общее поведение приложения.   
  
Существуют четыре типа компонентов приложения. Каждый из них служит различным целям и имеет свой жизненный цикл, который определяет, как компонент создаётся и уничтожается.   
  
_**Activity (Деятельность)**_  
Activity представляет собой один экран с пользовательским интерфейсом. Например, приложение электронной почты, может иметь одну Activity, которая показывает список новых сообщений электронной почты, другую для создания нового сообщения, и ещё одну для чтения письма. Хотя все они работают вместе в рамках одного приложения, каждая из них независима от других. Таким образом, другие приложения могут вызвать любую из этих Activity (если почтовое приложение позволяет это). Например, приложение камеры может открыть Activity в которой создаётся новое сообщение, чтобы пользователь мог отправить фотографии по почте.   
  
_**Service (Служба)**_  
Service это компонент, который работает в фоновом режиме и не имеет пользовательского интерфейса. Службы используются для обработки длительных операций или для выполнения удалённых процессов. Например, Service может воспроизводить музыку в фоновом режиме или получать данные по сети, не блокируя взаимодействие пользователя с работающим приложением. Service могут запустить другие компоненты, например Activity, и затем взаимодействовать с ней.  
  
_**Content provider (Поставщик данных)**_  
Content provider управляет данными приложения. Данные можно хранить в файловой системе, базе данных SQLite, в Интернете или любом другом доступном для приложения месте хранения. Через Content providers другие приложения могут запрашивать или даже изменить данные (если на это есть права доступа). Например, в операционной системе Android существует Content provider, который управляет списком контактов пользователя. Таким образом, любое приложение, с соответствующими разрешениями могут запрашивать информацию о конкретном человеке для чтения или записи. Content provider также можно использовать для чтения и записи данных, которые доступны только для одного приложения.   
  
_**Broadcast receivers (Получатель широковещательных сообщений)**_  
Broadcast receiver - компонент, который позволяет принимать широковещательные сообщения операционной системы. Такими сообщениями являются, например, объявления о том, что экран выключился, батарея разряжена или был сделан фотоснимок. Такие сообщения также могут посылаться пользовательскими приложениями, например, уведомления о том, что некоторые данные были загружены и готовы к использованию. Хотя Broadcast receiver не имеют пользовательского интерфейса, он может создавать уведомления в строке состояния. Однако, чаще всего Broadcast receiver это просто "шлюз" для других компонентов, например, он может запускать Service для обработки определённых событий.   
  
Уникальной особенностью системы Android является то, что любое приложение может запустить компоненты другого приложения. Если необходимо дать пользователю возможность сделать фотографию, то не обязательно это реализовывать, можно вызвать уже существующее приложение. После завершения оно вернёт созданную фотографию в ваше приложение для дальнейшего использования. Для пользователя это будет выглядеть как одно приложение.   
  
Для запуска любого компонента операционная система начинает новый процесс (если его ещё не было) и инициализирует классы, необходимые для компонента. Например, если в вашем приложении запускается Activity для работы с камеры (принадлежащая стороннему приложению), то она запускается в отдельном процессе, который принадлежит этому стороннему приложению, а не в процессе вашего приложения. Поэтому, в отличие от приложений на большинство других систем, приложений Android не имеют единую точку входа (нет функции main()).   
  
Так как система запускает каждое приложение в отдельном процессе с правами доступа к файлам, которые ограничивают доступ для других приложений, ваше приложение не может непосредственно вызвать компонент из стороннего приложения. Однако, операционная система Android это может, поэтому для активации такого компонента, необходимо отправить сообщение операционной системе о своём намерении начать конкретный компонент и она его активирует.  
  
**Активация компонентов**  
Три из четырёх типов компонентов — Activity (деятельность), Service (сервис), а также Broadcast receivers (получатель широковещательных сообщений) — активируются с помощью асинхронного сообщения Intent (намерение). Intent связывает отдельные компоненты друг с другом во время выполнения, будь то компонент принадлежащий вашему приложению или другой.   
  
Intent (намерение) создаётся с помощью класса Intent, который описывает запрос на активацию конкретного компонента или конкретного типа компонента, соответственно Intent может быть явным или неявным.   
  
Для Activity и Service, Intent(намерение) определяет действие, которое надо выполнить (например, "Просмотреть" или "Отправить" что-то), и может указать URI (Uniform Resource Identifier — унифицированный идентификатор ресурса) данных необходимых для выполнения. Например, Intent может передать запрос Activity показать изображение или открыть веб-страницу.   
Для broadcast receivers Intent просто определяет транслируемые сообщения (например, широковещательное сообщения о том, что аккумулятор разряжен содержит только строковую константу обозначающую "батарея разряжена").   
Последний компонент - Content provider не активируется с помощью Intent. Хотя он и может вызывается, если Content provider запрашивает данные из ContentResolver.   
  
Методы для активации каждого типа компонентов:








  * Для запуска Activity используются методы startActivity(Intent intent) или startActivityForResult(Intent intent) (если необходимо вернуть результат).



  * Для запуска Service вызывается метод startService (Intent service).



  * Для запуска Broadcast reciever — sendBroadcast(Intent intent), sendOrderedBroadcast(Intent intent, String receiverPermission), или sendStickyBroadcast(Intent intent).



  * Для формирования запроса для Content Provider используется метод query ()






**Файл манифеста **  
Перед запуском любого компонента операционная система Android читает файл манифеста приложения AndroidManifest.xml, чтобы убедиться, что запускаемый компонент существует. В этом файле должны быть объявлены все компоненты приложения, которые находятся в корневой папке приложения.  
  
Кроме этого манифест-файл выполняет другие функции:








  * Определяет пользовательские разрешения, такие как доступ в Интернет или чтение контактов.



  * Объявление минимального API уровня (версии Android), необходимого для приложения.



  * Объявление аппаратных и программных требований, такие как камера, Bluetooth, или мультитач экран.



  * API библиотек с которыми приложение будет связываться, например библиотеки Google Maps.






Но все же основная задача манифеста сообщить системе о компонентах приложения. Например, можно объявить Activity (деятельность) следующим образом:







	<?xml version="1.0" encoding="utf-8"?>  
	<manifest ... >  
		<application android:icon="@drawable/app_icon.png" ... >  
			<activity android:name="com.example.project.ExampleActivity"  
			android:label="@string/example_label" ... >  
			</activity>  
		</application>  
	</manifest>  








В элементе <application> атрибут Android:icon указывает на ресурсы для иконки приложения.  
  
В элементе <activity> атрибут Android:name определяет полный путь на имя класса Activity (деятельности), а атрибут Android:label задаёт заголовок приложения.   
  
Для определения компонентов используются:  
<activity> для Activity (деятельности)  
<service> для Service (сервисы)  
<receiver> для Broadcast reciever (получатели широковещательных сообщений)  
<provider> для Content providers (поставщики данных)  
  
Activity (деятельность), Service (сервис) и Content provider (поставщики данных), которые существуют в исходниках, но не заявлены в манифесте не видны системе и, следовательно, не смогут запуститься. Однако, Broadcast provider (получатель широковещательных сообщений) может создаваться динамически в коде (как объекты BroadcastReceiver) и регистрироваться с помощью вызова registerReceiver ().   
  
**Объявление возможностей компонента**  
Как уже говорилось в разделе «Активация компонентов», для вызова Activity (деятельность), Service (сервис) и Broadcast receiver (получатель широковещательных сообщений) можно использовать класс Intent. Сделать это можно явно, задав конкретное имя компонента, или не явно, а этом случае описывается только тип действия, который нужно выполнить (и, возможно, данные, необходимые для него). Система сама находит компонент устройства, который может выполнить действия и запускает его. Если найдено несколько подходящих компонентов, то пользователь выбирает, какой из них использовать.   
  
Система определяет компоненты, которые могут реагировать на намерение путём сравнения полученного Intent (намерения), с Intent filters (фильтр намерений), определённых в файлах манифеста других приложений.   
  
При объявлении компонента в файле манифеста, можно дополнительно включить фильтр намерений, которые заявляют возможности компонента, чтобы он мог реагировать на запросы из других приложений. Для объявления фильтра намерения используется элемент <intent-filter>.   
  
Например, приложение электронной почты с Activity (деятельностью) для создания новых сообщений может объявить Intent filter (фильтр намерения) в своём файле манифеста запускаться на запрос "send" (отправить). Activity (деятельность) в стороннем приложении создаёт Intent (намерение) с типом действия "send" (ACTION_SEND), которое система сопоставит с приложением электронной почты и запустит нужную Activity (деятельность).  
  
**Объявление требований приложений **  
Существует большое количество устройств, работающий под управлением системы Android, однако, не все они обеспечивают одинаковые функции и возможности. Чтобы не позволить установить приложение на устройство, в котором отсутствуют необходимые функции, необходимо объявить аппаратные и программные требования в файле манифеста. Большинство из этих заявлений существуют исключительно для ознакомления и система не читает их, однако внешние сервисы, таких как Android Market используют их, чтобы обеспечить фильтрацию для пользователей, которые ищут приложения для своего устройства.   
  
Например, если приложение требует камеру и использует API, введённые в Android версии 2.1 (API уровень 7), надо записать эти требования в файл манифеста. Таким образом, устройства, которые не имеют камеру или с версией Android ниже, чем 2.1 не смогут установить приложение из Android Market.   
  
Однако, приложение может использовать камеру, но но это требование не является критичным для его работы. В этом случае приложение должно выполнять проверку во время выполнения, чтобы отключить функции, использующие камеру.   
  
При проектировании и разработке приложения, необходимо учитывать:   
  
_**Размер экрана и плотность**_  
Android определяет две характеристики экрана для устройства: размер экрана (физические размеры экрана) и плотность (плотность пикселей на экране, или dpi (dots per inch - точек на дюйм). Для упрощения Android обобщает их в отдельных группы  
  
Размер: small (маленький), normal (средний), large (большой), and extra large (очень большой).   
Плотность: low density (низкая), medium density (средняя), high density (высокая), and extra high density (очень высокая).   
  
По умолчанию, приложение совместимо со всеми размерами экрана, так как система Android делает необходимые изменения пользовательского интерфейса и изображений. Однако, лучше создать специализированные макеты и изображения для определённых размеров и плотностей и объявить в манифесте, какие именно размеры экрана приложение поддерживает в элементе <supports-screens>.  
  
_**Средства ввода **_  
Устройства могут иметь различные средства для ввода, такие как аппаратная клавиатура, трекбол или джойстик. Если приложение требует определённое оборудование для ввода, то необходимо объявить это в манифесте в элементе <uses-configuration>. Однако, в большинстве случаев приложения поддерживают любое средство ввода.  
  
_**Аппаратные требования**_  
Не все аппаратные или программные функции, таких как камера, датчик освещённости, Bluetooth или сенсорный экран, могут существовать на конкретном устройстве, поэтому необходимо декларировать любые функции, используемые приложения в элементе .   
  
_**Версия платформы **_  
Устройства работают на разных версиях платформы Android. Каждая последующая версия часто включает в себя дополнительные интерфейсы API, которые не доступны в предыдущей версии. Для того, чтобы указать, какой набор API-интерфейсов доступен, каждой версии платформы соответствует API уровень (например, Android 1.0 — 1 уровень API, Android 2.3 — 9 уровень). Если в приложении используются API, которые были добавлены к платформе после определённой версии, необходимо объявить минимальный уровень API с помощью элемента <uses-sdk>.  
  
**Ресурсы приложения **  
Приложения Android состоят не только из исходного кода, но также из ресурсов для визуального представления, такие как изображения или звуковые файлы. Для приложения необходимо определить меню, стили, цвета и разметку пользовательского интерфейса в файлах XML. Использование ресурсов даёт возможность изменять некоторые части приложения без модификации исходного кода, а также позволяет оптимизировать приложение для различных устройств (с различным языком интерфейса или размером экрана).   
  
Для каждого ресурса, включённого в проект Android, SDK определяет уникальный идентификатор (целое число), которое можно использовать для ссылки на ресурс из кода или из других ресурсов определённых в XML. Например, если приложение содержит изображение с именем logo.png (сохранённое в директории res/drawable), SDK сгенерирует идентификатор ресурса R.drawable.logo, которое можно использовать для ссылки на изображение.   
  
Главным достоинством отдельного хранения исходного кода и ресурсов является возможность создать разные ресурсы для разных аппаратных конфигураций. Например, строки интерфейса для разных языков можно определять в различных xml файлах (они хранятся например в директории res/values-fr/ для французского языка). В зависимости от выбранного пользователем языка система Android подставляет нужные строки в интерфейс.   
  
Android поддерживает множество классификаторов для альтернативных ресурсов. Классификатор это короткая строка в название директории ресурсов для определения когда эти ресурсы должны быть использованы. Часто создаются различные схемы интерфейса для разных размеров и ориентаций экранов устройства. Например, при портретной ориентации кнопки удобнее разместить по вертикали, а для альбомной ориентации - по горизонтали. Чтобы изменить расположение в зависимости от ориентации, можно определить две различные схемы и добавить соответствующие классификаторы к имени каталога каждого макета. Тогда, система автоматически применяет соответствующий макет в зависимости от текущей ориентации устройства.
Добрый день друзья.





По просьбе одного из участников нашего сообщества. Был поднят вопрос:





Как можно достучаться до элементов на табах.





Сегодня я вам покажу на эту тему видео и дам комментарии.


<!-- more -->


Смотрим видео.


{% youtube waUgWu8PV1w %}






#### bottom_selector.xml



	<?xml version="1.0" encoding="utf-8"?>

	<selector xmlns:android="http://schemas.android.com/apk/res/android">



		<item android:drawable="@android:drawable/ic_lock_silent_mode_off" android:state_selected="true"/>

		<item android:drawable="@android:drawable/ic_lock_silent_mode_off" android:state_focused="true"/>

		<item android:drawable="@android:drawable/ic_lock_silent_mode_off" android:state_pressed="true"/>

		<item android:drawable="@android:drawable/ic_lock_silent_mode"/>

	</selector>


	



#### text_colors_selector.xml



	<?xml version="1.0" encoding="utf-8"?>

	<selector xmlns:android="http://schemas.android.com/apk/res/android">



		<item android:state_selected="true" android:color="@android:color/white"/>

		<item android:state_focused="true" android:color="@android:color/white"/>

		<item android:state_pressed="true" android:color="@android:color/white"/>

		<item android:color="@android:color/darker_gray"/>



	</selector>

	



#### tab_host_layout.xml


	<?xml version="1.0" encoding="utf-8"?>

	<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"

		android:layout_width="fill_parent"

		android:layout_height="fill_parent"

		android:background="@android:color/black" >



	<ImageView

		android:id="@+id/tab_image"

		android:layout_width="fill_parent"

		android:layout_height="fill_parent"

		android:layout_above="@+id/tab_text"

		android:cropToPadding="true"

		android:scaleType="center"

		android:src="@android:drawable/ic_menu_add" />



	<TextView

		android:id="@+id/tab_text"

		android:layout_width="fill_parent"

		android:layout_height="wrap_content"

		android:layout_alignParentBottom="true"

		android:layout_marginBottom="5dp"

		android:gravity="center_horizontal"

		android:text="Text"

		android:textColor="@color/text_colors_selector"

		android:textSize="13sp" />



	<TextView

		android:id="@+id/tab_unread_message"

		android:layout_width="wrap_content"

		android:layout_height="wrap_content"

		android:layout_alignParentRight="true"

		android:layout_marginRight="10dp"

		android:layout_marginTop="2dp"

		android:gravity="center"

		android:text="5"

		android:textColor="@android:color/white"

		android:textSize="14sp"

		android:textStyle="bold" />



	</RelativeLayout>
	



#### MainActivity.java


1. Комментируем и добавляем построение табов



		// mTabsAdapter.addTab(mTabHost.newTabSpec("simple").setIndicator("Android"), AndroidFragment.class, null);

		// mTabsAdapter.addTab(mTabHost.newTabSpec("contacts").setIndicator("IOs"), IOsFragment.class, null);

		// mTabsAdapter.addTab(mTabHost.newTabSpec("custom").setIndicator("Windows"), WindowsFragment.class, null);

		// mTabsAdapter.addTab(mTabHost.newTabSpec("throttle").setIndicator("DOS"), DOSFragment.class, null);



		mTabsAdapter.addTab(setupTab(new TextView(this), "Android", R.drawable.bottom_selector, 0),

				AndroidFragment.class, null);

		mTabsAdapter

				.addTab(setupTab(new TextView(this), "IOs", R.drawable.bottom_selector, 0), IOsFragment.class, null);

		mTabsAdapter.addTab(setupTab(new TextView(this), "Windows", R.drawable.bottom_selector, 0),

				WindowsFragment.class, null);

		mTabsAdapter

				.addTab(setupTab(new TextView(this), "DOS", R.drawable.bottom_selector, 0), DOSFragment.class, null);

	



2. Добавляем 2 функции сразу после onCreate





		private TabSpec setupTab(final View view, final String tag, final int imageRes, final int notificationItem) {

		View tabview = createTabView(mTabHost.getContext(), tag, imageRes, notificationItem);

		TabSpec setContent = mTabHost.newTabSpec(tag).setIndicator(tabview).setContent(new TabContentFactory()                         {

			@Override

			public View createTabContent(final String tag) {

				return view;

			}

		});

		// mTabHost.addTab(setContent);

		return setContent;

		}



		private static View createTabView(final Context context, final String text, final int imageRes,

			final int notificationItem) {

		View view = LayoutInflater.from(context).inflate(R.layout.tab_host_layout, null);

		TextView tv = (TextView) view.findViewById(R.id.tab_text);

		tv.setText(text);

		ImageView iv = (ImageView) view.findViewById(R.id.tab_image);

		iv.setImageResource(imageRes);

		tv = (TextView) view.findViewById(R.id.tab_unread_message);

		tv.setText(String.valueOf(notificationItem));

		if (notificationItem == 0) {

			tv.setVisibility(View.GONE);

		} else {

			tv.setVisibility(View.VISIBLE);

		}

		return view;

		}






3. Добавляем функцию нотификации после метода onPageScrollStateChanged

4. Делаем нотификацию

		public void updateNotification(final int notificationItem, final int position) {

			View view = mTabHost.getTabWidget().getChildAt(position);

			TextView tv = (TextView) view.findViewById(R.id.tab_unread_message);

			tv.setText(String.valueOf(notificationItem));

			if (notificationItem == 0) {

				tv.setVisibility(View.GONE);

			} else {

				tv.setVisibility(View.VISIBLE);

			}

		}





P.S. Забыл на видео сказать, что нужно еще модифицировать activity_main.xml





#### activity_main.xml





	<?xml version="1.0" encoding="utf-8"?>

	<TabHost xmlns:android="http://schemas.android.com/apk/res/android"

	android:id="@android:id/tabhost"

	android:layout_width="match_parent"

	android:layout_height="match_parent" >



	<LinearLayout

		android:layout_width="match_parent"

		android:layout_height="match_parent"

		android:orientation="vertical" >



		<FrameLayout

			android:id="@android:id/tabcontent"

			android:layout_width="0dp"

			android:layout_height="0dp"

			android:layout_weight="0" />



		<android.support.v4.view.ViewPager

			android:id="@+id/pager"

			android:layout_width="match_parent"

			android:layout_height="0dp"

			android:layout_weight="1" />



		<TabWidget

			android:id="@android:id/tabs"

			android:layout_width="match_parent"

			android:layout_height="53dp"

			android:layout_weight="0"

			android:orientation="horizontal" />

	</LinearLayout>



	</TabHost>




Если вам понравилась статья, пишите свои комментарии.





Поделись этой статьей с другом.
Нашел довольно интересную статью по работе с mp3 файлами на стороне android.





Думаю это будет интересно как для профи так и для новичка.





Прошу к прочтению.


<!-- more -->


В данной статье описан процесс получения всей основной информации о аудиотреках в устройстве с Android, основы работы с плейлистами и проигрывания аудиофайлов.





**Общие принципы работы с провайдерами данных**





Источники данных ( Content Providers, Провайдеры данных ) в Android предоставляют интерфейс общего доступа к любому источнику данных путем отделения уровня доступа к данным от уровня приложения. Источники данных предлагают стандартный API, с помощью которого приложения могут обмениваться своими данными между собой, и использовать различные системные базы данных.





Типичный запрос к провайдеру данных выглядит следующим образом. Сначала запрашивается системный объект класса ContentResolver, который позволяет подключаться к провайдерам данных. Затем необходимо настроить параметры запроса и вызвать метод ContentResolver.query, в который передаются параметры запроса и который в случае успешного выполнения возвращает объект класса Cursor, предоставляющий интерфейс для работы с данными, возвращаемые в результате запроса к базе данных.




    
    
    
    [java]String[] projection = new String[] {
    
    People._ID,
    
    People.NAME,
    
    People.NUMBER,
    
    };
    
    
    
    Uri mContactsUri = People.CONTENT_URI;
    
    ContentResolver resolver = appContext.getContentResolver();
    
    
    
    Cursor managedCursor = resolver.query( mContactsUri,
    
              projection,.
    
              null, 
    
              null,
    
              People.NAME + " ASC"); 
    
    
    
    for( int i=0;i&lt;managedCursor.getCount();i++)
    
    {
    
          managedCursor.moveToPosition(i);
    
          String nameOfContact =  managedCursor.getString(1);
    
          ….    
    
    }
    
    [/java]
    
    





Подробнее о работе с провайдерами данных можно посмотреть на сайте разработчиков -[http://developer.android.com/guide/topics/providers/content-providers.html](http://developer.android.com/guide/topics/providers/content-providers.html).





**Провайдер данных MediaStore.Audio**





Провайдер данных MediaStore представляет собой централизованную базу данных мультимедиа, размещенных в памяти устройства или на сменном носителе ( SD карте ), включая аудио-, видеофайлы и изображения. Данные в MediaStore записываются автоматически при сканировании системой внутренней или сменной памяти, при этом рассылаются сообщения ACTION_MEDIA_SCANNER_STARTED и ACTION_MEDIA_SCANNER_FINISHED. Любая программа может уведомить сканер о наличии нового файла вызовом




    
    
    
    [java]sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE, newFilePath));[/java]





Примечание: чтобы запретить сканеру обрабатывать определенный каталог на диске, поместите туда пустой файл с именем .nomedia.





При сканировании анализируются ID теги и другая информация, которая становится доступна в пользовательских приложениях. Доступ к данным аудиофайлов осуществляется через провайдер MediaStore.Audio, который также дает возможность работать с плейлистами ( списками воспроизведения ). 





В примерах этой статьи будет использоваться вызов myquery, который утилизирует получение курсора по URI провайдера данных и других параметров запроса.




    
    [java]public static Cursor myquery(Context context, Uri uri, String[] projection,
    
                 String selection, String[] selectionArgs, String sortOrder, int limit) {
    
                 try {
    
                       ContentResolver resolver = context.getContentResolver();
    
                       if (resolver == null) {
    
                            return null;
    
                       }
    
                        if (limit &gt; 0) {
    
                            uri = uri.buildUpon().appendQueryParameter("limit", "" + limit).build();
    
                         }
    
                      return resolver.query(uri, projection, selection, selectionArgs, sortOrder);
    
                    } catch (UnsupportedOperationException ex) {
    
                                return null;
    
                     }
    
                 
    
                  }[/java]





**Простое перечисление всей музыки в телефоне**




    
    [java]String[] projection = { MediaStore.Audio.Media._ID,             // 0
    
                              MediaStore.Audio.Media.ARTIST,          // 1
    
                              MediaStore.Audio.Media.TITLE,           // 2
    
                              MediaStore.Audio.Media.ALBUM_ID,  // 3
    
                              MediaStore.Audio.Media.ALBUM,           // 4
    
                              MediaStore.Audio.Media.DATA,            // 5
    
                              MediaStore.Audio.Media.DISPLAY_NAME,    // 6
    
                              MediaStore.Audio.Media.DURATION,
    
                                            MediaStore.Audio.Media.TITLE_KEY
    
            };      // 7
    
    
    
    String selection = MediaStore.Audio.Media.IS_MUSIC + " != 0 ";
    
    Cursor musicListSDCardCursor = myquery(
    
                               this,
    
                               MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,
    
                               projection, selection , null, null,0);
    
    Cursor musicListInternalMemoryCursor = myquery(
    
                               this,
    
                               MediaStore.Audio.Media.INTERNAL_CONTENT_URI,
    
                               projection, selection , null, null,0);
    
    [/java]





**Списки альбомов**





Получение списка альбомов:




    
    [java]String[] projection = {
    
                 MediaStore.Audio.Albums.ALBUM,            // 0
    
                 MediaStore.Audio.Albums.NUMBER_OF_SONGS,  // 1
    
                 MediaStore.Audio.Albums.LAST_YEAR,       // 2
    
                               MediaStore.Audio.Albums.ARTIST,           // 3
    
                               MediaStore.Audio.Albums._ID               // 4
    
                                            };
    
    
    
    
    
      Cursor albumsListSDCardCursor = myquery(
    
                               this,
    
                               MediaStore.Audio.Albums.EXTERNAL_CONTENT_URI,
    
                               projection, null , null, null,0);
    
    
    
      Cursor albumsListInternalMemoryCursor = myquery(
    
                               this,
    
                               MediaStore.Audio.Albums.INTERNAL_CONTENT_URI,
    
                               projection, null , null, null,0);
    
    [/java]





Получение списка дорожек, входящих в данный альбом:




    
    [java]// String albumId содержит выбранный MediaStore.Audio.Albums._ID  
    
    
    
    String[] projection = { MediaStore.Audio.Media._ID,             // 0
    
                              MediaStore.Audio.Media.ARTIST,          // 1
    
                              MediaStore.Audio.Media.TITLE,           // 2
    
                              MediaStore.Audio.Media.ALBUM_ID,  // 3
    
                              MediaStore.Audio.Media.ALBUM,           // 4
    
                              MediaStore.Audio.Media.DATA,            // 5
    
                              MediaStore.Audio.Media.DISPLAY_NAME,    // 6
    
                              MediaStore.Audio.Media.DURATION,
    
                                            MediaStore.Audio.Media.TITLE_KEY
    
            };      // 7
    
    
    
           String selection = MediaStore.Audio.Media.IS_MUSIC + " != 0 AND "+
    
                   MediaStore.Audio.Media.ALBUM_ID +"=?";
    
           String[] args = new String[] {albumId};
    
    
    
    Cursor musicListSDCardCursor = myquery(
    
                               this,
    
                               MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,
    
                               projection, selection , args, null,0);
    
    Cursor musicListInternalMemoryCursor = myquery(
    
                               this,
    
                               MediaStore.Audio.Media.INTERNAL_CONTENT_URI,
    
                               projection, selection , args, null,0);
    
    [/java]





**Списки исполнителей**





Получение списка всех исполнителей:




    
    [java]String[] projection = {
    
                MediaStore.Audio.Artists.ARTIST,            // 0
    
                MediaStore.Audio.Artists.NUMBER_OF_ALBUMS,  // 1
    
                MediaStore.Audio.Artists.NUMBER_OF_TRACKS,
    
                              MediaStore.Audio.Artists._ID
    
                                            };
    
    
    
    
    
      Cursor artistListSDCardCursor = myquery(
    
                               this,
    
                               MediaStore.Audio.Artists.EXTERNAL_CONTENT_URI,
    
                               projection, null , null, null,0);
    
    
    
      Cursor artistListInternalMemoryCursor = myquery(
    
                               this,
    
                               MediaStore.Audio.Artists.INTERNAL_CONTENT_URI,
    
                               projection, null , null, null,0);
    
    [/java]





Получение списка композиций данного исполнителя:




    
    [java]// String artistId содержит выбранный MediaStore.Audio.Artists._ID  
    
    String[] projection = {
    
                  String[] projection = { MediaStore.Audio.Media._ID,             // 0
    
                              MediaStore.Audio.Media.ARTIST,          // 1
    
                              MediaStore.Audio.Media.TITLE,           // 2
    
                              MediaStore.Audio.Media.ALBUM_ID,  // 3
    
                              MediaStore.Audio.Media.ALBUM,           // 4
    
                              MediaStore.Audio.Media.DATA,            // 5
    
                              MediaStore.Audio.Media.DISPLAY_NAME,    // 6
    
                              MediaStore.Audio.Media.DURATION,
    
                                            MediaStore.Audio.Media.TITLE_KEY
    
            };      // 7
    
    
    
           String selection = MediaStore.Audio.Media.IS_MUSIC + " != 0 AND "+
    
                   MediaStore.Audio.Media.ARTIST_ID +"=?";
    
           String[] args = new String[] {artistId};
    
    
    
          Cursor musicListSDCardCursor = myquery(
    
                               this,
    
                               MediaStore.Audio.Artists.EXTERNAL_CONTENT_URI,
    
                               projection, null , null, null,0);
    
    
    
          Cursor musicListInternalMemoryCursor = myquery(
    
                               this,
    
                               MediaStore.Audio.Artists.INTERNAL_CONTENT_URI,
    
                               projection, null , null, null,0);
    
    [/java]





**Списки жанров**





Получение списка всех жанров:




    
    [java]String[] projection = { MediaStore.Audio.Genres._ID,          // 0
    
                  MediaStore.Audio.Genres.NAME          // 1
    
                                                        };
    
        Cursor genresListSDCardCursor = myquery(
    
                               this,
    
                               MediaStore.Audio.Genres.EXTERNAL_CONTENT_URI,
    
                               projection, null , null, MediaStore.Audio.Genres.NAME, 0);
    
    
    
        Cursor genresListInternalMemoryCursor = myquery(
    
                               this,
    
                               MediaStore.Audio.Genres.INTERNAL_CONTENT_URI,
    
                               projection, null , null, MediaStore.Audio.Genres.NAME, 0);[/java]





Получение списка композиций выбранного жанра:




    
    [java]// String genreId содержит выбранный MediaStore.Audio.Genres._ID
    
     String[] projection = { MediaStore.Audio.Genres.Members._ID,             // 0
    
                              MediaStore.Audio.Genres.Members.ARTIST,          // 1
    
                              MediaStore.Audio.Genres.Members.TITLE,           // 2
    
                              MediaStore.Audio.Genres.Members.ALBUM_ID,  // 3
    
                              MediaStore.Audio.Genres.Members.ALBUM,           // 4
    
                              MediaStore.Audio.Genres.Members.DATA,            // 5
    
                              MediaStore.Audio.Genres.Members.DISPLAY_NAME,    // 6
    
                              MediaStore.Audio.Genres.Members.DURATION,
    
                                            MediaStore.Audio.Media.TITLE_KEY
    
                       };      // 7
    
    
    
            String selection = MediaStore.Audio.Genres.Members.IS_MUSIC + " != 0";
    
    
    
      Cursor musicListSDCardCursor = myquery(
    
                               this,
    
                               MediaStore.Audio.Genres.Members.getContentUri("external", Long.valueOf(s)),
    
                               projection, selection , null, null,0);
    
    
    
      Cursor musicListInternalMemoryCursor = myquery(
    
                               this,
    
                               MediaStore.Audio.Genres.Members.getContentUri("internal", Long.valueOf(s)),
    
                               projection, selection , null, null,0);
    
    
    
    [/java]





**Работа с плейлистами**





Получение списка всех плейлистов в устройстве:




    
    [java]String[] projection = { MediaStore.Audio.Playlists._ID,             // 0
    
                                 MediaStore.Audio.Playlists.NAME          // 1
    
                                                        };
    
    
    
                    
    
    
    
    Cursor playListSDCardCursor = myquery(
    
                               this,
    
                               MediaStore.Audio.Playlists.EXTERNAL_CONTENT_URI,
    
                               projection, null , null, MediaStore.Audio.Playlists.NAME,0);
    
    
    
    Cursor playListInternalMemoryCursor = myquery(
    
                               this,
    
                               MediaStore.Audio.Playlists.INTERNAL_CONTENT_URI,
    
                               projection, null , null, MediaStore.Audio.Playlists.NAME,0);[/java]





Создание нового плейлиста:




    
    [java]ContentValues cv = new ContentValues();
    
    cv.put(MediaStore.Audio.Playlists.NAME, "Новый плейлист");
    
    Uri uri = getContentResolver().insert(MediaStore.Audio.Playlists.getContentUri("external"), cv);[/java]





Добавление композиции в плейлист:




    
    [java]// long playlistId - MediaStore.Audio.Playlists._ID выбранного плейлиста
    
    // int audioId - MediaStore.Audio.Media._ID композиции
    
            ContentResolver resolver = getContentResolver();
    
            String[] cols = new String[] {
    
                    "count(*)"
    
            };
    
            Uri uri = MediaStore.Audio.Playlists.Members.getContentUri("external", playlistId);
    
            Cursor cur = resolver.query(uri, cols, null, null, null);
    
            cur.moveToFirst();
    
            final int base = cur.getInt(0);
    
            cur.close();
    
            ContentValues values = new ContentValues();
    
            values.put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, Integer.valueOf(base + 1));
    
            values.put(MediaStore.Audio.Playlists.Members.AUDIO_ID, audioId);
    
            resolver.insert(uri, values);[/java]





Перечисление всех композиций плейлиста:




    
    [java]// String playlistId - MediaStore.Audio.Playlists._ID выбранного плейлиста
    
    
    
    String[] projection = {         MediaStore.Audio.Media._ID,             // 0
    
                              MediaStore.Audio.Media.ARTIST,          // 1
    
                              MediaStore.Audio.Media.TITLE,           // 2
    
                              MediaStore.Audio.Media.ALBUM_ID,  // 3
    
                              MediaStore.Audio.Media.ALBUM,           // 4
    
                              MediaStore.Audio.Media.DATA,            // 5
    
                              MediaStore.Audio.Media.DISPLAY_NAME,    // 6
    
                              MediaStore.Audio.Media.DURATION,
    
                                            MediaStore.Audio.Media.TITLE_KEY
    
            };     
    
    
    
           
    
     Cursor musicListSDCardCursor = myquery(
    
                               this,
    
                               MediaStore.Audio.Playlists.Members.getContentUri("external", Long.valueOf(playlistId)),
    
                               projection, null , null, null,0);
    
    
    
      Cursor musicListInternalMemoryCursor = myquery(
    
                               this,
    
                               MediaStore.Audio.Playlists.Members.getContentUri("internal", Long.valueOf(playlistId)),
    
                               projection, null , null, null,0);
    
    [/java]





**Проигрывание аудиотрека**





Чтобы открыть mp3 файл в одном из плееров, установленных в системе, можно использовать Intents таким образом:




    
    [java]Intent it = new Intent(Intent.ACTION_VIEW);
    
     Uri uri = Uri.parse( "file:///sdcard/mymusic/happysong.mp3");
    
     it.setDataAndType(uri, "audio/mp3");
    
     startActivity(it);[/java]





Для проигрывания mp3 файлов из приложения можно использовать объект класса MediaPlayer. Класс MediaPlayer из Android SDK работает на основе модели автомата состояний ( конечного автомата, state machine ) и используется для воспроизведения аудио и видео роликов. 





После создания объекта класса MediaPlayer устанавливается путь к файлу аудиоролика на диске и вызывается метод MediaPlayer.prepare(), который инициализирует MediaPlayer и приводит его в состояние готовности к воспроизведению аудиофайла. 





После успешной инициализации MediaPlayer приложение может вызывать его методы start(), stop() и pause() для управления воспроизведением. 




    
    [java]// Общий пример воспроизведения mp3 с использованием класса MediaPlayer
    
    
    
         MediaPlayer mediaPlayer = new  MediaPlayer();
    
    
    
         
    
        try {
    
              mediaPlayer.setDataSource("/sdcard/mytracks/happysong.mp3");
    
              mediaPlayer.prepare();
    
              mediaPlayer.start();
    
    
    
            } catch (IllegalArgumentException iae) {
    
                  // TODO Auto-generated catch block
    
                  iae.printStackTrace();
    
     
    
            } catch (IllegalStateException ise) {
    
                 // TODO Auto-generated catch block
    
                 ise.printStackTrace();
    
    
    
            } catch (IOException ioe) {
    
                 // TODO Auto-generated catch block
    
                 ioe.printStackTrace();
    
            } catch (Exception e) {
    
                 // TODO Auto-generated catch block
    
                 e.printStackTrace();
    
            }
    
    
    
    [/java]





Подробнее об использовании класса MediaPlayer можно посмотреть на сайте разработчиков [http://developer.android.com/reference/android/media/MediaPlayer.html](http://developer.android.com/reference/android/media/MediaPlayer.html).





**Пример - проигрывание случайной дорожки**





Программа открывает в проигрывателе случайно выбранный mp3 файл.




    
    [java]package org.me.androidrandomplay;
    
    
    
    import android.app.Activity;
    
    import android.os.Bundle;
    
    import android.content.*;
    
    import android.database.Cursor;
    
    import android.net.Uri;
    
    import  android.provider.MediaStore;
    
    import android.widget.Toast;
    
    
    
    public class AndroidRandomPlay extends Activity {
    
    
    
        /** Called when the activity is first created. */
    
        @Override
    
        public void onCreate(Bundle icicle) {
    
            super.onCreate(icicle);
    
    
    
    
    
            String[] projection = { 
    
                                    MediaStore.Audio.Media._ID,
    
                                    MediaStore.Audio.Media.DATA
    
                                  };  
    
    
    
            String selection = MediaStore.Audio.Media.IS_MUSIC + " != 0 ";
    
            Cursor musicListSDCardCursor = myquery(
    
                                       this,
    
                                       MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,
    
                                       projection, selection , null, null,0);
    
            Cursor musicListInternalMemoryCursor = myquery(
    
                                       this,
    
                                       MediaStore.Audio.Media.INTERNAL_CONTENT_URI,
    
                                       projection, selection , null, null,0);
    
    
    
            java.util.Vector&lt;String&gt; paths = new java.util.Vector();
    
    
    
            if( musicListSDCardCursor!= null )
    
            {
    
                for(int i=0;i&lt;musicListSDCardCursor.getCount();i++)
    
                {
    
                    musicListSDCardCursor.moveToPosition(i);
    
                    String p = musicListSDCardCursor.getString(1);
    
                    if(p.endsWith("mp3"))
    
                            paths.addElement(p);
    
    
    
                }
    
                musicListSDCardCursor.close();
    
            }
    
    
    
             if( musicListInternalMemoryCursor!= null )
    
            {
    
                for(int i=0;i&lt;musicListInternalMemoryCursor.getCount();i++)
    
                {
    
                    musicListInternalMemoryCursor.moveToPosition(i);
    
                    String p = musicListInternalMemoryCursor.getString(1);
    
                    if(p.endsWith("mp3"))
    
                            paths.addElement(p);
    
    
    
                }
    
                musicListInternalMemoryCursor.close();
    
            }
    
    
    
            if( paths.isEmpty() ) 
    
            {
    
                Toast.makeText( this, "no media found", Toast.LENGTH_LONG).show();   
    
                return;
    
            }
    
    
    
            java.util.Random r = new  java.util.Random();
    
            int pos = r.nextInt(paths.size()-1);
    
            if( paths.size() == 1 ) pos = 0;
    
    
    
            String url  = paths.elementAt(pos);
    
    
    
            if( url.length() == 0 ) return;
    
    
    
            Toast.makeText( this, url, Toast.LENGTH_LONG).show();
    
    
    
            try{
    
    
    
                Intent it = new Intent(Intent.ACTION_VIEW);
    
                Uri uri = Uri.parse( "file://"+url);
    
                it.setDataAndType(uri, "audio/mp3");
    
                startActivity(it);
    
          
    
            }catch (Exception e)
    
            {
    
                Toast.makeText( this, e.toString(), Toast.LENGTH_LONG).show();
    
            }
    
        }
    
    
    
        public static Cursor myquery(Context context, Uri uri, String[] projection,
    
                 String selection, String[] selectionArgs, String sortOrder, int limit) {
    
                 try {
    
                       ContentResolver resolver = context.getContentResolver();
    
                       if (resolver == null) {
    
                            return null;
    
                       }
    
                        if (limit &gt; 0) {
    
                            uri = uri.buildUpon().appendQueryParameter("limit", "" + limit).build();
    
                         }
    
                      return resolver.query(uri, projection, selection, selectionArgs, sortOrder);
    
                    } catch (UnsupportedOperationException ex) {
    
                                return null;
    
                     }
    
                  }
    
    
    
    }[/java]
Добрый день друзья.





Продолжаю собирать важную информацию по программированию под android.





Сегодня речь пойдет о SOAP и REST запросах.


 <!-- more -->


Одной из задач, часто решаемых разработчиками мобильного софта, является получение данных от удаленного **web сервиса**. Этот процесс включает в себя несколько этапов: отправка запрос web-сервису, получение ответа и парсинг ответа с целью получения данных. В Android нет встроенного SOAP клиента, однако существует несколько довольно неплохих сторонних библиотек. Мы не будем пользоваться чужими поделками, а разработаем собственный клиент на базе Android API.  
  
_**SOAP **(Simple Object Access Protocol) это основанный на XML протокол, предназначенный для обмена данными между распределенными приложениями.  **REST **(Representational State Transfer)- архитектура позволяющая строить распределенные, масштабируемые приложения. Основная задача сервера в этой архитектуре предоставить клиентам доступ к ресурсам по их идентификаторам (URI). Под доступом подразумевается как получение информации, так и ее изменение. SOAP и REST строятся поверх существующих web протоколов, например HTTP. Я не буду здесь вдаваться в детали, если Вы не знакомы с темой, рекомендую посмотреть вот эту [статью](http://habrahabr.ru/blogs/webdev/131343/)._  
  






### Формат запроса для SOAP сервису





Прежде чем переходить к написанию кода, давайте посмотрим на структуру SOAP.





![](http://android-helper.com.ua/images/uploads/2012/10/soap_structure.png)





Обычный** SOAP запрос** выглядит так:




	POST /InStock HTTP/1.1

	Host: www.example.org

	Content-Type: application/soap+xml; charset=utf-8

	Content-Length: length

	SOAPAction: "http://www.w3schools.com/GetItems"

 

	<?xml version="1.0"?>

	<soap:Envelope

	xmlns:soap="http://www.w3.org/2001/12/soap-envelope"

	soap:encodingStyle="http://www.w3.org/2001/12/soap-encoding">

	<soap:Header>

  	<m:Trans xmlns:m="http://www.w3schools.com/transaction/"

  	soap:mustUnderstand="1">234

	  </m:Trans>

	</soap:Header>

	<soap:Body>

  	<m:GetPrice xmlns:m="http://www.w3schools.com/prices">

    	<m:Item>Apples</m:Item>

	  </m:GetPrice>

	</soap:Body></soap:Envelope>




То есть SOAP запрос/ответ передается как пакет (SOAP Envelope), состоящий из заголовка (SOAP Header) и тела (SOAP Body).**SOAP Header** - вспомогательный  компонент, содержащий конфиденциальную информацию для приложения, например параметры  аутентификации. **SOAP Body** - это сообщение с полезной информацией. Заголовок может также содержать** SOAP Action**, который определяет функцию, запрашиваемую сервисом.  
  






### Отправка запроса SOAP-сервису





Чтобы вызвать SOAP-сервис вы должны сделать две вещи:  
**Во-первых**, вручную сконструировать SOAP пакет, например вот так:




	String envelope="<?xml version=\"1.0\" encoding=\"utf-8\"?>"+

	"<soap:Envelope xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\"xmlns:soap=\"http://schemas.xmlsoap.org/soap/envelope/\">"+

  	"<soap:Body>"+

    "<GetItems xmlns=\"http://tempuri.org/\">"+

      "<startDate>%s</ startDate>"+

      "<getAll>%s</getAll>"+

    "</Items>"+

  	"</soap:Body>"+

	"</soap:Envelope>";




где %s метка формата. С помощью метода String.format на ее место  будет подставляться конкретное значение.


	String requestEnvelope=String.format(envelope, "10-5-2011","true");



**Во-вторых**, вызвать web-сервис, например так:

	String CallWebService(String url,

    String soapAction,

   	String envelope)  {

  	final DefaultHttpClient httpClient=new DefaultHttpClient();

	  // параметры запроса

	  HttpParams params = httpClient.getParams();

     HttpConnectionParams.setConnectionTimeout(params, 10000);

     HttpConnectionParams.setSoTimeout(params, 15000);

     // устанавливаем параметры

  	HttpProtocolParams.setUseExpectContinue(httpClient.getParams(), true);

 

  	// С помощью метода POST отправляем конверт

  	HttpPost httppost = new HttpPost(url);

  	// и заголовки

     httppost.setHeader("soapaction", soapAction);

     httppost.setHeader("Content-Type", "text/xml; charset=utf-8");

 

     String responseString="";

     try {

 

      // выполняем запрос

   	HttpEntity entity = new StringEntity(envelope);

   	httppost.setEntity(entity);

 

   	// Заголоаок запроса

   	ResponseHandler<string> rh=new ResponseHandler<string>() {

    // вызывается, когда клиент пришлет ответ

    public String handleResponse(HttpResponse response)

      throws ClientProtocolException, IOException {

 

     // получаем ответ

     HttpEntity entity = response.getEntity();

 

     // читаем его в массив

           StringBuffer out = new StringBuffer();

           byte[] b = EntityUtils.toByteArray(entity);

 

           // write the response byte array to a string buffer

           out.append(new String(b, 0, b.length));

           return out.toString();

    }

   	};

 

   	responseString=httpClient.execute(httppost, rh); 

 

  	}

     catch (Exception e) {

      Log.v("exception", e.toString());

  	}

 

     // закрываем соединение

  	httpClient.getConnectionManager().shutdown();

  	return responseString;

 		}




После вызова этой функции Вы получите ответ, который будет выглядеть как-то так:


	<?xml version="1.0" encoding="utf-8"?>

	<soap:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">

  	<soap:Body>

    	<GetItemsResponse xmlns="http://tempuri.org/">

     	 <GetItemsResult>



        <Items>

          <Item>

            <name>string</name>

            <description>string</ description >

          </iPhoneCategory>

          <iPhoneCategory>

            <name>string</name>

            <description>string</ description >

          </ Item >

        </Items>

      	</GetItemsResult>

    	</ GetItemsResponse >

  	</soap:Body>

	</soap:Envelope>


Этот ответ нужно разобрать XML парсером и извлечь нужные данные.  
  






### Отправка запроса REST-сервису





Расбота с REST-сервисом намного проще. Вы должны вызвать сервис, передав ему URL с параметрами, например вот так:  
  
	http://example.com/resources/getitems  
  
Пример вызова REST сервиса:


	String callWebErvice(String serviceURL){

        // http get client

            HttpClient client=new DefaultHttpClient();

            HttpGet getRequest=new HttpGet();

 

            try {

                // создаем a URI объект

                getRequest.setURI(new URI(serviceURL));

            } catch (URISyntaxException e) {

                Log.e("URISyntaxException", e.toString());

            }

 

            // Создаем BufferedReader дял чтения ответа

            BufferedReader in=null;

            // и HttpResponse для получения ответа

            HttpResponse response=null;

            try {

                // выполняем запрос

                response = client.execute(getRequest);

            } catch (ClientProtocolException e) {

                Log.e("ClientProtocolException", e.toString());

            } catch (IOException e) {

                Log.e("IO exception", e.toString());

            }

            try {

                in=new BufferedReader(new InputStreamReader(response.getEntity().getContent()));

            } catch (IllegalStateException e) {

                Log.e("IllegalStateException", e.toString());

            } catch (IOException e) {

                Log.e("IO exception", e.toString());

            }

            StringBuffer buff=new StringBuffer("");

            String line="";

            try {

                while((line=in.readLine())!=null)

                {

                    buff.append(line);

                }

            } catch (IOException e) {

                Log.e("IO exception", e.toString());

                return e.getMessage();

            }

 

            try {

                in.close();

            } catch (IOException e) {

                Log.e("IO exception", e.toString());

            }

            // возвращаем ответ в виде строки текста

            return buff.toString();

    }




Соединение с web-сервисом по протоколу Secure Sockets Layer (SSL)  
  
HttpClinet не поддерживает SSL соединения, поэтому если Вам необходимо работать с защищенным web-сервисом, то используйте  javax.net.ssl.HttpsURLConnection. Ниже приведен пример, иллюстрирующий работу с SSL SOAP web-сервисом.


	String CallWebService(String url,

             String soapAction,

            String envelope) throws IOException  {

        URL address=new URL(url);

        URLConnection connection=address.openConnection();

        HttpsURLConnection post=(HttpsURLConnection)connection;

        post.setDoInput(true);

        post.setDoOutput(true);

        post.setRequestMethod("POST");

        post.setRequestProperty("SOAPAction", soapAction);

        post.setRequestProperty( "Content-type", "text/xml; charset=utf-8" );

        post.setRequestProperty( "Content-Length", String.valueOf(envelope.length()));

        post.setReadTimeout(4000);

 

        OutputStream outStream=post.getOutputStream();

        Writer out=new OutputStreamWriter(outStream);

        out.write(envelope);

        out.flush();

        out.close();

 

        InputStream inStream = post.getInputStream();

        BufferedInputStream in = new BufferedInputStream(inStream,4);

        StringBuffer buffer=new StringBuffer();

        // читаем за раз 4 байта

        byte[] buffArray=new byte[4];

        int c=0;

            while((c=in.read(buffArray))!=-1){

                for(int i=0;i<c;i++)

                    buffer.append((char)buffArray[i]);

            }

 

            return buffer.toString();

    }


Итак, мы отправили запрос web-сервису и получили ответ в виде строки. Настало время использовать парсер.  
  






### Использование парсера в Android





В зависимости от реализации сервиса в ответ на наш запрос может прийти ответ в формате XML, SOAP или JSON.  
  






#### Программирование XML парсера в Android





Рассмотрим конкретный пример. Допустим, нам пришел XML ответ, содержащий имя, фамилию и возраст пользователя:


	<?xml version="1.0"?>

	<person>

    <firstname>Jack</firstname>

    <lastname>smith</lastname>

    <age>28</age>

	</person>





С помощью этих параметров нужно создать объект класса Person:




	public class Person{

        public String firstName;

        public String lastName;

        public int age;

    }


### Использование DOM Parser





В библиотека **org.w3c.dom** можно найти классы, с помощью которых можно разобрать xml, создав документ и сравнив каждый узел с шаблоном. Приведенная ниже функция использует DOM парсер:



	void parseByDOM(String response) throws 	ParserConfigurationException, SAXException, IOException{

        Person person=new Person();

        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();

        DocumentBuilder db = dbf.newDocumentBuilder();

        Document doc = db.parse(new InputSource(new StringReader(response)));

        // нормализируем документ

        doc.getDocumentElement().normalize();

        // получаем корневой узел

        NodeList nodeList = doc.getElementsByTagName("person");

        Node node=nodeList.item(0);

        // узел имеет три дочерних узла

        for (int i = 0; i < node.getChildNodes().getLength(); i++) {

        Node temp=node.getChildNodes().item(i);

        if(temp.getNodeName().equalsIgnoreCase("firstname")){

            person.firstName=temp.getTextContent();

        }

        else if(temp.getNodeName().equalsIgnoreCase("lastname")){

            person.lastName=temp.getTextContent();

        }

        else if(temp.getNodeName().equalsIgnoreCase("age")){

            person.age=Integer.parseInt(temp.getTextContent());

        }

 

        }

 

        Log.e("person", person.firstName+ " "+person.lastName+" "+String.valueOf(person.age));

    }




Показаный метод работает, однако для его использования нужно знать структуру разбираемого xml и порядок перечисления узлов. Более гибок в этом плане SAX парсер.  
 





###  Использование SAX Parser





SAX Parser находится в пакете **org.xml.sax**. В процессе разбора документа SAX генерирует события, для которых программист должен написать обработчики. Создадим класс-потомок основе класса **DefaultHandler **и переопределим следующие методы:  
 








  * **startDocument()**: Этот метод вызывается при открытии XML документа.



  * **startElement(String uri, String localName, String qName, Attributes attributes)**: вызывается, когда парсер встречает XML-узел.



  * **endElement(String uri, String localName, String Name)**: вызывается, когда парсер считал закрывающий тег.



  * **characters(char[] ch, int start, int length)**: этот метод вызывается, когда парсер считывает данные из узла.






Напишем класс для парсинга нашего примера





	public class PersonParser extends DefaultHandler

	{

 

    // arraylist для сохранения объектов persons

    ArrayList persons;

    // вспомогательный объект

    Person tempPerson;

    // буфер

    StringBuilder builder;

 

    /**

     * Инициализируем arraylist

     * @throws SAXException

     */

    @Override

    public void startDocument() throws SAXException {

        pesons=new ArrayList();

 

    }

 

    /**

     * Инициализируем вспомогательный объект и буфер 

     * @param uri

     * @param localName

     * @param qName

     * @param attributes

     * @throws SAXException

     */

    @Override

    public void startElement(String uri, String localName, String qName,

            Attributes attributes) throws SAXException {

 

        if(localName.equalsIgnoreCase.equals("person")){

            tempPerson=new Person();

            builder=new StringBuilder();

        }

 

    }

    /**

     * Завершение чтения тега person и

     * добавление данных в arraylist

     * @param uri

     * @param localName

     * @param qName

     * @throws SAXException

     */

    @Override

    public void endElement(String uri, String localName, String qName)

            throws SAXException {

        // закончилось чтение person, добавим собранные данные в массив

        if(localName.toLowerCase().equals("person"))

        {

            this.persons.add(tempPerson);

        }

        // закончилось чтение  "firstname", добавим эти данные во вспомогательный объект

        else if(localName.toLowerCase().equals("firstname")){

            tempPerson.firstName=builder.toString();

        }

        // закончилось чтение  "lastname", добавим эти данные во вспомогательный объект

        else if(localName.toLowerCase().equals("lastname")){

            tempPerson.lastName=builder.toString();

        }

        // закончилось чтение  "age", добавим эти данные во вспомогательный объект

        else if(localName.toLowerCase().equals("age")){

            tempPerson.age=Integer.parseInt(builder.toString());

        }

    }

 

    /**

     * Считываем данные из каждого тега

     * @param ch

     * @param start

     * @param length

     * @throws SAXException

     */

    @Override

    public void characters(char[] ch, int start, int length)

            throws SAXException {

        // читаем символы в буфер

        String tempString=new String(ch, start, length);

         builder.append(tempString);

    }

	}



Код довольно прост. Парсер проходится по всем узлам, и в зависимости от считанного тега, вы выполняете то или иное действие. Используем этот класс:


	public ArrayList getPersons(final String response) throws 

	ParserConfigurationException, SAXException, IOException

    {

        BufferedReader br=new BufferedReader(new StringReader(response));

        InputSource is=new InputSource(br);

        PersonParser parser=new PersonParser();

        SAXParserFactory factory=SAXParserFactory.newInstance();

           SAXParser sp=factory.newSAXParser();

           XMLReader reader=sp.getXMLReader();

           reader.setContentHandler(parser);

           reader.parse(is);

           ArrayList persons=parser.persons;

 

        return persons;

 

    }




### Программирование JSON парсера в Android





Некоторые сервисы могут вернуть ответ не в виде XML, а как JSON массив:



	"persons"

	[

	{

		"person"{

			"firstName": "John",

     	"lastName": "Smith",

    	"age": 25

		}

	}

	{

		"person"{

			"firstName": "Catherine",

     	"lastName": "Jones",

     	"age": 35

		}

	}

	]





Здесь мы видим JSON массив persons, содержащий несколько JSON объектов person. На самом деле, работать с JSON намного проще, чем с XML:

	public ArrayList<Person> getMessage(String response){

        JSONObject jsonResponse;

        ArrayList<Person> arrPersons=new ArrayList<Person>;

        try {

            // получаем ответ

            jsonResponse = new JSONObject(response);

            // получаем массив

            JSONArray persons=jsonResponse.optJSONArray("persons");

            // проходимся по массиву и извлекаем персоны

            for(int i=0;i<persons.length();i++){

                // получаем объект person

                JSONObject person=persons.getJSONObject(i);

                // получаем firstname

                String firstname=person.optString("firstname");

                // получаем lastname

                String lastname=person.optString("lastname");

                // получаем age

                int age=person.optInt("age");

 

                // создаем объект и добавляем его в массив

                Person p=new Person();

                p.firstName=firstname;

                p.lastName=lastname;

                p.age=age;

                arrPersons.add(p);

            }

 

        } catch (JSONException e) {

 

            e.printStackTrace();

        }

 

        return arrPersons;

    }    



Обратите внимание, здесь мы использовали методы optJSONArray, optString, optInt вместо getString, getInt, поскольку opt-методы эти методы возвращают пустую строку или 0, если какой-то элемент не найден, в то время как get-методы генерируют исключения.





Источник статьи [mobilab.ru](http://www.mobilab.ru/androiddev/androidwebserviceclient.html)
Столкнулся с необходимостью распознавать речь на android устройстве.





Долго собирал крупицы информации, пока не нашел хорошею и полною статью





Прошу к прочтению.


<!-- more -->


Последнее время большой интерес у пользователей вызывает возможность распознавания речи в телефонах. Огромная заслуга в популяризации этого направления принадлежит компании Aple, однако Google также располагает подобными технологиями. Собственно этой теме и будет посвящена данная статья. Мы разработаем приложение, которое будет распознавать речь пользователя и воспроизводить результат с помощью голосового движка "Text To Speech" (TTS). Отметим, что распознавание происходит на серверах Google, поэтому для работы приложению необходимо разрешить использовать коммуникационные возможности. Кроме того, распознавание речи не работает на эмуляторе. Тестировать программу необходимо на реальном устройстве.





На самом деле работать с распознаванием и синтезом речи в Android очень просто. Все сложные вычисления скрыты от нас в довольно элегантную библиотеку с простым API. Вы сможете осилить этот урок, даже если имеете весьма поверхностные знания о программировании для Android.





Давайте создадим новый проект в Eclipse. Для наших нужд понадобится версия SDK не меньше 8. Опишем в общих чертах создаваемую программу. При запуске приложения пользователю будет показана кнопка, после нажатия на которую пользователю будет предложено надиктовать фразу. Затем будет осуществлено распознавание и будет показан список возможных вариантов. Поскольку технологии распознавания речи далеки от совершенства, программа не может ручаться за точность результата, именно поэтому будет предложено несколько вариантов. После того, как пользователь выберет один из них, будет запущен генератор голоса, который воспроизведет выбранную фразу. 





Нам понадобится несколько текстовых строк, объявим их в фале "res/values/strings.xml"





	<resources>

    <string name="intro">Press the button to speak!</string>

    <string name="app_name">SpeechRepeat</string>

    <string name="speech">Speak now!</string>

    <string name="word_intro">Suggested words&#8230;</string>

	</resources>







Откроем файл "res/layout/main.xml" и зададим шаблон дизайна приложения. Для этого переключимся из графического в XML редактор и изменим содержимое файла





	<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"

    android:layout_width="fill_parent"

    android:layout_height="fill_parent"

    android:orientation="vertical"

    android:background="#ff330066"

    android:paddingBottom="5dp" >

 

	</LinearLayout>







Добавим в Linear Layout элемент Text View






	<TextView android:layout_width="fill_parent"

    android:layout_height="wrap_content"

    android:text="@string/intro"

    android:padding="5dp"

    android:textStyle="bold"

    android:textSize="16dp"

    android:gravity="center"

    android:textColor="#ffffff33" />







обратите внимание, TextView ссылается на строку intro, которую мы задали в файле strings.xml. 





После Text View добавим кнопку





	<Button android:id="@+id/speech_btn"

    android:layout_width="match_parent"

    android:layout_height="wrap_content"

    android:text="@string/speech" />








Пользователь будет нажимать эту кнопку, чтобы начать говорить. Кнопка имеет параметр id, через который ее можно вызвать из Java кода. После нажатия на кнопку пользователю показывается сообщение. Нам также понадобится TextView для вывода слов с предложениями






	<TextView android:layout_width="fill_parent"

    android:layout_height="wrap_content"

    android:padding="5dp"

    android:text="@string/word_intro"

    android:textStyle="italic" />






TextView будет использовать строковый ресурс. Нам также понадобится список для вариантов слов







	<ListView android:id="@+id/word_list"

    android:layout_width="fill_parent"

    android:layout_height="0dip"

    android:layout_weight="1"

    android:paddingLeft="10dp"

    android:paddingTop="3dp"

    android:paddingRight="10dp"

    android:paddingBottom="3dp"

    android:layout_marginLeft="20dp"

    android:layout_marginRight="20dp"

    android:layout_marginTop="5dp"

    android:layout_marginBottom="5dp"

    android:background="@drawable/words_bg" />







ListView будет заполняться данными в процессе работы программы, поэтому для доступа к этому компоненту также требуется ID. Обратите также внимание на наличие ресурса drawable. Вы должны сохранить файл words_bg.xml в папке res




	<shape xmlns:android="http://schemas.android.com/apk/res/android"

    android:dither="true">

    <gradient

    android:startColor="#ff000000"

    android:endColor="#ff000000"

    android:centerColor="#00000000"

    android:angle="180" />

    <corners android:radius="10dp" />

    <stroke

    android:width="2dp"

    android:color="#66ffffff" />

	</shape> 







Ничего особенного. Вы можете настроить дизайн ListView по своему усмотрению. Нам осталось задать еще один элемент пользовательского интерфейса - шаблон для элемента ListView. Создайте новый файл res/layout/word.xml со следующим содержанием





	<TextView xmlns:android="http://schemas.android.com/apk/res/android"

    android:layout_width="fill_parent"

    android:layout_height="fill_parent"

    android:gravity="center"

    android:padding="5dp"

    android:textColor="#ffffffff"

    android:textSize="16dp" >

	</TextView>







Таким образом, каждый элемент списка представляет собой просто Text View.





Если Вы все сделали правильно, то при запуске должно получиться следующее





![](http://android-helper.com.ua/images/uploads/2012/10/speechsample1.jpg)




### Программируем распознавание речи в Android





После того, как шаблон будущего приложения создан, можно перейти к кодированию. Откройте java файл главной Activity и добавьте в начало файла





	import java.util.ArrayList;

	import java.util.List;

	import java.util.Locale;

 

	import android.app.Activity;

	import android.content.Intent;

	import android.content.pm.PackageManager;

	import android.content.pm.ResolveInfo;

	import android.os.Bundle;

	import android.speech.RecognizerIntent;

	import android.speech.tts.TextToSpeech.OnInitListener;

	import android.speech.tts.TextToSpeech;

	import android.util.Log;

	import android.view.View;

	import android.view.View.OnClickListener;

	import android.widget.AdapterView;

	import android.widget.AdapterView.OnItemClickListener;

	import android.widget.ArrayAdapter;

	import android.widget.Button;

	import android.widget.ListView;

	import android.widget.Toast;

	import android.widget.TextView;






Изменим немного декларацию главного класса






	public class SpeechRepeatActivity extends Activity implements OnClickListener, OnInitListener {





OnInitListener необходим для работы TTS движка. Внутри класса добавим объявления переменных перед методом onCreate







	//переменная для проверки возможности

	//распознавания голоса в телефоне

	private static final int VR_REQUEST = 999;

 

	//ListView для отображения распознанных слов

	private ListView wordList;

 

	//Log для вывода вспомогательной информации

	private final String LOG_TAG = "SpeechRepeatActivity";

	//***здесь можно использовать собственный тег***

 

	//переменные для работы TTS 

 

	//переменная для проверки данных для TTS 

	private int MY_DATA_CHECK_CODE = 0;

 

	//Text To Speech интерфейс

	private TextToSpeech repeatTTS;



Внутри метода onCreate автоматически сгенерирован код, вызывающий метод родительского класса и устанавливающий главный контекст вывода.




	//вызов суперкласса

	super.onCreate(savedInstanceState);

	//установка контекста вывода

	setContentView(R.layout.main);








Cоздадим переменные для работы с кнопкой и списком распознанных слов



	Button speechBtn = (Button) findViewById(R.id.speech_btn);

	wordList = (ListView) findViewById(R.id.word_list);








Далее необходимо проверить поддерживается ли возможность распознавания голоса телефоном


	//проверяем, поддерживается ли распознование речи

	PackageManager packManager = getPackageManager();

	List<ResolveInfo> intActivities = packManager.queryIntentActivities(new 

        Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH), 0);

	if (intActivities.size() != 0) {

    // распознавание поддерживается, будем отслеживать событие щелчка по кнопке

    speechBtn.setOnClickListener(this);

	}

	else

	{

    // распознавание не работает. Заблокируем 

    // кнопку и выведем соответствующее 

    // предупреждение.

    speechBtn.setEnabled(false);

    Toast.makeText(this, "Oops - Speech recognition not supported!", Toast.LENGTH_LONG).show();

	}








Мы запрашиваем среду, поддерживается ли Recognizer Intent. Если поддерживается, мы говорим приложению, что нужно отслеживать щелчок пользователя по кнопке. Если интент не поддерживается, мы блокируем кнопку и выводим соответствующее сообщение пользователю.





Напишем код, обрабатывающий нажатие на кнопку. Внутри класса после метода OnCreate добавим метод OnClick.






	public void onClick(View v) {

    if (v.getId() == R.id.speech_btn) {

        // отслеживаем результат

        listenToSpeech();

    }

	}







Как видите, при нажатии на кнопку мы вызываем метод listenToSpeech().



	private void listenToSpeech() {

 

    //запускаем интент, распознающий речь и передаем ему требуемые данные

    Intent listenIntent = new Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH);

    //указываем пакет

 	listenIntent.putExtra(RecognizerIntent.EXTRA_CALLING_PACKAGE, 

           getClass().getPackage().getName());

    //В процессе распознования выводим сообщение

    listenIntent.putExtra(RecognizerIntent.EXTRA_PROMPT, "Say a word!");

    //устанавливаем модель речи

    	listenIntent.putExtra(RecognizerIntent.EXTRA_LANGUAGE_MODEL, 

            RecognizerIntent.LANGUAGE_MODEL_FREE_FORM);

    //указываем число результатов, которые могут быть получены

    listenIntent.putExtra(RecognizerIntent.EXTRA_MAX_RESULTS, 10);

 

    //начинаем прослушивание

    startActivityForResult(listenIntent, VR_REQUEST);

	}





Большая часть приведенного кода стандартна для программ, использующих распознавание голоса. Обратите внимание на параметр EXTRA_PROMPT. Он задает строку-приглашение для пользователя. Параметр EXTRA_MAX_RESULTS определяет максимальное число вариантов распознавания. В конце концов, мы вызываем startActivityForResult. Результат его работы будет передан в метод onActivityResult.





На следующем скриншоте показан экран в момент распознавания речи.





![](http://android-helper.com.ua/images/uploads/2012/10/speechsample2.jpg)





Определим метод onActivityResult



	@Override

	protected void onActivityResult(int requestCode, int resultCode, Intent data) {

    //проверяем результат распознавания речи

    if (requestCode == VR_REQUEST && resultCode == RESULT_OK)

    {

        //Добавляем распознанные слова в список результатов

        ArrayList<String> suggestedWords = 

                 data.getStringArrayListExtra(RecognizerIntent.EXTRA_RESULTS);

        //Передаем список возможных слов через ArrayAdapter компоненту ListView  

        wordList.setAdapter(new ArrayAdapter<String> (this, R.layout.word, suggestedWords));

    }

 

    //tss код здесь

 

    //вызываем метод родительского класса

    super.onActivityResult(requestCode, resultCode, data);

	}





Обратите внимание, при проверке результата мы сравниваем переменную requestCode с константой VR_REQUEST, которую использовали ранее при вызове метода startActivityForResult. Таким образом, мы рассматриваем только результаты от нашего запроса. В метод возвращается 10 вариантов распознанных слов, которые мы записываем в список ArrayList. Этот список мы используем в ArrayAdapter компонента List View. 





Если приложение справилось с задачей и смогло что-то распознать, вы увидите похожий н показанный на левом скриншоте результат. Если приложению не удалось распознать фразу, будет показано сообщение, как на правом скриншоте





![](http://android-helper.com.ua/images/uploads/2012/10/speechsample3.jpg)
![](http://android-helper.com.ua/images/uploads/2012/10/speechsample4.jpg)



Вот, собственно и все. Распознавание голоса в Android - довольно простая задача. Мы вызываем интент RecognizerIntent с требуемыми нами параметрами. Результат  возвращается в onActivityResult.





### Генерация речи в Android





Перейдем ко второй части нашего приложения, связанного с генерацией речи. Мы хотим, чтобы телефон проговаривал фразу из списка результатов. Мы должны определить строку, на которую щелкнул пользователь. Вернемся к методу onCreate и добавим в конец этого метода код




	//засекаем щелчок пользователя по слову из списка

	wordList.setOnItemClickListener(new OnItemClickListener() {

 

    //метод вызывается в ответ на щелчок по слову

    public void onItemClick(AdapterView<?> parent, View view, int position, long id)

    {

        //записываем в переменную TextView строки

        TextView wordView = (TextView)view;

        //получаем строку с текстом

        String wordChosen = (String) wordView.getText();

        //выводим ее в лог для отладки

        Log.v(LOG_TAG, "chosen: "+wordChosen);

        //выводим Toast сообщение

        Toast.makeText(SpeechRepeatActivity.this, "You said: "+wordChosen, 

                Toast.LENGTH_SHORT).show();

    }

	});





Мы используем метод setOnItemClickListener чтобы установить отслеживание щелчков для каждой строки. Внутри нового объекта OnItemClickListener мы описали метод onItemClick, который вызывается в ответ на щелчок по строке списка. Выбранная строка передается, как View в этот метод. Поскольку при проектировании шаблона приложения мы указали, что наш список состоит из TextView, мы преобразуем полученное значение в объект TextView и достаем из него строковое значение. Мы записываем это слово в лог и показываем пользователю Toast сообщение.





Если Вас не интересует процесс генерации речи, Вы можете остановиться и протестировать приложение. 





Для генерации речи необходимо настроить движок TTS. Добавим код в конец метода onCreate



	//подготовка движка TTS для проговаривания слов

	Intent checkTTSIntent = new Intent(); 

	//проверка наличия TTS 

	checkTTSIntent.setAction(TextToSpeech.Engine.ACTION_CHECK_TTS_DATA); 

	//запуск checkTTSIntent интента

	startActivityForResult(checkTTSIntent, MY_DATA_CHECK_CODE); 





Как и в случае распознавания, результат интента возвращается в метод onActivityResult. В этом методе перед строкой super.onActivityResult(requestCode, resultCode, data); добавьте





	//returned from TTS data check

	if (requestCode == MY_DATA_CHECK_CODE)

	{ 

    //все необходимые приложения установлены, создаем TTS 

    if (resultCode == TextToSpeech.Engine.CHECK_VOICE_DATA_PASS) 

        repeatTTS = new TextToSpeech(this, this); 

    //движок не установлен, предположим пользователю установить его

    else

    { 

        //интент, перебрасывающий пользователя на страницу TSS в Google Play

        Intent installTTSIntent = new Intent(); 

        installTTSIntent.setAction(TextToSpeech.Engine.ACTION_INSTALL_TTS_DATA); 

        startActivity(installTTSIntent); 

    } 

	}






Таким образом, мы проверяем наличие TTS движка, и если он не установлен - предлагаем пользователю установить соответствующую программу. 





Чтобы завершить настройку TTS, добавим метод onInit, который вызывается при успешной инициализации TTS.







	public void onInit(int initStatus) {

    if (initStatus == TextToSpeech.SUCCESS)  

        repeatTTS.setLanguage(Locale.UK); //Язык

	}







Здесь мы устанавливаем язык генератора речи.





Для того, чтобы заставить движок проговорить строку, нужно вызвать метод repeatTTS.speak. Вернемся к методу onCreate. Внутри метода onItemClick после строки Toast.makeText(SpeechRepeatActivity.this, "You said: "+wordChosen, Toast.LENGTH_SHORT).show(); добавьте следующий код






	repeatTTS.speak("You said: "+wordChosen, TextToSpeech.QUEUE_FLUSH, null);




Таким образом, одновременно с Toast сообщением пользователь услышит сгенерированную речь. Отметим еще раз, что эмулятор не поддерживает распознавание речи, поэтому тестировать программу необходимо на телефоне.





Полный проект вы можете скачать на [странице с кодами](http://android-helper.com.ua/codes/).





Статья взята из сайта [mobilab.ru](http://www.mobilab.ru/androiddev/androidspeechrecognition.html)
Добрый день друзья.





Много уже работал с базами данных.





Но ни как не мог подготовить статью на эту тему.





Сегодня я ее нашел хорошею статью. И покажу ее вам.

<!-- more -->



По умолчанию в Android используется база данных SQLite - это довольно популярная, легкая и быстрая реляционная база данных. Если для вас SQL – это пустой звук, то, скорее всего, вы мало что поймете из этой статьи. Предполагается, что читатель знаком с SQL, знает что такое запросы выборки, триггеры и представления. Если это не так - почитайте какое-нибудь введение в SQL, а потом возвращайтесь сюда.  
  
База данных SQLite  имеет некоторые особенности, о которых нужно помнить:








  * Не поддерживается проверка типов данных. Это значит, что Вы случайно сможете записать данные не того типа, например поместить строку в колонку, предназначенную для целых чисел.



  * Не поддерживается ссылочная целостность:  нет поддержки FOREIGN KEY и конструкций JOIN.



  * Полная поддержка Unicode отключена по умолчанию.






  
Давайте создадим простую базу данных, содержащую информацию о работниках. База содержит две таблицы:  Employees - для хранения данных о сотрудниках и Dept - о департаментах. И представление ViewEmps, связывающее работников с департаментами.





![](http://android-helper.com.ua/images/uploads/2012/10/android_db_sql.jpg)




## Создание SQLite базы данных в Android проекте





По умолчанию, Android не содержит удобных СУБД для создания и работы с базами данных (есть sqlite3.exe - консоль для работы с базой данных), поэтому давайте создадим базу и все необходимые таблицы непосредственно из кода.   
  
Во-первых, мы напишем класс, который будет управлять всеми операциями с базой данных: созданием базы, созданием таблиц, вставкой и удалением записей. Давайте создадим класс потомок от **SQLiteOpenHelper**. Нам нужно переопределить два метода:








  * onCreate(SQLiteDatabase db) - вызывается при создании базы данных. Здесь мы можем создать таблицы, определить в них колонки, создать виды и триггеры.



  * onUpgrade(SQLiteDatabse db, int oldVersion, int newVersion) - вызывается, при внесении изменений в базу, например при создании и удалении таблиц






  
Внутри нашего класса определим переменные





	public class DatabaseHelper extends SQLiteOpenHelper {

 

 	static final String dbName="demoDB";

 	static final String employeeTable="Employees";

 	static final String colID="EmployeeID";

 	static final String colName="EmployeeName";

 	static final String colAge="Age";

 	static final String colDept="Dept";

 

 	static final String deptTable="Dept";

 	static final String colDeptID="DeptID";

 	static final String colDeptName="DeptName";

 

 	static final String viewEmps="ViewEmps";

 

 	// и создадим конструктор

 

	public DatabaseHelper(Context context) {

  	super(context, dbName, null,33);

		}

	}


Как видите, здесь мы просто вызываем конструктор суперкласса, который имеет четыре параметра:








  * **Context **- контекст, связанный с базой данных.



  * **dataBaseName **- имя базы данных.



  * **CursorFactory** - можно использовать класс, созданный на основе класса Cursor. Это позволяет проводить некоторые дополнительные проверки и операции с результатами запросов. Если сюда подставить ссылку на наш класс, он будет использоваться вместо стандартного курсора. Мы не будем работать с  **CursorFactory**, поэтому передадим значение null.



  * **Version**- версия базы данных. Смысл этого параметра будет раскрыт ниже






## Создание базы данных





Давайте переопределим метод **onCreate**


	public void onCreate(SQLiteDatabase db) {

  	// TODO Auto-generated method stub

 

  	db.execSQL("CREATE TABLE "+deptTable+" ("+

        colDeptID+ " INTEGER PRIMARY KEY , "+

        colDeptName+ " TEXT)");

 

  	db.execSQL("CREATE TABLE "+employeeTable+

        " ("+colID+" INTEGER PRIMARY KEY AUTOINCREMENT, "+

        colName+" TEXT, "+colAge+" Integer, "+colDept+

        " INTEGER NOT NULL ,FOREIGN KEY ("+colDept+")

        REFERENCES "+deptTable+" ("+colDeptID+"));");

 

 	 db.execSQL("CREATE TRIGGER fk_empdept_deptid " +

    " BEFORE INSERT "+

    " ON "+employeeTable+

 

    " FOR EACH ROW BEGIN"+

    " SELECT CASE WHEN ((SELECT "+colDeptID+" FROM "+

    deptTable+" WHERE "+colDeptID+"=new."+colDept+" ) IS NULL)"+

    " THEN RAISE (ABORT,'Foreign Key Violation') END;"+

    "  END;");

 

  	db.execSQL("CREATE VIEW "+viewEmps+

    " AS SELECT "+employeeTable+"."+colID+" AS _id,"+

    " "+employeeTable+"."+colName+","+

    " "+employeeTable+"."+colAge+","+

    " "+deptTable+"."+colDeptName+""+

    " FROM "+employeeTable+" JOIN "+deptTable+

    " ON "+employeeTable+"."+colDept+" ="+deptTable+"."+colDeptID

    );

 	 //Inserts pre-defined departments

  	InsertDepts(db);

 	}


Внутри метода мы с помощью SQL запросов создаем таблицы, триггеры и представления. Запросы вызываются для базы db с помощью метода **execSQL**.  
   
Метод **onCreate  **вызывается при создании базы данных, как только база создана, мы добавляем туда таблицы с необходимым набором полей. Вызов метода происходит, когда база данных не существует на диске, то есть для данного конкретного устройства этот метод будет вызван всего один раз, сколько бы мы потом не запускали нашу программу.  
 





##  Изменение базы данных





   
Иногда возникает необходимость внести изменения в базу данных: поменять схему, добавить новые таблицы или поменять типы столбцов таблиц. Все это можно сделать внутри метода **onUpdate(SQLiteDatabase db,int old Version,int newVerison)** .




	public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {

  	// TODO Auto-generated method stub

 

  	db.execSQL("DROP TABLE IF EXISTS "+employeeTable);

  	db.execSQL("DROP TABLE IF EXISTS "+deptTable);

 

  	db.execSQL("DROP TRIGGER IF EXISTS dept_id_trigger");

  	db.execSQL("DROP TRIGGER IF EXISTS dept_id_trigger22");

  	db.execSQL("DROP TRIGGER IF EXISTS fk_empdept_deptid");

  	db.execSQL("DROP VIEW IF EXISTS "+viewEmps);

  	onCreate(db);

 	}




Этот метод вызывается, когда изменяется номер, указанный в конструкторе класса. Помните то загадочное число 33, внутри конструктора **DatabaseHelper**? Если Вам вдруг понадобится внести изменение в свою базу, просто поменяйте номер в конструкторе. То есть, если вы измените конструктор


	public DatabaseHelper(Context context) {

  	super(context, dbName, null,34);

 	}




приложение поймет, что вы хотите изменить свою базу и вызовет метод onUpgrade. Обычно внутри этого метода удаляются таблицы и создаются заново с другим набором полей.   
 





##  Управление внешними ключами





Давайте создадим триггер, который будет следить при добавлении нового сотрудника за тем, чтобы указанный в описании сотрудника департамент присутствовал в таблице Dept.   
   
 SQL команда, создающая такой триггер, выглядит следующим образом:





	CREATE TRIGGER fk_empdept_deptid Before INSERT ON Employees

	FOR EACH ROW BEGIN

    SELECT CASE WHEN ((SELECT DeptID FROM Dept WHERE DeptID =new.Dept ) IS NULL)

    THEN RAISE (ABORT,'Foreign Key Violation') END;

    END

 

Добавим в метод onCreate вызов метода execSQL с соответствующим запросом:

	db.execSQL("CREATE TRIGGER fk_empdept_deptid " +

    " BEFORE INSERT "+

    " ON "+employeeTable+

 

    " FOR EACH ROW BEGIN"+

    " SELECT CASE WHEN ((SELECT "+colDeptID+" FROM "+deptTable+

    " WHERE "+colDeptID+"=new."+colDept+" ) IS NULL)"+

    " THEN RAISE (ABORT,'Foreign Key Violation') END;"+

    "  END;");


# Выполнение SQL команд в Android





 Как уже было отмечено выше, Вы можете выполнить любую SQL команду с помощью метода **db.execSQL(String statement)**.   
 





##  Добавление записи в таблицу





 Можно добавить новую запись в таблицу с помощью SQL команды **INSERT**, а можно воспользоваться методом **db.insert**:



	SQLiteDatabase db=this.getWritableDatabase();

	ContentValues cv=new ContentValues();

  	cv.put(colDeptID, 1);

  	cv.put(colDeptName, "Sales");

  	db.insert(deptTable, colDeptID, cv);

 		
	cv.put(colDeptID, 2);

  	cv.put(colDeptName, "IT");

  	db.insert(deptTable, colDeptID, cv);

  	db.close();



Обратите внимание, для соединения с базой данных мы вызвали метод **this.getWritableDatabase()**. Класс **ContentValues** позволяет создать карту с параметрами ключ-значение. Эта карта затем используется методом **insert**, который фактически добавляет запись в таблицу. Метод **ContentValues.put** создает пару ключ-значение. Еще одно замечание, хорошим тоном считается закрывать базу данных вызовом метода  **close()** после завершения выполнения группы команд.  
  






## Изменение значений в таблице





Изменить значение в какой-либо записи можно с помощью SQL команды **UPDATE **или с помощью метода  **db.update**:


	public int UpdateEmp(Employee emp)

  	{

   	SQLiteDatabase db=this.getWritableDatabase();

   	ContentValues cv=new ContentValues();

   	cv.put(colName, emp.getName());

   	cv.put(colAge, emp.getAge());

   	cv.put(colDept, emp.getDept());

   	return db.update(employeeTable, cv, colID+"=?", new String []{String.valueOf(emp.getID())});

  	}


Метод update имеет следующие параметры: 








  * **String Table**: название таблицы в которой мы хотим что-то изменить.



  * **ContentValues cv**: пара ключ-значение с новой информацией.



  * **String where**: строка-шаблон, определяющая условие  WHERE, которое проверяется для каждой строки таблицы. Ксли условие истинно, то в этой строке обновляется информация в соответствии с параметром cv.



  * **String[] args**: массив с аргументами, которые подставляются в строку-шаблон where.






## Удаление строк





Удалить строку в таблице можно с помощью SQL команды **DELETE**, а также с помощью метода **db.delete**. Этот метод имеет аналогичный  **update **набор параметров (за исключением cv).



	public void DeleteEmp(Employee emp)

  	{

   	SQLiteDatabase db=this.getWritableDatabase();

   	db.delete(employeeTable,colID+"=?", new String [] {String.valueOf(emp.getID())});

   	db.close();

  	}



## Выполнение SQL запросов





 Для выполнения запросов в Android используются два метода: **db.rawQuery** и **db.query**. Давайте сделаем запрос к базе, с целью получения списка всех департаментов:




	Cursor getAllDepts()

  	{

   	SQLiteDatabase db=this.getReadableDatabase();

   	Cursor cur=db.rawQuery("SELECT "+colDeptID+" as _id, "+

   	colDeptName+" from "+deptTable,new String [] {});

 

   	return cur;

  	}





 Метод **rawQuery** имеет два параметра:








  * **String query**: Строка с SQL запросом SELECT.



  * **String[] selection args**: массив аргументов where, если он используется в SELECT запросе.






  
**Замечания!** В качестве результата этого запроса возвращается объект **Cursor**. Если в качестве ключевого поля в таблице используется колонка с именем, отличным от** _id**, Вам необходимо использовать alias в форме "SELECT [Column Name] as _id". Дело в том, что объект **Cursor** всегда считает, что ключевое поле имеет имя **_id**, и если это не так, генерируется исключение.  
  
Другим способом выполнения запроса к базе является вызов метода **db.query**. Давайте напишем метод, который выдает всех сотрудников, работающих в каком-то конкретном департаменте:



	public Cursor getEmpByDept(String Dept)

  	{

   	SQLiteDatabase db=this.getReadableDatabase();

   	String [] columns=new String[]{"_id",colName,colAge,colDeptName};

   	Cursor c=db.query(viewEmps, columns, colDeptName+"=?", new String[]{Dept}, null, null, null);

   	return c;

  	}


Метод **db.query** имеет следующий набор параметров:








  * **String Table Name**: Имя таблицы, из которой осуществляется выборка.



  * **String [ ] columns**: список столбцов, которые войдут в результат.



  * **String WHERE clause**: шаблон where-условия или null.



  * **String [ ] selection args**: массив с аргументами where-условия.



  * **String Group by**: условие группировки.



  * **String Having**: условие HAVING.



  * **String Order By by**: порядок сортировки.






##  Управление объектом Cursor





В результате выполнения запросов нам возвращается объект **Cursor**, содержащий таблицу с результатами запроса. **Cursor**предполагает последовательную работу со строками результата. В каждый момент времени активна одна строка, на которую ссылается указатель. Ниже перечислены методы, которые используются для работы с этим объектом:








  * **boolean moveToNext()**- перемещает указатель на одну запись вперед. Возвращает false, если достигнут конец таблицы результата.



  * **boolean moveToFirst()**- перемещает указатель на первую строку. Возвращает false, если таблица-результат не содержит строк.



  * **boolean moveToPosition(int position)** - перемещает указатель на конкретную строку в таблице результатов. Если строки с таким номером нет - возвращает false.



  * **boolean moveToPrevious()**- перемещает указатель на одну запись назад. Возвращает false, если достигнуто начало таблицы результата.



  * **boolean moveToLast()**- перемещает указатель на последнюю строку. Возвращает false, если таблица-результат не содержит строк.



  * **int  getColumnIndex(String column)** - возвращает ссылку на колонку column в текущей строке. Для получения значения по ссылке используются методы **Cursor.getInt(int ColumnIndex), getShort,getString,getDouble, getBlob**. 






  
Для определение текущей позиции указателя можно воспользоваться методами:**boolean isAfterLast(), isBeforeFirst, isFirst, isLast и isNull(columnIndex)**. Их назначение без труда можно понять из названий.  
  
Если в результате выполнения запроса вы получили только одну строку, то извлечь из нее значения столбцов можно следующим образом:





	public int GetDeptID(String Dept)

  	{

  	SQLiteDatabase db=this.getReadableDatabase();

   	Cursor c=db.query(deptTable, new String[]{colDeptID+" as _id",colDeptName},colDeptName+"=?",

   	new String[]{Dept}, null, null, null);

   	c.moveToFirst();

   	return c.getInt(c.getColumnIndex("_id"));

  	}




В результате выполнения этого метода, мы получим значение колонки _id текущей строки.  После использования курсора его хорошо бы закрыть с помощью метода **close()**.  
   
 Вот собственно и все. Теперь вы вполне сможете использовать базы данных в своих Android проектах.





Если вам понравилась статья, пишите комментарии и рассказывайте друзьям.
Добрый день друзья.





Я продолжаю сбор интересной информации.





И сегодня я нашел статью о работе с ListFragment.





Прошу к прочтению.

<!-- more -->



Вернемся к фрагментам. В Android есть несколько полезных классов – наследников класса Fragment. Мы рассмотрим несколько из них. Начнем с [ListFragment](http://developer.android.com/reference/android/app/ListFragment.html). В принципе, это просто Fragment, в котором есть методы, упрощающие доступ к ListView и некоторым его операциям.





Тут можно провести аналогию - для Activity есть класс наследник [ListActivity](http://developer.android.com/reference/android/app/ListActivity.html). Когда мы только знакомились со списками, я не стал рассматривать этот класс, чтобы не вносить путаницы в непростую тему. Но в учебниках и хелпе о нем обычно говорят. Думаю, многие уже сталкивались с ним и примерно знают, что это такое. Если да, то ListFragment будет совсем прост для понимания.





Напишем приложение и рассмотрим основные возможности ListFragment.





Создадим класс фрагмента, наследующий не android.app.Fragment как обычно, а android.app.ListFragment.





**MainList.java**:

	import android.app.ListFragment;



	public class MainList extends ListFragment {



	}







Класс так и оставляем пока пустым. И пока что не будем создавать Layout-файл для этого фрагмента. Дело в том, что ListFragment по умолчанию уже содержит ListView и мы вполне можем обойтись им. Адаптер мы пока также никакой не создаем, посмотрим чего получится.





Редактируем layout для MainActivity





**main.xml**:


	<?xml version="1.0" encoding="utf-8"?>

	<LinearLayout

 	xmlns:android="http://schemas.android.com/apk/res/android"

 	xmlns:tools="http://schemas.android.com/tools"

 	android:id="@+id/LinearLayout1"

 	android:layout_width="match_parent"

 	android:layout_height="match_parent"

 	android:orientation="vertical">

	<fragment android:name="ru.startandroid.develop.p1091listfragment.MainList"

	android:layout_width="match_parent"

 	android:layout_height="match_parent">

	</fragment>

	</LinearLayout>







Здесь только компонент fragment, использующий наш класс.





Все сохраняем, запускаем приложение.





![](http://android-helper.com.ua/images/uploads/2012/10/L0109_010.jpg)




ListFragment показывает нам, что он ждет данных. 





Ок, давайте дадим ему данные. Перепишем **MainList.java**:



	import android.app.ListFragment;

	import android.os.Bundle;

	import android.widget.ArrayAdapter;



	public class MainList extends ListFragment {



  	String data[] = new String[] { "one", "two", "three", "four" };



  	@Override

  	public void onActivityCreated(Bundle savedInstanceState) {

    super.onActivityCreated(savedInstanceState);

    ArrayAdapter<String> adapter = new ArrayAdapter<String>(getActivity(),

        android.R.layout.simple_list_item_1, data);

    setListAdapter(adapter);

  	}



	}








Мы создаем адаптер и используем метод [setListAdapter](http://developer.android.com/reference/android/app/ListFragment.html#setListAdapter(android.widget.ListAdapter)), чтобы передать его списку. Обратите внимание - мы даже не создаем или не находим (findViewById) список (ListView), он уже есть где-то внутри фрагмента и метод setListAdapter сам знает, как до него добраться. В принципе, это и есть основная фишка ListFragment - нам не надо работать с ListView.





Все сохраним, запустим приложение.





![](http://android-helper.com.ua/images/uploads/2012/10/L0109_0201.jpg)



Данные появились.





Еще раз обращаю ваше внимание на то, что мы вообще не создавали никаких layout с ListView. ListFragment работает с каким-то своим, встроенным списком. 





Если же вас чем-то не устраивает этот дефолтный список, можно использовать свой layout-файл для фрагмента.





В **strings.xml** добавим строки


	<string name="number_list">Список чисел</string>

	<string name="empty">Нет данных</string>








И создадим layout файл **fragment.xml**:



	<?xml version="1.0" encoding="utf-8"?>

	<LinearLayout

 	xmlns:android="http://schemas.android.com/apk/res/android"

 		android:layout_width="match_parent"

 		android:layout_height="match_parent"

 		android:orientation="vertical">

		<TextView

 			android:layout_width="wrap_content"

 			android:layout_height="wrap_content"

 			android:text="@string/number_list">

		</TextView>

	<ListView

		 android:id="@id/android:list"

		 android:layout_width="match_parent"

		 android:layout_height="match_parent">

	</ListView>

	<TextView

		 android:id="@id/android:empty"

		 android:layout_width="match_parent"

		 android:layout_height="match_parent"

		 android:gravity="center"

		 android:text="@string/empty">

	</TextView>

	</LinearLayout>








Первый TextView – просто заголовок списка. Далее идет ListView. Его ID обязательно должен быть равен **@id/android:list**. Чтобы ListFragment сам его нашел и мог с ним работать. Второй TextView – будет показан, если нет данных для списка. Его ID обязательно должен быть равен **@id/android:empty**.





Допишем в **MainList.java** метод создания View.





	@Override

 	public View onCreateView(LayoutInflater inflater, ViewGroup container,

      Bundle savedInstanceState) {

    return inflater.inflate(R.layout.fragment, null);

 	 }







Фрагмент будет отображать компоненты из layout-файла, который мы только что создавали.





Все сохраняем и запускаем.





![](http://android-helper.com.ua/images/uploads/2012/10/L0109_030.jpg)





Видим заголовок и данные. Наш layout был использован.





Если не дать списку данные, то приложение будет выглядеть так





![](http://android-helper.com.ua/images/uploads/2012/10/L0109_040.jpg)





Отобразился наш второй TextView с ID = @id/android:empty. Причем, это вовсе не обязательно должен быть TextView. Главное тут именно этот ID. Компонент с этим ID будет показан вместо ListView, если нет данных.





Чтобы включать одиночный и множественный выбор, необходимо провести все те же действия, которые мы рассматривали в Уроке 43: передать в адаптер соответствующий layout-файл и включить соответствующий режим выбора для списка. В этом же 43-м Уроке можно посмотреть, как определять, какие пункты списка выбраны. Чтобы в ListFragment получить доступ к списку – используйте метод [getListView](http://developer.android.com/reference/android/app/ListFragment.html#getListView()).





Результаты включения режима выбора будут такие:





одиночный выбор





![](http://android-helper.com.ua/images/uploads/2012/10/L0109_050.jpg)





множественный выбор





![](http://android-helper.com.ua/images/uploads/2012/10/L0109_060.jpg)




Еще, как вариант, можно в адаптер передавать layout-файл **android.R.layout.simple_list_item_activated_1**.





В этом случае результаты будут такие:





![](http://android-helper.com.ua/images/uploads/2012/10/L0109_070.jpg)




![](http://android-helper.com.ua/images/uploads/2012/10/L0109_080.jpg)





Это хорошо подходит для случая, когда у вас на экране слева фрагмент-список, а справа фрагмент-содержимое и вы всегда видите какой именно пункт из списка сейчас просматриваете.





Чуть не забыл про самое главное )  Ловить нажатия можно в методе [onListItemClick](http://developer.android.com/reference/android/app/ListFragment.html#onListItemClick(android.widget.ListView, android.view.View, int, long)). 





Если добавим в MainList.java его реализацию:





	public void onListItemClick(ListView l, View v, int position, long id) {

    super.onListItemClick(l, v, position, id);

    Toast.makeText(getActivity(), "position = " + position, Toast.LENGTH_SHORT).show();

 	 }








то при нажатии на пункт списка, увидим результат:





![](http://android-helper.com.ua/images/uploads/2012/10/L0109_090.jpg)





Статья взята из сайта [startandroid.ru](http://startandroid.ru/uroki/vse-uroki-spiskom/179-urok-109-android-3-fragments-listfragment-spisok.html)





Если вам понравилась статья, пишите ваши комментарии.





Если у вас есть интересные примеры решения, пишите мне и я буду их публиковать на блоге.





Полный проект вы можете скачать на [странице с кодами](http://android-helper.com.ua/codes/).
Добрый день друзья.





Нашел сегодня интересную статью. Которая еще более детально описывает работу с actionbar.





Прошу к прочтению.


<!-- more -->


На прошлом уроке мы рассмотрели добавление элементов ActionBar. Пользователю эти элементы удобно использовать для совершения каких-либо операций в приложении. Например, в почтовой программе это может быть удаление письма, пересылка, ответ и т.д.





Теперь рассмотрим, как добавить элементы для навигации по приложению. Есть два типа элементов для навигации: табы и выпадающий список. Создадим простое приложение и реализуем в нем сначала один, затем второй способ.





Создадим проект:





**Project name**: P1081_ActionBarNavigation  
**Build Target**: Android 4.1   
**Application name**: ActionBarItems  
**Package name**: ru.startandroid.develop.p1081actionbarnavigation  
**Create Activity**: MainActivity





Никакие строки не добавляем, основной layout не трогаем.





### Табы





Кодим **MainActivity.java**:



	import android.app.ActionBar;

	import android.app.ActionBar.Tab;

	import android.app.Activity;

	import android.app.FragmentTransaction;

	import android.os.Bundle;

	import android.util.Log;



	public class MainActivity extends Activity implements ActionBar.TabListener {



  	final String LOG_TAG = "myLogs";



  	@Override

  	public void onCreate(Bundle savedInstanceState) {

    super.onCreate(savedInstanceState);

    setContentView(R.layout.main);



    ActionBar bar = getActionBar();



    bar.setNavigationMode(ActionBar.NAVIGATION_MODE_TABS);



    Tab tab = bar.newTab();

    tab.setText("tab1");

    tab.setTabListener(this);

    bar.addTab(tab);



    tab = bar.newTab();

    tab.setText("tab2");

    tab.setTabListener(this);

    bar.addTab(tab);



  	}



  	@Override

  	public void onTabReselected(Tab tab, FragmentTransaction ft) 	{

    Log.d(LOG_TAG, "reselected tab: " + tab.getText());

  	}



  	@Override

  	public void onTabSelected(Tab tab, FragmentTransaction ft) {

    Log.d(LOG_TAG, "selected tab: " + tab.getText());

  	}



  	@Override

  	public void onTabUnselected(Tab tab, FragmentTransaction ft) 	{

    Log.d(LOG_TAG, "unselected tab: " + tab.getText());

  	}

	}







Смотрим, что нам нужно, чтобы включить табы.





В **onCreate** мы получаем доступ к ActionBar и устанавливаем для него режим навигации в [NAVIGATION_MODE_TABS](http://developer.android.com/reference/android/app/ActionBar.html#NAVIGATION_MODE_TABS). Далее идет добавление табов. Тут все несложно – создаем, пишем текст, присваиваем обработчика, добавляем в ActionBar.





Обработчиком для табов мы сделали MainActivity, оно реализует методы интерфейса [ActionBar.TabListener](http://developer.android.com/reference/android/app/ActionBar.TabListener.html):





[onTabReselected](http://developer.android.com/reference/android/app/ActionBar.TabListener.html) – выбран уже выбранный таб





[onTabSelected](http://developer.android.com/reference/android/app/ActionBar.TabListener.html)– таб выбран





[onTabUnselected](http://developer.android.com/reference/android/app/ActionBar.TabListener.html)– таб более не выбран





В эти методы поместим запись в лог и посмотрим, как оно все там работает.





Все сохраняем и запускаем приложение.





Видим табы





![](http://android-helper.com.ua/images/uploads/2012/10/L0108_010.jpg)





Сейчас выбран первый таб и лог сразу об этом сообщает:





	_selected tab: tab1_





Нажмем на второй таб,





![](http://android-helper.com.ua/images/uploads/2012/10/L0108_020.jpg)




смотрим логи:





	_unselected tab: tab1  
	__selected tab: tab_2





Первый таб «развыбран», а второй выбран.





Еще раз нажмем на второй таб:





	_reselected tab: tab2_





Второй таб перевыбран. Все логично и понятно.





Я, чтобы не перегружать урок, не стал реализовывать какие-либо операции по навигации в приложении. А, вообще, подразумевается, что в методах обработчика мы кодим операции с фрагментами. Нам даже любезно предоставляют объект **FragmentTransaction** для этих целей. При этом хелп предупреждает, что в этих методах нам не надо самим вызывать метод **commit**, а также мы не можем добавлять транзакцию в **BackStack**.





### Выпадающий список





Теперь посмотрим, как работает навигация с выпадающим списком.





Перепишем **MainActivity.java**:





	import android.app.ActionBar;

	import android.app.Activity;

	import android.os.Bundle;

	import android.util.Log;

	import android.widget.ArrayAdapter;



	public class MainActivity extends Activity implements

    ActionBar.OnNavigationListener {



  	String[] data = new String[] { "one", "two", "three" };



  	final String LOG_TAG = "myLogs";



  	@Override

  	public void onCreate(Bundle savedInstanceState) {

    super.onCreate(savedInstanceState);

    setContentView(R.layout.main);



    ActionBar bar = getActionBar();

    bar.setNavigationMode(ActionBar.NAVIGATION_MODE_LIST);



    ArrayAdapter<String> adapter = new ArrayAdapter<String>(this,

        android.R.layout.simple_spinner_item, data);

    adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);

    bar.setListNavigationCallbacks(adapter, this);

  	}



  	@Override

  	public boolean onNavigationItemSelected(int itemPosition, long itemId) {

    Log.d(LOG_TAG, "selected: position = " + itemPosition + ", id = "

        + itemId + ", " + data[itemPosition]);

    return false;

  	}

	}







В **onCreate** получаем ActionBar и включаем ему режим навигации [NAVIGATION_MODE_LIST](http://developer.android.com/reference/android/app/ActionBar.html#NAVIGATION_MODE_LIST). Для выпадающего списка необходимо создать адаптер, реализующий SpinnerAdapter. Пусть это будет ArrayAdapter. При создании используем массив из трех строк. Далее вызываем метод [setListNavigationCallbacks](http://developer.android.com/reference/android/app/ActionBar.html#setListNavigationCallbacks(android.widget.SpinnerAdapter, android.app.ActionBar.OnNavigationListener)), в который передаем адаптер и обработчик.





Обработчиком у нас снова является Activity, реализует метод [onNavigationItemSelected](http://developer.android.com/reference/android/app/ActionBar.OnNavigationListener.html#onNavigationItemSelected(int, long)) интерфейса [ActionBar.OnNavigationListener](http://developer.android.com/reference/android/app/ActionBar.OnNavigationListener.html). Этот метод дает нам позицию и id выбранного из списка элемента. Выводим в лог эту инфу и соответствующий элемент массива.





В манифесте я прописал для MainActivity атрибут темы: android:theme="@android:style/Theme.Holo.Light". Иначе был темный текст на темном фоне.





Все сохраняем и запускаем.





![](http://android-helper.com.ua/images/uploads/2012/10/L0108_030.jpg)





Первый элемент сразу выбран. В логах видим:





	_selected: position = 0, id = 0, one_





Выберем какой-нить другой элемент из списка





![](http://android-helper.com.ua/images/uploads/2012/10/L0108_040.jpg)




В логах:





	_selected: position = 2, id = 2, three_





Снова все логично и понятно.





Для обоих видов навигации мы всегда можем получить текущий выбранный элемент с помощью метода [getSelectedNavigationIndex](http://developer.android.com/reference/android/app/ActionBar.html#getSelectedNavigationIndex()). А для навигации с табами есть также метод [getSelectedTab](http://developer.android.com/reference/android/app/ActionBar.html#getSelectedTab()), возвращающий текущий выбранный таб.





Разумеется, что вместе с навигацией мы можем добавлять в ActionBar и обычные элементы, которые были рассмотрены на прошлом уроке.





![](http://android-helper.com.ua/images/uploads/2012/10/L0108_050.jpg)





При этом, если места будет недостаточно, то ActionBar разделит все свои элементы на две полосы.





![](http://android-helper.com.ua/images/uploads/2012/10/L0108_060.jpg)





Начиная с четвертой версии Андроид, можно использовать атрибут **uiOptions** для Activity или Application в манифесте. Если присвоить ему значение**splitActionBarWhenNarrow**, то результат при нехватке места получится такой:





![](http://android-helper.com.ua/images/uploads/2012/10/L0108_070.jpg)




Элементы ушли вниз. Правда, при этом почему-то перестает работать withText в showAsAction.





Статья взята из сайта [startandroid.ru](http://startandroid.ru/uroki/vse-uroki-spiskom/178-urok-108-android-3-actionbar-navigatsija-taby-i-vypadajuschij-spisok.html)





Если вам понравилась статья, оставляйте свои комментарии. И не забывайте рассказать друзьям о нас.
Добрый день.





Сегодня нашел статью, как можно закачать файлы с сервера.





Оригинал статьи [тут](http://findevelop.blogspot.com/2012/01/android_19.html).


 <!-- more -->


Хорошо сделанное Android-приложение (кроме всего прочего) не заставляет клиента угадывать что в данный момент происходит "по ту сторону экрана". Приятное и аккуратное приложение показывает при всех продолжительных операциях прогресс-бар, который реализует, как правило, с помощью класса AsyncTask. Давайте посмотрим как правильно использовать этот замечательный инструмент на примере загрузки файла из сети:





	import java.io.File;

	import java.io.FileOutputStream;

	import java.io.IOException;

	import java.io.InputStream;

	import java.net.HttpURLConnection;

	import java.net.MalformedURLException;

	import java.net.URL;

	import android.app.Act	ivity;

	import android.app.ProgressDialog;

	import android.os.AsyncTask;

	import android.os.Bundle;

	import android.view.View;

	import android.view.ViewGroup.LayoutParams;

	import android.widget.Button;

	import android.widget.TextView;

	public class BackFLoaderActivity extends Activity {

 

 	@Override

 	public void onCreate(Bundle savedInstanceState) {

  	super.onCreate(savedInstanceState);

  	Button load = new Button(this);

  	load.setText("Load file");

  	load.setOnClickListener(new View.OnClickListener() {

   	@Override

   	public void onClick(View v) {

    	downloadFile("http://anjedi.com/api_lib/2.2_level8.jar");

   	}

  	});

  	setContentView(load, new LayoutParams(LayoutParams.WRAP_CONTENT,

   	LayoutParams.WRAP_CONTENT));

 	}

 



 	private void downloadFile(String url) {

  	final ProgressDialog progressDialog = new ProgressDialog(this);

 

  	new AsyncTask<String, Integer, File>() {

   	private Exception m_error = null;

 

   	@Override

   	protected void onPreExecute() {

    progressDialog.setMessage("Downloading ...");

    progressDialog.setCancelable(false);

    progressDialog.setMax(100);

    progressDialog

      .setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);

 

    progressDialog.show();

   	}

 

   	@Override

   	protected File doInBackground(String... params) {

    URL url;

    HttpURLConnection urlConnection;

    InputStream inputStream;

    int totalSize;

    int downloadedSize;

    byte[] buffer;

    int bufferLength;

 

    File file = null;

    FileOutputStream fos = null;

 

    try {

     url = new URL(params[0]);

     urlConnection = (HttpURLConnection) url.openConnection();

 

     urlConnection.setRequestMethod("GET");

     urlConnection.setDoOutput(true);

     urlConnection.connect();

 

     file = File.createTempFile("Mustachify", "download");

     fos = new FileOutputStream(file);

     inputStream = urlConnection.getInputStream();

 

     totalSize = urlConnection.getContentLength();

     downloadedSize = 0;

 

     buffer = new byte[1024];

     bufferLength = 0;

 

     // читаем со входа и пишем в выход, 

     // с каждой итерацией публикуем прогресс

     while ((bufferLength = inputStream.read(buffer)) > 0) {

      fos.write(buffer, 0, bufferLength);

      downloadedSize += bufferLength;

      publishProgress(downloadedSize, totalSize);

     }

 

     fos.close();

     inputStream.close();

 

     return file;

    } catch (MalformedURLException e) {

     e.printStackTrace();

     m_error = e;

    } catch (IOException e) {

     e.printStackTrace();

     m_error = e;

    }

 

    return null;

   	}

 

   	// обновляем progressDialog

   	protected void onProgressUpdate(Integer... values) {

    progressDialog

      .setProgress((int) ((values[0] / (float) values[1]) * 100));

   	};

 

   	@Override

   	protected void onPostExecute(File file) {

    // отображаем сообщение, если возникла ошибка

    if (m_error != null) {

     m_error.printStackTrace();

     return;

    }

    // закрываем прогресс и удаляем временный файл

    progressDialog.hide();

    file.delete();

   	}

  	}.execute(url);

 		}

	}






В этом маленьком приложении при нажатии на кнопку запускается загрузка файла, при этом пользователь наблюдает прогресс-бар. Не забудьте добавить в манифест запрос разрешений на доступ к интернет и файловой системе.  
Основой примера является метод, который я взял [отсюда](http://twigstechtips.blogspot.com/2011/10/android-download-file-with-progress.html) (и поправил пару ошибок).     
Этот метод принимает url файла, который нужно загрузить, загружает файл, отображая при этом горизонатальный прогресс-бар. При этом прогресс-бар реально показывает какая часть файла в данный момент загружена. По окончании загрузки файл удаляется.  
  
**Разберём работу метода подробнее:**  
  
Главная часть метода - создание AcyncTask-а и переопределение его методов.  
В методе _onPreExecute_ мы запускаем progressDialog, установив предварительно текст сообщения и максимальное значение прогресса: 100%.   
В методе _doInBackground_ - выполняем собственно загрузку файла. Файл читаем  из_urlConnection_ порциями по 1024 байт, каждый раз прибавляя размер полученной порции к общему счётчику. Счётчик и общий размер файла передаём при каждой итерации в метод _publishProgress_, благодаря чему в методе _onProgressUpdate_ мы получаем эти данные и обновляем текущий статус progressDialog-а.   
И, наконец, в методе _onPostExecute_ мы прячем диалог и удаляем временный файл.   
Особенностью использования AsyncTask-a является способ, как он объявляется и как в него передаются параметры. Типы, которыми параметризуется экземпляр AsyncTask-a определяю по порядку: тип входящего значения, тип параметра, опреляющего прогресс опреации и тип результата фоновой операции (то что возвращает _doInBackground_ и принимает _onPostExecute_). Кроме того конструктор и чаcть методов AsyncTask-а принимает _varargs, _т.е. произвольное число параметров, что весьма удобно в некоторых случаях.
Привет всем.





Сегодня изучил для себя новую тему- работу с ActionBar.





Это новый патерн который программисты могут использовать с 3 версии android.





Изучал я этот патерн по одной статье.


<!-- more -->


Оригинал [тут.](http://startandroid.ru/uroki/vse-uroki-spiskom/177-urok-107-android-3-actionbar-razmeschenie-elementov.html)





Поскольку статья, заслуживает внимания как новичков так и гуру, я ее продублирую у себя на сайте.





Еще одно нововведение третьего Андроида – [Action Bar](http://developer.android.com/guide/topics/ui/actionbar.html). Это панель в верхней части приложения.





В этом уроке попробуем размещать там свои элементы с иконками и посмотрим, как с ними взаимодействовать. Тут нам все уже будет знакомо, т.к. используется механизм, который раньше строил меню.  Т.е. мы в методе [onCreateOptionsMenu](http://developer.android.com/reference/android/app/Activity.html#onCreateOptionsMenu(android.view.Menu)) получаем на вход объект Menu и (программно или с помощью XML) наполняем его элементами.





Для элементов будем указывать id, текст, иконку и режим показа.





В **strings.xml** добавим строки:




	<string name="item1">Item1</string>

	<string name="item2">Item2</string>

	<string name="item3">Item3</string>

	<string name="item4">Item4</string>







В файл **res\menu\main.xml** напишем следующий текст:





	<?xml version="1.0" encoding="utf-8"?>

	<menu

 xmlns:android="http://schemas.android.com/apk/res/android">

	<item

 android:id="@+id/item1"

 android:showAsAction="always"

 android:title="@string/item1">

	</item>

	<item

 		android:id="@+id/item2"

 		android:icon="@android:drawable/ic_menu_call"

 		android:showAsAction="ifRoom"

 		android:title="@string/item2">

	</item>

	<item

 		android:id="@+id/item3"

 		android:icon="@android:drawable/ic_menu_info_details"

 		android:showAsAction="ifRoom|withText"

 		android:title="@string/item3">

	</item>

	<item

 		android:id="@+id/item4"

 		android:icon="@android:drawable/ic_menu_view"

 		android:showAsAction="never"

 		android:title="@string/item4">

	</item>

	</menu>






С **id**, **title** и **icon**, думаю все понятно – это идентификатор, текст и иконка элемента. Иконки системные, выбранные случайно.





Нам тут больше интересен атрибут **showAsAction**, это режим показа элемента. Он может принимать значения:





**never**– не показывать элемент





**ifRoom**– показывать, если есть место





**always**– всегда показывать





К этим значениям может быть добавлено еще одно – **withText**. Актуально для элементов с указанной иконкой. В этом случае для элемента будет показана не только иконка, но и текст из **title**. 





Кодим **MainActivity.java**:

	package ru.startandroid.develop.p1071actionbaritems;



	import android.app.Activity;

	import android.os.Bundle;

	import android.view.Menu;



	public class MainActivity extends Activity {



  @Override

  public void onCreate(Bundle savedInstanceState) {

    super.onCreate(savedInstanceState);

    setContentView(R.layout.main);

  }



  @Override

  public boolean onCreateOptionsMenu(Menu menu) {

    getMenuInflater().inflate(R.menu.main, menu);

    return true;

  }



	}







Думаю, комментарии тут особо не нужны. Все знакомое. Заполненный нами ранее xml-файл используется для создания элементов Menu. 





Все сохраняем, запускаем приложение.





Отобразился **item1 **и **item2**.





![](http://android-helper.com.ua/images/uploads/2012/09/L0107_010.jpg)



Для **item1** мы не указывали иконку, поэтому видим только текст. А в **showAsAction **мы указали **always**, т.е. система будет пытаться отобразить элемент, даже если не хватает места на ActionBar.





Для **item2** мы указали иконку ic_menu_call, ее и видим в ActionBar. В **showAsAction **мы указали **ifRoom**, т.е. отображать, если есть свободное место. Место есть – элемент виден.





Жмем на эмуляторе menu и видим два оставшихся элемента. Они не отобразились в ActionBar и теперь доступны только так.





![](http://android-helper.com.ua/images/uploads/2012/09/L0107_020.jpg)





**item3** не отобразился, т.к. ему не хватило места. Мы для него указывали **showAsAction** = **ifRoom**, т.е. отображать, если есть где. Для **item2** место нашлось, а вот **item3**не влез.





**item4** не отобразился, т.к. мы указали **showAsAction**= **never**.





Давайте увеличим место в ActionBar и посмотрим, что изменится. Для этого просто повернем экран в горизонтальную ориентацию – CTRL+F12.





![](http://android-helper.com.ua/images/uploads/2012/09/L0107_030.jpg)





Для **item1** и **item2** ничего не изменилось. А вот для **item3** теперь появилось местечко, и он вылез. Если для **item2** отображена только иконка, то для **item3** мы видим и текст. Это сказывается **withText** в атрибуте **showAsAction**.





**item4** не виден несмотря на то, что есть куча места свободного. Причина - **never** в атрибуте **showAsAction**. Чтоб добраться до него, жмем menu.





![](http://android-helper.com.ua/images/uploads/2012/09/L0107_040.jpg)




### overflow menu





Если запустить это же приложение на планшете, то увидим чуть другой интерфейс ActionBar:





![](http://android-helper.com.ua/images/uploads/2012/09/L0107_050.jpg)




Справа появляется кнопка, нажатие на которую аналогично нажатию на menu. Судя по всему, эта кнопка видна только на тех устройствах, на которых нет кнопки menu.





### Как узнать текст элемента, если видна только иконка





Если для элемента показана только иконка, то долгим нажатием на нее можно добиться показа текста. Попробуем на item2:





![](http://android-helper.com.ua/images/uploads/2012/09/L0107_060.jpg)




На AVD с 4.1 это работает. На планшете с 3.2 – почему-то нет.





### Как отключить ActionBar





Для этого в коде можно прописать:





Либо выбрать для **Activity** тему, содержащую текст _NoActionBar_.





![](http://android-helper.com.ua/images/uploads/2012/09/L0107_070.jpg)




### Где обрабатывать нажатия на элементы





Там же, где и при работе с меню – метод [onOptionsItemSelected](http://developer.android.com/reference/android/app/Activity.html#onOptionsItemSelected(android.view.MenuItem)). Все аналогично.





### О кнопке Home





В левой части ActionBar находится кнопка **Home**. По умолчанию для нее используется иконка приложения или Activity. Мы можем поставить сюда свою иконку, не трогая текущие. Для этого используется атрибут android:logo у Activity или Application.





В третьем Андроиде кнопка Home кликабельна по умолчанию. В четвертом же ее надо явно задействовать методом [setHomeButtonEnabled](http://developer.android.com/reference/android/app/ActionBar.html#setHomeButtonEnabled(boolean)).





Поймать нажатие кнопки **Home** можно также в onOptionsItemSelected. Она имеет id = **android.R.id.home**.





Насколько я понял по хелпу, назначение этой кнопки – перейти в коренное Activity программы, т.е. действительно кнопка «Домой». Также хелп говорит об еще одной логической возможности использования – как кнопка «Вверх». Т.е. не в корневое Activity, а на один логический уровень вверх. Например, из чтения письма переходим к списку писем. А для того, чтобы пользователь знал, что он попадет не Домой, а Вверх предлагается вещать на кнопку стрелочку методом [setDisplayHomeAsUpEnabled](http://developer.android.com/reference/android/app/ActionBar.html#setDisplayHomeAsUpEnabled(boolean)).





В итоге выглядит это примерно так





![](http://android-helper.com.ua/images/uploads/2012/09/L0107_080.jpg)





На кнопке появилась стрелка.





Надо понимать, что эта стрелка – это просто изображение для пользователя, чтобы он знал, какое поведение ожидать от нажатия. А кодить весь процесс перехода Вверх надо самим. Как впрочем и процесс перехода Домой.









Напоследок еще несколько полезных методов для ActionBar:





[setTitle](http://developer.android.com/reference/android/app/ActionBar.html#setTitle(java.lang.CharSequence)) – установить свой текст около кнопки Home





[setDisplayShowTitleEnabled ](http://developer.android.com/reference/android/app/ActionBar.html#setDisplayShowTitleEnabled(boolean))– скрыть/показать текст около кнопки Home





[setDisplayShowHomeEnabled](http://developer.android.com/reference/android/app/ActionBar.html#setDisplayShowHomeEnabled(boolean)) – скрыть/показать кнопку Home









Если вам понравилась статья, или вы бы хотели что бы описали что то конкретно. Пишите, мы с радостью вам поможем.
Сегодня нашел интересую статью, как можно строить диаграммы в Android.





Оригинал статьи вы можете найти [тут](http://www.mobilab.ru/androiddev/achartengineforandroid.html).





Я же в свою очередь продублирую ее у себя на блоге, так как считаю, что она заслуживает внимания.


<!-- more -->


При разработке бизнес приложений программисты часто сталкиваются с необходимостью строить большое количество различных диаграмм и графиков. Конечно, все можно делать с нуля, вручную отрисовывая все необходимое, но зачем так мучатся, если есть неплохое бесплатное решение? Сегодня я хочу рассказать Вам об open source библиотеке AChartEngine, позволяющей создавать красивые графики и диаграммы для ваших отчетов. Приятно, что библиотека распространяется под весьма мягкой лицензией Apache Version 2, так что Вы вполне можете использовать **AChartEngine **в своих коммерческих проектах.     
  
[На сайте разработчика](http://www.achartengine.org/index.html) помимо самой библиотеки можно найти подробную документацию, офермленную в стиле Javadoc pages, примеры использования библиотеки, а также ее исходный код. В разделе Demo приводится несколько диаграмм и графиков, построенных средствами AChartEngine.





![](http://android-helper.com.ua/images/uploads/2012/09/AChartEngine.jpg)





Для построения диаграммы нужно выполнить несколько довольно простых шагов








  1. Перед использованием библиотеки вам нужно подключить ее к своему проекту в Eclipse. Для этого создайте где-нибудь папку для библиотеки и поместите туда jar файл. Теперь добавьте этот jar в свой project build path. После этого добавьте строку <activity android:name="org.achartengine.GraphicalActivity"/> в файл манифеста вашего проекта.



  2. Создайте и инициализируйте три массива. В первом будут содержаться цвета, во втором - подписи, в третьем - значения. 



  3. Создайте объект CategorySeries и загрузите в него массивы строк с подписями и значения. При построении диаграмм будут использоваться именно эти данные.



  4. Создайте объект DefaultRenderer. CategorySeries и DefaultRenderer определены в библиотеке AChartEngine.



  5. Для каждого цвета в диаграмме создайте SimpleSeriesRenderer и установите его в этот цвет. Затем каждый SimpleSeriesRenderer добавьте в DefaultRenderer. Таким образом, имеем один Render на каждый Series. К слову, Render может включать другой Render, таким образом можно создавать подкатегории.



  6. Создайте объект PieChartIntent и передайте ему CategorySeries и DefaultRenderer.



  7. С помощью PieChartIntent можно показать диаграмму, как отдельную деятельность.






  
Ниже приводится исходный код, в котором реализованы все описанные выше шаги.





	package com.example.bars;

 

	import org.achartengine.ChartFactory;

	import org.achartengine.chart.PieChart;

	import org.achartengine.model.CategorySeries;

	import org.achartengine.renderer.DefaultRenderer;

	import org.achartengine.renderer.SimpleSeriesRenderer;

	import android.content.Context;

	import android.content.Intent;

	import android.graphics.Color;

	import android.app.Activity;

	import android.os.Bundle;

 

	public class MainActivity extends Activity {

 

    @Override

    public void onCreate(Bundle savedInstanceState) {

       super.onCreate(savedInstanceState);

          Intent intent = buildIntent();

        startActivity(intent);          // шаг 7

    }

 

    public Intent buildIntent() {

        int[] values = new int[] { 5, 15, 25, 50, 75 };        // шаг 2

        String[] bars = new String[] {"Francesca's",  "King of Clubs", 

                                 "Zen Lounge", "Tied House", "Molly Magees"};

        int[] colors = new int[] { Color.BLUE, Color.GREEN, Color.MAGENTA, 

                                   Color.YELLOW, Color.CYAN };

 

        CategorySeries series = new CategorySeries("Pie Chart");  // шаг 3

        DefaultRenderer dr = new DefaultRenderer();   // шаг 4

 

        for (int v=0; v<5; v++){    // шаг 5

            series.add(bars[v], values[v]);

            SimpleSeriesRenderer r = new SimpleSeriesRenderer();

            r.setColor(colors[v]);

            dr.addSeriesRenderer(r);

        }

        dr.setZoomButtonsVisible(true);

        dr.setZoomEnabled(true);

        dr.setChartTitleTextSize(20);

        return ChartFactory.getPieChartIntent(    // шаг 6

                              this, series, dr, "Pie of bars");

    }

 

	}






Мы построили диаграмму PieChartIntent, однако подобным образом можно построить и другие виды графиков. Мне библиотека показалась довольно удобной и понятной. Ее можно использовать, если необходимо быстро разработать какое-нибудь бизнес-приложение со строгим дизайном.







Если вам понравилось, пишите комментарии и подписывайтесь на наши обновления.


Всем привет.





С вами снова я. И сегодня мы поговорим, как показывать HTML код в TextView.





Если все готовы. Тогда приступим.


<!-- more -->


Вам необходимо вызвать функцию:







	TextView txtView = new TextView(this);

	Spanned s = Html.fromHtml("Android - это супер <font color=\"red\">android-helper.com.ua</font>");

	txtView.setText(s);









Вот полный код:






	public class TestActivity extends Activity {

 

    @Override

    public void onCreate(Bundle savedInstanceState) {

        super.onCreate(savedInstanceState);

        TextView txtView = new TextView(this);

        Spanned s = Html.fromHtml("Android - это супер <font color=\"red\">android-helper.com.ua</font>");

        txtView.setText(s);

 

        setContentView(txtView);

    }

	}







Все готово. Теперь можете наслаждаться.





Но нужно помнить, что так можно отформатировать не все HTML теги.





Вот список тегов, которые поддерживает класс **Html**.








  * a href="...",



  * b,



  * big,



  * blockquote,



  * br,



  * cite,



  * dfn,



  * div align="...",



  * em,



  * font size="..." color="..." face="...",



  * h1-h6,



  * i,



  * img src="...",



  * p,



  * small,



  * strike,



  * strong,



  * sub,



  * sup,



  * tt,



  * u



Недавно столкнулся с задачей - сделать приложение для android 4 с его интерфейсом.





Все было супер, пока я не запустил на android 2.3. И там увидел, что таких стилей нету.





Покопав просторы интернета. Я нашел такую [статью](http://findevelop.blogspot.com/2012/06/android-android-4.html#more)





Но так как я на своем блоге собираю всю полезную информацию. Я ее продублирую у себя на блоге.





Прошу к прочтению:

 <!-- more -->



![](http://android-helper.com.ua/images/uploads/2012/09/holo.jpg)




Ничто так не портит настроение программиста, как необходимость заниматься вместо программирования чем-то другим. Например, дизайном. Но приложение без дизайна в наше время  обречено на забвение избалованных пользователей. Как же быть? А давайте нашим формам и кнопочкам "выдадим" стандартный стиль Android Ice Cream Sandwich. Пусть наши пользователи, которые пока ещё не обновились до последней версии Android наслаждаются стильным дизайном и проникаются к нашему приложению тёплыми чувствами. В этом добром деле нам поможет библиотека [HoloEverywhere](https://github.com/ChristopheVersieux/HoloEverywhere). Использовать всю библиотеку мы не будем, нам хватит и одной темы, например моей любимой HoloEverywhereDark. А прикрутим к проекту мы её ручками, попутно изучив механизм "стилизации" Android-приложений.   
  
**Стили - это просто**  
  
В res/values/ нашего проекта создаём файл styles.xml, где мы будем описывать стили для всех контролов в нашей теме. Описывать - это громко сказано: мы просто скопируем аналогичный файл из библиотеки HoloEverywhere, удалив лишние стили. Картинки для HoloEverywhereDark копируем в свои каталоги drawable-mdpi, drawable-hdpi и drawable-xhdpi. Название всех нужных файлов заканчивается на "dark".   
Кроме картинок нам понадобятся xml-файлы описания ресурсов, напрмер цветов. Их складываем в каталог drawable. Больше нам из библиотеки HoloEverywhere ничего не понадобится.  
Посмотрим подробнее в наш styles.xml. Например:



	<style name="ButtonHoloDark" parent="android:style/Widget.Button">

 	<item name="android:background">@drawable/btn_default_holo_dark</item>

 	<item name="android:textColor">#ffffff</item>

	</style>








В этом фрагменте мы видим описание стиля кнопки с именем ButtonHoloDark. Тег style имеет обязательный атрибут name и необязательный parent. Именно parent позволяет нам реализовать иерархию стилей элементов интерфейса Android-приложений. В данном случае мы наследуем стиль стандартной кнопки и переопределяем в нашем новом стиле два item-а: цвет фона и цвет текста. Цвет можно задавать как комбинацией rgb (как в html), так и ссылкой на xml-ресурс. В данном случае для фона кнопки это файл btn_default_holo_dark.xml в каталоге drawable. Посмотрим в него и поймём почему используется xml-ресурс вместо обычного описания цвета:




	<selector xmlns:android="http://schemas.android.com/apk/res/android">

    <item android:drawable="@drawable/btn_default_normal_holo_dark" android:state_enabled="true" android:state_window_focused="false"/>

    <item android:drawable="@drawable/btn_default_disabled_holo_dark" android:state_enabled="false" android:state_window_focused="false"/>

    <item android:drawable="@drawable/btn_default_pressed_holo_dark" android:state_pressed="true"/>

    <item android:drawable="@drawable/btn_default_focused_holo_dark" android:state_enabled="true" android:state_focused="true"/>

    <item android:drawable="@drawable/btn_default_normal_holo_dark" android:state_enabled="true"/>

    <item android:drawable="@drawable/btn_default_disabled_focused_holo_dark" android:state_focused="true"/>

    <item android:drawable="@drawable/btn_default_disabled_holo_dark"/>

	</selector>






Тут описано несколько цветов, которые назначаются фону кнопки в зависимости от её состояния. Эти цвета уже не xml-ресурсы а обычные изображения (некоторые в формате nine-patch, оптимизированном для "растягивания").  
И так мы дошли до подножия "пирамиды стилей". А что же наверху?  
Мы, безусловно можем назначить готовый стиль кнопке в нашем xml-layout или в коде. Но зачем этот утомительный процесс? Назначить стиль всем элементам интерфейса в приложении можно одной инструкцией в AndroidManifest.xml:





	android:theme="@style/Theme.HoloEverywhereDark"






в теге application.  
Так мы устанавливаем "тему", которая описывается в том же styles.xml.  
Отличие от обычного описания стиля только в том, что стиль кнопки определяет в item-ах её свойства, а item-ами темы является сама кнопка и другие элементы интерфейса. Например:






	<style name="Theme.HoloEverywhereDark" parent="android:Theme.NoTitleBar">

       ...

       <item name="android:buttonStyle">@style/ButtonHoloDark</item>

       ...

	</style>







Вот тут мы и связываем тему с стилем отдельного элемента, который мы видели вначале. Как видите, использовать стили в приложении для Android ничуть не сложнее, чем в web-страницах. 





Надеюсь вам понравилась статья.





Если это так, тогда ваши комментарии будут кстати. :)
Добрый день друзья.





Очень много программистов сейчас сталкиваются с много язычными приложениями.





Я решил поделится опытом работы с такими приложениями.


<!-- more -->


Есть 2 подхода разработки таких приложений.








  1. Язык приложения зависит от языка системы



  2. Возможность менять язык в самом приложении






Ну что приступим.





### Язык приложения зависит от языка системы





В android для реализации данного подхода, используется следующая структура вложения папок.





![](http://android-helper.com.ua/images/uploads/2012/09/m1.png)





Тут все просто, создаем папку с расширением ru (Для России), fr - Франции и так далее.





Больше информации вы можете получить [тут](http://developer.android.com/intl/ru/training/basics/supporting-devices/languages.html).







strings.xml - с папки values





	<resources>



    <string name="app_name">multilanguage</string>

    <string name="hello_world">Hello world!</string>

    <string name="menu_settings">Settings</string>

    <string name="title_activity_main">MainActivity</string>



	</resources>










strings.xml - с папки values-ru









	<resources>



    <string name="app_name">multilanguage</string>

    <string name="hello_world">Привет Мир!</string>

    <string name="menu_settings">Настройки</string>

    <string name="title_activity_main">Главное активити</string>



	</resources>







### Возможность менять язык в самом приложении





Вот тут более интересней тема.





Для того что бы приложение на лету поменяло язык нужно сделать следующее.





Создаем файл который наследуется от Application.





	package com.example.multilanguage;



	import java.util.Locale;



	import android.app.Application;

	import android.content.res.Configuration;



	public class MyApp extends Application {



	private Locale locale = null;



	@Override

	public void onConfigurationChanged(Configuration newConfig) {

		super.onConfigurationChanged(newConfig);

		if (locale != null) {

			newConfig.locale = locale;

			Locale.setDefault(locale);

			getBaseContext().getResources().updateConfiguration(newConfig,

					getBaseContext().getResources().getDisplayMetrics());

		}

	}



	@Override

	public void onCreate() {

		super.onCreate();



		Configuration config = getBaseContext().getResources().getConfiguration();



		String lang = "ru";

		if (!"".equals(lang) && !config.locale.getLanguage().equals(lang)) {

			locale = new Locale(lang);

			Locale.setDefault(locale);

			config.locale = locale;

			getBaseContext().getResources().updateConfiguration(config,

					getBaseContext().getResources().getDisplayMetrics());

		}

	}



	}





Вот и все.





Теперь если вам нужно изменить язык при нажатии на кнопку вызываете просто:






	Configuration config = getBaseContext().getResources().getConfiguration();



		String lang = "ru";

		if (!"".equals(lang) && !config.locale.getLanguage().equals(lang)) {

			locale = new Locale(lang);

			Locale.setDefault(locale);

			config.locale = locale;

			getBaseContext().getResources().updateConfiguration(config,

					getBaseContext().getResources().getDisplayMetrics());

		}







Если вам понравилась статья пишите комментарии и рассказывайте друзьям.





Коды вы можете скачать [тут](http://android-helper.com.ua/forms)
При разработке приложения порой бывает необходимо выполнять какие-то действия в будущем. Например, вы хотите создать будильник или периодически отправлять данные на свой сайт в строго определенное время. Для решения подобных задач в Android используется класс**AlarmManager**, который позволяет выполнять код в требуемый момент времени, даже если ваше приложение не запущено. То-есть AlarmManager - аналог corn в Linux или планировщика задач Windows. Вы говорите, что такой-то кусок кода должен выполниться тогда-то и AlarmManager обеспечивает запуск кода. В англоязычный литературе таймер, который выполняет код в требуемый момент времени обозначается термином**alarm**. Давайте в рамках данной статьи называть этот таймер**будильником**, чтобы отделить это понятие от таймера.



 <!-- more -->

## Несколько слов о классе AlarmManager





Фактически класс AlarmManager обеспечивает доступ к сервису планировки задач Android. Для получения объекта этого класса нужно вызвать метод **Context.getSystemService(Context.ALARM_SERVICE)**. **AlarmManager** регистрирует в системе интент и когда наступает обозначенное время, AlarmManager запускает этот интент. Если момент вызова приложение закрыто, то оно будет вновь запущено. AlarmManager нужно использовать только в случае, если код должен быть выполнен даже при закрытом приложении, во всех других случаях рекомендуется использовать класс **Handler**.  
  
Класс AlarmManager довольно прост. В нашем распоряжении шесть методов:  
  









  * **void cancel(PendingIntent operation)** - отменяет установленный таймер для переданного в качестве параметра интента.



  * **void set (int type, long triggerAtMillis, PendingIntent operation)** - устанавливает будильник, который сработает один раз.



  * **void setInexactRepeating (int type, long triggerAtMillis, long intervalMillis, PendingIntent operation)** - установка будильника с неточным повторением.



  * **setRepeating(int type, long triggerAtMillis, long intervalMillis, PendingIntent operation)**- установка будильника с точным повторением.



  * **setTime(long millis)** - установка системного времени.



  * **setTimeZone(String timeZone)** - установка временной зоны, выбранной по-умолчанию.






  
Здесь **PendingIntent**- класс, который представляет интент и связанное с его выполнением действие. Передавая PendingIntent другому приложению Вы тем самым даете ему право запускать кусок кода из своей программы.  
  
В качестве типа будильника (параметр **type**) может быть передано одно из значений ELAPSED_REALTIME, ELAPSED_REALTIME_WAKEUP, RTC и RTC_WAKEUP. ELAPSED_REALTIME и ELAPSED_REALTIME_WAKEUP - время задается с момента загрузки устройства, а RTC и RTC_WAKEUP - системное время в UTC. Для ELAPSED_REALTIME и RTC если устройство находится в спящем режиме в момент срабатывания будильника, то связанный с ним интент будет вызван позже, когда пользователь выведет устройство из спящего режима. Для ELAPSED_REALTIME_WAKEUP и RTC_WAKEUP если устройство находится в спящем режиме, оно немедленно пробуждается и вызывается интент.





## Программируем приложение-будильник для Android





Давайте в качестве примера разработаем приложение - будильник. При запуске программы пользователю будет показано окно с тремя кнопками. С их помощью пользователь сможет: установить будильник, который срабатывает один раз; будильник, который будет срабатывать периодически; а также удалить ранее установленные будильники. 





![](http://android-helper.com.ua/images/uploads/2012/09/device-2012-09-10-172549.png)



Создадим новый проект в макет шаблона добавим три кнопки





	<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"

    xmlns:tools="http://schemas.android.com/tools"

    android:layout_width="match_parent"

    android:layout_height="match_parent"

    android:orientation="vertical" >



    <Button

        android:id="@+id/btStart"

        android:layout_width="match_parent"

        android:layout_height="wrap_content"

        android:onClick="startRepeatingTimer"

        android:padding="@dimen/padding_medium"

        android:text="Start"

        tools:context=".WidgetAlarmManagerActivity" />



    <Button

        android:id="@+id/btCancel"

        android:layout_width="match_parent"

        android:layout_height="wrap_content"

        android:onClick="cancelRepeatingTimer"

        android:padding="@dimen/padding_medium"

        android:text="Cancel"

        tools:context=".WidgetAlarmManagerActivity" />



    <Button

        android:id="@+id/btOneTime"

        android:layout_width="match_parent"

        android:layout_height="wrap_content"

        android:onClick="onetimeTimer"

        android:padding="@dimen/padding_medium"

        android:text="One Time"

        tools:context=".WidgetAlarmManagerActivity" />



	</LinearLayout>



Кнопка **btStart** устанавливает повторяющийся будильник, кнопка **btCancel**- отменяет его. Кнопка **btOneTime**- создает не повторяющийся будильник. Прямо в шаблоне мы указали методы, которые будут вызываться при нажатии на кнопки: startRepeatingTimer, cancelRepeatingTimer и onetimeTimer соответственно. Код этих методов будут приведен в классе Activity.  
   
Для работы с **AlarmManager** напишем отдельный класс. В качестве базового класса используем BroadcastReciever. Наш класс будет управлять зарегистрированным с помощью AlarmManager интентом. Мы переопределим метод **onReceive()**, который будет вызываться после получения интента. Внутри метод onReceive() мы должны попытаться получить связанные с интентом параметры. В своей программе мы будем использовать один параметр ONE_TIME, который позволяет определить, относится ли интент к однократно срабатывающему будильнику или нет. После того, как значение ONE_TIME получено, пользователю показывается соответствующее сообщение.   
   
Также в этом классе определим методы setAlarm(), cancelAlarm() и onetimeTimer(). Конечно эти методы можно было определить и в другом месте, мы включили их в данный класс из соображения простоты примера.








  * Метод setAlarm() устанавливает повторяющийся будильник с помощью метода setRepeating(). Этому методу требуется четыре параметра: тип будильника, время запуска (устанавливаем текущий момент), интервал в миллисекундах, интент, который будет вызываться при срабатывании будильника.



  * Метод cancelAlarm() отменяет зарегистрированный ранее будильник с помощью вызова метода cancel(), которому перезается в качестве параметра интент. При совпадении этого параметра с зарегистрированным ранее интентом, произойдет удаление будильника.



  * Метод onetimeTimer() создает будильник, который срабатывает один раз. Делается с помощью метода set(), которому передается три параметра: тип будильника, время запуска, вызываемый интент.


		package com.example.alarm;

		import java.text.Format;

		import java.text.SimpleDateFormat;

		import java.util.Date;

		import android.app.AlarmManager;

		import android.app.PendingIntent;

		import android.content.BroadcastReceiver;

		import android.content.Context;

		import android.content.Intent;

		import android.os.Bundle;

		import android.os.PowerManager;

		import android.widget.Toast;

		public class AlarmManagerBroadcastReceiver extends BroadcastReceiver {



		final public static String ONE_TIME = "onetime";



		@Override

		public void onReceive(Context context, Intent intent) {

		PowerManager pm = (PowerManager) context.getSystemService(Context.POWER_SERVICE);

		PowerManager.WakeLock wl = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "YOUR TAG");

		// Осуществляем блокировку

		wl.acquire();



		// Здесь можно делать обработку.

		Bundle extras = intent.getExtras();

		StringBuilder msgStr = new StringBuilder();



		if (extras != null && extras.getBoolean(ONE_TIME, Boolean.FALSE)) {

			// проверяем параметр ONE_TIME, если это одиночный будильник,

			// выводим соответствующее сообщение.

			msgStr.append("Одноразовый будильник: ");

		}

		Format formatter = new SimpleDateFormat("hh:mm:ss a");

		msgStr.append(formatter.format(new Date()));



		Toast.makeText(context, msgStr, Toast.LENGTH_LONG).show();



		// Разблокируем поток.

		wl.release();

		}



		public void SetAlarm(Context context) {

		AlarmManager am = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);

		Intent intent = new Intent(context, AlarmManagerBroadcastReceiver.class);

		intent.putExtra(ONE_TIME, Boolean.FALSE); // Задаем параметр интента

		PendingIntent pi = PendingIntent.getBroadcast(context, 0, intent, 0);

		// Устанавливаем интервал срабатывания в 5 секунд.

		am.setRepeating(AlarmManager.RTC_WAKEUP, System.currentTimeMillis(), 1000 * 5, pi);

		}



		public void CancelAlarm(Context context) {

		Intent intent = new Intent(context, AlarmManagerBroadcastReceiver.class);

		PendingIntent sender = PendingIntent.getBroadcast(context, 0, intent, 0);

		AlarmManager alarmManager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);

		alarmManager.cancel(sender); // Отменяем будильник, связанный с интентом данного класса

		}



		public void setOnetimeTimer(Context context) {

		AlarmManager am = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);

		Intent intent = new Intent(context, AlarmManagerBroadcastReceiver.class);

		intent.putExtra(ONE_TIME, Boolean.TRUE); // Задаем параметр интента

		PendingIntent pi = PendingIntent.getBroadcast(context, 0, intent, 0);

		am.set(AlarmManager.RTC_WAKEUP, System.currentTimeMillis(), pi);

		}

		}







Ниже приводится файл манифеста. Обратите внимание, для корректной работы программе необходимо дать разрешение**WAKE_LOCK**, поскольку мы используем блокировку потока в методе onReceive(). Также тут мы регистрируем AlarmManagerBroadcastReceiver, как получатель широковещательных сообщений


	<manifest xmlns:android="http://schemas.android.com/apk/res/android"

    package="com.example.alarm"

    android:versionCode="1"

    android:versionName="1.0" >



    <uses-sdk

        android:minSdkVersion="8"

        android:targetSdkVersion="15" />



    <uses-permission android:name="android.permission.WAKE_LOCK" />



    <application

        android:icon="@drawable/ic_launcher"

        android:label="@string/app_name"

        android:theme="@style/AppTheme" >

        <activity

            android:name=".MainActivity"

            android:label="@string/title_activity_main" >

            <intent-filter>

                <action android:name="android.intent.action.MAIN" />



                <category android:name="android.intent.category.LAUNCHER" />

            </intent-filter>

        </activity>



        <receiver android:name="AlarmManagerBroadcastReceiver" >

        </receiver>

    </application>



	</manifest>






Теперь давайте напишем класс, в котором реализуем обработчики кнопок. Здесь мы создадим экземпляр описанного выше класса AlarmManagerBroadcastReciever и будем вызывать методы setAlarm(), cancelAlarm() и setOnetime(). 




	package com.example.alarm;



	import android.app.Activity;

	import android.content.Context;

	import android.os.Bundle;

	import android.view.Menu;

	import android.view.View;

	import android.widget.Toast;



	public class MainActivity extends Activity {



	private AlarmManagerBroadcastReceiver alarm;



	@Override

	public void onCreate(Bundle savedInstanceState) {

		super.onCreate(savedInstanceState);

		setContentView(R.layout.activity_main);

		alarm = new AlarmManagerBroadcastReceiver();

	}



	@Override

	protected void onStart() {

		super.onStart();

	}



	public void startRepeatingTimer(View view) {

		Context context = this.getApplicationContext();

		if (alarm != null) {

			alarm.SetAlarm(context);

		} else {

			Toast.makeText(context, "Alarm is null", Toast.LENGTH_SHORT).show();

		}

	}



	public void cancelRepeatingTimer(View view) {

		Context context = this.getApplicationContext();

		if (alarm != null) {

			alarm.CancelAlarm(context);

		} else {

			Toast.makeText(context, "Alarm is null", Toast.LENGTH_SHORT).show();

		}

	}



	public void onetimeTimer(View view) {

		Context context = this.getApplicationContext();

		if (alarm != null) {

			alarm.setOnetimeTimer(context);

		} else {

			Toast.makeText(context, "Alarm is null", Toast.LENGTH_SHORT).show();

		}

	}



	@Override

	public boolean onCreateOptionsMenu(Menu menu) {

		getMenuInflater().inflate(R.menu.activity_main, menu);

		return true;

	}



	}





При надатии на кнопки будут установлен будильник.





Комментируем и подписываемся на обновления.





Коды вы можете скачать [тут](http://android-helper.com.ua/forms)
Добрый день.




Сегодня речь пойдет о Service, IntentService и Foreground.




Попробуем сегодня разобрать, что это такое и как оно работает.




Я решил не выдумывать велосипед, и взял уже готовую [статью](http://startandroid.ru/uroki/vse-uroki-spiskom/165-urok-100-service-intentservice-foreground-avtozagruzka-servisa.html).




Прошу к прочтению.

<!-- more -->


В этом уроке:




- изучаем IntentService  
- включаем режим Foreground для сервиса  
- помещаем сервис в автозагрузку




Строили мы, строили, и, наконец, построили. Урок номер 100, с чем всех нас и поздравляю )




В этом уроке рассмотрим еще несколько полезных вещей про сервисы. Выносить каждую из них в отдельный урок я не стал, вполне можно в одном все рассмотреть. Проекты здесь тоже создавать не будем, чтобы урок не получился слишком громоздким. Я просто приведу некоторые куски кода и скрины для наглядности своих рассуждений. А если у вас будет желание, вы по этим наработкам сами можете создать проекты-примеры.




 **IntentService**




 Это подкласс обычного Service. Он используется, если вам в сервисе надо выполнять какие-то тяжелые задачи, и вы не хотите сами возиться с асинхронностью. Принцип работы этого вида сервиса прост. Он создает новый поток для своей работы. Затем берет все Intent пришедшие ему в onStartCommand и отправляет их на обработку в этот поток. Как именно обрабатываются Intent – зависит от нас, т.к. мы сами кодим это в методе onHandleIntent.




Т.е. приложение сыпет в сервис вызовами startService, в которых передает Intent-ы. [IntentService ](http://developer.android.com/reference/android/app/IntentService.html)принимает эти вызовы в onStartCommand, берет Intent-ы и отправляет их в очередь на обработку. И далее они поочередно обрабатываются в отдельном процессе методом [onHandleIntent](http://developer.android.com/reference/android/app/IntentService.html#onHandleIntent(android.content.Intent)). Когда последний Intent из очереди обработан, процесс сам завершает свою работу.




Пример




В приложении делаем три вызова:


	Intent intent = new Intent(this, MyService.class);
	startService(intent.putExtra("time", 3).putExtra("label", "Call 1"));
	startService(intent.putExtra("time", 1).putExtra("label", "Call 2"));
	startService(intent.putExtra("time", 4).putExtra("label", "Call 3"));






Где **time **– это время паузы, которую будем делать в сервисе, а **label **– просто метка, чтобы отличать вызовы.




Код сервиса:


	package com.example.service;

	import java.util.concurrent.TimeUnit;

	import android.app.IntentService;
	import android.content.Intent;
	import android.util.Log;

	public class MyService extends IntentService {

	final String LOG_TAG = "myLogs";

	public MyService() {
		super("myname");
	}

	@Override
	public void onCreate() {
		super.onCreate();
		Log.d(LOG_TAG, "onCreate");
	}

	@Override
	protected void onHandleIntent(final Intent intent) {
		int tm = intent.getIntExtra("time", 0);
		String label = intent.getStringExtra("label");
		Log.d(LOG_TAG, "onHandleIntent start " + label);
		try {
			TimeUnit.SECONDS.sleep(tm);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		Log.d(LOG_TAG, "onHandleIntent end " + label);
	}

	@Override
	public void onDestroy() {
		super.onDestroy();
		Log.d(LOG_TAG, "onDestroy");
	}

	}


Здесь необходим конструктор, в котором вызываем конструктор супер-класса и указываем какое-нить имя. Оно будет использовано для наименования потока.




В методе onHandleIntent кодим обработку Intent-ов. Достаем из них time и label, запускаем паузу на time секунд и выводим в лог label в начале и в конце.




В итоге, при запуске в логах видим:




	11:07:37.880: D/myLogs(4137): onCreate  
	11:07:37.880: D/myLogs(4137): onHandleIntent start Call 1  
	11:07:40.880: D/myLogs(4137): onHandleIntent end Call 1  
	11:07:40.880: D/myLogs(4137): onHandleIntent start Call 2  
	11:07:41.880: D/myLogs(4137): onHandleIntent end Call 2  
	11:07:41.880: D/myLogs(4137): onHandleIntent start Call 3  
	11:07:45.890: D/myLogs(4137): onHandleIntent end Call 3  
	11:07:45.890: D/myLogs(4137): onDestroy_




Сервис создался, вызовы выполнились по очереди и сервис завершил работу. От нас понадобилось только накодить обработку.




### **Foreground**




Вы можете сказать системе, что ваш сервис очень важен для пользователя и его нельзя грохать при нехватке памяти. Это актуально, например, для музыкального плеера. В статус-бар при этом будет помещено уведомление.




Делается это методом [startForeground(int id, Notification notification)](http://developer.android.com/reference/android/app/Service.html#startForeground(int, android.app.Notification)).




На вход он принимает те же параметры, что и NotificationManager.notify – ID и Notification.




Т.е. вы создаете уведомление, назначаете ему ID и передаете это в startForeground. Сервис переходит в режим [IDDQD](http://lurkmore.to/IDDQD) :), а в статус-баре появилось уведомление.




![](http://android-helper.com.ua/images/uploads/2012/09/L0100_010.jpg)



Оно появилось в разделе для постоянных уведомлений (Ongoing). 




Метод [stopForeground (boolean removeNotification)](http://developer.android.com/reference/android/app/Service.html#stopForeground(boolean))  - возвращает сервису способность быть убитым системой в случае острой нехватки памяти. А на вход он принимает boolean-значение – удалять уведомление из статус-бара или нет.




Уведомление также пропадет, когда сервис будет остановлен.




Эти методы работают, начиная с Android 2.0.  Пример реализации для более ранних версий есть в [хелпе](http://developer.android.com/reference/android/app/Service.html#startForeground(int, android.app.Notification)).




Напомню, что уведомления мы научились создавать на прошлом уроке.




### **Автозагрузка**




Сервисы для получения погоды или почты имеет смысл помещать в автозагрузку. Для этого нам надо создать [BroadcastReceiver](http://developer.android.com/reference/android/content/BroadcastReceiver.html), настроить его IntentFilter на Action =**android.intent.action.BOOT_COMPLETED**, и добавить права **android.permission.RECEIVE_BOOT_COMPLETED**. Этот BroadcastReceiver будет вызван системой при старте системы и в нем мы кодим запуск сервиса.




Допустим, есть проект с сервисом MyService.




Создаем в проекте класс **MyBroadReceiv**


	package com.example.service;

	import android.content.BroadcastReceiver;
	import android.content.Context;
	import android.content.Intent;
	import android.util.Log;

	public class MyBroadReceiv extends BroadcastReceiver {

	final String LOG_TAG = "myLogs";

	@Override
	public void onReceive(final Context context, final Intent intent) {
		Log.d(LOG_TAG, "onReceive " + intent.getAction());
		context.startService(new Intent(context, MyService.class));
	}
	}


В манифесте добавляем его как **Receiver **и настраиваем фильтр

![](http://android-helper.com.ua/images/uploads/2012/09/L0100_020.jpg)




 




Добавляем права на получение сообщения о загрузке




![](http://android-helper.com.ua/images/uploads/2012/09/L0100_030.jpg)


Инсталлим проект на AVD. Закрываем AVD. Запускаем через меню в Eclipse: Window > AVD Manager. Находим там наш эмулятор и запускаем вручную.




Когда он запустился, смотрим логи




	_onReceive android.intent.action.BOOT_COMPLETED  
	MyService onCreate  
	MyService onStartCommand_




Сработал BroadcastReceiver и запустил сервис.







Если после запуска AVD логи не отображаются, то откройте DDMS и во вкладке Devices явно выберите ваш AVD.




Надеюсь вам понравилась статья.




Ожидаю ваших комментариев.




Коды вы можете скачать [тут](http://android-helper.com.ua/forms)
Добрый день друзья.





Продолжая собирать у себя на сайте различного рода ценную информацию.





Я решил продолжить описание работы с fragments.





И как всегда на помощь мне пришла статья одного известного сайта.


<!-- more -->


Оригинал статьи [тут](http://startandroid.ru/uroki/vse-uroki-spiskom/175-urok-105-android-3-fragments-dinamicheskaja-rabota.html).





Прошу к прочтению.





В этом уроке:





- динамически работаем с фрагментами





Размещать статические фрагменты мы уже умеем. Но, ясно дело, что гораздо интереснее работать с ними динамически. Система позволяет нам добавлять, удалять и заменять фрагменты друг другом. При этом мы можем сохранять все эти манипуляции в BackStack и кнопкой Назад отменять. В общем, все удобно и красиво.





Создадим простое приложение с двумя  фрагментами, которое будет уметь:





- добавлять первый фрагмент  
- удалять первый фрагмент  
- заменять первый фрагмент вторым фрагментом  
- переключать режим сохранения в BackStack операций с фрагментами





В **strings.xml** добавим строки:


		<string name="frag1_text">Fragment 1</string>

    <string name="frag2_text">Fragment 2</string>

    <string name="add">Add</string>

    <string name="remove">Remove</string>

    <string name="replace">Replace</string>

    <string name="stack">add to Back Stack</string>







Создаем фрагменты. Как мы помним из прошлого урока, для этого нам нужны будут layout-файлы и классы, наследующие android.app.Fragment





 **fragment1.xml**:




	<?xml version="1.0" encoding="utf-8"?>

	<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"

    android:layout_width="match_parent"

    android:layout_height="match_parent"

    android:background="#77ff0000"

    android:orientation="vertical" >



    <TextView

        android:layout_width="wrap_content"

        android:layout_height="wrap_content"

        android:text="@string/frag1_text" >

    </TextView>



	</LinearLayout>







**fragment2.xml:**






	<?xml version="1.0" encoding="utf-8"?>

	<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"

    android:layout_width="match_parent"

    android:layout_height="match_parent"

    android:background="#7700ff00"

    android:orientation="vertical" >



    <TextView

        android:layout_width="wrap_content"

        android:layout_height="wrap_content"

        android:text="@string/frag2_text" >

    </TextView>



	</LinearLayout>






**Fragment1.java**:






	package com.example.fragmetns2;



	import android.os.Bundle;

	import android.support.v4.app.Fragment;

	import android.view.LayoutInflater;

	import android.view.View;

	import android.view.ViewGroup;

	public class Fragment1 extends Fragment {



	@Override

	public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {

		return inflater.inflate(R.layout.fragment1, null);

	}

	}









**Fragment2.java**:


	package com.example.fragmetns2;


	import android.os.Bundle;

	import android.support.v4.app.Fragment;

	import android.view.LayoutInflater;

	import android.view.View;

	import android.view.ViewGroup;



	public class Fragment2 extends Fragment {



	@Override

	public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {

		return inflater.inflate(R.layout.fragment2, null);

	}

	}


Все почти аналогично прошлому уроку, только убрали вызовы кучи lifecycle методов с логами.









Рисуем основное Activity.





**activity_main.xml**:



	<?xml version="1.0" encoding="utf-8"?>

	<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"

    xmlns:tools="http://schemas.android.com/tools"

    android:id="@+id/LinearLayout1"

    android:layout_width="match_parent"

    android:layout_height="match_parent"

    android:orientation="vertical" >



    <LinearLayout

        android:layout_width="wrap_content"

        android:layout_height="wrap_content"

        android:orientation="vertical" >



        <Button

            android:id="@+id/btnAdd"

            android:layout_width="wrap_content"

            android:layout_height="wrap_content"

            android:onClick="onClick"

            android:text="@string/add" >

        </Button>



        <Button

            android:id="@+id/btnRemove"

            android:layout_width="wrap_content"

            android:layout_height="wrap_content"

            android:onClick="onClick"

            android:text="@string/remove" >

        </Button>



        <Button

            android:id="@+id/btnReplace"

            android:layout_width="wrap_content"

            android:layout_height="wrap_content"

            android:onClick="onClick"

            android:text="@string/replace" >

        </Button>



        <CheckBox

            android:id="@+id/chbStack"

            android:layout_width="wrap_content"

            android:layout_height="wrap_content"

            android:text="@string/stack" >

        </CheckBox>

    </LinearLayout>



    <FrameLayout

        android:id="@+id/frgmCont"

        android:layout_width="match_parent"

        android:layout_height="match_parent" >

    </FrameLayout>



	</LinearLayout>






Три кнопки для добавления, удаления и замены фрагментов. Чекбокс для включения использования BackStack. И FrameLayout – это контейнер, в котором будет происходить вся работа с фрагментами. Он должен быть типа ViewGroup. А элементы Fragment, которые мы использовали на прошлом уроке для размещения фрагментов, нам не нужны для динамической работы. 





 **MainActivity.java**:


	package com.example.fragmetns2;



	import android.os.Bundle;

	import android.support.v4.app.FragmentActivity;

	import android.support.v4.app.FragmentTransaction;

	import android.view.View;

	import android.widget.CheckBox;



	public class MainActivity extends FragmentActivity {



	Fragment1 frag1;

	Fragment2 frag2;

	FragmentTransaction fTrans;

	CheckBox chbStack;



	@Override

	public void onCreate(Bundle savedInstanceState) {

		super.onCreate(savedInstanceState);

		setContentView(R.layout.activity_main);



		frag1 = new Fragment1();

		frag2 = new Fragment2();



		chbStack = (CheckBox) findViewById(R.id.chbStack);

	}



	public void onClick(View v) {

		fTrans = getSupportFragmentManager().beginTransaction();

		switch (v.getId()) {

			case R.id.btnAdd:

				fTrans.add(R.id.frgmCont, frag1);

				break;

			case R.id.btnRemove:

				fTrans.remove(frag1);

				break;

			case R.id.btnReplace:

				fTrans.replace(R.id.frgmCont, frag2);

			default:

				break;

		}

		if (chbStack.isChecked()) {

			fTrans.addToBackStack(null);

		}

		fTrans.commit();

	}

	}






В **onCreate** создаем пару фрагментов и находим чекбокс.





В **onClick** мы получаем менеджер фрагментов с помощью метода [getFragmentManager](http://developer.android.com/reference/android/app/Activity.html#getFragmentManager()). Этот объект является основным для работы с фрагментами. Далее, чтобы добавить/удалить/заменить фрагмент, нам необходимо использовать транзакции. Они аналогичны транзакциям в БД, где мы открываем транзакцию, производим операции с БД, выполняем commit. Здесь мы открываем транзакцию, производим операции с фрагментами (добавляем, удаляем, заменяем), выполняем commit.





Итак, мы получили FragmentManager и открыли транзакцию методом [beginTransaction](http://developer.android.com/reference/android/app/FragmentManager.html#beginTransaction()). Далее определяем, какая кнопка была нажата:





если **Add**, то вызываем метод [add](http://developer.android.com/reference/android/app/FragmentTransaction.html#add(int, android.app.Fragment)), в который передаем id контейнера (тот самый FrameLayout из main.xml) и объект фрагмента. В итоге, в контейнер будет помещен Fragment1





если **Remove**, то вызываем метод [remove](http://developer.android.com/reference/android/app/FragmentTransaction.html#remove(android.app.Fragment)), в который передаем объект фрагмента, который хотим убрать. В итоге, фрагмент удалится с экрана.





если **Replace**, то вызываем метод [replace](http://developer.android.com/reference/android/app/FragmentTransaction.html#replace(int, android.app.Fragment)), в который передаем id контейнера и объект фрагмента. В итоге, из контейнера удалится его текущий фрагмент (если он там есть) и добавится фрагмент, указанный нами.





Далее проверяем чекбокс. Если он включен, то добавляем транзакцию в BackStack. Для этого используем метод [addToBackStack](http://developer.android.com/reference/android/app/FragmentTransaction.html#addToBackStack(java.lang.String)). На вход можно подать строку-тэг. Я передаю null.





Ну и вызываем [commit](http://developer.android.com/reference/android/app/FragmentTransaction.html#commit()), транзакция завершена.





Давайте смотреть, что получилось. Все сохраняем, запускаем приложение.





![](http://android-helper.com.ua/images/uploads/2012/09/L0105_010.jpg)




Жмем **Add**





![](http://android-helper.com.ua/images/uploads/2012/09/L0105_020.jpg)





появился первый фрагмент.









Жмем **Remove**





![](http://android-helper.com.ua/images/uploads/2012/09/L0105_030.jpg)




фрагмент удалился.









Еще раз добавим первый фрагмент – жмем **Add**. И жмем **Replace**





![](http://android-helper.com.ua/images/uploads/2012/09/L0105_040.jpg)




первый фрагмент заменился вторым.





Жмем кнопку **Назад**. Приложение закрылось, т.к. все эти операции с фрагментами не сохранялись в BackStack. Давайте используем эту возможность.





Снова запускаем приложение и включаем чекбокс** add to Back Stack**





![](http://android-helper.com.ua/images/uploads/2012/09/L0105_050.jpg)



Выполняем те же операции: **Add**, **Remove**, **Add**, **Replace**. У нас добавится первый фрагмент, удалится первый фрагмент, добавится первый фрагмент, заменится вторым. В итоге мы снова видим второй фрагмент. Теперь жмем несколько раз кнопку **Назад **и наблюдаем, как выполняются операции, обратные тем, что мы делали. Когда транзакции, сохраненные в стеке закончатся, кнопка Назад закроет приложение.





Т.е. все достаточно просто и понятно. Скажу еще про пару интересных моментов.





Я в этом примере выполнял всего одну операцию в каждой транзакции. Но, разумеется, их может быть больше.





Когда мы удаляем фрагмент и не добавляем транзакцию в BackStack, то фрагмент уничтожается. Если же транзакция добавляется в BackStack, то, при удалении, фрагмент не уничтожается (onDestroy не вызывается), а останавливается (onStop).









В качестве самостоятельной работы: попробуйте немного изменить приложение и добавлять в один контейнер сразу два фрагмента. Возможно, результат вас удивит ) 





Надеюсь что вам понравилась статья.





Жду ваших комментариев.





Коды вы можете скачать [тут](http://android-helper.com.ua/forms)







От себя хочу также добавить, что коды которые я предоставляю, работают до 1.6 версии.


Продолжим описание android программирования.





Все вы наверное видели красивые widget у себя на рабочем столе телефона.





Вы угадали, сегодня речь пойдет именно о них.





Ну что поехали.


 <!-- more -->


Оригинал статьи [тут](http://www.mobilab.ru/articles/109/).





С начала этого года (прим. автора с 2007 года) команда разработчиков **Android** упорно работала над созданием нового релиза, который получил название**Android 1.5**. В его состав входит **AppWidget framework**, предназначенный для создания виджетов, которые пользователь может размещать на своем домашнем экране. Виджеты могут импортировать и отображать в удобной для пользователя форме информацию из Ваших Android приложений. Например, можно создать виджет, который будет отображать список невыполненных дел или давать информацию об играющей в фоновом режиме музыке.





![](http://android-helper.com.ua/images/uploads/2012/09/Awidget.png)





Когда пользователь перетаскивает виждет на домашний экран, он фактически резервирует место, на котором будет отображаться контент из Вашего приложения. Кроме того, пользователь может взаимодействовать с Вашим приложением через виджет, например, приостанавливать проигрывание музыки. Если у Вас есть сервис, работающий в фоновом режиме, Вы можете обновлять виджет по собственному графику, или использовать стандартный механизм из **AppWidget framework**.





Виджет представляет собой BroadcastReceiver скрещенный с XML описанием параметров виждета. **AppWidget framework**связывается с Вашим виджетом через радиовещание, когда требуется обновление. Обновления строятся и посылаются с помощью RemoteViews, включающий контент, для отображения на домашней странице.





Вы без особого труда можете создать виджет для своего приложения. Давайте создадим виджет для Android приложения "Слово дня" ([исходники](http://code.google.com/p/wiktionary-android/source/browse/#svn/trunk/SimpleWiktionary)). Я не буду рассматривать здесь это приложение, а сосредоточусь на самом виджете.





Прежде всего нужно создать XML описание виджета, указав там область домашнего экрана, которую Вы хотели бы зарезервировать для своего виджета, начальный слой для отображения, а также частоту обновления информации. Домашний экран **Android** разбит на ячейки, так что указанные вами размеры округляются до размеров ячеек. Это может сбить с толку. Возможно вам поможет вот эта формула





Минимальный размер в dip=(Число ячеек * 74dip)-2dip





В нашем примере мы хотим создать виджет, который будет занимать 2 ячейки в ширину и 1 в высоту. Это значит, что минимальный размер должен составлять 146dip x 72dip. Мы хотим, чтобы информация обновлялась раз в день, то есть через каждые 86,400,000 миллисекунд. XML metadata имеет вид:






	<appwidget-provider

    xmlns:android="http://schemas.android.com/apk/res/android"

    android:minWidth="146dip"

    android:minHeight="72dip"

    android:initialLayout="@layout/widget_message"

    android:updatePeriodMillis="86400000"

    />




Теперь давайте сопоставим эти XML данные и BroadcastReceiver в AndroidManifest:




	<!-- Broadcast Receiver that will process AppWidget updates -->

	<receiver android:name=".WordWidget" android:label="@string/widget_name">

    <intent-filter>

        <action android:name="android.appwidget.action.APPWIDGET_UPDATE" />

    </intent-filter>

    <meta-data android:name="android.appwidget.provider" android:resource="@xml/widget_word" />

	</receiver>



	<!-- Service to perform web API queries -->

	<service android:name=".WordWidget$UpdateService" />







Давайте напишем код для BroadcastReceiver, который будет управлять **AppWidget** запросами. Чтобы помочь виджету управлять различными радиовещательными событиями, разработчики написали класс **AppWidgetProvider**. Важно отметить, что мы запустим фоновый сервис, чтобы выполнять обновления. Это связано с тем, что BroadcastReceivers - потомок Application Not Responding (ANR) таймера, который может предложить пользователю закрыть приложение, если запрос выполняется слишком долго. Выполнение веб запроса может занимать несколько секунд, поэтому мы используем именно сервисы, чтобы избежать ANR таймаутов.



	/**

	 * Определяем простой виджет, который отображает слово дня. Для обновлений

	 * мы порождаем фоновой сервис {@link Service} для выполнения API запросов.

	 */

	public class WordWidget extends AppWidgetProvider {

    @Override

    public void onUpdate(Context context, AppWidgetManager appWidgetManager,

        int[] appWidgetIds) {

        // Чтобы предотвратить любые ANR таймацты, мы выполняем обновление в сервисе.

        context.startService(new Intent(context, UpdateService.class));

    }

 

    public static class UpdateService extends Service {

        @Override

        public void onStart(Intent intent, int startId) {

            // Выполняем сегодняшнее обновление виджета.

            RemoteViews updateViews = buildUpdate(this);

 

            // Помещаем обновление этого выджета на домашний экран

            ComponentName thisWidget = new ComponentName(this, WordWidget.class);

            AppWidgetManager manager = AppWidgetManager.getInstance(this);

            manager.updateAppWidget(thisWidget, updateViews);

        }

 

        /**

                     * Строим обновление виджета, чтобы показать текущее слово.

                     * Заблокируем пока не получим online ответ.

         */

        public RemoteViews buildUpdate(Context context) {

            // Берем название месяца из ресурсов

            Resources res = context.getResources();

            String[] monthNames = res.getStringArray(R.array.month_names);

 

            // ищем текущий месяц и день

            Time today = new Time();

            today.setToNow();

 

            // Заголовок страницы в вмде "Wiktionary:Word of the day/March 21"

            String pageName = res.getString(R.string.template_wotd_title,

                monthNames[today.month], today.monthDay);

            RemoteViews updateViews = null;

            String pageContent = "";

 

            try {

                // Пытаемся послать запрос Wiktionary API для получения слова дня

                SimpleWikiHelper.prepareUserAgent(context);

                pageContent = SimpleWikiHelper.getPageContent(pageName, false);

            } catch (ApiException e) {

                Log.e("WordWidget", "Couldn't contact API", e);

            } catch (ParseException e) {

                Log.e("WordWidget", "Couldn't parse API response", e);

            }

 

            // Используем регулярное выражение для парсинга слов и их описания

            Pattern pattern = Pattern.compile(SimpleWikiHelper.WORD_OF_DAY_REGEX);

            Matcher matcher = pattern.matcher(pageContent);

            if (matcher.find()) {

                // Выполняем обновление контента виджета

                updateViews = new RemoteViews(context.getPackageName(), R.layout.widget_word);

 

                String wordTitle = matcher.group(1);

                updateViews.setTextViewText(R.id.word_title, wordTitle);

                updateViews.setTextViewText(R.id.word_type, matcher.group(2));

                updateViews.setTextViewText(R.id.definition, matcher.group(3).trim());

 

                // Когда пользователь кликает на виджет, запускается страница Wiktionary.

                String definePage = res.getString(R.string.template_define_url,

                        Uri.encode(wordTitle));

                Intent defineIntent = new Intent(Intent.ACTION_VIEW, Uri.parse(definePage));

                PendingIntent pendingIntent = PendingIntent.getActivity(context,

                        0 /* no requestCode */, defineIntent, 0 /* no flags */);

                updateViews.setOnClickPendingIntent(R.id.widget, pendingIntent);

 

            } else {

                // Слово дня не найдено, показываем ошибку

                updateViews = new RemoteViews(context.getPackageName(), R.layout.widget_message);

                CharSequence errorMessage = context.getText(R.string.widget_error);

                updateViews.setTextViewText(R.id.message, errorMessage);

            }

            return updateViews;

        }

 

        @Override

        public IBinder onBind(Intent intent) {

            // Мы не хотим привязываться к этому сервису

            return null;

        }

    }

	}

 


Все. Мы написали виджет для приложения Wiktionary "Слово дня". Когда требуется обновление, мы с помощью online API получаем новые данные. **AppWidget framework** автоматически запрашивает у нас обновления, например в момент добавления виджета на экран или согласно своему расписанию - раз в день.





Вообще виджеты стоит создавать для отображения не очень часто обновляемых данных (не чаще чем раз в час). Старайтесь обновлять информацию как можно реже и предусмотрите возможность ручного обновления.





Созданные таким образом виджеты можно размещать на любом домашнем экране, поддерживающим **AppWidget framework**.





Спасибо вам, за то что вы с нами.





Ожидаем ваших комментариев.







Коды вы можете скачать [тут](http://android-helper.com.ua/forms)
Добрый день друзья.





Я продолжаю собирать информацию по android программированию у себя на сайте.





Сегодня я нашел достойную статью. Которую следует прочесть как экспертам так и начинающим.





Речь сегодня пойдет о Push-notification.


<!-- more -->


Оригинал статьи [тут](http://startandroid.ru/uroki/vse-uroki-spiskom/164-urok-99-service-uvedomlenija-notifications.html).





Читаем, комментируем.









В принципе, **уведомления **– отдельная от **сервисов **тема. Но чаще всего уведомления используются именно в сервисах, поэтому я решил дать эту тему сейчас.





В андроид (версии < 3) есть строка вверху экрана. Называется она статус-бар. Туда обычно в виде иконок сваливаются различные уведомления для пользователя (новые письма, смс и прочие). Пользователь открывает статус бар – видит там чуть более подробную инфу о событии. Дальше он может либо стереть это уведомление, либо нажать на него и перейти непосредственно к событию.





В этом уроке научимся все это проделывать. Для начала разберем уведомление на логические составляющие, чтобы проще было понять как его создавать и отправлять.





**Первая часть** – то, что видно в статус-баре, когда уведомление только приходит – иконка и текст. Текст потом исчезает и остается только иконка.





**Вторая часть** – то, что мы видим, когда открываем статус бар (тянем вниз). Там уже полноценный View с иконкой и двумя текстами, т.е. более подробная информация о событии.





**Третья часть** – то, что произойдет, если мы нажмем на View из второй части. Тут обычно идет вызов Activity, где мы можем просмотреть полную информацию и обработать событие.





Кроме этого есть еще несколько возможностей, по которым совсем кратко пробежимся в конце урока.





Создадим приложение и сервис. Сервис, как будто загружает файл и посылает уведомление, по нажатию на которое будет открываться приложение и отображать имя файла.









**activity_main.xml**:


	<?xml version="1.0" encoding="utf-8"?>

	<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"

    android:layout_width="fill_parent"

    android:layout_height="fill_parent"

    android:orientation="vertical" >



    <Button

        android:id="@+id/btnStart"

        android:layout_width="wrap_content"

        android:layout_height="wrap_content"

        android:onClick="onClickStart"

        android:text="Start" >

    </Button>



    <Button

        android:id="@+id/btnStop"

        android:layout_width="wrap_content"

        android:layout_height="wrap_content"

        android:onClick="onClickStop"

        android:text="Stop" >

    </Button>



    <TextView

        android:id="@+id/tv"

        android:layout_width="fill_parent"

        android:layout_height="wrap_content"

        android:text="" >

    </TextView>



	</LinearLayout>


Кнопки для старт/стопа сервиса и TextView для отображения результата





Создаем сервис **MyService**.java и прописываем его в манифесте. В манифесте же настроим сервис так, чтобы он работал в отдельном процессе. Для этого надо в его атрибуте process написать двоеточие и какое-нить слово. В итоге у вас должен получится следующий файл манифест:



	<manifest xmlns:android="http://schemas.android.com/apk/res/android"

    package="com.example.push_notification"

    android:versionCode="1"

    android:versionName="1.0" >



    <uses-sdk

        android:minSdkVersion="8"

        android:targetSdkVersion="15" />



    <application

        android:icon="@drawable/ic_launcher"

        android:label="@string/app_name"

        android:theme="@style/AppTheme" >

        <activity

            android:name=".MainActivity"

            android:label="@string/title_activity_main" >

            <intent-filter>

                <action android:name="android.intent.action.MAIN" />



                <category android:name="android.intent.category.LAUNCHER" />

            </intent-filter>

        </activity>



        <service

            android:name="MyService"

            android:process=":myservice" >

        </service>

    </application>



	</manifest>








Система эту строку добавит к package сервиса и, тем самым, получит название нового процесса, в котором и запустит сервис





 ![](http://android-helper.com.ua/images/uploads/2012/09/L0099_020.jpg)




**MainActivity.java**:



	package com.example.push_notification;



	import android.app.Activity;

	import android.content.Intent;

	import android.os.Bundle;

	import android.text.TextUtils;

	import android.view.View;

	import android.widget.TextView;



	public class MainActivity extends Activity {



	public final static String FILE_NAME = "filename";



	/** Called when the activity is first created. */

	@Override

	public void onCreate(Bundle savedInstanceState) {

		super.onCreate(savedInstanceState);

		setContentView(R.layout.activity_main);



		TextView tv = (TextView) findViewById(R.id.tv);



		Intent intent = getIntent();



		String fileName = intent.getStringExtra(FILE_NAME);

		if (!TextUtils.isEmpty(fileName)) {

			tv.setText(fileName);

		}

	}



	public void onClickStart(View v) {

		startService(new Intent(this, MyService.class));

	}



	public void onClickStop(View v) {

		stopService(new Intent(this, MyService.class));

	}



	}








В onCreate мы вытаскиваем из intent и кладем в TextView текст. Этот текст мы будем отправлять из сервиса через уведомление.



**onClickStart** и **onClickStop** – это обработчики кнопок. Стартуют и останавливают сервис.







**MyService.java**:




	package com.example.push_notification;



	import java.util.concurrent.TimeUnit;

	import android.app.Notification;

	import android.app.NotificationManager;

	import android.app.PendingIntent;

	import android.app.Service;

	import android.content.Intent;

	import android.os.IBinder;



	public class MyService extends Service {



	NotificationManager nm;



	@Override

	public void onCreate() {

		super.onCreate();

		nm = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);

	}



	@Override

	public int onStartCommand(Intent intent, int flags, int startId) {

		try {

			TimeUnit.SECONDS.sleep(5);

		} catch (InterruptedException e) {

			e.printStackTrace();

		}

		sendNotif();

		return super.onStartCommand(intent, flags, startId);

	}



	void sendNotif() {

		// 1-я часть

		Notification notif = new Notification(R.drawable.ic_launcher, "Text in status bar", System.currentTimeMillis());



		// 3-я часть

		Intent intent = new Intent(this, MainActivity.class);

		intent.putExtra(MainActivity.FILE_NAME, "somefile");

		PendingIntent pIntent = PendingIntent.getActivity(this, 0, intent, 0);



		// 2-я часть

		notif.setLatestEventInfo(this, "Notification's title", "Notification's text", pIntent);



		// ставим флаг, чтобы уведомление пропало после нажатия

		notif.flags |= Notification.FLAG_AUTO_CANCEL;

		notif.number = 3;



		// отправляем

		nm.notify(1, notif);

	}



	@Override

	public IBinder onBind(Intent arg0) {

		return null;

	}

	}







В **onCreate **получаем менеджер уведомлений – [NotificationManager](http://developer.android.com/reference/android/app/NotificationManager.html). Он нам понадобится, чтобы отправить уведомление.





В **onStartCommand **запускаем паузу на 5 секунд (эмулируем закачку файла) и после этого отправляем уведомление. Именно из-за этой паузы мы и используем другой процесс, чтобы не тормозило основное приложение.





В **sendNotif **мы создаем и отправляем уведомление. Правда, немного в иной последовательности, что я описывал выше. Сначала первая часть, потом третья, потом вторая.





Первая часть – создаем [Notification](http://developer.android.com/reference/android/app/Notification.html). В конструкторе указываем иконку и текст, которые будут видны в статус-баре. Также мы здесь указываем время. Обычно это текущее время. Но можно указать и прошлое и будущее. По этому времени уведомления будут отсортированы в статус-баре и в его раскрытой части.





Третья часть – создаем Intent, который мы бы использовали для вызова нашего Activity. Туда помещаем имя загруженного файла. Activity его достанет и поместит в TextView. Далее мы оборачиваем этот Intent в PendingIntent, с помощью метода [getActivity](http://developer.android.com/reference/android/app/PendingIntent.html#getActivity(android.content.Context, int, android.content.Intent, int)). На вход ему передаем контекст и Intent. Второй параметр не используется (так написано в хелпе). А четвертый – это флаги, влияющие на поведение PendingIntent. Они не относятся к теме урока, мы их не используем.





Теперь этот созданный PendingIntent содержит информацию о том, что надо вызывать Activity, а также объект Intent, который для этой цели надо использовать. Это будет использовано при нажатии на уведомлении.





Вторая часть – вызываем метод [setLatestEventInfo](http://developer.android.com/reference/android/app/Notification.html#setLatestEventInfo(android.content.Context, java.lang.CharSequence, java.lang.CharSequence, android.app.PendingIntent)). Передаем на вход контекст, текст-заголовок, подробный текст и PendingIntent. Теперь, когда мы откроем статус-бар, мы увидим два этих текста (заголовок и подробный). А, когда нажмем на уведомление, система использует PendingIntent для запуска Activity.





Далее мы для созданного уведомления ставим флаг [FLAG_AUTO_CANCEL](http://developer.android.com/reference/android/app/Notification.html#FLAG_AUTO_CANCEL), чтобы оно исчезло из статус-бара после нажатия. По умолчанию оно не исчезает и продолжает висеть.





Далее вызываем метод [notify](http://developer.android.com/reference/android/app/NotificationManager.html#notify(int, android.app.Notification)) для менеджера уведомлений и передаем туда ID и созданное уведомление. ID используется, если мы хотим изменить или удалить уведомление.





Все сохраним, запустим.





![](http://android-helper.com.ua/images/uploads/2012/09/device-2012-09-05-163359.png)




Жмем **Start **и сразу закрываем приложение кнопкой **Назад**.





Проходит 5 сек и появляется уведомление (первая часть)





![](http://android-helper.com.ua/images/uploads/2012/09/device-2012-09-05-163430.png)







Жмем на уведомление.





Открывается наше приложение (третья часть) и в TextView появляется текст, переданный из сервиса.





![](http://android-helper.com.ua/images/uploads/2012/09/device-2012-09-05-163441.png)




Теперь вкратце пробежимся по остальным интересным возможностям уведомлений.





### Обновление старого или новое уведомление





Если вы создадите новое уведомление и отправите его (notify) с тем же ID, что и у уже существующего уведомления, то новое заменит старое. Таким образом, вы можете уведомления обновлять.





Если же надо показать новое уведомление, то используйте другой ID.





### Удаление





Чтобы убрать уведомление из статус-бара, используется метод [cancel](http://developer.android.com/reference/android/app/NotificationManager.html#cancel(int)) у менеджера уведомлений. На вход подается ID. Либо используйте метод [cancelAll](http://developer.android.com/reference/android/app/NotificationManager.html#cancelAll()), чтобы удалить все уведомления.





### Звук





Если хотите, чтобы уведомление появилось со стандартным звуком, добавьте флаг [Notification.DEFAULT_SOUND](http://developer.android.com/reference/android/app/Notification.html#DEFAULT_SOUND) в поле уведомления [defaults](http://developer.android.com/reference/android/app/Notification.html#defaults).





А для использования своих звуков используется поле [sound](http://developer.android.com/reference/android/app/Notification.html#sound).





Чтобы проиграть файл с **SD**:





_notif.sound = Uri.parse("file:///sdcard/notification/ringer.mp3");_





Чтобы использовать какую-либо из стандартных мелодий, используем **Content Provider**:





_notif.sound = Uri.withAppendedPath(Audio.Media.INTERNAL_CONTENT_URI, "6");_





Подробнее [здесь](http://developer.android.com/guide/topics/ui/notifiers/notifications.html#Sound).





### Вибра





Если хотите, чтобы уведомление появилось со стандартной виброй, добавьте флаг [Notification.DEFAULT_VIBRATE](http://developer.android.com/reference/android/app/Notification.html#DEFAULT_VIBRATE) в поле уведомления defaults.





А для использования своей комбинации вибры используется поле [vibrate](http://developer.android.com/reference/android/app/Notification.html#vibrate). В это поле помещается массив long-чисел. Первое – длительность паузы (в миллисекундах) перед началом вибрирования, второе – длительность вибрирования, третье – длительность паузы, четвертое – длительность вибрирования … и т.д. Т.е. создаете свою комбинацию пауз и вибрирования. И мобила при получении уведомления вам ее провибрирует.





Подробнее [здесь](http://developer.android.com/guide/topics/ui/notifiers/notifications.html#Vibration).





Для работы вибры необходимо прописать права [VIBRATE](http://developer.android.com/reference/android/Manifest.permission.html#VIBRATE) в манифесте.





### Индикатор





Если хотите, чтобы уведомление появилось с миганием индикатора, добавьте флаг [Notification.DEFAULT_LIGHTS](http://developer.android.com/reference/android/app/Notification.html#DEFAULT_LIGHTS) в поле уведомления defaults.





А для использования своей комбинации мигания индикатора используются поля





[ledARGB](http://developer.android.com/reference/android/app/Notification.html#ledARGB) – здесь задается цвет





[ledOnMS](http://developer.android.com/reference/android/app/Notification.html#ledOnMS) – время «горения»





[ledOffMS](http://developer.android.com/reference/android/app/Notification.html#ledOffMS) – время «не горения»





И в поле [flags](http://developer.android.com/reference/android/app/Notification.html#flags) надо добавить флаг [Notification.FLAG_SHOW_LIGHTS](http://developer.android.com/reference/android/app/Notification.html#FLAG_SHOW_LIGHTS).





В итоге индикатор будет мигать с заданными значениями и с заданным цветом. В хелпе написано, что не все девайсы поддерживают разные цвета. Поэтому выбранный вами цвет не гарантируется.





Подробнее [здесь](http://developer.android.com/guide/topics/ui/notifiers/notifications.html#Lights).





### Число





У Notification есть поле [number](http://developer.android.com/reference/android/app/Notification.html#number). Вы можете поместить туда число больше нуля и оно отобразится на уведомлении.





Например, при notif.number = 3 уведомление будет выглядеть так:





![](http://android-helper.com.ua/images/uploads/2012/09/L0099_070-300x210.jpg)





### Флаги





Добавляются в поле flags





[FLAG_INSISTENT](http://developer.android.com/reference/android/app/Notification.html#FLAG_INSISTENT) – звук уведомления будет повторяться, пока не откроют статус-бар





[FLAG_ONGOING_EVENT](http://developer.android.com/reference/android/app/Notification.html#FLAG_ONGOING_EVENT) – уведомление появляется не в обычной секции, а в ongoing (постоянные). Уведомления из этой секции не удаляются при нажатии кнопки очистки уведомлений.





[![](http://android-helper.com.ua/images/uploads/2012/09/L0099_080-300x210.jpg)](http://android-helper.com.ua/images/uploads/2012/09/L0099_080.jpg)





[FLAG_NO_CLEAR ](http://developer.android.com/reference/android/app/Notification.html#FLAG_NO_CLEAR)– уведомление не удалится при очистке всех уведомлений





Не очень понимаю, в чем разница между ongoing и тем, что уведомление не удалится после нажатия на кнопку очистки всех уведомлений. Но флаги такие есть, и я о них упомянул.





Надеюсь вам статья понравилась.





Ожидаю ваших комментариев!





Коды вы можете скачать [тут](http://android-helper.com.ua/forms)
Добрый день друзья.  
В одном из проэктов я столкнулся с задачей обрабатывать нажатия на сенсорный экран.  
Долго искал материалы, и мои поиски увенчались успехом.  
Ниже я приведу статью, которая описывает как с этим работать.  
Прошу к прочтению.





  






Занимаясь программированием под Android необходимо знать, как взаимодействовать с сенсорным экраном — главным устройством ввода на большинстве Android устройств. В этой статье будет рассмотрено:



<!-- more -->




  * Низкоуровневое взаимодействие с тачскрином, нужное прежде всего для разработки игр.




  * Класс MotionEvent



  * Обработка MotionEvent'ов




  * Работа с MultiTouch.



  * Некоторые высокоуровневые методы обработки прикосновений.






Также будут приведены различные примеры…





#### Отступление по поводу Лога





Так как в дальнейшем в этой статье мы будем активно использовать Log, я кратко расскажу про него(те, кто уже знаком с логом Андроида, могут благополучно пропустить этот раздел статьи).  
В Android имеется собственный лог, куда могут писать все желающие приложения от Dvalvik VM до вашего приложения. Все сообщения в логе разделяются по приоритету (право выбирать приоритет сообщения, посылаемого в лог остается за вами)   
Для записи в лог достаточно вызвать один из статических методов класса Log, различающихся только приоритетом отсылаемых ими сообщений.  
Эти методы приведены ниже, по возрастанию приоритета:








  * Log.v(String tag, String msg) — VERBOSE



  * Log.d(String tag, String msg) — DEBUG



  * Log.i(String tag, String msg) — INFO



  * Log.w(String tag, String msg) — WARNING



  * Log.e(String tag, String msg) — ERROR



  * Log.wtf(String tag, String msg) — What a Terrible Failure






Также есть возможность отправлять в лог исключения. В этом случае добавляется еще один аргумент — Throwable tr. Например:








  * Log.v(String tag, String msg, Throwable tr)






Вывести окно Log'а в Eclipse можно так:  
**Window -> Show View -> Other -> Android -> LogCat**





#### Понятие о MotionEvent





Класс MotionEvent служит хранилищем данных о прикосновении (touch event). Каждый раз, когда пользователь проводит пальцем по экрану, или даже просто тапает, создается целая последовательность экземпляров класса **MotionEvent**: последовательность начинается, когда пользователь дотрагивается до экрана, продолжается, пока пользователь двигает палец по экрану, и кончается, когда пользователь поднимает палец. Таким образом получается три основных типа действия, которые описывает MotionEvent: опускание пальца, его передвижение и поднятие. Каждый MotionEvent хранит в себе информацию о типе действия, которое он описывает. Для этого в классе MotionEvent предусмотрены константы:








  * int MotionEvent.ACTION_DOWN — пользователь опускает палец на экран.



  * int MotionEvent.ACTION_MOVE — пользователь передвигает пальцем по экрану.



  * int MotionEvent.ACTION_UP — пользователь поднимает палец с экрана.






Узнать какое действие описывает данный MotionEvent можно с помощью метода **getAction()**.  
Стоит отметить, что существует еще один тип действия — MotionEvent.ACTION_CANCEL, который по сути является обозначением того, что последовательность завершена некорректно, то есть без MotionEvent.ACTION_UP. Все это будет объяснено подробнее на примере, но чуть позже.





#### Получение и обработка MotionEvent'ов





Теперь, когда мы получили общее представление о MotionEvent'ах, необходимо разобраться с тем, откуда нам их «брать». Существует 2 способа, разберем их по отдельности.








  * Первый способ является оптимальным, когда вы используете один из стандартных View. У класса View существует метод SetOnTouchListener(View.OnTouchListener l), аргументом которого является класс, реализующий интерфейс OnTouchListener. Этот метод позволяет назначить «слушателя» MotionEvent'ов. Интерфейс OnTouchListener обязует класс реализовывать метод public boolean OnTouch(View v,MotionEvent event), вторым аргументом которого и является нужный нам MotionEvent. Теперь каждый раз, когда пользователь будет прикасаться к экрану, Android будет вызывать наш метод OnTouch, давая ему в аргумент описание произошедшего действия, то есть MotionEvent. Рассмотрим подробнее на примере:  
Вот наш файл res/layout/main.xml:  
  
		<?xml version="1.0" encoding="utf-8"?> 
	
		<LinearLayout xmlns:android="schemas.android.com/apk/res/android" 
    	android:orientation="vertical" 
    	android:layout_width="fill_parent" 
    	android:layout_height="fill_parent" 
    	android:id="@+id/ll" 
	 	/> 


  
  
  
А вот наш Activity класс:  
	
	import android.app.Activity;
	import android.os.Bundle;
	import android.util.Log;
	import android.view.MotionEvent;
	import android.view.View;
	import android.view.View.OnTouchListener;
	import android.widget.LinearLayout; 
	
	  public class main extends Activity implements OnTouchListener{// Заставляем наш Activity класс воплощать интерфейс OnTouchListener

      /** Called when the activity is first created. */

      @Override

      public void onCreate(Bundle savedInstanceState) {

          super.onCreate(savedInstanceState);

          setContentView(R.layout.main);

          LinearLayout ll =(LinearLayout)this.findViewById(R.id.ll);//Достаем нужный View

          ll.setOnTouchListener(this);// Устанавливаем данный класс в качестве слушателя MotionEvent'ов для нашего LinearLayout

      } 

      @Override

      public boolean onTouch(View v, MotionEvent event)// Вот, собственно, метод, который и будет обрабатывать MotionEvent'ы.

      {

          int Action=event.getAction();

		  // С помощью метода getAction() получаем тип действия(ACTION_DOWN,ACTION_MOVE или ACTION_UP)

          StringBuilder str=new StringBuilder();

          str.append("\nActrion type: ");

		  //Дальше для лучшего восприятия(т.к. константы ACTION_DOWN,ACTION_MOVE и ACTION_UP числовые)

          //проводим switch по переменной Action и добавляем в наш StringBuilder название константы

          switch(Action)

         {

              case MotionEvent.ACTION_DOWN: str.append("ACTION_DOWN\n");break;

              case MotionEvent.ACTION_MOVE: str.append("ACTION_MOVE\n");break;

              case MotionEvent.ACTION_UP: str.append("ACTION_UP\n");break;

         }

          //С помощью методов getX() и getY() получаем координаты по оси x и y соответственно

          //Следует отметить, что точка 0 располагается в левом верхнем углу экрана.

          //Ось x направлена вправо

          //Ось y направлена вниз(чем ниже, тем больше координата).

          str.append("Location: ").append(event.getX()).append(" x ").append(event.getY()).append("\n");//Узнаем координаты

          str.append("Edge flags: ").append(event.getEdgeFlags()).append("\n");// Метод getEdgeFlags возвращает информацию о пересечении краев экрана

          str.append("Pressure: ").append(event.getPressure()).append("\n");// Узнаем давление

          str.append("Size: ").append(event.getSize()).append("\n"); // Узнаем размер указателя(места соприкосновения пальца с экраном)

          str.append("Down time: ").append(event.getDownTime()).append("ms\n");// Узнаем время, когда палец был опущен на экран в миллисекундах

          str.append("Event time: ").append(event.getEventTime()).append("ms");//узнаем текущее время(соответствующее обрабатываемому MotionEvent'у) в миллисекундах

          str.append(" Elapsed: ").append(event.getEventTime()-event.getDownTime());//Узнаем сколько времени прошло с момента опускания пальца, до текущего MotionEvent'а

          Log.v("Mytag", str.toString());//Для того, чтобы можно было отслеживать эти действия, записываем всю информацию о них в лог.

          return true;// Почему мы возвращаем true будет рассмотрено потом

      }

  	}







  
  
  
Понятно, что один класс может быть слушателем у нескольких View. Чтобы это учитывать метод onTouch принимает в аргумент View.



  * Второй способ является оптимальным, когда вы пишете свой View класс, который должен реагировать на прикосновения. У View есть метод onTouchEvent(MotionEvent event), который, собственно, и позволяет обрабатывать MotionEvent'ы. Рассмотрим на примере:  
Напишем свой класс SomeView:  
  

		package com.example.MotionEventExample1;

		import android.content.Context;
		import android.util.AttributeSet;
		import android.view.View;

		public class SomeView extends View {

    	// Сначала необходимо реализовать конструктор.

    	// Тут все просто - просто вызываем конструктор суперкласса

    	public SomeView(Context context, AttributeSet attrs) {

        super(context, attrs);

    	}
		}



	// Теперь приступаем непосредственно к обработке MotionEvent'ов.

	// Для этого нужно переписать метод onTouchEvent

		@Override

		public boolean onTouchEvent(MotionEvent event) {

			Float X = (Float) event.getX();

			Float Y = (Float) event.getY();

			int Action = event.getAction();

			String ActionString = "";

			switch (Action) {

			case MotionEvent.ACTION_DOWN:

				ActionString = "ACTION_DOWN";

				break;

			case MotionEvent.ACTION_MOVE:

				ActionString = "ACTION_MOVE";

				break;

			case MotionEvent.ACTION_UP:

				ActionString = "ACTION_UP";

				break;

			}

			Log.v("MyTag", "View OnTouchListener:\n" + "Coords: " + X.toString() + " x " + Y.toString() + "\nAction type: " +  ActionString);

			return true;

			}

		}
  


  
  
И наш /res/layout/main.xml:  
  


   	<?xml version="1.0" encoding="utf-8"?>

   	<LinearLayout xmlns:android="schemas.android.com/apk/res/android"

       android:orientation="vertical"

       android:layout_width="fill_parent"

       android:layout_height="fill_parent"

       >

   	<com.example.MotionEventExample1.SomeView

       android:layout_width="fill_parent"

       android:layout_height="fill_parent"

      android:id="@+id/sv"

  	/>

  	</LinearLayout>





  
Activity класс:  
   


	package com.example.MotionEventExample1;

	import android.app.Activity;
	import android.os.Bundle;

	public class main extends Activity {

	/** Called when the activity is first created. */

	@Override

	public void onCreate(Bundle savedInstanceState) {

		super.onCreate(savedInstanceState);

		setContentView(R.layout.main);

	}

	}


  






#### О том, что возвращают обработчики MotionEvent'ов





Как вы могли заметить, обработчики MotionEvent'ов должны возвращать boolean'овское значение. В примерах до этого мы просто всегда возвращали true. Так для чего же этим методам вообще нужно возвращать значение? Дело в том, что у одного View может быть несколько слушателей (например onTouchEvent в самом View и OnTouch у внешнего слушателя) и они имеют некоторый приоритет: OnTouch вызывается первым (если он вообще имеется), а уже после него может вызываться onTouchEvent. Вызов следующего по приоритету обработчика как раз зависит от возвращаемого текущим обработчиком значения (true — ничто не вызывается, false — вызывается следующий по приоритету, если таковой имеется). Таким образом Android позволяет нам разделять обязанности по обработке touch event'ов на несколько слушателей.





##### Drag and Drop





Вот мы и разобрались с основами обработки MotionEvento'ов. Для закрепления навыков напишем приложение, реализующее простенький Drag and Drop.  
  
Вот наш /res/layout/main.xml:  
  


   	<?xml version="1.0" encoding="utf-8"?>

  	<LinearLayout xmlns:android="schemas.android.com/apk/res/android"

       android:orientation="vertical"

       android:layout_width="fill_parent"

       android:layout_height="fill_parent"

       >

   	<com.example.dragdrop.SomeView

       android:layout_width="fill_parent"

       android:layout_height="fill_parent"

      android:id="@+id/sv"

  	/>

  	</LinearLayout>







 





Вот наш Activity класс:


	package com.example.dragdrop;
	
	import android.app.Activity;
	import android.os.Bundle;

	public class main extends Activity {

	/** Called when the activity is first created. */

	@Override

	public void onCreate(Bundle savedInstanceState) {

		super.onCreate(savedInstanceState);

		setContentView(R.layout.main);

	}

	}






А вот наш основной класс SomeView:

	package com.example.dragdrop;

	import android.content.Context;
	import android.graphics.Canvas;
	import android.graphics.Color;
	import android.graphics.Paint;
	import android.graphics.Paint.Style;
	import android.util.AttributeSet;
	import android.view.MotionEvent;
	import android.view.View;
	
	public class SomeView extends View {

	Paint paint;

	int X;

	int Y;

	final static int Radius = 20;



	public SomeView(Context context, AttributeSet attrs) {

		super(context, attrs);

		paint = new Paint();

		paint.setColor(Color.YELLOW);

		paint.setStyle(Style.FILL);

		X = 30;

		Y = 30;

	}



	@Override

	public boolean onTouchEvent(MotionEvent event) {

		X = (int) event.getX();

		Y = (int) event.getY();

		return true;

	}



	@Override

	protected void onDraw(Canvas canvas)// метод OnDraw вызвается Андроидом

										// тогда, когда нужно отрисовать данный

										// View

	{

		canvas.drawCircle(X, Y, Radius, paint);

		invalidate();// invalidate() нужен для того, чтобы оповестить Android,

						// что нужно выполнить метод OnDraw снова, без него View

						// не будет перериcовываться.

	}

	}





**Multitouch**





 





В Android, сколько-бы вы пальцев ни использовали, информация о всех них хранится в одном MotionEvent'е. Первый метод, который нужно узнать, если вы собираетесь использовать мультитач — getPointerCount(), который возвращает количество пальцев, зафиксированных на экране(Не всегда совпадает с реальным количеством из-за ограничений в железе). Каждому пальцу, находящемуся на экране, присваивается индекс и id. Индексы всегда начинаются с 0, id — не обязательно. Для понятности рассмотрим на примере.  
Первый палец опускается — ему присваивается index=0 и id=0  
Второй палец опускается — ему присваивается index=1 и id=1  
Первый палец поднимается — Второму пальцу присваивается index=0 (Индексы всегда начинаются с нуля), а id остается тем же  
Второй палец поднимается — MotionEvent'ов больше нет, вплоть до следушего прикосновения.  
Id всегда сохраняется за указателем(пальцем), так что мы всегда можем отследить какой угодно указатель.  
Когда мы разобрались с id и индексами, рассмотрим как получать свойства (координаты, величину и т. п. ) у конкретного указателя, когда их много. Для этого в классе MotionEvent существуют методы:getX(int Index)getY(int Index)getSize(int Index)и т. д., мы уже их рассматривали  
В аргумент эти методы принимают **индекс** указателя.  
Но так как индексы указателя могут меняться, а часто требуется отследить конкретный палец, то существует очень важный метод  getPointerId(int index), который позволяет по указанному индексу узнать id указателя.





 





Рассмотрим пример: перепишем наше приложение (Drag and Drop) так, чтобы оно воспринимало мультитач.  
(Важно: На эмуляторе мультитач не проверить, это можно сделать только на настоящем девайсе)  
Вот наш res/layout/main.xml  
   


   	<?xml version="1.0" encoding="utf-8"?>

   	<LinearLayout xmlns:android="schemas.android.com/apk/res/android"

       android:orientation="vertical"

       android:layout_width="fill_parent"

       android:layout_height="fill_parent"

       >

   	<com.example.multitouch.SomeView

       android:layout_width="fill_parent"

       android:layout_height="wrap_content"

      android:id="@+id/view"

      />

  	</LinearLayout> 

    
Наш Activity класс:


	package com.example.multitouch;

	import android.app.Activity;
	import android.os.Bundle;

	public class main extends Activity {

	/** Called when the activity is first created. */

	@Override

	public void onCreate(Bundle savedInstanceState) {

		super.onCreate(savedInstanceState);

		setContentView(R.layout.main);

	}

	}


А вот основной класс — SomeView:


	package com.example.multitouch;

	import android.content.Context;
	import android.graphics.Canvas;
	import android.graphics.Color;
	import android.graphics.Paint;
	import android.graphics.Paint.Style;
	import android.util.AttributeSet;
	import android.util.Log;
	import android.view.MotionEvent;
	import android.view.View;

	//Будем рисовать желтые круги под пальцами

	public class SomeView extends View {

	Paint paint;// нужен чтобы установить цвет.

	int[] X;

	int[] Y;

	final static int Radius = 20;

	int PointerCount;



	public SomeView(Context context, AttributeSet attrs) {

		super(context, attrs);

		paint = new Paint();

		paint.setColor(Color.YELLOW);

		paint.setStyle(Style.FILL);

		PointerCount = 0;

		X = new int[10];// Это будут массивы координат(будем воспринимать до 10

						// пальцев)

		Y = new int[10];

	}



	@Override

	public boolean onTouchEvent(MotionEvent event) {

		StringBuilder result = new StringBuilder(300);

		PointerCount = event.getPointerCount();

		for (int i = 0; i < PointerCount; i++) {

			int ptrId = event.getPointerId(i);

			X[i] = (int) event.getX(i);// Запоминаем координаты

			Y[i] = (int) event.getY(i);

			result.append("Pointer Index: ").append(i);

			result.append(", Pointer Id: ").append(ptrId).append("\n");

			result.append("Location: ").append(event.getX(i));

			result.append(" x ").append(event.getX(i)).append("\n");

			result.append("Pressure: ").append(event.getPressure(i));

			result.append("Size: ").append(event.getSize(i)).append("\n");

		}

		Log.v("Mytag", result.toString());// Выводим всю информацию в лог

		return true;

	}



	@Override

	protected void onDraw(Canvas canvas) {

		for (int i = 0; i < PointerCount; i++)// Смотрим сколько пальцев было на

												// экране и отрисовываем View

		{

			canvas.drawCircle(X[i], Y[i], Radius, paint);

		}

		invalidate();// invalidate() нужен для того, чтобы оповестить Android,

						// что нужно выполнить метод OnDraw снова, без него View

						// не будет перериовываться. }

	}

	}




**Другие способы взаимодействия с тачскрином**





 





Взаимодействие с экраном через MotionEvent'ы является довольно низкоуровневым, нужно это прежде всего для разработки игр. Для более узких, повседневных ситуаций в Android предусмотрен ряд интерфейсов, которые позволяют распознавать наиболее «популярные» touch event'ы:

- **OnClickListener** — onClick(View v)
- **OnFocusChangeListener** — onFocusChange(View v, boolean hasFocus)
- **OnKeyListener** — onKey(View v, int keyCode, KeyEvent event)
- **OnLongClickListener** — onLongClick(View v)
- и т. д.





 





Обрабатываются они аналогично, так что в пояснении не нуждаются.  
Больше информации о таких методах можно узнать здесь:  
[developer.android.com/reference/android/view/View.html ](http://developer.android.com/reference/android/view/View.html)





#### Для написания статьи использовались:








  * [developer.android.com](http://developer.android.com/)



  * Pro Android 2 — глава TouchScreens.






Спасибо за внимание.









Если вам понравилась статья. Прошу вас оставить комментарии и подписаться на рассылку.  
Всегда ваш, Андрей
Добрый день друзья.





В предыдущих записях я писал как можно отправлять сообщения с помощью встроенной системы.





Сегодня же я решил поделится опытом отправки и приема сообщений без участия стандартных программ.





Приступим.


<!-- more -->


### Отправка сообщений





## 1. Дадим права отправки сообщений



	<uses-permission android:name="android.permission.SEND_SMS"></uses-permission>


## 2. Базовая функция отправки сообщений


	SmsManager sms = SmsManager.getDefault();

	sms.sendTextMessage("1-212-555-1212", null, "Привет, Android-helper.com.ua", null, null);








## 3. Опишем Activity для отправки.





Хочу отметить, что для получения статуса сообщение мы создадим BroadcastReceiver и зарегистрируем его.




	import android.app.Activity;

	import android.app.PendingIntent;

	import android.content.BroadcastReceiver;

	import android.content.Context;

	import android.content.Intent;

	import android.content.IntentFilter;

	import android.os.Bundle;

	import android.telephony.SmsManager;

	import android.util.Log;

	import android.view.View;

	import android.view.View.OnClickListener;

	import android.widget.Button;

	import android.widget.Toast;

	public class SMSFun extends Activity {

	// Button to trigger sending the SMS

	Button aButton;

	// PendingIntent to tell the SMS app to notify us

	PendingIntent sentPI;

	// The intent action we are using

    String SENT = "SMS_SENT";

    // The BroadcastReceiver that we use to listen for the notification back

    BroadcastReceiver br;

    @Override

	public void onCreate(Bundle savedInstanceState) {

        super.onCreate(savedInstanceState);

        setContentView(R.layout.main);

        // Create the Pending Intent

	sentPI = PendingIntent.getBroadcast(this, 0,

                new Intent(SENT), 0);

	aButton = (Button) this.findViewById(R.id.Button01);

        aButton.setOnClickListener(new OnClickListener() {

	public void onClick(View v) {

	SmsManager sms = SmsManager.getDefault();

	// send the message, passing in the pending intent, sentPI

        sms.sendTextMessage("1-212-555-1212", null, "Привет android-helper.com.ua", sentPI, null);  

        registerReceiver(br, new IntentFilter(SENT));       

	}});  

          

        // In order to receive the results via the pending intent we need

	// to register a new BroadcastReceiver and pay attention to the various

	// values we could get back

	br = new BroadcastReceiver(){

                @Override

	public void onReceive(Context ctx, Intent intent) {

                    switch (getResultCode())

                    {

                        case Activity.RESULT_OK:

                            Toast.makeText(getBaseContext(), "SMS sent", 

                                    Toast.LENGTH_SHORT).show();

                            break;

                        case SmsManager.RESULT_ERROR_GENERIC_FAILURE:

                            Toast.makeText(getBaseContext(), "SMS: Generic failure", 

                                    Toast.LENGTH_SHORT).show();

                            break;

                        case SmsManager.RESULT_ERROR_NO_SERVICE:

                            Toast.makeText(getBaseContext(), "SMS: No service", 

                                    Toast.LENGTH_SHORT).show();

                            break;

                        case SmsManager.RESULT_ERROR_NULL_PDU:

                            Toast.makeText(getBaseContext(), "SMS: Null PDU", 

                                    Toast.LENGTH_SHORT).show();

                            break;

                        case SmsManager.RESULT_ERROR_RADIO_OFF:

                            Toast.makeText(getBaseContext(), "SMS: Radio off", 

                                    Toast.LENGTH_SHORT).show();

                            break;

                    }

                    unregisterReceiver(br);

                }

            };    }

	}








###  Получение сообщений 





## 1. Права доступа







	<uses-permission android:name="android.permission.RECEIVE_SMS"></uses-permission>








## 2. Для того что бы получать сообщения, нужно создать BroadcastReceiver







	<receiver android:name=".SMSFunReceive">

     <intent-filter>

                <action android:name=

                   "android.provider.Telephony.SMS_RECEIVED" />

     </intent-filter>

	</receiver>

**Java**

	import android.content.BroadcastReceiver;

	import android.content.Context;

	import android.content.Intent;

	import android.os.Bundle;

	import android.telephony.SmsMessage;

	import android.util.Log;

	// This will run when an SMS message comes in.

	// We can see if we want to do something based upon the message

	// Perhaps launch an activity

	public class SMSFunReceive extends BroadcastReceiver 

	{

	@Override

	public void onReceive(Context ctx, Intent intent) 

	{

	Bundle bundle = intent.getExtras();        

	Object[] pdus = (Object[]) bundle.get("pdus");

	SmsMessage[] messages = new SmsMessage[pdus.length];

        

	for (int i = 0; i < messages.length; i++)
	{

	messages[i] = SmsMessage.createFromPdu((byte[])pdus[i]);

        

	Log.v("SMSFun","Body: " + messages[i].getDisplayMessageBody());

	Log.v("SMSFun","Address: " + messages[i].getDisplayOriginatingAddress());

	//If say we wanted to do something based on who sent it

	if (messages[i].getDisplayOriginatingAddress().contains("2125551212"))

         {

	// we could launch an activity and pass the data

	Intent newintent = new Intent(ctx, SecretMessage.class);
	newintent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);         // Pass in data

	newintent.putExtra("address", messages[i].getDisplayOriginatingAddress());

	newintent.putExtra("message", messages[i].getDisplayMessageBody());

	ctx.startActivity(newintent);         

	}

	}

	}

	}








## 5. Финальный аккорд. Создадим Activity для отображения сообщения.


	import android.app.Activity;

	import android.os.Bundle;

	import android.widget.TextView;

	public class SecretMessage extends Activity {

    public void onCreate(Bundle savedInstanceState) {

        super.onCreate(savedInstanceState);

        setContentView(R.layout.secret);

        // Get the extra data

        Bundle extras = getIntent().getExtras(); 

        String address = extras.getString("address");

        String message = extras.getString("message");

        

        TextView addresstv = (TextView) findViewById(R.id.addresstv);

        TextView messagetv = (TextView) findViewById(R.id.messagetv);

        

        messagetv.setText(message);

        addresstv.setText(address);

    }

	}



**xml**

	<?xml version="1.0" encoding="utf-8"?>

	<LinearLayout 
		xmlns:android="http://schemas.android.com/apk/res/android" 
		android:layout_width="wrap_content" 
		android:layout_height="wrap_content">

		<TextView 
			android:layout_height="wrap_content" 
			android:id="@+id/addresstv" 
			android:text="address" 
			android:layout_width="fill_parent"
			android:layout_gravity="fill_horizontal" />

		<TextView 
			android:layout_height="wrap_content" 
			android:id="@+id/messagetv" 
			android:text="message" 
			android:layout_width="fill_parent" 
			android:layout_gravity="fill_horizontal" />

	</LinearLayout>

Если понравилась статья, нажми рассказать друзьям.


Полный код программы [тут](http://android-helper.com.ua/forms).


Несколько дней наз столкнулся с задачей отправки почты с приложения.





И как оказалось и тут google позаботился о нас.


 <!-- more -->


Пример кода:







	Intent it = new Intent(Intent.ACTION_SEND);   

	it.putExtra(Intent.EXTRA_EMAIL, "me@abc.com");   

	it.putExtra(Intent.EXTRA_TEXT, "The email body text");   

	it.setType("text/plain");   

	context.startActivity(Intent.createChooser(it, "Choose Email Client")); 










После этого будет вызван диалог выбора почтового клиента.


Добрый день друзья.





Сегодня я бы хотел поделится с вами одной интересной темой.





Если вы когда нибудь использовали приложение Twitter у себя на устройстве, то видели, что если потянуть список вниз то появится что то типа этого:





[![](http://android-helper.com.ua/images/uploads/2012/07/device-2012-07-19-155609.jpg)](http://android-helper.com.ua/images/uploads/2012/07/device-2012-07-19-155609.jpg)


 <!-- more -->


[![](http://android-helper.com.ua/images/uploads/2012/07/device-2012-07-19-155634.jpg)](http://android-helper.com.ua/images/uploads/2012/07/device-2012-07-19-155634.jpg)





[![](http://android-helper.com.ua/images/uploads/2012/07/device-2012-07-19-155646.jpg)](http://android-helper.com.ua/images/uploads/2012/07/device-2012-07-19-155646.jpg)





Попробуем это написать сами.





Должно получится что то вроде этого:





[![](http://android-helper.com.ua/images/uploads/2012/07/device-2012-07-19-162848.png)](http://android-helper.com.ua/images/uploads/2012/07/device-2012-07-19-162848.png)





[![](http://android-helper.com.ua/images/uploads/2012/07/device-2012-07-19-162904.png)](http://android-helper.com.ua/images/uploads/2012/07/device-2012-07-19-162904.png)





[![](http://android-helper.com.ua/images/uploads/2012/07/device-2012-07-19-162911.png)](http://android-helper.com.ua/images/uploads/2012/07/device-2012-07-19-162911.png)





[![](http://android-helper.com.ua/images/uploads/2012/07/device-2012-07-19-162918.png)](http://android-helper.com.ua/images/uploads/2012/07/device-2012-07-19-162918.png)





Создадим разметку нашего загрузчика:







[xml]

<?xml version="1.0" encoding="utf-8"?>

<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"

    android:id="@+id/pull_to_refresh_header"

    android:layout_width="fill_parent"

    android:layout_height="fill_parent"

    android:gravity="center"

    android:paddingBottom="15dip"

    android:paddingTop="10dip" >



    <ProgressBar

        android:id="@+id/pull_to_refresh_progress"

        style="?android:attr/progressBarStyleSmall"

        android:layout_width="wrap_content"

        android:layout_height="wrap_content"

        android:layout_centerVertical="true"

        android:layout_marginLeft="30dip"

        android:layout_marginRight="20dip"

        android:layout_marginTop="10dip"

        android:indeterminate="true"

        android:visibility="gone" />



    <ImageView

        android:id="@+id/pull_to_refresh_image"

        android:layout_width="wrap_content"

        android:layout_height="wrap_content"

        android:layout_gravity="center"

        android:layout_marginLeft="30dip"

        android:layout_marginRight="20dip"

        android:gravity="center"

        android:src="@drawable/ic_pulltorefresh_arrow"

        android:visibility="gone" />



    <TextView

        android:id="@+id/pull_to_refresh_text"

        android:layout_width="fill_parent"

        android:layout_height="wrap_content"

        android:layout_gravity="center"

        android:gravity="center"

        android:paddingTop="5dip"

        android:text="@string/pull_to_refresh_tap_label"

        android:textAppearance="?android:attr/textAppearanceMedium"

        android:textStyle="bold" />



    <TextView

        android:id="@+id/pull_to_refresh_updated_at"

        android:layout_width="fill_parent"

        android:layout_height="wrap_content"

        android:layout_below="@+id/pull_to_refresh_text"

        android:layout_gravity="center"

        android:gravity="center"

        android:textAppearance="?android:attr/textAppearanceSmall"

        android:visibility="gone" />



</RelativeLayout>

[/xml]







Реализуем ListView (полный код):



[java]

package com.ua.androidhelper.widget;



import android.content.Context;

import android.util.AttributeSet;

import android.util.Log;

import android.view.LayoutInflater;

import android.view.MotionEvent;

import android.view.View;

import android.view.ViewGroup;

import android.view.animation.LinearInterpolator;

import android.view.animation.RotateAnimation;

import android.widget.AbsListView;

import android.widget.AbsListView.OnScrollListener;

import android.widget.ImageView;

import android.widget.ListAdapter;

import android.widget.ListView;

import android.widget.ProgressBar;

import android.widget.RelativeLayout;

import android.widget.TextView;



public class PullToRefreshListView extends ListView implements OnScrollListener {



	private static final int TAP_TO_REFRESH = 1;

	private static final int PULL_TO_REFRESH = 2;

	private static final int RELEASE_TO_REFRESH = 3;

	private static final int REFRESHING = 4;



	private static final String TAG = "PullToRefreshListView";



	private OnRefreshListener mOnRefreshListener;



	/**

	 * Listener that will receive notifications every time the list scrolls.

	 */

	private OnScrollListener mOnScrollListener;

	private LayoutInflater mInflater;



	private RelativeLayout mRefreshView;

	private TextView mRefreshViewText;

	private ImageView mRefreshViewImage;

	private ProgressBar mRefreshViewProgress;

	private TextView mRefreshViewLastUpdated;



	private int mCurrentScrollState;

	private int mRefreshState;



	private RotateAnimation mFlipAnimation;

	private RotateAnimation mReverseFlipAnimation;



	private int mRefreshViewHeight;

	private int mRefreshOriginalTopPadding;

	private int mLastMotionY;



	private boolean mBounceHack;



	public PullToRefreshListView(Context context) {

		super(context);

		init(context);

	}



	public PullToRefreshListView(Context context, AttributeSet attrs) {

		super(context, attrs);

		init(context);

	}



	public PullToRefreshListView(Context context, AttributeSet attrs, int defStyle) {

		super(context, attrs, defStyle);

		init(context);

	}



	private void init(Context context) {

		// Load all of the animations we need in code rather than through XML

		mFlipAnimation = new RotateAnimation(0, -180, RotateAnimation.RELATIVE_TO_SELF, 0.5f,

				RotateAnimation.RELATIVE_TO_SELF, 0.5f);

		mFlipAnimation.setInterpolator(new LinearInterpolator());

		mFlipAnimation.setDuration(250);

		mFlipAnimation.setFillAfter(true);

		mReverseFlipAnimation = new RotateAnimation(-180, 0, RotateAnimation.RELATIVE_TO_SELF, 0.5f,

				RotateAnimation.RELATIVE_TO_SELF, 0.5f);

		mReverseFlipAnimation.setInterpolator(new LinearInterpolator());

		mReverseFlipAnimation.setDuration(250);

		mReverseFlipAnimation.setFillAfter(true);



		mInflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);



		mRefreshView = (RelativeLayout) mInflater.inflate(R.layout.pull_to_refresh_header, this, false);

		mRefreshViewText = (TextView) mRefreshView.findViewById(R.id.pull_to_refresh_text);

		mRefreshViewImage = (ImageView) mRefreshView.findViewById(R.id.pull_to_refresh_image);

		mRefreshViewProgress = (ProgressBar) mRefreshView.findViewById(R.id.pull_to_refresh_progress);

		mRefreshViewLastUpdated = (TextView) mRefreshView.findViewById(R.id.pull_to_refresh_updated_at);



		mRefreshViewImage.setMinimumHeight(50);

		mRefreshView.setOnClickListener(new OnClickRefreshListener());

		mRefreshOriginalTopPadding = mRefreshView.getPaddingTop();



		mRefreshState = TAP_TO_REFRESH;



		addHeaderView(mRefreshView);



		super.setOnScrollListener(this);



		measureView(mRefreshView);

		mRefreshViewHeight = mRefreshView.getMeasuredHeight();

	}



	@Override

	protected void onAttachedToWindow() {

		setSelection(1);

	}



	@Override

	public void setAdapter(ListAdapter adapter) {

		super.setAdapter(adapter);



		setSelection(1);

	}



	/**

	 * Set the listener that will receive notifications every time the list scrolls.

	 * 

	 * @param l

	 *            The scroll listener.

	 */

	@Override

	public void setOnScrollListener(AbsListView.OnScrollListener l) {

		mOnScrollListener = l;

	}



	/**

	 * Register a callback to be invoked when this list should be refreshed.

	 * 

	 * @param onRefreshListener

	 *            The callback to run.

	 */

	public void setOnRefreshListener(OnRefreshListener onRefreshListener) {

		mOnRefreshListener = onRefreshListener;

	}



	/**

	 * Set a text to represent when the list was last updated.

	 * 

	 * @param lastUpdated

	 *            Last updated at.

	 */

	public void setLastUpdated(CharSequence lastUpdated) {

		if (lastUpdated != null) {

			mRefreshViewLastUpdated.setVisibility(View.VISIBLE);

			mRefreshViewLastUpdated.setText(lastUpdated);

		} else {

			mRefreshViewLastUpdated.setVisibility(View.GONE);

		}

	}



	@Override

	public boolean onTouchEvent(MotionEvent event) {

		final int y = (int) event.getY();

		mBounceHack = false;



		switch (event.getAction()) {

			case MotionEvent.ACTION_UP:

				if (!isVerticalScrollBarEnabled()) {

					setVerticalScrollBarEnabled(true);

				}

				if (getFirstVisiblePosition() == 0 && mRefreshState != REFRESHING) {

					if ((mRefreshView.getBottom() >= mRefreshViewHeight || mRefreshView.getTop() >= 0)

							&& mRefreshState == RELEASE_TO_REFRESH) {

						// Initiate the refresh

						mRefreshState = REFRESHING;

						prepareForRefresh();

						onRefresh();

					} else if (mRefreshView.getBottom() < mRefreshViewHeight || mRefreshView.getTop() <= 0) {

						// Abort refresh and scroll down below the refresh view

						resetHeader();

						setSelection(1);

					}

				}

				break;

			case MotionEvent.ACTION_DOWN:

				mLastMotionY = y;

				break;

			case MotionEvent.ACTION_MOVE:

				applyHeaderPadding(event);

				break;

		}

		return super.onTouchEvent(event);

	}



	private void applyHeaderPadding(MotionEvent ev) {

		// getHistorySize has been available since API 1

		int pointerCount = ev.getHistorySize();



		for (int p = 0; p < pointerCount; p++) {

			if (mRefreshState == RELEASE_TO_REFRESH) {

				if (isVerticalFadingEdgeEnabled()) {

					setVerticalScrollBarEnabled(false);

				}



				int historicalY = (int) ev.getHistoricalY(p);



				// Calculate the padding to apply, we divide by 1.7 to

				// simulate a more resistant effect during pull.

				int topPadding = (int) (((historicalY - mLastMotionY) - mRefreshViewHeight) / 1.7);



				mRefreshView.setPadding(mRefreshView.getPaddingLeft(), topPadding, mRefreshView.getPaddingRight(),

						mRefreshView.getPaddingBottom());

			}

		}

	}



	/**

	 * Sets the header padding back to original size.

	 */

	private void resetHeaderPadding() {

		mRefreshView.setPadding(mRefreshView.getPaddingLeft(), mRefreshOriginalTopPadding,

				mRefreshView.getPaddingRight(), mRefreshView.getPaddingBottom());

	}



	/**

	 * Resets the header to the original state.

	 */

	private void resetHeader() {

		if (mRefreshState != TAP_TO_REFRESH) {

			mRefreshState = TAP_TO_REFRESH;



			resetHeaderPadding();



			// Set refresh view text to the pull label

			mRefreshViewText.setText(R.string.pull_to_refresh_tap_label);

			// Replace refresh drawable with arrow drawable

			mRefreshViewImage.setImageResource(R.drawable.ic_pulltorefresh_arrow);

			// Clear the full rotation animation

			mRefreshViewImage.clearAnimation();

			// Hide progress bar and arrow.

			mRefreshViewImage.setVisibility(View.GONE);

			mRefreshViewProgress.setVisibility(View.GONE);

		}

	}



	private void measureView(View child) {

		ViewGroup.LayoutParams p = child.getLayoutParams();

		if (p == null) {

			p = new ViewGroup.LayoutParams(ViewGroup.LayoutParams.FILL_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT);

		}



		int childWidthSpec = ViewGroup.getChildMeasureSpec(0, 0 + 0, p.width);

		int lpHeight = p.height;

		int childHeightSpec;

		if (lpHeight > 0) {

			childHeightSpec = MeasureSpec.makeMeasureSpec(lpHeight, MeasureSpec.EXACTLY);

		} else {

			childHeightSpec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED);

		}

		child.measure(childWidthSpec, childHeightSpec);

	}



	@Override

	public void onScroll(AbsListView view, int firstVisibleItem, int visibleItemCount, int totalItemCount) {

		// When the refresh view is completely visible, change the text to say

		// "Release to refresh..." and flip the arrow drawable.

		if (mCurrentScrollState == SCROLL_STATE_TOUCH_SCROLL && mRefreshState != REFRESHING) {

			if (firstVisibleItem == 0) {

				mRefreshViewImage.setVisibility(View.VISIBLE);

				if ((mRefreshView.getBottom() >= mRefreshViewHeight + 20 || mRefreshView.getTop() >= 0)

						&& mRefreshState != RELEASE_TO_REFRESH) {

					mRefreshViewText.setText(R.string.pull_to_refresh_release_label);

					mRefreshViewImage.clearAnimation();

					mRefreshViewImage.startAnimation(mFlipAnimation);

					mRefreshState = RELEASE_TO_REFRESH;

				} else if (mRefreshView.getBottom() < mRefreshViewHeight + 20 && mRefreshState != PULL_TO_REFRESH) {

					mRefreshViewText.setText(R.string.pull_to_refresh_pull_label);

					if (mRefreshState != TAP_TO_REFRESH) {

						mRefreshViewImage.clearAnimation();

						mRefreshViewImage.startAnimation(mReverseFlipAnimation);

					}

					mRefreshState = PULL_TO_REFRESH;

				}

			} else {

				mRefreshViewImage.setVisibility(View.GONE);

				resetHeader();

			}

		} else if (mCurrentScrollState == SCROLL_STATE_FLING && firstVisibleItem == 0 && mRefreshState != REFRESHING) {

			setSelection(1);

			mBounceHack = true;

		} else if (mBounceHack && mCurrentScrollState == SCROLL_STATE_FLING) {

			setSelection(1);

		}



		if (mOnScrollListener != null) {

			mOnScrollListener.onScroll(view, firstVisibleItem, visibleItemCount, totalItemCount);

		}

	}



	@Override

	public void onScrollStateChanged(AbsListView view, int scrollState) {

		mCurrentScrollState = scrollState;



		if (mCurrentScrollState == SCROLL_STATE_IDLE) {

			mBounceHack = false;

		}



		if (mOnScrollListener != null) {

			mOnScrollListener.onScrollStateChanged(view, scrollState);

		}

	}



	public void prepareForRefresh() {

		resetHeaderPadding();



		mRefreshViewImage.setVisibility(View.GONE);

		// We need this hack, otherwise it will keep the previous drawable.

		mRefreshViewImage.setImageDrawable(null);

		mRefreshViewProgress.setVisibility(View.VISIBLE);



		// Set refresh view text to the refreshing label

		mRefreshViewText.setText(R.string.pull_to_refresh_refreshing_label);



		mRefreshState = REFRESHING;

	}



	public void onRefresh() {

		Log.d(TAG, "onRefresh");



		if (mOnRefreshListener != null) {

			mOnRefreshListener.onRefresh();

		}

	}



	/**

	 * Resets the list to a normal state after a refresh.

	 * 

	 * @param lastUpdated

	 *            Last updated at.

	 */

	public void onRefreshComplete(CharSequence lastUpdated) {

		setLastUpdated(lastUpdated);

		onRefreshComplete();

	}



	/**

	 * Resets the list to a normal state after a refresh.

	 */

	public void onRefreshComplete() {

		Log.d(TAG, "onRefreshComplete");



		resetHeader();



		// If refresh view is visible when loading completes, scroll down to

		// the next item.

		if (mRefreshView.getBottom() > 0) {

			invalidateViews();

			setSelection(1);

		}

	}



	/**

	 * Invoked when the refresh view is clicked on. This is mainly used when there's only a few items in the list and

	 * it's not possible to drag the list.

	 */

	private class OnClickRefreshListener implements OnClickListener {



		@Override

		public void onClick(View v) {

			if (mRefreshState != REFRESHING) {

				prepareForRefresh();

				onRefresh();

			} else {

				onRefreshComplete();

			}

		}



	}



	/**

	 * Interface definition for a callback to be invoked when list should be refreshed.

	 */

	public interface OnRefreshListener {

		/**

		 * Called when the list should be refreshed.

		 * <p>

		 * A call to {@link PullToRefreshListView #onRefreshComplete()} is expected to indicate that the refresh has

		 * completed.

		 */

		public void onRefresh();

	}

}

[/java]



Добавим ListView на наш Activity:



[java]

public class MainActivity extends Activity {

	private final String[] values = { "Test 1", "Test 2", "Test 3", "Test 4", "Test 5", "Test 6", "Test 7", "Test 8",

			"Test 1", "Test 2", "Test 3", "Test 4", "Test 5", "Test 6", "Test 7", "Test 8", "Test 1", "Test 2",

			"Test 3", "Test 4", "Test 5", "Test 6", "Test 7", "Test 8", "Test 1", "Test 2", "Test 3", "Test 4",

			"Test 5", "Test 6", "Test 7", "Test 8" };



	@Override

	public void onCreate(Bundle savedInstanceState) {

		super.onCreate(savedInstanceState);

		// setContentView(R.layout.activity_main);



		ListAdapter adapter = new ArrayAdapter<String>(this, R.layout.list_item, values);

		PullToRefreshListView listView = new PullToRefreshListView(this);

		listView.setAdapter(adapter);

		setContentView(listView, new LayoutParams(LayoutParams.FILL_PARENT, LayoutParams.FILL_PARENT));

	}



}

[/java]



Все готово.





Коды как всегда [тут](http://android-helper.com.ua/forms).
Добрый день друзья.





Как и обещал выкладываю информацию о Fragments.





Пошарил немного по Интернету и нашел увлекательную статью на [Habrahabr.ru](http://habrahabr.ru/post/113196/)





Поэтому было решено вставить ее сюда полностью + со своей доработкой


<!-- more -->


_В Android 3.0 введена новая концепция фрагментов, которая служит для упрощения работы с интерфейсом под разные размеры экранов. Данный топик является переводом статьи с android-developers.blogspot.com. В ней рассмотрены преимущества фрагментов, а также приведен простой, но законченный пример приложения, работающего по этому принципу._





Важная цель Android 3.0 — упростить написание программ, которые должны масштабироваться в зависимости от размеров экрана. Для этого в платформе Android уже доступны следующие средства:








  * С самого начала, UI-фреймворк был спроектирован для использования layout managers, которые позволяют описывать интерфейс так, чтобы он «подгонялся» к размерам. Примером этого является ListView, высота которого изменяется в зависимости от размера экрана, который варьируется между соотношениями QVGA, HVGA, and WVGA.



  * В Android 1.6 была введена новая концепция плотности экрана, позволяющая приложениям легче масштабировать размеры между разными разрешениями, в то время как экраны имеют почти один и тот же физический размер. Разработчики незамедлительно начали использовать эту особенность, когда были введены телефоны с высоким разрешением, такие как Droid.



  * Также в Android 1.6 разработчикам стали доступны размеры экрана, при помощи их классификации: «small» для соотношения QVGA, «normal» для HVGA и WVGA, и «large» для более больших экранов. Разработчики могут использовать систему ресурсов для выбора между различными layout'ами, в зависимости от размера экрана






Комбинация layout managers и выбора различных ресурсов представляет долгий путь для создания масштабируемого интерфейса. В итоге многие приложения для хэндсетов не используют специальный интерфейс для планшетов, работающих под Honeycomb.





#### Введение во фрагменты





В Android 3.0 введена поддержка новых классов, которые помогают приложениям масштабировать их интерфейс, называемых фрагментами (Fragment). Фрагмент — это независимый компонент со своим интерфейсом и жизненным циклом; он может быть неоднократно использован в разных частях пользовательского интерфейса, в зависимости от нужного UI потока для определенного устройства или экрана.





В некотором смысле можно рассматривать фрагмент как мини-Activity, хотя он не может запускаться независимо и должен размещаться внутри Activity. На самом деле введение Fragment API дало нам возможность решать многие проблемы, с которыми сталкивались разработчики, при работе с Activity, так как полезность фрагмента простирается далеко за пределы обычных настроек для разных разрешений экрана:








  * Activity, вложенные через ActivityGroup были хорошей идеей, однако с ними было не так просто работать, так как Activity изначально разработан как независимый компонент. Fragment API — намного лучшее решение для этого, его стоит рассматривать как замену для вложенных Activity.



  * Сохранение данных для экземпляров Activity может быть выполнено через Activity.onRetainNonConfigurationInstance(), но это неуклюже само по себе и не очевидно. Фрагменты заменяют этот механизм, позволяя сохранять целый экземпляр фрагмента простой установкой флага.



  * Одна из конкретизаций фрагмента — DialogFragment, она упрощает отображение диалога, который управляется как часть жизненного цикла Activity. Он заменяет API Activity, используемые для управления диалогами.



  * Еще одна конкретизация фрагмента — ListFragment, она упрощает отображение списка данных. ListFragment похож на ListActivity (с несколькими дополнительными особенностями), его использование упростит отображение данных в списке.



  * Информация по всем фрагментам, прикрепленным к Activity, сохраняется фреймворком в сохраненное состояние той же Activity и восстанавливается при рестарте. Таким образом уменьшается количество сохраняемых состояний.



  * У фреймворка есть встроенная поддержка для управления стеком фрагментов, она упрощает поддержку поведения кнопки BACK внутри Activity, причем это поведение интегрируется с существующим стеком Activities.






#### Приступая к работе





Вот простой, но полный пример реализации множественных потоков UI, с помощью фрагментов. Начнем с проектирования ландшафтного layout'a, содержащего список элементов слева и данные по ним справа. Так выглядит нужный нам layout:





![](http://android-helper.com.ua/images/uploads/2012/07/device-fragment-land_new.png)




Код для Activity не особенно интересен, он просто вызывает setContentView() со следующим макетом:







	<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"

    android:layout_width="match_parent"

    android:layout_height="match_parent"

    android:orientation="horizontal" >



    <fragment

        android:id="@+id/titles"

        android:layout_width="0px"

        android:layout_height="match_parent"

        android:layout_weight="1"

        class="com.example.androidhelper.fragments.TitlesFragment" />



    <FrameLayout

        android:id="@+id/details"

        android:layout_width="0px"

        android:layout_height="match_parent"

        android:layout_weight="1" />



	</LinearLayout>


Вы можете заметить первую особенность: тег

	<fragment>

позволяет устанавливать фрагмент в вашу иерархию интерфейса. Вышеописанный фрагмент наследует свойства ListFragment, который отображает данные по элементу в текущем месте, или в отдельном Activity, в зависимости от layout'a. Обратите внимание на то, как сохраняются изменения в состоянии фрагмента.

	public class TitlesFragment extends ListFragment {

	boolean mDualPane;

	int mCurCheckPosition = 0;



	@Override

	public void onActivityCreated(Bundle savedState) {

		super.onActivityCreated(savedState);



		// Populate list with our static array of titles.

		setListAdapter(new ArrayAdapter<String>(getActivity(), R.layout.list_item, Shakespeare.TITLES));



		// Check to see if we have a frame in which to embed the details

		// fragment directly in the containing UI.

		View detailsFrame = getActivity().findViewById(R.id.details);

		mDualPane = detailsFrame != null && detailsFrame.getVisibility() == View.VISIBLE;



		if (savedState != null) {

			// Restore last state for checked position.

			mCurCheckPosition = savedState.getInt("curChoice", 0);

		}



		if (mDualPane) {

			// In dual-pane mode, list view highlights selected item.

			getListView().setChoiceMode(ListView.CHOICE_MODE_SINGLE);

			// Make sure our UI is in the correct state.

			showDetails(mCurCheckPosition);

		}

	}



	@Override

	public void onSaveInstanceState(Bundle outState) {

		super.onSaveInstanceState(outState);

		outState.putInt("curChoice", mCurCheckPosition);

	}



	@Override

	public void onListItemClick(ListView l, View v, int pos, long id) {

		showDetails(pos);

	}



	/**

	 * Helper function to show the details of a selected item, either by displaying a fragment in-place in the current

	 * UI, or starting a whole new activity in which it is displayed.

	 */

	void showDetails(int index) {

		mCurCheckPosition = index;



		if (mDualPane) {

			// We can display everything in-place with fragments.

			// Have the list highlight this item and show the data.

			getListView().setItemChecked(index, true);



			// Check what fragment is shown, replace if needed.

			DetailsFragment details = (DetailsFragment) getFragmentManager().findFragmentById(R.id.details);

			if (details == null || details.getShownIndex() != index) {

				// Make new fragment to show this selection.

				details = DetailsFragment.newInstance(index);



				// Execute a transaction, replacing any existing

				// fragment with this one inside the frame.

				FragmentTransaction ft = getFragmentManager().beginTransaction();

				ft.replace(R.id.details, details);

				ft.setTransition(FragmentTransaction.TRANSIT_FRAGMENT_FADE);

				ft.commit();

			}



		} else {

			// Otherwise we need to launch a new activity to display

			// the dialog fragment with selected text.

			Intent intent = new Intent();

			intent.setClass(getActivity(), DetailsActivity.class);

			intent.putExtra("index", index);

			startActivity(intent);

		}

	}

	}


Также необходимо реализовать DetailsFragment, который будет отображать данные по элементу в обычном TextView.

	public class DetailsFragment extends Fragment {

	/**

	 * Create a new instance of DetailsFragment, initialized to show the text at 'index'.

	 */

	public static DetailsFragment newInstance(int index) {

		DetailsFragment f = new DetailsFragment();



		// Supply index input as an argument.

		Bundle args = new Bundle();

		args.putInt("index", index);

		f.setArguments(args);



		return f;

	}



	public int getShownIndex() {

		return getArguments().getInt("index", 0);

	}



	@Override

	public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {

		if (container == null) {

			// Currently in a layout without a container, so no

			// reason to create our view.

			return null;

		}



		ScrollView scroller = new ScrollView(getActivity());

		TextView text = new TextView(getActivity());

		int padding = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 4, getActivity().getResources()

				.getDisplayMetrics());

		text.setPadding(padding, padding, padding, padding);

		scroller.addView(text);

		text.setText(Shakespeare.DIALOGUE[getShownIndex()]);

		return scroller;

	}

	}

Настало время для добавления еще одного потока UI в наше приложение. Когда экран находится в портретном режиме, то недостаточно места для отображения двух фрагментов бок о бок. То есть мы хотим, чтобы отображался только список:





![](http://android-helper.com.ua/images/uploads/2012/07/device-fragment-port1_new.png)





Напишем новый layout для портретной ориентации:


	<?xml version="1.0" encoding="utf-8"?>

	<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"

    android:layout_width="match_parent"

    android:layout_height="match_parent" >



    <fragment

        android:id="@+id/titles"

        android:layout_width="match_parent"

        android:layout_height="match_parent"

        class="com.example.androidhelper.fragments.TitlesFragment" />



	</FrameLayout>



Теперь у нас нет контейнера для отображения данных для TitlesFragment, отображается только список. При нажатии на элемент списка теперь нужно вызывать отдельное Activity, в котором и будут отображаться данные:





![](http://android-helper.com.ua/images/uploads/2012/07/device-fragment-port2_new.png)





Теперь, всё что от нас требуется — использовать уже готовый DetailsFragment:
	
	public class DetailsActivity extends FragmentActivity {



	@Override

	protected void onCreate(Bundle savedInstanceState) {

		super.onCreate(savedInstanceState);



		if (getResources().getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPE) {

			// If the screen is now in landscape mode, we can show the

			// dialog in-line so we don't need this activity.

			finish();

			return;

		}



		if (savedInstanceState == null) {

			// During initial setup, plug in the details fragment.

			DetailsFragment details = new DetailsFragment();

			details.setArguments(getIntent().getExtras());

			getSupportFragmentManager().beginTransaction().add(android.R.id.content, details).commit();

		}

	}



	}



Соединив Activity, мы получаем полностью работающий пример приложения, использующего радикальное изменение UI потока, основанное на том, какая конфигурация используется в данный момент. Также приложение автоматически подгоняется под требования размеров экрана при смене конфигурации.





Этот пример иллюстрирует всего лишь один способ использования фрагментов для подгонки вашего UI. В зависимости от дизайна, вы можете предпочесть другие. Например, вы можете поместить всё ваше приложение в одно Activity, в котором будет изменяться структура фрагментов.





Как обычно, больше информации можно найти в документации по SDK. Также можно найти примеры в ApiDemos.





#### Фрагментация для всех





Fragment API будет полезен для разработчиков, начинающих работать с приложениями, ориентированными на планшеты, которые спроектированы под Android 3.0, во многих случаях, связанных с большим экраном. Также использование фрагментов должно сделать проще настройку UI для приложений под новые устройства на Android, например, телевизоры.





Однако, сейчас Fragment API будет наиболее востребован для улучшения интерфейса существующих приложений для телефонов под планшеты.





Также планируется сделать статическую библиотеку для использования Fragment API (_Ура!!!_), чтобы использовать вышеописанный метод на ранних версиях Android. На самом деле, весь код в примере использует как раз статическую библиотеку классов, причем выполняется на Android 2.3 (можете сравнить с примерами в Android 3.0 SDK, они почти не отличаются). Наша цель — сделать эти API как можно более похожими, чтобы вы могли начать работать с ними сейчас, независимо от того, когда вы перейдете на Android 3.0.





Пока нет точной даты, когда библиотека будет доступна, но она точно будет скоро. Пока вы можете начать работать с фрагментами на Android 3.0.





#### Дополнения





Это была первая статья которая описывала фрагменты. На данный момент выпущена библиотека с обратной совместимостью (см. мои предыдущие посты) до версии андроид 1.6.





Для подключения фрагментов в приложения с обратной совместимостью вам нужно сделать следующее:





Наследоватся не от Activity, а от FragmentActivity. Это самое главное требование.





Пример как всегда вы сможете скачать [тут](http://android-helper.com.ua/forms/).
Добрый день друзья.





В предыдущих статьях я писал о использовании [Swipe](http://android-helper.com.ua/%D1%81%D0%BB%D0%B0%D0%B9%D0%B4%D0%B8%D0%BD%D0%B3-%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%BE%D0%B2-%D1%81-%D0%BF%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%D1%8E-viewpager/) и своих [Tabs](http://android-helper.com.ua/%D0%BA%D0%B0%D0%BA-%D1%81%D0%B4%D0%B5%D0%BB%D0%B0%D1%82%D1%8C-%D1%81%D0%B2%D0%BE%D0%B8-tabs-%D0%B2-android/)





Тогда у меня возник вопрос, как же их можно объединить. 





![](http://android-helper.com.ua/images/uploads/2012/07/device-2012-07-17-084758.png)


<!-- more -->


### 1. Подготовка проекта





Перед тем как приступить к реализации этой задачи, нам нужно подключить библиотеку обратной совместимости.





Как это сделать, вы можете прочесть [тут](http://android-helper.com.ua/%D1%81%D0%BB%D0%B0%D0%B9%D0%B4%D0%B8%D0%BD%D0%B3-%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%BE%D0%B2-%D1%81-%D0%BF%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%D1%8E-viewpager/) (предварительная настройка).





### 2. Подготовка ресурсов





Откройте файл main.xml и пропишите туда следующий код:

	<?xml version="1.0" encoding="utf-8"?>

	<TabHost xmlns:android="http://schemas.android.com/apk/res/android"

	android:id="@android:id/tabhost"

	android:layout_width="match_parent"

	android:layout_height="match_parent" >



		<LinearLayout

		android:layout_width="match_parent"

		android:layout_height="match_parent"

		android:orientation="vertical" >



		<FrameLayout

			android:id="@android:id/tabcontent"

			android:layout_width="0dp"

			android:layout_height="0dp"

			android:layout_weight="0" />



		<android.support.v4.view.ViewPager

			android:id="@+id/pager"

			android:layout_width="match_parent"

			android:layout_height="0dp"

			android:layout_weight="1" />



		<TabWidget

			android:id="@android:id/tabs"

			android:layout_width="match_parent"

			android:layout_height="wrap_content"

			android:layout_weight="0"

			android:orientation="horizontal" />

	</LinearLayout>



	</TabHost>


### 3. Подготовка Activity





Для реализации данного примера мы будем наследоваться не от Activity, а от **FragmentActivity** (о фрагментах мы поговорим в следующей статье):



	public class MainActivity extends FragmentActivity 
  




В метод onCreate пишем следующее:



	private TabHost mTabHost;

	private ViewPager mViewPager;

	private TabsAdapter mTabsAdapter;



	@Override

	public void onCreate(final Bundle savedInstanceState) {

		super.onCreate(savedInstanceState);

		setContentView(R.layout.activity_main);

		mTabHost = (TabHost) findViewById(android.R.id.tabhost);

		mTabHost.setup();



		mViewPager = (ViewPager) findViewById(R.id.pager);



		mTabsAdapter = new TabsAdapter(this, mTabHost, mViewPager);



		mTabsAdapter.addTab(mTabHost.newTabSpec("simple").setIndicator("Android"), AndroidFragment.class, null);

		mTabsAdapter.addTab(mTabHost.newTabSpec("contacts").setIndicator("IOs"), IOsFragment.class, null);

		mTabsAdapter.addTab(mTabHost.newTabSpec("custom").setIndicator("Windows"), WindowsFragment.class, null);

		mTabsAdapter.addTab(mTabHost.newTabSpec("throttle").setIndicator("DOS"), DOSFragment.class, null);



		if (savedInstanceState != null) {

			mTabHost.setCurrentTabByTag(savedInstanceState.getString("tab"));

		}

	}


  




### 4. Реализация Adapter





Вот тут начинается самое интересное.





Создаем adapter который у нас будет унаследован от **FragmentPagerAdapter**, а также для обработки нажатий на Tabs мы подпишемся на обработчик событий **TabHost.OnTabChangeListener** и для скролинга страниц также подписываемся на **ViewPager.OnPageChangeListener**





Полный код вы можете увидеть ниже:



	public static class TabsAdapter extends FragmentPagerAdapter implements TabHost.OnTabChangeListener,

			ViewPager.OnPageChangeListener {

		private final Context mContext;

		private final TabHost mTabHost;

		private final ViewPager mViewPager;

		private final ArrayList<TabInfo> mTabs = new ArrayList<TabInfo>();



		static final class TabInfo {

			private final String tag;

			private final Class<?> clss;

			private final Bundle args;



			TabInfo(final String _tag, final Class<?> _class, final Bundle _args) {

				tag = _tag;

				clss = _class;

				args = _args;

			}

		}



		static class DummyTabFactory implements TabHost.TabContentFactory {

			private final Context mContext;



			public DummyTabFactory(final Context context) {

				mContext = context;

			}



			@Override

			public View createTabContent(final String tag) {

				View v = new View(mContext);

				v.setMinimumWidth(0);

				v.setMinimumHeight(0);

				return v;

			}

		}



		public TabsAdapter(final FragmentActivity activity, final TabHost tabHost, final ViewPager pager) {

			super(activity.getSupportFragmentManager());

			mContext = activity;

			mTabHost = tabHost;

			mViewPager = pager;

			mTabHost.setOnTabChangedListener(this);

			mViewPager.setAdapter(this);

			mViewPager.setOnPageChangeListener(this);

		}



		public void addTab(final TabHost.TabSpec tabSpec, final Class<?> clss, final Bundle args) {

			tabSpec.setContent(new DummyTabFactory(mContext));

			String tag = tabSpec.getTag();



			TabInfo info = new TabInfo(tag, clss, args);

			mTabs.add(info);

			mTabHost.addTab(tabSpec);

			notifyDataSetChanged();

		}



		@Override

		public int getCount() {

			return mTabs.size();

		}



		@Override

		public Fragment getItem(final int position) {

			TabInfo info = mTabs.get(position);

			return Fragment.instantiate(mContext, info.clss.getName(), info.args);

		}



		@Override

		public void onTabChanged(final String tabId) {

			int position = mTabHost.getCurrentTab();

			mViewPager.setCurrentItem(position);

		}



		@Override

		public void onPageScrolled(final int position, final float positionOffset, final int positionOffsetPixels) {

		}



		@Override

		public void onPageSelected(final int position) {

			// Unfortunately when TabHost changes the current tab, it kindly

			// also takes care of putting focus on it when not in touch mode.

			// The jerk.

			// This hack tries to prevent this from pulling focus out of our

			// ViewPager.

			TabWidget widget = mTabHost.getTabWidget();

			int oldFocusability = widget.getDescendantFocusability();

			widget.setDescendantFocusability(ViewGroup.FOCUS_BLOCK_DESCENDANTS);

			mTabHost.setCurrentTab(position);

			widget.setDescendantFocusability(oldFocusability);

		}



		@Override

		public void onPageScrollStateChanged(final int state) {

		}

	}
 
  




### 5. Финальная стадия





Из пункта 2 видно что у нас есть 4 новых фрагмента. Так давайте их создадим.





**AndroidFragment**:




	import android.os.Bundle;

	import android.support.v4.app.Fragment;

	import android.view.LayoutInflater;

	import android.view.View;

	import android.view.ViewGroup;



	public class AndroidFragment extends Fragment {



	@Override

	public View onCreateView(final LayoutInflater inflater, final ViewGroup container, final Bundle savedInstanceState) {

		View view = inflater.inflate(R.layout.android_fragment, container, false);

		return view;

	}



	}




**IOsFragment**:



	public class IOsFragment extends Fragment {



	@Override

	public View onCreateView(final LayoutInflater inflater, final ViewGroup container, final Bundle savedInstanceState) {

		View view = inflater.inflate(R.layout.ios_fragment, container, false);

		return view;

	}



	}

  




**WindowsFragment:**



	public class WindowsFragment extends Fragment {



	@Override

	public View onCreateView(final LayoutInflater inflater, final ViewGroup container, final Bundle savedInstanceState) {

		View view = inflater.inflate(R.layout.windows_fragment, container, false);

		return view;

	}



	}

 
  




**DOSFragment:**



	public class DOSFragment extends Fragment {



	@Override

	public View onCreateView(final LayoutInflater inflater, final ViewGroup container, final Bundle savedInstanceState) {

		View view = inflater.inflate(R.layout.dos_fragment, container, false);

		return view;

	}



	}
  
  




Теперь нам нужно создать еще 4 xml файла которые мы используем в фрагментах





**android_fragment.xml**




	<?xml version="1.0" encoding="utf-8"?>
	
	<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"

	android:layout_width="match_parent"

	android:layout_height="match_parent"

	android:orientation="vertical" >



	<TextView

		android:id="@+id/textView1"

		android:layout_width="wrap_content"

		android:layout_height="wrap_content"

		android:text="Android" />



	</LinearLayout>

  
  




**dos_fragment.xml**



	<?xml version="1.0" encoding="utf-8"?>

	<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"

	android:layout_width="match_parent"

	android:layout_height="match_parent"

	android:orientation="vertical" >



	<TextView

		android:id="@+id/textView1"

		android:layout_width="wrap_content"

		android:layout_height="wrap_content"

		android:text="DOS" />



	</LinearLayout>


  




**ios_fragment.xml**




	<?xml version="1.0" encoding="utf-8"?>

	<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"

	android:layout_width="match_parent"

	android:layout_height="match_parent"

	android:orientation="vertical" >



	<TextView

		android:id="@+id/textView1"

		android:layout_width="wrap_content"

		android:layout_height="wrap_content"

		android:text="IOs" />



	</LinearLayout>
  
  




**windows_fragment.xml**



	<?xml version="1.0" encoding="utf-8"?>

	<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"

	android:layout_width="match_parent"

	android:layout_height="match_parent"

	android:orientation="vertical" >



	<TextView

		android:id="@+id/textView1"

		android:layout_width="wrap_content"

		android:layout_height="wrap_content"

		android:text="Windows" />



	</LinearLayout>

  




Ну вот и все. 





Коды можно скачать [тут](http://android-helper.com.ua/forms/).
Всем привет.





Я долго думал как же мне поскорее помочь вам разобраться в android. И решил, что я буду собирать очень интересные статьи на своем сайте.





Сегодня речь пойдет о горизонтальной прокрутке экранов. (статья из [Хабрахабр](http://habrahabr.ru/post/131889/))

<!-- more -->



##### Вступление





Горизонтальная прокрутка экранов — удобная и модная вещь. На Хабре уже был [топик ](http://habrahabr.ru/blogs/android_development/118482/), посвященный данной теме. Однако использование ViewFlipper не позволяет с легкостью добиться эффекта привязки, когда экраны двигаются вместе с пальцем. Также нужен механизм автоматической доводки экранов в ту или иную сторону. Примера, где это было бы хорошо разъяснено и реализовано, так и не нашел. В комментариях [предлагали](http://habrahabr.ru/blogs/android_development/118482/#comment_3863174) посмотреть исходники гугловского кода, где это реализовано. Однако удобнее было бы воспользоваться готовым решением. Такой механизм реализован в Android [Support Package ](http://developer.android.com/sdk/compatibility-library.html). Использовать эту библиотеку можно для версий Android 1.6 и старше. Конкретно нам понадобятся классы ViewPager и PagerAdapter.





##### Предварительная настройка





Чтобы подключить библиотеку к проекту, выполняем следующие действия.  
Идем в директорию, куда установлен Android SDK, запускаем SDK Manager и в списке доступных к установке компонентов выбираем Android Support package. Устанавливаем его. Все что нужно будет находиться в следующей директории: <директория с sdk>/extras/android/support/. В папке v4 будет лежать .jar файл, который и нужно подключить к проекту. Если вы работаете в Eclipse, то в Package Explorer щелкаем правым кликом по проекту, выбираем Build Path -> Add External Archives. В появившемся диалоговом окне переходим к скачанному .jar файлу, выбираем его и щелкаем OK. Всё, библиотека подключена к проекту и готова к использованию.  
Хочется заметить, что могут возникнуть проблемы, если вы используете старую версию SDK Manager. У меня указанный Support Package не появлялся в списке доступных загрузок. После обновления SDK проблема решилась.





##### Разработка





Выполнив инструкции, приведенные по указанной выше ссылке, и установив библиотеку, можно приступать к реализации поставленной задачи.  
ViewPager по принципу работы похож на ListView. Данные для отображения он берет из PagerAdapter. Нам потребуется унаследовать свой класс от PagerAdapter и реализовать в нем некоторые методы. Добавление и удаление экранов реализуется с помощью методов instantiateItem() и destroyItem() соответственно. View для отображения можно создавать прямо в адаптере. Такой подход хорош тем, что ViewPager можно настраивать так, чтобы в адаптере не хранились все экраны сразу. По умолчанию адаптер хранит текущий экран, и по одному слева и справа от него. Это может сэкономить память, если содержание экранов слишком сложное. Однако в данном примере создадим все экраны в activity приложения, добавим их в список, и передадим затем этот список адаптеру. Адаптер же не будет сам создавать view, а будет брать их их списка.  
Код адаптера получился следующим. 








	public class SamplePagerAdapter extends PagerAdapter{

    

    List<View> pages = null;

    

    public SamplePagerAdapter(List<View> pages){

        this.pages = pages;

    }

    

    @Override

    public Object instantiateItem(View collection, int position){

        View v = pages.get(position);

        ((ViewPager) collection).addView(v, 0);

        return v;

    }

    

    @Override

    public void destroyItem(View collection, int position, Object view){

        ((ViewPager) collection).removeView((View) view);

    }

    

    @Override

    public int getCount(){

        return pages.size();

    }

    

    @Override

    public boolean isViewFromObject(View view, Object object){

        return view.equals(object);

    }



    @Override

    public void finishUpdate(View arg0){

    }



    @Override

    public void restoreState(Parcelable arg0, ClassLoader arg1){

    }



    @Override

    public Parcelable saveState(){

        return null;

    }



    @Override

    public void startUpdate(View arg0){

    }

	}









В адаптере нам потребовалось определить свою реализацию для методов instantiateItem(), destroyItem(), getCount() и isViewFromObject(). Для остальных методов тела можно оставить пустыми.  
  
Создадим файл разметки page.xml и опишем в нем содержимое экрана следующим образом:









	<?xml version="1.0" encoding="utf-8"?>

	<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"

    android:layout_width="fill_parent"

    android:layout_height="fill_parent"

    android:padding="10dip"

    android:background="#ddd">



    <TextView

        android:id="@+id/text_view"

        android:layout_width="fill_parent"

        android:layout_height="fill_parent"

        android:layout_centerInParent="true"

        android:gravity="center"

        android:background="#888"

        android:textColor="#fff"

        android:textSize="30dip"/>

	</RelativeLayout>












В activity приложения, как было указано выше, создадим несколько View, которые и будут нашими экранами, добавим их в список и передадим список адаптеру. Затем создадим ViewPager и установим для него полученный адаптер.  
  
Код activity:












	public class ViewPagerSampleActivity extends Activity {

    /** Called when the activity is first created. */

    @Override

    public void onCreate(Bundle savedInstanceState) {

        super.onCreate(savedInstanceState);

        

        LayoutInflater inflater = LayoutInflater.from(this);

        List<View> pages = new ArrayList<View>();

        

        View page = inflater.inflate(R.layout.page, null);

        TextView textView = (TextView) page.findViewById(R.id.text_view);

        textView.setText("Страница 1");

        pages.add(page);

        

        page = inflater.inflate(R.layout.page, null);

        textView = (TextView) page.findViewById(R.id.text_view);

        textView.setText("Страница 2");

        pages.add(page);

        

        page = inflater.inflate(R.layout.page, null);

        textView = (TextView) page.findViewById(R.id.text_view);

        textView.setText("Страница 3");

        pages.add(page);

        

        SamplePagerAdapter pagerAdapter = new SamplePagerAdapter(pages);

        ViewPager viewPager = new ViewPager(this);

        viewPager.setAdapter(pagerAdapter);

        viewPager.setCurrentItem(1);     

        

        setContentView(viewPager);

    }

	}













Как видно из кода, мы создали три экрана. Для каждого из них мы указали какой он по счету. Установив адаптер для ViewPager, укажем что сейчас будет показываться экран с индексом 1, т.е. на котором написано «Страница 2».   
Скриншот приложения, во время прокручивания экрана:









![](http://android-helper.com.ua/images/uploads/2012/06/Image.png)












##### Заключение



Как видно из примера, использовать ViewPager и PagerAdapter достаточно легко. При слайдинге экранов, изображения привязывается к положению пальца. Работает автоматическая доводка в какую либо из сторон. Нажатия на дочерние элементы (различные кнопки, элементы списка, если таковой присутствует) обрабатываются корректно.  
  
И в заключение, ссылка на [статью ](http://android-developers.blogspot.com/2011/08/horizontal-view-swiping-with-viewpager.html), в которой рассказывается о ViewPager.




</li>&ndash;&gt;-->
    <!--&lt;!&ndash;&ndash;&gt;-->
    <!--&lt;!&ndash;<li>ТренингиДобрый день друзья.





Много времени было затрачено, на изготовление данного курса.





Надеюсь вам он очень понравиться и поможет.





И так приступим.


<!-- more -->


**Тема курса:** Пошаговая инструкция для Android





**Формат курса:** Видео.





**Содержание курса:**








1. Регистрация в Google
2. Создание новых контактов
3. Установка русского языка на телефон
4. Добавление google account в телефон
5. Синхронизация с серверами Google
6. Работа с контактами, почтой и календарем
7. Google Play - установка и удаление программ
8. 5 нужных программ
9. Установка музыки на звонок
10. Использование Google Talk или замена ICQ
11. Что делать когда ваш телефон тормозит? 






1. **Регистрация в Google**

{% youtube QleZZheJJE8 %}


2. **Создание новых контактов**

{% youtube _Gvp_3nBHsQ %}


3. **Установка русского языка на телефон**

{% youtube vj9fHNutl3 %}


4. **Добавление google account в телефон**

{% youtube UqTKVR3c34A %}


5. **Синхронизация с серверами Google**


{% youtube ah-RGWmm0Sw %}








6. **Работа с контактами, почтой и календарем**

{% youtube LPkgRf_FJro %}









7. **Google Play - установка и удаление программ**

{% youtube vHZz299UCF0 %}









8. **5 нужных программ**

{% youtube 1fB7bIMxsag %}









9. **Установка музыки на звонок**


{% youtube IsoBTiT3Jv4 %}








10. **Использование Google Talk или замена ICQ**

{% youtube lma-EzSgCYs %}









11. **Что делать когда ваш телефон тормозит?**

{% youtube _Gvp_3nBHsQ %}





Надеюсь, что вам понравилась наш тренинг.





Приглашайте друзей и освоим android вместе.
</li>&ndash;&gt;-->
    <!--&lt;!&ndash;&ndash;&gt;-->
    <!--&lt;!&ndash;<li>Игры для android### Уважаемый читатель.





Обращаюсь к тебе, как к основному источнику моих идей и предложений.





Недавно мы организовали общий аккаунт (доступный только нашим подписчикам).





Думаю многим будет интересно, что же там такое есть в этом аккаунте.<!-- more -->





### Общий аккаунт





Большинство наших подписчиков и особенно тех людей которые проходят вебинар - “Android на 100%”, жалуются, что в PlayMarket есть программы которые стоят денег. Некоторые из них, не малых.





Так вот, мы подумали и решили, почему же не сделать один аккаунт и пополнять его купленными программами. Да-да вы не ошиблись, мы реально покупаем программы для этого аккаунта. Также мы подготовили небольшой список того, что уже куплено или планируется к покупке. [Список](http://android-helper.com.ua/premiumaccaount/)





### Как получить доступ?





Все очень просто, заходите [сюда](http://andrii.stakhov.justclick.ru/order/premium_account/), вводите этот номер: **AcPrAH200**. А дальше мы вам присылаем инструкции.





### ВАЖНО!





Но важно, то что нам нужна ваша помощь. Вы спросите скорее всего в чем. Так вот. Мы хотим покупать только те программы которые нужны нашим подписчикам. А не те, что считаем нужными. Так как общий аккаунт для вас, то и персонализация будет уместна.





Заполните пожайлуста вопросник ниже, с именами и ссылками на те программы которые вы хотели бы получить.





Рейтинг будет составлен на количестве повторений.





Спасибо за помощь.




Всем привет.





Вот список того, что будет и есть в общем аккаунте:


<!-- more -->


[Moon+ Reader Pro](https://play.google.com/store/apps/details?id=com.flyersoft.moonreaderp) - **Купленно**





[Asphalt 7: Heat ](https://play.google.com/store/apps/details?id=com.gameloft.android.ANMP.GloftA7HM)- **Купленно**





[Tasker](https://play.google.com/store/apps/details?id=net.dinglisch.android.taskerm&feature=apps_topselling_paid)





[ROM Manager (Premium)](https://play.google.com/store/apps/details?id=com.koushikdutta.rommanager.license&feature=apps_topselling_paid)





[Smart Tools](https://play.google.com/store/apps/details?id=kr.aboy.tools&feature=apps_topselling_paid)





[World of Goo](https://play.google.com/store/apps/details?id=com.twodboy.worldofgoofull&feature=apps_topselling_paid)





[Fruit Ninja](https://play.google.com/store/apps/details?id=com.halfbrick.fruitninja&feature=apps_topselling_paid)





[Titanium Backup PRO Key ★ root](https://play.google.com/store/apps/details?id=com.keramidas.TitaniumBackupPro&feature=apps_topselling_paid)





[Poweramp Full Version Unlocker ](https://play.google.com/store/apps/details?id=com.maxmpz.audioplayer.unlock)- **Купленно**
Android уже давно не страдает от отсутствия навороченных 3D игрушек. Прошли те времена, когда единственным производителем красивых времяубивалок была компания Gameloft. Сейчас в Маркете можно найти множество игр с красивой трехмерной графикой, которые требуют самого мощного и современного железа для запуска.









![Reign of Amira: the lost kingdom](http://www.droidnews.ru/wp-content/uploads/2013/03/reign_of_amira_3-600x337.jpg)





  <!-- more -->


Однако, это не мешает компаниям, традиционно производящим исключительно железо, взять и выпустить какой-нибудь свой софтверный навороченный продукт. К примеру, экшн-рпг, как это сделали в Qualcomm, выложив в Google Play новую игрушку Reign of Amira: the lost kingdom, призванную продемонстрировать все возможности новой линейки процессоров Snapdragon 600.













![Reign of Amira: the lost kingdom](http://www.droidnews.ru/wp-content/uploads/2013/03/reign_of_amira_2-600x337.jpg)








Reign of Amira — это своего рода бенчмарк, который покажет вам все достижения компании в области вычислительной мощи и графики. Впрочем, это уже не первый раз, когда железный вендор выпускает собственную игру для демонстрации своих новых тенхологий. Те же Qualcomm ранее впустили просто Reign of Amira, чтобы показать, насколько удался графический ускоритель Andreno 320. А теперь продолжением Reign of Amira: the lost kingdom Они стремятся продвинуть и прорекламировать свои процессоры Snapdragon 600, которые сейчас уже можно увидеть во всех актуальных флагманах.









![Reign of Amira: the lost kingdom](http://www.droidnews.ru/wp-content/uploads/2013/03/reign_of_amira_1-600x337.jpg)








Не стоит ждать увлекательного сюжета и затягивающего геймплея от этой игрушки. Акцент тут всё же был сделан на другом. Правда, судя по отзывам в Google Play, не все довольны и бенчмарк-стороной. Пользователи отмечают, что графика и физика в игре не особенно впечатляет и могла бы быть и лучше, а сама игра надоедает уже после 10-15 минут процесса. Стоит отметить лишь, что некоторым удалось завести Reign of Amira: the lost kingdom на Optimus G. Может быть именно поэтому графика не самая эффектная.





Но, если новость об игрушке вас заинтересовала настолько, что захотелось пойти рубить монстров на право и на лево, то вот ссылка на [установку](https://play.google.com/store/apps/details?id=com.qualcomm.sgs.reignofamiratlk).
20 апреля в Санкт-Петербурге [ITmozg](http://spb.itmozg.ru/) снова соберет на одной площадке новичков и профессионалов IT-рынка на ежегодном Фестивале профессионального развития — [BitByte](http://bitbyte.itmozg.ru/). 









![Bitbyte](http://www.droidnews.ru/wp-content/uploads/2013/03/bitbyte_logo_2013-600x242.jpg)


 <!-- more -->

  
   
В программе:  
— Две параллельные секции докладов, посвященные техническим и карьерным вопросам;  
— Выставка, где можно напрямую пообщаться с представителями IT-компаний, узнать о возможностях трудоустройства;  
— Много активностей: головоломки и тесты, розыгрыши и подарки, сюрпризы и еще много-много интересного :)













Среди компаний-участников: Google, Oracle, EMC, Яндекс.Деньги, Sperasoft, Mail. ru Group, T-Systems, Электрон и многие другие.





Участие бесплатное! Вход только по регистрации [http://bitbyte.itmozg.ru/register#form](http://bitbyte.itmozg.ru/register#form) 





Все подробности на сайте мероприятия: [http://bitbyte.itmozg.ru](http://bitbyte.itmozg.ru/)
Ну что, кто может сказать, когда мы уже, наконец, увидим следующую версию Android? Наверное, большинство из читателей скажет, что подобное событие произойдёт на мероприятии Google I/O. Во всяком случае об этом твердит большинство источников, и именно на это намекает прошлый опыт. Так что терпеливо ждём 15 мая.









![Эволюция Android](http://www.droidnews.ru/wp-content/uploads/2013/04/Android-5.0-Key-Lime-Pie-Rumors1-600x347.jpg)



 <!-- more -->




Однако, пока мы застыли в ожидании, давайте посмотрим, какие интересные слухи и догадки блуждают по Сети касаемо Android 5.0 Key Lime Pie.









Первое, о чем можно встретить упоминание — свежее ядро Linux версии 3.8. Любители перепрошиваться знают, насколько важно в системе грамотно собранное ядро. Ведь от него во многом зависит скорость работы мультитаскинга, оно может сильно влиять на расход заряда батареи, ядро же определит, сколько оперативной свободной памяти будет выделено пользователю. Так что у многих сейчас есть надежды, что оптимизация ядра поможет улучшить ситуацию вокруг некоторых давних проблем нашей любимой ОС.





Второй интересный слух про Kie Lime Pie гласит, что эта версия Android будет работать исключительно на четырёхъядерных устройствах. Однако, лично мне кажется, что такое развитие событий очень маловероятно. Вряд ли в Google решатся так сразу оставить огромное количество чуть менее современных устройств без обновления системы.





Куда более вероятным кажется, что в Key Lime Pie появится унифицированная Google-платформа для общения Google Babel, которая объединит в себе Google Talk, Google Plus, Google Voice.





Наверняка же к Android 5.0 обновится клавиатура, которая порадует нас более обширными словарями и улучшенными алгоритмами предугадывания вводимого текста.





Интересным остаётся вопрос, на каком именно устройстве нам продемонстрируют Key Lime Pie. Будет ли это Nexus 5 или же ожидаемый многими Motorola X Phone. Что вы думаете по этому поводу?





А вам какие из этих слухов кажутся максимально достоверными? Или какие наоборот — откровенной чепухой? Чего бы хотелось, чтобы подтвердилось?









 
Очередная игра.





И снова роботы и снова битвы, но на этот раз через музыку.





Смотрим, играем.


  <!-- more -->


**Вepcия:** 2.1.1  
**Рaзpaбoтчик:** Rayark Inc  
**Тpeбoвaния:** [Android](http://androidnews.com.ua/) OS 2.1 и вышe  
**Язык:** Руccкий, Английcкий  
Cytus - В дaлeкoм и пpизpaчнoм будущeм, миpoм cтaли пpaвить poбoты, бeздушныe и бeзэмoциoнaльныe мaшины, кoтopыe пытaютcя cмыcлить и пoчувcтвoвaть чeлoвeчecкиe мeчты и эмoции. Для этиx цeлeй oни coздaли мecтo, и дaли eй нaзвaниe Cytus, гдe вce чeлoвeчecкиe эмoции, чувcтвa и пepeживaния мoжнo пepeнocить в музыку.   
  
Вaм нeoбxoдимo нaжимaть в нoту в oпpeдeлeнный пpoмeжутoк вpeмeни. В вaшeм pacпopяжeнии бoлee 18 пeceн, 36 вapиaций и 9 уpoвнeй cлoжнocти. Пpoявитe cвoй тaлaнт!   
  
Оcoбeннocти:  
- Бoльшe 18 пeceн и 36 вapиaций, включaя мнoгиe oт извecтныx кoмпoзитopoв co вceгo миpa  
- Пoтpяcaющий, cдeлaнный вpучную, cтиль  
- Пpocтaя и интуитивнaя cиcтeмa aктивнoгo cкaниpoвaния и 3 типa нoт  
- Рaзличныe peжимы oтoбpaжeния  
- Сильныe удapы и pитмы oбecпeчaт нacлaждeниe oт тaпoв  
- Бoлee 9 уpoвнeй cлoжнocти для бoльшeгo вeceлья  
- Рaзличныe музыкaльныe жaнpы: POP, JAZZ, TRANCE, HARDCORE, DRUM 'N BASS и мнoгиe дpугиe  
- Тaблицы peкopдoв Game Center  
- Интeгpaция c Facebook





![cytus01](http://android-helper.com.ua/images/uploads/2013/02/cytus01.png)




Источник [androidnews.com.ua](http://androidnews.com.ua/android-games/8562-cytus.html)








И почему все помешались на этих зомби.





Ведь мы уже пережили конец света, а все компании так и продолжают их выпускать.





Тема зомби всегда была популярной как в кинематографе и литературе, так и в индустрии видеоигр. Сложно даже сосчитать сколько раз зомби находились в центре сюжета той или иной игры. Объяснить востребованность этих персонажей можно достаточно просто – одним из вариантов апокалипсиса считалось вероятное заражение человечества ужасным вирусом.





![Call of Mini: Zombies](http://www.droidnews.ru/wp-content/uploads/2013/01/call_of_mini_zombies_1.jpg)

<!-- more -->


Игра «Call of Mini: Zombies» представляет из себя некое подобие легендарной «[Minigore](http://www.droidnews.ru/minigore-interesnaya-3d-arkadnaya-strelyalka)». Хотя и отличия заметны невооружённым взглядом. Здесь весь экшн реализован в трёхмерном мире, и мы управляем выжившим героем от третьего лица. 









Перед игроком стоит задание продержаться как можно больше дней в столь непростой для человечества период. Каждый день происходит атака целой волны зомби, преодолев которую можно обзавестись деньгами. А потратить их есть на что – улучшение героя, новое оружие, мощная броня и так далее.





![Call of Mini: Zombies](http://www.droidnews.ru/wp-content/uploads/2013/01/call_of_mini_zombies_2.jpg)




С каждым новым днём количество врагов увеличивается. По своим характеристикам они очень отличаются – от простых и медлительных до более совершенных и опасных существ. Всего в процессе игры можно встретить до десяти разновидностей монстров.





В начале игры предстоит управлять самым обычным человеком, не наделённым никакими специальными возможностями, но за игровую валюту можно приобретать других героев, обладающих различными специальными умениями. Конечно же, реализована возможность приобретения игровой валюты за реальные деньги. 





Графическая составляющая не несёт в себе ничего сверхъестественного, но в целом всё реализовано на достаточно высоком уровне. Герои прорисованы в достаточно лёгкой юмористической манере, что также можно назвать положительной чертой игры. Но и здесь прослеживается сходство «Call of Mini: Zombies» с «Minigore».





![Call of Mini: Zombies](http://www.droidnews.ru/wp-content/uploads/2013/01/call_of_mini_zombies_3.jpg)




Аудио оформление игры довольно странное и понравится не всем. На фоне играет тяжёлый рок в различных его проявлениях. В общем, саундтрек, мягко говоря, на любителя. А вот звуки эффектов и выстрелов никаких нареканий не вызывают.





Благодаря постоянно нарастающей сложности, процесс прохождения становится очень динамичным и увлекательным. В целом, игра рассчитана на достаточно широкую аудиторию игроков, и она способна заинтересовать с первого взгляда.





«Call of Mini: Zombies» — достойный тайм-киллер с хорошей картинкой, интересной задумкой и насыщенным игровым процессом. Особенно она понравится поклонникам «Minigore», ведь здесь есть целых 3 карты, в то время как в знаменитой игре она только одна.









[Скачать Call of Mini: Zombies — apk](http://letitbit.net/download/89579.81560c2d6a55ed8efaab880a0c48/call_of_mini_zombies.apk.html).





[Установить Call of Mini: Zombies через Google Play](https://play.google.com/store/apps/details?id=com.trinitigame.callofminiandroid).





![](http://www.droidnews.ru/wp-content/uploads/2013/01/call_of_mini_zombies_qr.png)







Источник [droidnews.ru](http://www.droidnews.ru/call-of-mini-zombies-v-kotoryy-raz-uzhe-pro-zombi)
Недавно я писал о вредоносных программах.





Но нашел статью, где есть целая подборка таких программ.





Читаем и не устанавливаем их себе.


 <!-- more -->


С угрозами со стороны вредоносных программ ОС Android столкнулась практически с момента своего появления на рынке. И хотя многие пользователи поначалу восприняли этот факт скептически, постепенно их сомнения сменились обеспокоенностью за безопасность используемых мобильных устройств, так как число вредоносных приложений продолжало неуклонно расти. Прошедший 2012 год в этом плане не стал исключением. В этом обзоре мы рассмотрим наиболее интересные и заметные прошлогодние события, связанные с Android-угрозами.





![](http://www.droidnews.ru/wp-content/uploads/2013/01/android_2012_1.jpg)




**СМС-троянцы**  
Троянцы семейства Android.SmsSend, появившиеся еще в 2010 году и быстро ставшие настоящей головной болью пользователей мобильных Android-устройств, по-прежнему являются наиболее распространенной и массовой угрозой для этой мобильной платформы. Эти вредоносные программы предназначены для отправки дорогостоящих СМС-сообщений и подписки абонентов на различные контент-услуги, что может повлечь за собой серьезные финансовые потери (при этом жертва даже не будет знать, что деньги списаны с ее счета). Чаще всего они распространяются под видом популярных игр и приложений, а также их обновлений, однако могут встречаться и другие каналы распространения.









![](http://www.droidnews.ru/wp-content/uploads/2013/01/android_2012_2.jpg)




![](http://www.droidnews.ru/wp-content/uploads/2013/01/android_2012_3.jpg)





Для создания большинства подобных программ не требуется особых знаний, большого количества времени и средств, а получаемая злоумышленниками прибыль от их использования многократно компенсирует все затраты.





Широкое распространение троянцев обусловлено хорошо развитой сетью партнерских программ, которые предлагают весьма выгодные условия оплаты всем своим участникам. Кроме того, летом 2012 года были зафиксированы многочисленные случаи взлома легитимных веб-сайтов, которые модифицировались злоумышленниками таким образом, что пользователи, посещающие их с мобильных устройств, перенаправлялись на мошеннические ресурсы, распространяющие эти вредоносные программы.





Именно благодаря относительной простоте, высокой окупаемости и эффективности применяемых методов распространения семейство Android.SmsSend доминировало в прошедшем году среди остальных вредоносных приложений.  
Увеличение риска кражи конфиденциальной информации, негласный мониторинг и кибершпионаж





Учитывая возможности мобильных Android-устройств, а также принимая во внимание продолжающийся рост числа их пользователей, неудивительно, что проблема сохранности конфиденциальной информации становится все более ощутимой. Рискам в этой сфере подвержены все: как простые пользователи, так и представители коммерческого и государственного секторов. Ценные сведения, интересующие злоумышленников, могут быть самыми разнообразными.  
Шпионы — пособники спамеров





Сами по себе вредоносные программы, шпионящие за пользователями и крадущие их конфиденциальную информацию, не уникальны и известны достаточно давно. Однако в 2012 году обозначилась четкая тенденция к появлению довольно специфической группы троянцев-шпионов, направленных против жителей Японии. Все они распространялись при помощи спам-писем, в которых пользователям предлагалось установить то или иное «полезное» приложение, начиная от эротической игры и заканчивая оптимизатором расхода аккумулятора. 





![](http://www.droidnews.ru/wp-content/uploads/2013/01/android_2012_4.jpg)




![](http://www.droidnews.ru/wp-content/uploads/2013/01/android_2012_6.jpg)




![](http://www.droidnews.ru/wp-content/uploads/2013/01/android_2012_7.jpg)




![](http://www.droidnews.ru/wp-content/uploads/2013/01/android_2012_5.jpg)





К этой группе относятся такие вредоносные программы как Android.MailSteal.1.origin, Android.Maxbet.1.origin, Android.Loozfon.origin и Android.EmailSpy.origin. Их основная задача — похищение адресов электронной почты из книги контактов мобильного устройства и отправка их на удаленный сервер. Помимо этого, некоторые троянцы могут отправлять злоумышленникам не только адреса электронной почты, но и всю информацию из телефонной книги, а также идентификаторы устройства, включая номер сотового телефона. Добытая таким образом информация в дальнейшем может быть использована киберпреступниками для организации новых спам-кампаний и для продажи на черном рынке, а для владельцев похищенных адресов это несет потенциальную угрозу фишинг-атак и вероятность заражения их персональных компьютеров самыми разными вредоносными программами, использующими для инфицирования каналы электронной почты.





**Узконаправленные атаки — угроза с повышенным риском**  
Узконаправленные, точечные или таргетированные атаки несут в себе серьезную угрозу, поскольку они, в отличие от большинства обычных атак, направлены не на максимально возможное число пользователей, а на их ограниченный круг, что снижает вероятность оперативного и эффективного обнаружения используемых при преступлении вредоносных программ.





Одним из вариантов точечной атаки является Advanced Persistent Threat или APT-атака. Ее суть заключается в том, чтобы вредоносная программа как можно дольше оставалась в скомпрометированной системе без обнаружения и получила при этом максимально возможный объем ценных сведений. Жертвами обычно становятся различные компании, организации и государственные структуры.





До сих пор под ударом подобных кампаний находились лишь «большие» компьютерные системы, такие как рабочие станции и серверы. Однако в 2012 году была зафиксирована новая APT-атака, в процессе изучения которой обнаружилась вредоносная программа Android.Luckycat.origin. Функционал троянца включал выполнение команд, поступающих с управляющего сервера, загрузка различных файлов с мобильного устройства и на него, сбор идентификационных данных и некоторые другие возможности.





![](http://www.droidnews.ru/wp-content/uploads/2013/01/android_2012_8.jpg)





![](http://www.droidnews.ru/wp-content/uploads/2013/01/android_2012_9.jpg)





![](http://www.droidnews.ru/wp-content/uploads/2013/01/android_2012_10.jpg)





Несмотря на то, что троянец находился в стадии разработки, и свидетельств его применения на практике не было, факт существования такого инструмента дает серьезное основание полагать, что мобильные Android-устройства в скором времени могут стать такой же привычной мишенью APT-атак, как и обычные компьютеры.





Еще одним инструментом проведения таргетированных атак с целью завладения конфиденциальной и ценной информацией стали мобильные банковские троянцы, крадущие одноразовые коды mTAN. Для обеспечения безопасности финансовых операций в сети Интернет банковские системы отправляют СМС-сообщения с этими кодами на привязанный к клиентскому счету номер мобильного телефона. Чтобы успешно завершить транзакцию, пользователь должен ввести в специальную веб-форму полученный код. Мобильные банковские троянцы предназначены для перехвата СМС-сообщений, кражи этих кодов и передачи их злоумышленникам, которые выполняют различные финансовые операции с электронными счетами ничего не подозревающих жертв (например, совершают онлайн-покупки).





Применение подобных вредоносных программ никогда не было массовым явлением, в том числе и для устройств под управлением Android. В 2012 году мы стали свидетелями появления лишь нескольких новых представителей этого класса троянцев, направленных на мобильную операционную систему от Google. Ими стали Android.SpyEye.2.origin, Android.Panda.2.origin, Android.SmsSpy.6.origin и Android.FakeSber.1.origin.





![](http://www.droidnews.ru/wp-content/uploads/2013/01/android_2012_11.jpg)



![](http://www.droidnews.ru/wp-content/uploads/2013/01/android_2012_12.jpg)




![](http://www.droidnews.ru/wp-content/uploads/2013/01/android_2012_13.jpg)





![](http://www.droidnews.ru/wp-content/uploads/2013/01/android_2012_14.jpg)





![](http://www.droidnews.ru/wp-content/uploads/2013/01/android_2012_15.jpg)




![](http://www.droidnews.ru/wp-content/uploads/2013/01/android_2012_16.jpg)




Типичный способ распространения таких вредоносных программ — социальная инженерия, когда пользователя вводят в заблуждение, предлагая срочное обновление операционной системы или установку некоего сертификата безопасности, необходимого для дальнейшего получения финансовых услуг. Несмотря на то, что случаи появления банковских троянцев для ОС Android являются редкими, проводимые с их помощью атаки весьма эффективны. Именно благодаря неширокой распространенности таких приложений и направленности на пользователей конкретных банковских систем снижается вероятность их быстрого обнаружения и обеспечения необходимой защиты от них.





Среди всех этих вредоносных программ стоит особо выделить Android.FakeSber.1.origin: он стал первым банковским Android-троянцем, направленным против клиентов российского банка. До его появления киберпреступников интересовали лишь зарубежные пользователи. Кроме того, в отличие от своих собратьев, распространяющихся при помощи мошеннических сайтов, данный троянец был помещен злоумышленниками непосредственно в официальный каталог приложений Google Play. К счастью, к моменту, когда троянец был удален из каталога, установить его успели немногие. Тем не менее, потенциальная опасность, которую он представлял, была весьма существенной.





Принцип, по которому работал Android.FakeSber.1.origin, был схож со схемами, применяемыми злоумышленниками в других банковских Android-троянцах. Во-первых, для того чтобы заставить пользователей выполнить его установку, была использована весьма распространенная тактика запугивания: на официальным веб-сайте банка посетителям демонстрировалось сообщение о необходимости авторизации при помощи мобильного телефона (это сообщение отображалось благодаря Windows-троянцу, заразившему компьютеры жертв и работавшему в связке с Android.FakeSber.1.origin). Пользователям предлагалось установить специальное приложение, которое на самом деле и было мобильным банковским троянцем. Во-вторых, попав на мобильное устройство, эта вредоносная программа имитировала ожидаемый функционал, усыпляя бдительность пользователя. В конечном итоге Android.FakeSber.1.origin скрытно перехватывал все входящие сообщения и пересылал полученные из них сведения на удаленный сервер, поэтому помимо mTAN-кодов в руках киберпреступников могли оказаться и другие конфиденциальные сведения, например, частная переписка. 





**Коммерческое шпионское ПО**  
Потенциальную угрозу сохранности персональной информации продолжают нести и различные виды коммерческого программного обеспечения для мониторинга и шпионажа. В 2012 году было обнаружено значительное число не только новых модификаций уже известных программ, но и новые представители этого класса приложений. Большинство подобных шпионов может использоваться как легально, с согласия владельца мобильного устройства, так и без его ведома. Для их установки обычно требуется физический доступ к мобильному устройству, однако после установки данные [Приложения для Андроид](http://smartfon.dp.ua/) способны скрывать свое присутствие в системе (например, не создавая иконку на главном экране, а также маскируясь под системное ПО). Наиболее распространенными функциями таких шпионов являются отслеживание СМС-сообщений, получение координат пользователя, перехват совершаемых им звонков, а также запись происходящего вокруг в аудиофайл.





**Затруднение анализа, разделение функционала и активное противодействие удалению**  
Борьба с вредоносными Android-программами при помощи антивирусных средств и постепенное повышение компьютерной грамотности владельцев мобильных устройств на базе ОС от Google заставляет злоумышленников искать способы обхода возникающих трудностей. И если раньше троянцы представляли собой единственный программный пакет, содержащий весь вредоносный функционал, сейчас все чаще встречаются более сложные схемы их построения и работы.





Весьма интересным решением киберпреступников была своеобразная матрешка из трех вредоносных приложений, обнаруженных в мае 2012 года. Дроппер Android.MulDrop.origin.3 содержал в своих ресурсах зашифрованный пакет, который также являлся дроппером (Android.MulDrop.origin.4). Он, в свою очередь, имел в своих ресурсах еще один зашифрованный пакет, представляющий собой троянца-загрузчика Android.DownLoader.origin.2, способного получать с удаленного сервера список приложений для загрузки на мобильное устройство.





![](http://www.droidnews.ru/wp-content/uploads/2013/01/android_2012_17.jpg)




Для успешного функционирования разработанной схемы были необходимы root-привилегии, а так как основной дроппер находился в модифицированном злоумышленниками легитимном приложении, для работы которого требовался root-доступ, у пользователей не должно было возникнуть серьезных опасений в связи с необходимостью предоставления ему соответствующих прав. Примененный в данном случае механизм может быть весьма эффективным способом избежать лишних подозрений и увеличить шансы успешного заражения мобильного Android-устройства.





Другим примером разделения функционала между несколькими вредоносными приложениями являются троянцы Android.SmsSend.405.origin и Android.SmsSend.696.origin. Первый в различных модификациях распространялся в каталоге Google Play под видом сборника обоев для рабочего стола, доступ к которым пользователь мог получить, нажав кнопку «Далее». В этом случае приложение подключалось к облачному сервису Dropbox и загружало второй программный пакет, который являлся СМС-троянцем. По всей видимости, подобным переносом основного функционала во второе приложение, расположенное вне Google Play, злоумышленники пытались обойти систему Bouncer, которая контролирует каталог на предмет наличия вредоносных программ.





Весьма тревожит появление у вредоносных Android-приложений функционала по противодействию своему удалению. В мае 2012 года был обнаружен троянец Android.Relik.origin, который завершал работу популярных китайских антивирусных средств, а также запрашивал у пользователя доступ к режиму администратора мобильного устройства. В случае активации этого режима другие антивирусные программы уже не смогли бы удалить троянца, однако для избавления от этой вредоносной программы пользователю ничто не мешало убрать вредоносное приложение из списка администраторов.





Идея противодействия удалению в дальнейшем была значительно развита в другом китайском троянце, Android.SmsSend.186.origin. Практически сразу после установки он отображал требование предоставить ему права администратора мобильного устройства, причем в случае отказа требование выводилось вновь до тех пор, пока троянец не получал соответствующие права.





![](http://www.droidnews.ru/wp-content/uploads/2013/01/android_2012_18.jpg)





![](http://www.droidnews.ru/wp-content/uploads/2013/01/android_2012_19.jpg)





После получения троянцем необходимых прав попытки убрать его из списка администраторов мобильного устройства на некоторых версиях ОС Android заканчивались полным провалом, так как Android.SmsSend.186.origin препятствовал этому, не давая владельцу мобильного устройства зайти в необходимые системные настройки. Антивирусные средства, не располагающие функционалом по нейтрализации таких угроз, также не могли избавить систему от инфицирования, даже если и детектировали вредоносную программу. Самостоятельно же избавиться от троянца было весьма проблематично, поскольку это требовало выполнения ряда нетривиальных действий и определенной доли терпения. Ко всему прочему, эта вредоносная программа распространялась при помощи дроппера, помещенного киберпреступниками в «живые обои», которые при установке не требовали никаких специальных разрешений для своей работы. Таким образом, Android.SmsSend.186.origin представляет собой одну из самых серьезных за последнее время Android-угроз.





Нельзя не отметить тенденцию к росту использования авторами вредоносных программ обфускации кода, которая призвана затруднить анализ троянцев и помешать их детектированию антивирусными средствами. Например, обфускация встречается в целом ряде представителей семейства Android.SmsSend. 





**Интересные и необычные угрозы**  
Весьма интересной вредоносной программой, обнаруженной в 2012 году, стал троянец Android.MMarketPay.origin, который самостоятельно покупал приложения в электронном магазине китайского оператора связи China Mobile. Для этого он перехватывал СМС-сообщения с кодами подтверждения совершения покупки, а также обходил проверку captcha, отправляя на удаленный сервер соответствующие изображения для анализа. Целью создания этого троянца могло стать как желание недобросовестных разработчиков увеличить прибыль за счет подобной незаконной продажи своих приложений, так и обычное желание злоумышленников досадить пользователям и сотовому оператору, репутация которого могла заметно пострадать.





**Рынок заказных услуг киберпреступников?**  
Не секрет, что большая часть современных вредоносных программ создается не из простого любопытства — эта сфера незаконной деятельности уже давно стала источником заработка для самых разнообразных групп киберпреступников. И появившихся в 2012 году Android-троянцев Android.Spambot.1.origin и Android.DDoS.1.origin вполне обоснованно можно отнести к инструментам осуществления киберкриминальных услуг. Android.Spambot.1.origin представлял собой троянца, предназначенного для массовой рассылки СМС-спама. Текст сообщений и номера, по которым осуществлялась рассылка, загружались с удаленного сервера, принадлежащего злоумышленникам, поэтому им не составляло большого труда выполнить спам-рассылку для заинтересованных лиц. Чтобы скрыть свою вредоносную деятельность, троянец удалял все сведения об отправляемых СМС, и владельцы инфицированных мобильных устройств могли не сразу обнаружить подозрительную активность. Что же касается Android.DDoS.1.origin, то это — вредоносная программа, предназначенная для осуществления DoS-атак с использованием мобильных Android-устройств. Параметры, необходимые для их проведения, троянец получал посредством СМС-сообщений, в которых указывались имя сервера и требуемый порт. Особенность этой вредоносной программы — в том, что атакуемый сайт мог быть абсолютно любым, поэтому теоретически воспользоваться возможностями этой вредоносной программы могли все, кто проявит должный интерес и заплатит соответствующую цену за оказание незаконной услуги.





Вандализм — редкая, но опасная угроза c деструктивным потенциалом





На фоне общей массы вредоносных Android-приложений, направленных на получение той или иной материальной выгоды, Android.Moghava, обнаруженный весной 2012 года, держится особняком, будучи троянцем-вандалом. Он распространялся в модифицированной злоумышленниками версии приложения — сборника рецептов иранской кухни. Через определенные промежутки времени троянец выполнял на мобильном устройстве поиск JPEG-изображений в каталоге /DCIM/Camera/ и накладывал на них еще одно изображение. В результате этого фотографии пользователя безвозвратно портились.





![](http://www.droidnews.ru/wp-content/uploads/2013/01/android_2012_20.jpg)





![](http://www.droidnews.ru/wp-content/uploads/2013/01/android_2012_21.jpg)





Обычно вирусописатели создают подобные вредоносные программы с целью громко заявить о себе, либо в качестве мести или простого развлечения. Более редкой причиной является попытка совершить диверсию среди определенной группы лиц. Так или иначе, ущерб от подобных приложений может быть весьма существенным.





**Выводы**  
По состоянию на конец 2012 года вирусные базы Dr.Web содержали почти 1300 записей для Android-угроз. Их процентное распределение представлено на следующей диаграмме:





![](http://www.droidnews.ru/wp-content/uploads/2013/01/android_2012_22_450.jpg)





Следует учитывать тот факт, что специалисты компании проводят постоянную оптимизацию баз, поэтому число соответствующих вирусных записей может со временем уменьшаться.





С ростом популярности мобильных устройств под управлением ОС Android соответственно увеличивается число и разнообразие вредоносных приложений, представляющих опасность для пользователей этой платформы. Описанные выше типы угроз в 2012 году стали наиболее заметными, а также продемонстрировали потенциальный вектор развития вредоносных Android-программ в ближайшем будущем. Одновременно с этим могут появляться и вредоносные приложения, которые сочетают свойства самых разнообразных угроз или же являются «нестандартными» по сравнению с общей массой, что во многом повторяет ситуацию с Windows. Учитывая, что в ближайшие несколько лет мобильная платформа Android будет оставаться среди лидеров рынка, стоит ожидать дальнейшего роста числа созданных для нее вредоносных программ.





Источник [droidnews.ru](http://www.droidnews.ru/obzor-android-ugroz-v-2012-godu-osnovnye-riski-dlya-polzovateley)
Недавно я писал об игре **Temple Run 2.**





Сейчас уже есть ее полное описание и даже скриншоты.





Смотрим, читаем играем.


<!-- more -->


**Temple Run 2** является продолжением знаменитой игры, которая пришлась по душе не одному миллиону пользователей со всего земного шара (и возможно за его пределами).





Игра как и раньше поведает нам удивительную историю о том, как несколько смельчаков делают все ради «кражи» идола из храма, который тщательно охраняется демонами-приматами.





![Temple Run 2](http://www.droidnews.ru/wp-content/uploads/2013/01/temple_run_2_1.jpg)





Тех, кто не играл в первую часть, мы предупреждаем сразу: «У игры конца нет!». Её просто-напросто невозможно пройти, а в связи с этим целью игры становится вовсе не прохождение до нужной точки, а движение в режиме NON-STOP. Причем стоит учитывать то, что чем дольше вы двигаетесь, тем лучше.









Осуществлять контроль над исследователями игроку помогут наклоны смартфона, а так же простейшие жесты по сенсорному экрану. Стоит признать, что из всех существующих данная модель управления лучше всего подходит для Temple Run 2. Используя неё, игроки практически не тратят сил, и им не приходится сильно задумываться над своими действиями, что позволяет проходить ещё дальше.





![Temple Run 2](http://www.droidnews.ru/wp-content/uploads/2013/01/temple_run_2_2.jpg)





По рейтингу Temple Run 2 является одним из самых скачиваемых приложений в мире. К примеру за первые несколько дней, после появления данной игры на iOS её скачали около двадцати миллионов раз. В случае с OS Android, там показатели немного меньше. Это связанно с тем, что версия для Андроид вышла на неделю позже из-за изменения графического «движка».





Несомненно, в игре порадует и то, что создатели не стали возвращать платное скачивание и вместо этого снова создали игровой магазин, в котором игроки смогут за реальные деньги купить некоторые улучшения, а сама игра распространяется бесплатно.





![Temple Run 2](http://www.droidnews.ru/wp-content/uploads/2013/01/temple_run_2_3.jpg)





По статистике всего за несколько дней, игроки сыграли примерно 210 миллионов раз, что в среднем составляет по одиннадцать игр на каждую загруженную игру, а суммарное количество времени, проведенное за игрой, уже достигло 1775 лет, причем этот результат увеличивается с каждой секундой. 





Несмотря на то, что движок игры кардинально переделан, а картинка стала куда качественнее, этого все равно не достаточно для достижения планки своих «аналогов», однако существует надежда, что в скором времени данная ситуация изменится.





Для тех же, кто уже знаком с первой частью [Temple Run](http://www.droidnews.ru/temple-run-uvlekatelnyy-pobeg-iz-zloveschego-hrama), то скорее скачивайте вторую и вперед! Ведь в ней вас ожидают сотни достижений, различных «примочек» и конечно же море удивительных приключений…









[Скачать Temple Run 2 — apk](http://depositfiles.com/files/bdliwy4kc).





[Установить Temple Run 2 через Google Play](https://play.google.com/store/apps/details?id=com.imangi.templerun2).





![](http://www.droidnews.ru/wp-content/uploads/2013/01/temple_run_2_qr.png)







Источник [droidnews.ru](http://www.droidnews.ru/temple-run-2-ubegaem-iz-hrama-vtoraya-popytka)
Компания «Доктор Веб» сделала обзор Android-угроз в 2012 году. С угрозами со стороны вредоносных программ ОС Android столкнулась практически с момента своего появления на рынке. И хотя многие пользователи поначалу восприняли этот факт скептически, постепенно их сомнения сменились обеспокоенностью за безопасность используемых мобильных устройств, так как число вредоносных приложений продолжало неуклонно расти. Прошедший 2012 год в этом плане не стал исключением.





Троянцы семейства [Android.SmsSend](http://www.ferra.ru/ru/soft/news/2011/08/30/Android-SmsSend/), появившиеся еще в 2010 году и быстро ставшие настоящей головной болю пользователей мобильных Android-устройств, по-прежнему являются наиболее распространенной и массовой угрозой для этой мобильной платформы. Эти вредоносные программы предназначены для отправки дорогостоящих SMS-сообщений и подписки абонентов на различные контент-услуги, что может повлечь за собой серьезные финансовые потери (при этом жертва даже не будет знать, что деньги списаны с ее счета). Чаще всего они распространяются под видом популярных игр и приложений, а также их обновлений, однако могут встречаться и другиAе каналы распространения.


 <!-- more -->


Учитывая возможности мобильных Android-устройств, а также принимая во внимание продолжающийся рост числа их пользователей, неудивительно, что проблема сохранности конфиденциальной информации становится все более ощутимой. Рискам в этой сфере подвержены все: как простые пользователи, так и представители коммерческого и государственного секторов. Ценные сведения, интересующие злоумышленников, могут быть самыми разнообразными.





Сами по себе вредоносные программы, шпионящие за пользователями и крадущие их конфиденциальную информацию, не уникальны и известны достаточно давно. Однако в 2012 году обозначилась четкая тенденция к появлению довольно специфической группы троянцев-шпионов, направленных против жителей Японии. Все они распространялись при помощи спам-писем, в которых пользователям предлагалось установить то или иное «полезное» приложение, начиная от эротической игры и заканчивая оптимизатором расхода аккумулятора.





Узконаправленные, точечные или таргетированные атаки несут в себе серьезную угрозу, поскольку они, в отличие от большинства обычных атак, направлены не на максимально возможное число пользователей, а на их ограниченный круг, что снижает вероятность оперативного и эффективного обнаружения используемых при преступлении вредоносных программ.





![Android-угрозы](http://www.ferra.ru/images/344/344982.jpg) 
[Android-угрозы](http://news.ferra.ru/photo/techlife/news/Dr-Web-Android-2012/1872/344982)





Применение подобных вредоносных программ никогда не было массовым явлением, в том числе и для устройств под управлением [Android](http://www.ferra.ru/ru/techlife/news/2013/01/28/Trend-Micro-Android-1000000/). В 2012 году мы стали свидетелями появления лишь нескольких новых представителей этого класса троянцев, направленных на мобильную операционную систему от Google. Ими стали [Android.SpyEye.2.origin](http://www.ferra.ru/ru/soft/news/2012/06/21/drweb-Android-SpyEye/), Android.Panda.2.origin, Android.SmsSpy.6.origin и Android.FakeSber.1.origin.





Потенциальную угрозу сохранности персональной информации продолжают нести и различные виды коммерческого программного обеспечения для мониторинга и шпионажа. В 2012 году было обнаружено значительное число не только новых модификаций уже известных программ, но и новые представители этого класса приложений.





На фоне общей массы вредоносных Android-приложений, направленных на получение той или иной материальной выгоды, [Android.Moghava](http://www.ferra.ru/ru/soft/news/2012/03/02/Android-Moghava/), обнаруженный весной 2012 года, держится особняком, будучи троянцем-вандалом. Он распространялся в модифицированной злоумышленниками версии приложения — сборника рецептов иранской кухни. Через определенные промежутки времени троянец выполнял на мобильном устройстве поиск JPEG-изображений в каталоге /DCIM/Camera/ и накладывал на них еще одно изображение. В результате этого фотографии пользователя безвозвратно портились.





По состоянию на конец 2012 года вирусные базы Dr.Web содержали почти 1300 записей для Android-угроз. С ростом популярности мобильных устройств под управлением ОС Android соответственно увеличивается число и разнообразие вредоносных приложений, представляющих опасность для пользователей этой платформы. Описанные выше типы угроз в 2012 году стали наиболее заметными, а также продемонстрировали потенциальный вектор развития вредоносных Android-программ в ближайшем будущем. Одновременно с этим могут появляться и вредоносные приложения, которые сочетают свойства самых разнообразных угроз или же являются «нестандартными» по сравнению с общей массой, что во многом повторяет ситуацию с Windows. Учитывая, что в ближайшие несколько лет мобильная платформа Android будет оставаться среди лидеров рынка, стоит ожидать дальнейшего роста числа созданных для нее вредоносных программ.





Источник [pcnews.ru](http://www.pcnews.ru/news/android-2012-smssend-2010-sms-google-spyeye-origin-panda-smsspy-fakesber-moghava-jpeg-dcim-camera-dr-web-1300-425558.html)
По последним данным агентства Strategy Analytics за 2012 год в мире было продано около 700 миллионов смартфонов, при этом 684 процента от этого количества составляли устройства на базе платформы [Android](http://androidnews.com.ua/), iOS получила 194 процента, а 122 процентов пришлось на другие программные платформы. Что касается производителей смартфонов, то лидирующие позиции в 2012 году остались за Apple и Samsung, как по уровню прибыли, так и по объемам продаж. По мнению аналитиков, именно эти две компании сегодня можно считать главными противоборствующими сторонами в мобильной индустрии, а противостояние Apple и [Google](http://androidnews.com.ua/other-news/2740-google-rabotaet-nad-android-ochkami.html) начало отходить на второй план. Также в Strategy Analytics обращают внимание на замедление темпов развития рынка смартфонов. К примеру, в 2011 году рост поставок смартфонов в мире составил 64 процента, а в прошлом только 43.
Хорошая игра.





Защити свою башню.





**Вepcия:** 1.0.0  
**Рaзpaбoтчик:** Tangrams Studio  
**Тpeбoвaния:** [Android](http://androidnews.com.ua/) вepcии 2.2 и вышe  
**Язык:** Английcкий  
Нoвaя зaщитa бaшeн c уникaльными гepoями.   
  
**Carrot Fantasy** - coвepшeннo тoлькo coшeдшaя кaк гoвopитcя "c кoнвeйepa" игpa, зaнимaющaя дecятку лучшиx, жaнpa зaщиты бaшни. Мы будeм зaщищaть тaкoй oвoщ, кaк мopкoвь, дa дa имeннo eгo. Уникaльнocть гeмплeя cocтoит в зaтягивaнии caмoгo пpoцecca oбopoны, c вoзмoжными пpимoчкaми и бoнуcaми. Нacыщeннaя гpaфикa co cпeциaльными эффeктaми.  
  










![Carrot Fantasy](http://androidnews.com.ua/uploads/posts/2013-01/thumbs/androidnews.com.ua_carrot-fantasy_2.jpeg)


  
 <!-- more -->



![Carrot Fantasy](http://androidnews.com.ua/uploads/posts/2013-01/thumbs/androidnews.com.ua_carrot-fantasy_3.jpeg)




 





 





Источник [androidnews.com.ua](http://androidnews.com.ua/android-games/action/8548-carrot-fantasy.html)




Всем привет друзья.





И сново вместе с вами я.





Сегодня я выложу несколько прикольных игр.





Надеюсь вам понравятся.





Смотрим, ставим и пишем.

 <!-- more -->



Обучающая игра, которая поможет Вам весело и с пользой провести время, расширить свои знания в области географии! Изучите флаги разных стран мира в увлекательном игровом процессе; приятной, яркой и красочной атмосфере! Играя в эту игру Вы одновременно развлекаетесь, обучаетесь и развиваете память. Хорошее сочетание, не так ли? Игра подойдет как детям так и взрослым.





![](http://s.4pda.ru/wp-content/uploads/2013/01/device-2013-01-30-190747-480x269.png)


**Версия: **1.3





**Русский интерфейс: **Да





**Технические требования: **Android 2.2+





**Категория:** Головоломка









На данный момент игра поддерживает 2 разных режима:








  1. Классический – суть которого заключается в написании имени страны по флагу. Этот режим имеет 6 уровней сложности, которые помогут вам повысить  свой уровень познаний в флагах.



  2. Аркадный – суть которого заключается в том что бы угадать страну по флагу. Он имеет 2 уровня сложности: легкий и тяжелый. Легкий предназначен для тех кто только начинает изучать флаги(будет очень полезный для детей которые учатся в школе). Тяжелый подойдет более опытным игрокам, которые более осведомление в флагах и хотят отточить свои знания. Также имеется система начисления очков, а также бонусов.






Игра не стоит на месте и развивается, в дальнейшем планируется ряд важных нововведений:








  * Подсказки в классическом режиме.



  * Будут добавлен режим со столицами!



  * Будет обновляться дизайн приложения.






Данное приложение поддерживает множество языков, включая русский, что не может не радовать.





**Стоимость:** Бесплатно





**Обсуждение на 4pda:** [http://4pda.ru/forum/index.php?showtopic=420230&st=20#entry19132888](http://4pda.ru/forum/index.php?showtopic=420230&st=20#entry19132888)





**Ссылка на Google Play:** ![QR](http://s.4pda.ru/forum/style_images/1/qr_code.gif)[https://play.google.com/store/apps/details?id=example.attractive.flags](https://play.google.com/store/apps/details?id=example.attractive.flags&feature=search_result)





 Источник [4pda.ru](http://4pda.ru/2013/01/30/87830/)
Хорошая игра.





Как мало таких.





**Вepcия:** 1.01  
**Рaзpaбoтчик:** WonderGameLand  
**Тpeбoвaния:** [Android](http://androidnews.com.ua/) OS 2.1 и вышe  
**Язык:** Английcкий  
Ужe чeтвepтaя чacть бoeвoй игpы.   
  
**King Fighter IV** - вce тeчeт, вce мeняeтcя. Бывaeт нe уcпeeшь пpoйти пpoшлую чacть, кaк paзpaбoтчики пoдкинули ужe oчepeдную. Ну чтo ж дaвaйтe пoпpoбуeм нacлaдитcя ужe дpoгoй битвoй. Сoздaтeли дoбaвили бoccoв, opужия, улучшили гpaфичecкиe xapaктepиcтики и выжaли вcё пo мaкcимуму из пpeдыдущиx чacтeй. Чтo у ниx пoлучилocь, cудить тoлькo Вaм caмим.  
  


 <!-- more -->



![](http://androidnews.com.ua/templates/Droid/dleimages/spoiler-minus.gif) Дoпoлнитeльныe cкpиншoты









![King Fighter IV](http://androidnews.com.ua/uploads/posts/2013-01/thumbs/androidnews.com.ua_king-fighter-iv_2.jpeg)


  




![King Fighter IV](http://androidnews.com.ua/uploads/posts/2013-01/thumbs/androidnews.com.ua_king-fighter-iv_3.jpeg)




 Источник [androidnews.com.ua](http://androidnews.com.ua/android-games/action/8514-king-fighter-iv.html)




Когда то в детстве я очень мечтал научиться играть на клавишах всем извесной Ямахи.





Но вот как то не сложилось, и я только научился играть на клавишах клавиатуры.





А сейчас время не стоит на месте. И авторы этой программы как раз об этом и рассказывают.





Простой и быстрый "читатель" и проигрыватель гитарных табов. Может читать и играть Guitar Pro файлы. Есть веб поиск.





![](http://s.4pda.ru/wp-content/uploads/2013/01/vmlite-android-v4_21-480x360.png)

<!-- more -->

**Версия: **2.1.4





**Русский интерфейс: **Да





**Технические требования: **>= Android 2.1





**Категория:** Для музыкантов









Хотите чтобы ваши табулатуры всегда были с вами? Guitar Tab Player позволяет читать и проигрывать любой Guitar Pro формат. Причем делать это быстро и удобно.





![](http://s.4pda.ru/wp-content/uploads/2013/01/vmlite-android-v4_2-480x360.png)
![](http://s.4pda.ru/wp-content/uploads/2013/01/vmlite-android-v4_3-480x360.png)



![](http://s.4pda.ru/wp-content/uploads/2013/01/vmlite-android-v4-480x360.png)



Вы увидите все нюансы произведений, заложенные авторами на вашем мобильном устройстве. Восходящий-, нисходящий-, глиссандо- слайд, точные переходы от приема к приему, вибрато с бендом, и прочее - все это отображается как и должно, никаких упрощений.





Практически мгновенная скорость загрузки, удобный и не перегруженный интерфейс, возможность автоматического поиска табов в интернете - все это Guitar Tab Player.





**Стоимость:** Содержит рекламу





**Обсуждение на 4pda:** [http://4pda.ru/forum/index.php?showtopic=414655&st=0&p=18240684](http://4pda.ru/forum/index.php?showtopic=414655&st=0&p=18240684)





**Ссылка на Google Play:** ![QR](http://s.4pda.ru/forum/style_images/1/qr_code.gif)[http://play.google.com/store/apps/details?id=guitartab.player](http://play.google.com/store/apps/details?id=guitartab.player)





Источник [4pda.ru](http://4pda.ru/2013/01/29/87484/)
И снова гонки.





Люблю я иногда погонять.





Надеюсь, что и вам они придутся по вкусу.





Тому, как часто выходят новые гоночные игры из серии «Asphalt», могут позавидовать очень многие разработчики. Но вот временной промежуток между шестой и седьмой частью составил целых 20 месяцев. Но при первом же взгляде на игру возникает вопрос – чем занимались Gameloft всё это время? От предыдущей части игру отличают разве что ненужные попытки социализировать игру, сопровождающиеся назойливыми предложениями рассказать об успехах друзьям.





![Asphalt 7: Heat](http://www.droidnews.ru/wp-content/uploads/2013/01/asphalt_7_1.jpg)


 <!-- more -->


Пресс-релизы громогласно кричали: «Множество трасс и кубков, более сотни заездов!». Как оказалось, они не солгали. Правда, в Токио, Москве, Рейкьявике и других городах мы бывали и раньше, а якобы свежие режимы попросту сменили названия. 





В «Paint job» необходимо максимально точно и аккуратно входить в повороты. За каждое касание стены влепят штраф. В режиме «King of the Hill» для победы необходимо как можно дольше пробыть в тройке лидеров. 





Наиболее ярким режимом является «Beat 'em all», который в принципе является клоном «Road Rage» из «Burnout Paradise». Наша цель выбить соперника с дистанции путём прикосновения к нему во время ускорения. Пополнить запасы нитро можно благодаря любому эффектному действию. Что интересно, даже лобовое столкновение не уничтожит автомобиль, а вот минимальное касание сзади почему-то становится фатальным. 





![Asphalt 7: Heat](http://www.droidnews.ru/wp-content/uploads/2013/01/asphalt_7_2.jpg)



Что же касается подбора машин, то в автопарке обошлось без особых сюрпризов. Культовый «DeLorean DMC-12» из легендарной трилогии «Назад в будущее» доступен с самого начала, а вот остальные бонусные авто заблокированы, и чтобы их открыть придётся вдоволь попотеть. Всё потому, что стоят они немалое количество звёзд, а в «Asphalt 7» и без того есть уйма обязательных покупок в процессе игры.





![Asphalt 7: Heat](http://www.droidnews.ru/wp-content/uploads/2013/01/asphalt_7_3.jpg)



Как и во всех играх от Gameloft, в «Heat» не обошлось и без различных бонусов, которые можно приобрести за реальные деньги. Заплатив почти 5 долларов можно приобрести пачку игровых долларов, а за немыслимые сто долларов – стать обладателем внушительного пакета звёзд. Но сложно представить адекватного человека, который захочет расставаться с такими суммами для столь малозначимой нужды. Скорее всего, именно поэтому «Asphalt 7 Heat» стоит меньше доллара, в то время когда за старые игры от Gameloft придётся заплатить около 5 у.е.





Вспомним и о мультплеере. Он не представляет собой ничего революционного. До шести участников могут соревноваться одновременно через Wi-Fi или Bluetooth. Но соперников в сети отыскать очень сложно, что ещё раз намекает на некую пустоту и безжизненность проекта.





Мало кто удивится, если через небольшой промежуток времени появится и 8-ая часть серии, в которой также не произойдёт особых изменений, но свою прибыль от этого Gameloft всё равно поимеет.









[Установить Asphalt 7: Heat через Google Play](https://play.google.com/store/apps/details?id=com.gameloft.android.ANMP.GloftA7HM).





![](http://www.droidnews.ru/wp-content/uploads/2013/01/asphalt_7_qr.png)





Источник [droidnews.ru](http://www.droidnews.ru/droidgames-sobiraemsya-i-igraem)
Гррр, грррр........





Ну что поехали?





Каждый из вас играл в игру Need for speed?





Ох! Снова Need For Speed перепрыгивает через стену восхищения и продолжает подниматься все выше и выше. Если вы являетесь фанатом гонок из серии NFS или Asphalt, то от совершенно новой версии игры Most Wanted для OS Android вы точно не сможете отказаться.





![Need For Speed: Most Wanted](http://www.droidnews.ru/wp-content/uploads/2013/01/need_for_speed_most_wanted_1.jpg)

 <!-- more -->

Все, что вам остается в данной ситуации – пристегнуть понадежнее ремни и вдавить педаль газа как можно ниже, ведь именно сейчас начинается самая опасная и захватывающая гонка, которую вы когда-либо видели. 









![Need For Speed: Most Wanted](http://www.droidnews.ru/wp-content/uploads/2013/01/need_for_speed_most_wanted_2.jpg)




Однако стоит сразу предупредить игроков, которые не являются владельцами мощных смартфонов и планшетных компьютеров, ведь играть вы просто-напросто не сможете. Дело в том, что, как и его популярный аналог Asphalt 7, NFS: Most Wanted занимает не менее 1.9Гб вашего дискового пространства. И это не говоря уже о том, что для установки вам придется скачать около 550Мб (оптимальным вариантом станет закачка с помощью Wi-Fi, так вы минимизируете вероятность потерять важные файлы).





![Need For Speed: Most Wanted](http://www.droidnews.ru/wp-content/uploads/2013/01/need_for_speed_most_wanted_3.jpg)




Но если вы все же смогли установить и запустить данного монстра, то перед вашими глазами откроется самый настоящий «шедевр» игровой индустрии. Используя самые дорогие, и высококлассные машины: Porsche 911 Carrera S, SRT Viper GTS, Hummer H1 Alpha и т.д. вам придется на полной скорости скрываться от полицейских, а так же соревноваться за лидерство с гоночными и криминальными знаменитостями. Только NFS: Most Wanted дает возможность насладиться всей красотой уличных гонок используя при этом смартфон.





![Need For Speed: Most Wanted](http://www.droidnews.ru/wp-content/uploads/2013/01/need_for_speed_most_wanted_4.jpg)




Нововведения типа Origin позволяют игрокам NFS проверять список самых «разыскиваемых» гонщиков, а так же соревноваться с друзьями, за право отнять данный титул. Теперь каждый сможет вызвать на гонку «короля» и показать, кто является настоящим монстром.





![Need For Speed: Most Wanted](http://www.droidnews.ru/wp-content/uploads/2013/01/need_for_speed_most_wanted_5.jpg)



В отличие от серии игр Asphalt в NFS всегда существовала великолепная коллекция лучших автомобилей мира, которые при желании можно улучшать в «совершенные» машины. Специально для поддержания «марки» в игре присутствует сорок гоночных авто, и множество улучшений, каждое из которых станет шагом на пути к покорению мира гонщиков.





Так же в игре приятно удивляет возможность управлять не только касанием, но и акселерометром (наклоном устройства), что дает возможность не подстраиваться под управление, а напротив подгонять его под свои причуды.









[Установить Need For Speed: Most Wanted через Google Play](https://play.google.com/store/apps/details?id=com.ea.games.nfs13_row).





![](http://www.droidnews.ru/wp-content/uploads/2013/01/need_for_speed_most_wanted_qr.png)





Источник [droidnews.ru](http://www.droidnews.ru/need-for-speed-most-wanted-polneyshiy-perjod)
Все в детстве играли в супер Марио.





Да классная была игра, так сказать бестселлер своего времени.





Так почему же все хотят его наследовать?





Спросим у автора.


<!-- more -->


Думаете, что сладкой воды много не бывает? А вот главный герой нашей следующей игры с этим утверждением не согласен. Когда тонны газировки заполняют завод самое время брать в руки любимый гаечный ключ и бросаться на помощь. О том, как же бороться со сладкой напастью поведает игра** One Up – Lemonade Rush**.





 ![One Up – Lemonade Rush](http://droider.ru/wp-content/uploads/2013/01/dshhpshh1-640x312.jpg)





По жанровой принадлежности** One Up – чистый попрыгунчик**. Главный герой должен постоянно прыгать и прыгать все выше и выше, чтобы успеть спасти завод от аварии.





Так как действие игры разворачивается на заводе, то будьте готовы повсюду встретить механизмы и прочие приспособления, как вполне привычные, так и совсем неуместные на обычном производстве. С большинством предметов и механизмов, которые доступны на уровнях, можно и нужно взаимодействовать.









**Для управления героем  вам нужно всего на всего тапать по экрану.** Бежать наш работник будет сам, а наткнувшись на стену, он развернется и побежит в другую сторону.





![One Up – Lemonade Rush](http://droider.ru/wp-content/uploads/2013/01/130-300x180.jpg)
![One Up – Lemonade Rush](http://droider.ru/wp-content/uploads/2013/01/228-300x180.jpg)



**Внешне One Up выглядит очень забавно**. Несмотря на отсутствие спецэффектов и бонусов, графика One Up очень яркая, насыщенная и детализированная. Также радует глаз и немного комичная анимация главного героя.





[One Up – Lemonade Rush lite в  Google Play маркете](http://droider.ru/goto/https://play.google.com/store/apps/details?id=com.jeebumm.oneuplite&feature=search_result#?t=W251bGwsMSwxLDEsImNvbS5qZWVidW1tLm9uZXVwbGl0ZSJd)





![](http://chart.apis.google.com/chart?cht=qr&chs=150x150&chl=market://details?id=com.jeebumm.oneuplite)





[One Up – Lemonade Rush в  Google Play маркете за 1$.](http://droider.ru/goto/https://play.google.com/store/apps/details?id=com.jeebumm.oneup#?t=W251bGwsMSwxLDIxMiwiY29tLmplZWJ1bW0ub25ldXAiXQ..)





![](http://chart.apis.google.com/chart?cht=qr&chs=150x150&chl=market://details?id=com.jeebumm.oneup)





Источник [droider.ru](http://droider.ru/post/one-up-novyiy-popryigunchik-26-01-2013/)
Всем привет.





Сегодня у меня в рубрике игра, которая ведет нас темным подземельем.





Я думаю, что авторы расскажут о ней лучше.





Читаем.


<!-- more -->


Игры жанра **РПГ**, в которых большую часть времени приходится сидеть в подземельях, как в Torchlight, нравятся немалому количеству пользователей. Именно такой игровой процесс ожидает вас в приложении**Dungeon Quest** от разработчиков из компании Shiny Box, LLC.





 ![Dungeon Quest ](http://droider.ru/wp-content/uploads/2013/01/logo16-640x312.jpg)





На данный момент игра все еще находится в стадии бета тестирования, поэтому геймплей не так разнообразен, как хотелось бы. Так игрокам доступен лишь один класс – маг, а для прохождения открыты 100 уровней, правда, с несколькими режимами сложности, которые могут занять пользователей надолго.





![Dungeon Quest ](http://droider.ru/wp-content/uploads/2013/01/135-300x179.jpg)
![Dungeon Quest ](http://droider.ru/wp-content/uploads/2013/01/233-300x179.jpg)


Основной упор в **Dungeon Quest** сделан на зачистку подземелий от всевозможной нечисти и получении с них ценного лута. Если по мере прохождения вы испытаете сложности, параметры героя можно будет скинуть и распределить заново.









Само собой, игроков ожидает обилие всевозможного вооружения, щедро выпадающего из поверженных противников, однако самые ценные предметы можно приобрести лишь во внутриигровом магазине. Тем не менее, игра отлично проходится и без лишних капиталовложений.





[Dungeon Quest в  Google Play маркете](http://droider.ru/goto/http://play.google.com/store/apps/details?id=com.shinybox.smash&feature=search_result)





![](http://chart.apis.google.com/chart?cht=qr&chs=150x150&chl=market://details?id=com.shinybox.smash)





Источник [droider.ru](http://droider.ru/post/dungeon-quest-progulka-po-podzemelyam-28-01-2013/)
Ну как то не могу обойти мимо екшн игры.





Очередная игра из огромнейшего списка.









Gameloft  предлагает всем любителям жанра экшн игру **Wild Blood. **Вам придется выступить в роли сера Ланцелота, которому придется сражаться с большим количеством различных демонов, которые попали в мир из врат Ада. Игра построена на движке Unreal Technology, который позволяет на экране мобильного устройства создать очень реалистичные и захватывающие сражения в трехмерной графике. Погрузись в мир захватывающих приключений и кровопролитных битв.






 <!-- more -->






Краткий сюжет:





Король Артур начинает сходить с ума от ревности к Ланцелоту, который проявлял признаки внимания и по дружески ухаживал за королевой. Злая Моргана воспользовавшись затмением разума короля, заставляет его открыть врата в Ад. Все мерзкие существа попадают в мир королевства и разрушают все то, что было создано королем Артуром и его подданными. Кроме этого Моргана крадет королеву и уносит ее на волшебный остров Авалон. Ланцелоту остается один вариант: уничтожить всех демонов, вернуть королеву Гвиневру домой и стать товарищем Артуру, который осознал свои ошибки. Помогать в борьбе против темных сил будет сэр Гайвен – один из рыцарей круглого стола.





Графика Wild Blood получилась очень качественной, что характерно для всех игр Gameloft выполненных на движке Unreal Technology. Вас ожидают красочные миры, эпические сражения, проработанные до мелочей персонажи и огромное количество различных спецэффектов.





**Особенности Wild Blood:**





- 10 отлично продуманных, а главное разнообразных уровней, которые приведут главного героя к Авалону;





- большое количество разнообразного оружия: мечи, луки, топоры и т.д.;





- свыше 20 видов вражеских юнитов, которые отличаются характеристиками стилем ведения боя;





- красочные локации с огромным количеством красивых объектов;





- наличие отличного сетевого мультиплеера.





Игра порадует каждого игрока возможностью сетевого режима, который  позволит одновременно на поле боя свести до 8 игроков (по 4 в каждой команде). Главной целью подобного режима есть захват флага. Сетевой режим возможно осуществлять с помощью Gameloft LIVE или Wi-Fi. Gameloft LIVE позволит играть на серверах в Интернете с огромным количеством игроков со всего мира, Wi-Fi позволит играть в компании друзей, как в локальной сети.





Wild Blood позволит Вам погрузится в захватывающие приключения сера Ланцелота.





















**Версия Android: 2.3 и выше**













![](http://all4pda.org/images/games/action/wild_blood/wild_blood1.jpg)





![](http://all4pda.org/images/games/action/wild_blood/wild_blood2.jpg)





![](http://all4pda.org/images/games/action/wild_blood/wild_blood3.jpg)





![](http://all4pda.org/images/games/action/wild_blood/wild_blood4.jpg)





![](http://all4pda.org/images/games/action/wild_blood/wild_blood5.jpg)









 













**Перейти на маркет**





![](http://all4pda.org/media/images/Android-Market.png)






Источник [all4pda.org](http://all4pda.org/ekshn/wild-blood-nezabyvaemye-priklyucheniya-sera-lancelota.html)




Как я люблю разного рода пошаговые стратегии.





Вот помню еще в общаге рубились в герои.





Играли ночью, утром "типа" шли на пары.





Прошли те времена....


<!-- more -->


Но игры новые появляются.





Популярная пошаговая РПГ Kings Bounty перебралась с ПК на мобильные устройства. Игру под названием **Kings Bounty: Legions** уже сейчас можно скачать бесплатно в магазине Google Play.





 ![Kings Bounty: Legions](http://droider.ru/wp-content/uploads/2013/01/logo5-640x312.jpg)





Как и ожидалось, игра очень похода на своего старшего брата – оригинальную серию игр **Kings Bounty**. В распоряжении игрока несколько видов юнитов, которыми необходимо управлять, сражаясь с врагами на игровой доске. Не забыли разработчики и про разнообразные миссии, в которых на плечи героев лягут обязанности по зачистке округи от нечисти, спасению принцесс и добыче ценных артефактов.





![Kings Bounty: Legions](http://droider.ru/wp-content/uploads/2013/01/112-300x187.jpg)
![Kings Bounty: Legions](http://droider.ru/wp-content/uploads/2013/01/212-300x187.jpg)





Несмотря на то, что у игры нет явного ограничения для использования только на планшетах, все же оптимальным будет именно такой выбор. Недостаточный размер экрана смартфона негативно скажется на общем впечатлении от игры.









Графическая составляющая в **Kings Bounty: Legions** находится на довольно высоком уровне. Как уже было сказано выше, в Google Play игру  можно скачать бесплатно, но в ней есть внутриигровой магазин, в котором у игроков есть возможность приобрести множество товаров для облегчения игрового процесса за реальные деньги.





**Для игры в Kings Bounty: Legions  необходимо сетевое подключение.**





[Kings Bounty: Legions в Google Play маркете](http://droider.ru/goto/https://play.google.com/store/apps/details?id=com.kranx.kbl)





![](http://chart.apis.google.com/chart?cht=qr&chs=150x150&chl=market://details?id=com.kranx.kbl)





Источник [droider.ru](http://droider.ru/post/kings-bounty-legions-snova-v-boy-15-01-2013/)
Продолжаем тему игр.





Кто из нас не помнит Масяню.





Как все смотрели этот первый флеш мульт.





Но Масяня закрылась, а вот автор скорее всего перешел на гейм уровень.





Смотрим, комментируем, лайкаем.

 <!-- more -->



Не так давно на виртуальных полках гуглового магазина приложений появилась новая рисованная стрелялка от разработчиков из студии Appsomniacs LLC под названием **Doodle Army**.





![Doodle Army](http://droider.ru/wp-content/uploads/2013/01/logo10-640x312.jpg)





Разработчики предлагаю всем желающим сразиться с нарисованными врагами **на шести разных картах**. Главный герой сможет побывать во Вьетнаме, Египте и даже Марсе. На каждой карте вашей главной задачей будет уничтожение всех врагов.









Небольшое количество карт с лихвой компенсируется огромным арсеналом, который насчитывает **около 40 видов оружия всех форм и размеров**, начиная от простых винтовок и заканчивая лазерами.





![Doodle Army](http://droider.ru/wp-content/uploads/2013/01/117-300x168.jpg)
![Doodle Army](http://droider.ru/wp-content/uploads/2013/01/217-300x168.jpg)





Несмотря на рисованную и внешне простую графику, игра изобилует всевозможными яркими спецэффектами и в целом выглядит довольно приятно. Приятно, что разработчики не забыли про управление. При желании вы сможете выбрать один из двух разных типов расположения экранных клавиш.









В магазине Google Play игра представлена в двух вариантах – бесплатном с ограниченным количеством оружия, персонажей и всего одной картой, а также полноценном, который обойдется вам в 0.99$.





[Doodle Army lite в Google Play маркете](http://droider.ru/goto/http://play.google.com/store/apps/details?id=com.chadtowns.daxfree&feature=more_from_developer#?t=W251bGwsMSwxLDEwMiwiY29tLmNoYWR0b3ducy5kYXhmcmVlIl0.)





![](http://chart.apis.google.com/chart?cht=qr&chs=150x150&chl=market://details?id=com.chadtowns.daxfree)





[Doodle Army в Google Play маркете за 1$](http://droider.ru/goto/https://play.google.com/store/apps/details?id=com.chadtowns.dax&feature=more_from_developer#?t=W251bGwsMSwxLDEwMiwiY29tLmNoYWR0b3ducy5kYXgiXQ..)





![](http://chart.apis.google.com/chart?cht=qr&chs=150x150&chl=market://details?id=com.chadtowns.dax)





Источник [droider.ru](http://droider.ru/post/doodle-army-risovannaya-strelyalka-19-01-2013/)
Не успел опубликовать предыдущую статью.





Как нашел статью, где целый ряд поддельных программ.





Смотрим и удаляем из своего устройства.





А и чуть не забыл, пишем комментарии и лайки приветствуются тоже  :lol:


<!-- more -->


В последнее время в магазине Google Play все чаще стали появляться поддельные приложения, маскирующиеся под именитые и популярные аналоги. Об этом вчера в своем отчете сообщили эксперты из компании [Help Net Security](http://droider.ru/goto/http://www.net-security.org/).





![Help Net Security](http://droider.ru/wp-content/uploads/2013/01/125-521x400.jpg)





По данным исследователей, такая проблема существует не только на Android. С поддельными приложениями сталкиваются и пользователи яблочной платформы. Но в **App Store** такие программы долго не задерживаются. Да и нанести особого ущерба пользователям, по данным экспертов, они не могут.





С **Android** ситуация обстоит несколько иначе. Владельцы Android устройств, которые установили поддельные приложения, рискуют лишиться своей личной информации, или получить целую гору рекламных сообщений и уведомлений.





 ![Help Net Security](http://droider.ru/wp-content/uploads/2013/01/224-518x400.jpg)





В большинстве случаев поддельные приложения похожи на оригинал не только названием.  Обычно разработчики таких программ используют оригинальные скриншоты, а иногда и копируют часть описания.





Чтобы обезопасить себя от поддельных приложений в **Google Play**, мы настоятельно рекомендуем пользователям перед скачиванием внимательно прочитать описание приложения, просмотреть его рейтинг и отзывы.





Источник [droider.ru](http://droider.ru/post/help-net-security-v-google-play-mnogo-poddelnyih-prilozheniy-22-01-2013/)




Поскольку мой блог рассчитан на порядочных людей.





Я не могу пройти мимо, и не предупредить своих читателей.





Внимание! На маркете подделки!





Смотрим и не удаляем!


<!-- more -->


Только вчера мы писали о том, как злоумышленники выдают свои приложения с вредоносным кодом за популярные игры, как жертвой стала еще одна популярная игра – **Temple Run 2**.





![Копия Temple Run 2 ](http://droider.ru/wp-content/uploads/2013/01/temple_run_2_android_fake.jpg)





Всего за несколько дней с момента появления сиквела в магазине приложений App Store его скачали более 20 миллионов пользователей. За подобную популярность приложение даже получило специальную награду. Ситуацией решили воспользоваться злоумышленники и в Google Play начали появляться копии. Обмануться в этом случае очень легко, так как копируется все – название, скриншоты и описание.





Единственным отличием от оригинала является название студии разработчика. Поэтому будьте внимательны и**не скачивайте игру, у которой имя разработчика отличается от Imangi Studios**. Даже, несмотря на то, что из Google Play регулярно удаляются подделки, обезопасить себя сможете только вы сами.





К слову,** релиз игры для устройств на платформе Android состоится уже совсем скоро – 24 января.**





Источник [droider.ru](http://droider.ru/post/budte-bditelnyi-poddelnyiy-temple-run-2-23-01-2013/)
Всегда мечтал полетать на вертолете.





Но увы он только у нашего шефа ....  8-)





Ну да и ладно.





Давайте посмотрим, что нам предлагают разработчики.





Многие помнят старые простенькие аркады, где было необходимо управлять летательным аппаратом, проводя его по запутанным и опасным уровням. Именно к таким играм относится наш следующий гость –** Fly Cargo** от разработчиков из студии ANDISTUDIO.





 ![Fly Cargo](http://droider.ru/wp-content/uploads/2013/01/logo13-640x312.jpg)



<!-- more -->

В вашем распоряжении небольшой вертолет, с помощью которого **нужно доставить груз**. Общую простоту главной цели значительно затрудняет окружающая обстановка, которая заставит выложиться по максимуму и показать настоящее мастерство пилотирования.





**Управление в Fly Cargo предельно простое** и реализовано с помощью трех клавиш, отвечающих за движение вертолета влево, вправо и вверх. Только верный контроль над машиной приведет вас к успеху. Тут стоит отметить, что клавиши управления не самые крупные и порой возможны ложные нажатия.





![Fly Cargo](http://droider.ru/wp-content/uploads/2013/01/128-300x179.jpg)
![Fly Cargo](http://droider.ru/wp-content/uploads/2013/01/226-300x179.jpg)





Графическая составляющая **Fly Cargo** выполнена в интересном минималистичном стиле. Вся обстановка представляет собой лишь черные силуэты на цветном контрастном фоне, меняющемся по мере прохождения игры. Приобрести Fly Cargo можно в магазине Google Play за 1$.





[Fly Cargo в Google Play маркете за 1$](http://droider.ru/goto/http://play.google.com/store/apps/details?id=com.dmitry.flycargo)





![](http://chart.apis.google.com/chart?cht=qr&chs=150x150&chl=market://details?id=com.dmitry.flycargo)





Материалы из сайта [droider.ru](http://droider.ru/post/fly-cargo-multyashnyiy-polet-na-vertolete-25-01-2013/)
Всем привет.





Продолжаю искать самые интересные игры и программы.





Сегодня речь пойдет об играх.





И так вашему вниманию стратегия, которая должна выйти вот вот.





Посмотрим что нам предлагают авторы.


<!-- more -->


Несмотря на то, что мобильные платформы развиваются с огромной скоростью, в плане игр им все еще далеко до настольных компьютеров и игровых консолей. Очень мало приложений радуют пользователей и отличной графикой и сюжетом. Быть может переломным моментом станет появление на Android игры **Oil Rush**.





![Oil Rush](http://droider.ru/wp-content/uploads/2013/01/logo14.jpg)





Эта игра уже существует на ПК и продается [в Steam за 12$](http://droider.ru/goto/http://store.steampowered.com/app/200390/). Тем, кто успел познакомиться с **Oil Rush** известно, что сюжетная составляющая в ней есть. В первую очередь потому, что это все же стратегия и без должного уровня смысла и мотивации она была бы не такой популярной.









Действие игры разворачивается в постапокалиптическом мире, где постоянно идет борьба за важнейший мировой ресурс – нефть. Задача игроков захватить и удержать как можно больше буровых платформ в море. Постоянные нападения рейдеров, атака и защита не дадут никому скучать.





![Oil Rush](http://droider.ru/wp-content/uploads/2013/01/129.jpg)





По словам разработчиков, версия для Android будет иметь еще одно преимущество перед другими играми, помимо сюжета – это графика. Но и в бочке меда есть ложка дегтя. Все еще нет точной даты релиза **Oil Rush на Android**. Сейчас известно только о том, что стратегия появится в Google Play **в феврале 2013 года**.





![Oil Rush](http://droider.ru/wp-content/uploads/2013/01/227.jpg)





Также в_ _течение первых шести месяцев после релиза игру смогут установить только владельцы устройств с процессорами Qualcomm **Snapdragon S4 (MSM8960, APQ8064, MPQ8064)**.





Материал из сайта [droider.ru](http://droider.ru/post/strategiya-oil-rush-vyiydet-na-android-25-01-2013/)
Просматривал программы и игры.





И вот набрел на очень ..... просто не знаю как выразится  8-) игру.





Кто ее сможет использовать в реальности, напишите.





А еще лучше, присылайте мне ваши фото, я их опубликую.


<!-- more -->


А теперь...... Трепетное волнение ........





Описание и видео.

{% youtube a3l3TZousQI %}



Horror Rotten Friends (light) это приложение, вдохновлённое фильмами ужасов. Нет ничего проще и смешнее, чем приколоться над вашим другом, превратив его в зомби или придав ему демонический вид. Если Вам надоело засилье милых приложений и Вы всегда любили хоррор или ищете способ прикоснуться к Дню всех Святых – вы попали по адресу.





![Разработчик: ](http://s.4pda.ru/wp-content/uploads/2013/01/jr2rtbnechk-480x299.jpg)





**Версия: **2.2013.3





**Русский интерфейс: **Да





**Технические требования: **Android 2.1+





**Категория:** Фоторедактор









«Сгнившие Друзья» перенесёт вас и ваших друзей в мир ужаса. Можно стать кровожадным вампиром или сексуальным суккубом, манящим мужчин к их погибели, познать магию Вуду и восстать из мёртвых, стать покрытым шрамами хладнокровным, но кровожадным убийцей, дать пять Сатане и унизить его размером своих рогов и размахом крыльев. В Хэллоуин одеть гротескную маску лекаря времён чумы, примерить колпак палача, обозначить свою тёмную сторону: ведь это то, что сегодня разрешено.





ВНИМАНИЕ: Страшный контент не рекомендуется для просмотра детям, а так же впечатлительным людям.









[![](http://s.4pda.ru/wp-content/uploads/2013/01/34-480x288.jpg)](http://s.4pda.ru/wp-content/uploads/2013/01/34.jpg)





[![Зло - создания и предметы ада теперь и на земле. Создай зловещий антураж на фото!](http://s.4pda.ru/wp-content/uploads/2013/01/p_edited-480x321.jpg)](http://s.4pda.ru/wp-content/uploads/2013/01/p_edited.jpg)





ПАКЕТЫ:








  * Зомби - плод Чёрной магии жрецов Чёрного континента. Зомби и еще раз Зомби! Сожри их всех!



  * Зло - создания и предметы ада теперь и на земле. Создай зловещий антураж на фото!



  * Маски - страшные пугающие маски к предстоящему хелоуину!



  * Кожа - покрой себя боевыми шрамами и порезами, а так же жуткими татуировками



  * Оружие - орудия убийств для серийных маньяков и инквизиции. Вгони святой крест в голову нежити



  * FUN - Новый Год, Рождество, Halloween в стиле Rotten Friends






[![](http://s.4pda.ru/wp-content/uploads/2013/01/screen1.png)](http://s.4pda.ru/wp-content/uploads/2013/01/screen1.png)





Приложение уже несколько месяцев размещено на Google Play и пользователи часто присылают свои обработанные фото (несколько последних из Тайваня).





[![](http://s.4pda.ru/wp-content/uploads/2013/01/53-480x422.jpg)](http://s.4pda.ru/wp-content/uploads/2013/01/53.jpg)





Часть контента в приложении платная, но ее можно получить бесплатно с помощью GetJar, нужно всего лишь установить несколько любых приложений из списка (1 пакет = 50 gold, 5 приложений). Также есть Pro версия, в которой нет рекламы и ограничений.





Будем рады любым отзывам и комментариям!





**Стоимость:** Содержит рекламу





**Обсуждение на 4pda:** [http://4pda.ru/forum/index.php?showtopic=400480&st=0&#entry18723549](http://4pda.ru/forum/index.php?showtopic=400480&st=0&#entry18723549)





**Ссылка на Google Play:** ![QR](http://s.4pda.ru/forum/style_images/1/qr_code.gif)[https://play.google.com/store/apps/details?id=com.hellgames.rf.version.normal](https://play.google.com/store/apps/details?id=com.hellgames.rf.version.normal)





**Бонусы от разработчика:** Бонус: за постинг 2 обработанных в Rotten Friends фото друзей на Facebook доступен пакет иконок FUN бесплатно!





Материал из сайта [4pda.ru](http://4pda.ru/2013/01/17/86286/)
Всем привет.





Очередной обзор игр.





Игра "Первобытный парк" перевернет твое представление о доисторической жизни. Откликнись на зов предков и окунись в мир безумных первобытных развлечений. Преврати скучную жизнь пещерных людей в настоящий праздник!





![](http://s.4pda.ru/wp-content/uploads/2012/12/splash_800x480-480x288.jpg)

 <!-- more -->

**Версия: **1.0.47





**Русский интерфейс: **Да





**Технические требования: **Android версии 1.6 и выше





**Категория:** Казуальные, стратегии









Первобытный Парк - это строительный симулятор парка развлечений. В игре вам предстоит построить первый парк аттракционов в истории человечества. В вашем распоряжении более 200 различных аттракционов, сервисов, закусочных, экзотических цветов, деревьев и прочих декораций - в общем, все, чтобы сделать ваш парк уникальным и интересным. Вам придется пробовать различные комбинации расположения аттракционов, сервисов и декораций, чтобы удовлетворить желания требовательных первобытных посетителей. Помимо этого вы сможете нанимать работников, чтобы они помогали вам собирать деньги, мусор, ремонтировали аттракционы, разнимали драки и следили за парком в ваше отсутствие.





Особенности игры:








  * Отличная мультяшная графика и занимательный геймплэй;



  * Веселые звуки и музыка;



  * Более 60 аттракционов;



  * Более 100 сервисов, деревьев, цветов и декораций;



  * 5 типов работников;



  * Сотни забавных посетителей со своими желаниями;



  * Достижения, онлайн-рейтинг, посещение других парков.






**От разработчиков: **Что делает игру уникальной и отличной от остальных сити-билдеров, это то, что мы постарались сделать ее больше похожей на симулятор, а не на казуальную игру. Мы старались сохранить дух старого доброго Theme Park и RollerCoaster Tycoon, некогда популярных на PC. Но, в то же время, игра отвечает современным требованиям к мобильным играм. Помимо этого игра построена по принципу честного free-to-play. В игру можно спокойно играть, не вкладывая деньги, но это займет дольше времени. Практически всего в игре можно достичь бесплатно, а деньги нужны только для ускорения игрового процесса.





Скоро на IPhone и IPad!





**Стоимость:** Бесплатно





**Ссылка на Google Play:** ![QR](http://s.4pda.ru/forum/style_images/1/qr_code.gif)[https://play.google.com/store/apps/details?id=com.geargames.pfp](https://play.google.com/store/apps/details?id=com.geargames.pfp)





  
  






![Офицальный скриншот "Первобытный парк"](http://s.4pda.ru/wp-content/uploads/2012/12/ycrlkibolci-480x288.jpg) 
![Офицальный скриншот "Первобытный парк"](http://s.4pda.ru/wp-content/uploads/2012/12/wyyoyzke5ua-480x288.jpg)



![Офицальный скриншот "Первобытный парк"](http://s.4pda.ru/wp-content/uploads/2012/12/jxoz92ocly0-480x288.jpg)
![Офицальный скриншот "Первобытный парк"](http://s.4pda.ru/wp-content/uploads/2012/12/1hot_i9poxq-480x288.jpg)



Статья из сайта [4pda.ru](http://4pda.ru/2012/12/20/83394/)
Ребята всем привет.





На вебинаре меня спрашивали как получать прибыль с продажи.





К сожалению, для Украины прямого получения нету. (Как получать я узнаю.)





Но для России есть.


<!-- more -->


И сегодня я нашел статью, как можно получать деньги с PlayMarket.





Прошу к прочтению.





В октябре 2012 [вступили в силу новые правила получения платежей от продаж на Google Play](http://droidblog.merigotech.com/?p=70) и, одновременно, [новая инструкция ЦБ РФ О порядке предоставления документов, связанных с проведением валютных операций](http://droidblog.merigotech.com/?p=73) (Инструкция Банка России от 04.06.2012 № 138-И - [PDF](http://www.cbr.ru/analytics/standart_acts/currency_regulations/138-i.pdf)). В результате, платежи с Google Checkout теперь можно получать напрямую на расчетный счет индивидуального предпринимателя. Это позволяет избавиться от[работы с AdSense](http://aldro.ru/internet-i-biznes/29-nalogi-adsens.html) и связанных с ней [морем вопросов](http://forum.searchengines.ru/archive/index.php/t-646949.html).   
  
Многие разработчики уже [опробовали](http://habrahabr.ru/post/151831/) новую схему. Попробовал и я - на днях пришел первый платеж. Хочу поделиться подробностями организации работы с банком.





## РАСЧЕТНЫЙ СЧЕТ





Для получения платежей требуется долларовый расчетный счет ИП. Процесс открытия валютного счета я уже [подробно описывал](http://derevyanko.blogspot.ru/2010/09/1.html). При открытии счета вам откроют два счета: текущий и транзитный.   
  
В настройка Google Checkout в разделе Settings\Financials нужно будет указать информацию о банке





![](http://2.bp.blogspot.com/-1-qNj7K21xo/UK71gaD83GI/AAAAAAAAAOA/u0Bw14FL3qM/s320/checkout.jpg)




На примере [реквизитов Сибирского филиала Промсвязьбанка](http://www.sibenergocom.ru/contact):




    
    Сибирский филиал ОАО «Промсвязьбанк» г. Новосибирск  
    
    Рс/сч (20-значное число)
    
    Кор/сч 30101810500000000816 
    
    БИК 045004816
    
    Intermediary Bank (Банк – Посредник): Deutsche Bank Trust Company Americas
    
     New York, NY, USA
    
     SWIFT: BKTR US 33
    
    Account with Institution (Банк Бенефициара): ОJSC "Promsvyazbank"
    
     SIBIRSKY BRANCH,
    
    SWIFT: PRMSRUMMNSB
    
    





Здесь BIK = 045004816 (это БИК вашего банка). Account number = номер вашего**транзитного** счета. SWIFT = PRMSRUMMNSB. Bank name = ОJSC "Promsvyazbank". Account holder name = ваши фамилия и имя.   
  






## ДОКУМЕНТЫ В БАНК





Получение денег на валютный расчетный счет связано с обязательной процедурой валютного контроля. Принципиально вас ожидает то же самое, что при [получении денег от иностранного заказчика](http://derevyanko.blogspot.ru/2010/09/blog-post.html). При поступлении платежа требуется:








  1. Представить в банк договор с Google



  2. Создать справку о валютной операции и перевести деньги с транзитного счета на текущий валютный или сразу же с продать валюту с транзитного валютного счета на текущий рублевый.






Банк требует предоставить оригинал и перевод соглашения [Accept payments through Google - Terms of Service. Google Checkout - Terms of Service (https://checkout.google.com/termsOfService?type=SELLER)](https://checkout.google.com/termsOfService?type=SELLER) (для просмотра требуется войти в свой аккаунт Android-разработчика). С оригиналом - проблем нет. А вот перевода на русский в сети мне найти не удалось. Пришлось переводить самому...   
  
[Выкладываю перевод](http://code.google.com/p/dvsrc/downloads/detail?name=20120919v1_%D0%9F%D0%B5%D1%80%D0%B5%D0%B2%D0%BE%D0%B4%20Accept%20payments%20through%20Google%20-%20Terms%20of%20Service.7z&can=2&q=) в свободный доступ. (Качество перевода, прямо говоря, не очень - уж слишком много там юридической терминологии... Буду признателен, если кто-нибудь укажет на официальный или более качественный перевод. Если кто-нибудь возьмется править перевод - могу предоставить доступ к оригинальному документу в google docs, - параграфы на английском и русском чередуются. Пишите мне на dvpublic0 на гмейле).   
  
Судя по [комментариям на Хабре](http://habrahabr.ru/post/151831/), в некоторых банках могут требовать и другие документы, например, скришнот Payouts.   
  
Если у вас есть все необходимые документы, то дальше проблем особых нет. Создаете справку о валютной операции и заявление о переводе/продаже валюты с транзитного счета. Здесь главное уложиться в 15 дней с момента поступления платежа. Штрафы за опоздание могут быть [ОЧЕНЬ](http://habrahabr.ru/blogs/Dura_Lex/114069/) высокими. Лично мне Google перевел первый платеж чуть ли не в тот же день, как я вбил реквизиты банка в Google Checkout (а вовсе не в конце месяца). В итоге я чуть было этот платеж не пропустил.





## ПАСПОРТ СДЕЛКИ





Если совокупная сумма платежей по договору превысит $50 000, то потребуется, как мне сказали в банке, "открыть паспорт сделки или подписать новый договор". Сразу открывать паспорт сделки не требуется.





Статья из сайта [derevyanko.blogspot.com](http://derevyanko.blogspot.com/2012/11/google-play.html)





Расскажите своим друзьям.
Всем привет.





Новая подборка программ и игр.





 Памятка как выжить в экстремальных ситуациях и условиях. Что взять с собою из дома в экстренном случае? Как выжить в условиях отсутствия цивилизации? Полезная инструкция по выживанию, памятка что должно быть дома про запас, и как вести себя в случае наступления Конца Света или иных катастроф! Тревожные чемоданчики, подготовка квартиры и многое другое в одном приложении. Плюс бонус для тех, у кого все в порядке с чувством юмора.





![](http://s.4pda.ru/wp-content/uploads/2012/12/116-287x480.jpg)!


<!-- more -->

**Версия: **1.4





**Русский интерфейс: **Да





**Технические требования:** Android 2.2 и выше





**Категория:** стиль жизни, образование, справочник





По человеческой природе люди часто убегают от проблем в работу, в йогу, в другую страну. 21 декабря 2012 года возможности бежать не будет –попросту некуда. А ты готов как можно скорее завершить свои дела? Слетать в Нью-Йорк, заняться боксом,  очистить совесть перед Вечностью?





Если амбиции и планы- личное дело каждого, то помочь морально и физически  подготовиться поможет наше Приложение. Вы сможете избавиться от  тяготящих душу метаний, морально подготовиться к Наступлению Вечности, получить «Сертификат Чистой Совести» в разделе "Спастись", который поспособствует уверенной встрече Конца Света.





Для тех кто все-таки хочет остаться на Земле и посмотреть «Что будет?»  мы подготовили целый перечень полезных советов, руководств и средств для выживания. Остаться вопреки календарю Майя, параду Планет и магическому набору цифр 21.12.2012.





Как известно, кто владеет информацией - владеет миром. Получив сведения из нашего приложения и вооружившись «Сертификатом Чистой Совести» предлагаем Вам поэкспериментировать с подготовкой к Концу Света – возможно, вы еще многое не учли.





**Стоимость:** Бесплатно





**Обсуждение на 4pda:** [http://4pda.ru/forum/index.php?showtopic=407625&st=0&gopid=17718903](http://4pda.ru/forum/index.php?showtopic=407625&st=0&gopid=17718903)





**Ссылка на Google Play:** ![QR](http://s.4pda.ru/forum/style_images/1/qr_code.gif)[https://play.google.com/store/apps/details?id=ru.chebro.doomsday](https://play.google.com/store/apps/details?id=ru.chebro.doomsday)





**Бонусы от разработчика:** Присланные интересные материалы от "выживальщиков" будут размещены в приложении!





![](http://s.4pda.ru/wp-content/uploads/2012/12/24-287x480.jpg)
![](http://s.4pda.ru/wp-content/uploads/2012/12/37-287x480.jpg)




![](http://s.4pda.ru/wp-content/uploads/2012/12/45-287x480.jpg)
![](http://s.4pda.ru/wp-content/uploads/2012/12/54-287x480.jpg)





![](http://s.4pda.ru/wp-content/uploads/2012/12/64-287x480.jpg)



Статья из сайта [4pda.ru](http://4pda.ru/2012/12/12/82303/#more-82303)
Всем привет.





Новая подборка программ и игр.









Одна из самых популярных в мире онлайн-игр, "Феодалы и Рыцари", полностью перешла на платформу Android. На днях разработчик игры, компания Xyrality, завершил стадию бета-тестирования и представила стабильную версию средневековой стратегии.





![](http://s.4pda.ru/wp-content/uploads/2012/12/unnamed4-480x234.jpg)

 <!-- more -->

Новая версия работает заметно быстрее.  Для более комфортного геймплея на Android-устройствах игра была оптимизирована для планшетов. Также разработчики добавили масштабирование карты и многочисленные функции для более легкого управления альянсами. Венчает новую версию анимация и средневековая музыка, специально написанная для игры.





Для тех, кто еще не играл в "Феодалы и Рыцари", напомним, что действие стратегии разворачивается в средневековой Европе, где вам предстоит стать повелителем могущественной империи. Вы можете строить замки, исследовать новые технологии, торговать ресурсами, а для борьбы с другими феодалами вам потребуется создать мощную армию. В сражениях против тысяч других оппонентов вам необходимо проявить себя не только как воина, но и стратега, заключая дипломатические альянсы с другими участниками.





Ленточка, открывающая для геймеров вход в мир "Феодалов и Рыцарей", была перерезана 1 июня 2011 года. На сегодняшний момент это одна из самых популярных стратегий в жанре MMOG в Европе. Игра установлена на 1,5 миллионах устройств и входит в топ-рейтинги App Store и Google Play во многих странах.





[**Загрузить приложение бесплатно**](http://goo.gl/vW1l5)













Статья из сайта [4pda.ru](http://4pda.ru/2012/12/12/82498/#more-82498)
Всем привет.





Новая подборка программ и игр.





Только вы способны спасти этот Новый Год!! Злобные гремлины украли подарки у Деда Мороза. И теперь Деду Морозу нечего дарить детям на Новый Год. Но не стоит отчаиваться, вы можете помочь Дедушке Морозу вернуть все подарки обратно. И спасти Новый Год.





![](http://s.4pda.ru/wp-content/uploads/2012/12/mzl-kkbijenp1-480x480.png)


<!-- more -->


**Версия: **1.00





**Русский интерфейс: **Нет





**Технические требования: **Android 2.1+ (ARMv7), iOS iPhone (поддержка разрешения для iPhone 5), iPod touch, iPad. iOS 4.3 или выше





**Категория:** Игры, для детей









Особенности игры:








  * Новогодняя музыка в обработочном стиле



  * 25 интересных уровней






![](http://s.4pda.ru/wp-content/uploads/2012/12/mzl-lftwrvza.jpg)
![](http://s.4pda.ru/wp-content/uploads/2012/12/mzl-jbfjtkvw.jpg)



![](http://s.4pda.ru/wp-content/uploads/2012/12/mzl-jmvgekyg.jpg)


**Стоимость:** 1$





**Ссылка на Google Play:** ![QR](http://s.4pda.ru/forum/style_images/1/qr_code.gif)[https://play.google.com/store/apps/details?id=agaming.stolen.christmas](https://play.google.com/store/apps/details?id=agaming.stolen.christmas)





**Ссылка на Apple Store:** ![QR](http://s.4pda.ru/forum/style_images/1/qr_code.gif)[https://itunes.apple.com/ru/app/stolen-christmas/id586223548?mt=8](https://itunes.apple.com/ru/app/stolen-christmas/id586223548?mt=8)





**Бонусы от разработчика:** Android версия бесплатно









Статья из сайта [4pda.ru](http://4pda.ru/2012/12/15/82855/#more-82855)
Всем привет.





Новая подборка программ и игр.









Новый год – праздник, которого мы всегда ждем. Появляется свободное время, которое нужно потратить на что-то приятное. Прекрасный вариант – поиграть в Пятнашки Новый Год.





![](http://s.4pda.ru/wp-content/uploads/2012/12/pxmas-480x234.png)

<!-- more -->

**Версия: **2.0





**Русский интерфейс: **Да





**Технические требования: **2.2+





**Категория:** Игры, головоломка









Новый год – праздник, которого мы всегда ждем. Появляется свободное время, которое нужно потратить на что-то приятное. Прекрасный вариант – поиграть в Пятнашки Новый Год.





Пятнашки Новый Год – это праздничная ностальгия по известной пластмассовой головоломке.  Если Вы застали эти чудесные времена (ведь детство – это всегда прекрасно), наверняка помните, что на обратной стороне пятнашек был рисунок. Высший пилотаж - сложить его, не подсматривания на цифры.





В новогодних же пятнашках незамысловатый рисунок превратился в настоящую сказку с новогодними героями. Падающий снег на фоне пятнашек, кнопки управления из чистого льда – все приводит в восторг. Даже не замечаешь, как уровни становятся все сложнее и сложнее. Вот позади уже нос-морковка – снеговик, дальше - елка с кучей подарков, олени на коньках …. кусочков головоломки все больше и больше, угадать рисунок все сложнее и сложнее… о да!





Наконец-то я сложил главного героя!





Так и хочется стать на табуретку и рассказать стишок:





Над полями, над лесами,  
Мчаться расписные сани.  
В них запряжены олени,  
Дед Мороз в тех санках едет!  
К нам подкрался Дед Мороз,  
Нарумянил щеки, нос  
Снегом валенки набил  
И подарки подарил!





Ну, а если с поэзией не очень, можно просто поздравить друзей собранными открытками через соцсети…





P.S: Сейчас версия игры на BlackBerry и Symbian находиться на утверждение в appworld.blackberry.com и store.ovi.com





**Стоимость:** 1$





**Ссылка на Google Play:** ![QR](http://s.4pda.ru/forum/style_images/1/qr_code.gif)[https://play.google.com/store/apps/details?id=com.pyatnashki.pyatnashki.xmas](https://play.google.com/store/apps/details?id=com.pyatnashki.pyatnashki.xmas)





![](http://s.4pda.ru/wp-content/uploads/2012/12/unnamed-12-270x480.jpg)
![](http://s.4pda.ru/wp-content/uploads/2012/12/unnamed5-270x480.jpg)



Статья из сайта [4pda.ru](http://4pda.ru/2012/12/17/83064/)
Даже не знаю как рассказать.





А вообщем читайте сами.





Сегодня я расскажу вам сказку про белого б… осьминога. Начинается она так: «Жили да были молодцы удалые. Попутал их как-то бес влезть в Android Market-а лес. Долго они выход искали и насилу воротились. А как домой возвратились – приложение написали». О сервисе, который поможет не потеряться в Google Play и пойдет речь в этом обзоре.


<!-- more -->


![](http://s.4pda.ru/wp-content/uploads/2012/12/pic.png)









**Версия: **1.0.05





**Русский интерфейс: **Да





**Технические требования:** Андроид 2.1+





**Категория:** поисковое приложение





Найти что-то путевое в огромном изобилии приложений без чьей-либо помощи очень сложно. Описания приложений выглядят одинаково привлекательно, а полагаться на комментарии и рейтинги в Google Play из-за накруток можно не всегда. Для того, чтобы не тратить свое время на ерунду, можно довериться рекомендациям знакомых или пролистать обзоры приложений. Но есть еще один способ – заглянуть в контент самого приложения до установки. В этом поможет приложение osmino apps, которое индексирует контент внутри мобильного ПО наряду с их описаниями. В данный момент это в основном касается текстового контента. Не мудрствуя лукаво, запустим приложение и посмотрим, как оно работает.









## **Поиск по интересам**





![](http://s.4pda.ru/wp-content/uploads/2012/12/osmino-apps9-270x480.png)





Главный экран приветствует нас большой картинкой с названием приложения, окошком для поиска и несколькими абзацами поясняющего текста. Функциональная часть на первом экране одна – это окно ввода поискового запроса. Здесь можно вручную забить искомый запрос или попросить желаемое голосом.





![](http://s.4pda.ru/wp-content/uploads/2012/12/osmino-apps7-270x480.png)



В качестве пробного запроса я выбрал слово «аркады» - дело к зиме, а скуку развеять чем-то по вечерам надо.  Первый выстрел ушел в молоко. К сожалению, аркад я не нашел, зато смог почитать, что это такое на Википедии и еще в паре мест. То же самое произошло при запросе «стратегии».





![](http://s.4pda.ru/wp-content/uploads/2012/12/osmino-apps8-270x480.png)



Для второго запроса был выбран «гоночный симулятор». На 6-ой строчке оказался релевантный ответ «GT Racing». Бегло проглядываю список –  еще пара гонок. Удивляюсь, что среди них нет Asphalt, и ввожу новый запрос. К слову, каждый пункт из списка ответов снабжен полным названием приложения и датой его добавления. Нажимая на тот или иной пункт, мы попадаем прямиком в Google Play на страницу скачивания этого приложения.





![](http://s.4pda.ru/wp-content/uploads/2012/12/osmino-apps3-270x480.png)



С развлекательно-игровой частью запросов все понятно – если думать над запросом, то что-нибудь подходящее на крючок попадется. А что насчет контентных приложений. Например, тех же фильмов?





Вбиваю запрос «Фильмы» и просматриваю список результатов: здесь уже знакомые ivi, Stream и новый для меня VideoMix. Все это - мобильные версии онлайн-сервисов просмотра фильмов за умеренную денежку. Что ж, в этом сегменте приложений все стандартно  - новинок в ближайшее время ждать не стоит. Если же требуется найти какой-то конкретный фильм, osmino apps сообщит, в каких приложениях его нужно искать. Удобно.





А вот что не совсем удобно – так это то, что osmino apps уже проиндексировал контент VideoMix и Литрес с бесконечными описаниями фильмов и книг. Так что эти два приложения попадают практически в любой список ответов. То же касается и Википедии.





![](http://s.4pda.ru/wp-content/uploads/2012/12/osmino-apps1-270x480.png)

Если с приложениями для просмотра фильмов есть некоторая альтернатива, то по запросу «Музыка» osmino apps выдает только один ответ: приложение «MP3 Поиск». Ок, едем дальше.





![](http://s.4pda.ru/wp-content/uploads/2012/12/osmino-apps5-270x480.png)




Что касается запроса «рецепты» - кроме предложения купить книгу рецептов у Литреса ждать ничего не стоит. А вот по запросу «рецепты приложение» список ответов меня более чем удовлетворил. Здесь нашлось не меньше десяти приложений о том, как вкусно готовить. Одно из них даже осело на мой смартфон – «Рецепты Кофе», предлагающее 300 способов приготовления любимого напитка. Делаю вывод: чтобы получить внятный ответ, нужно правильно задать вопрос.





![](http://s.4pda.ru/wp-content/uploads/2012/12/osmino-apps6-270x480.png)



Запрос «Изучение Английского» выдает объемный список приложений, обещающих научить пользователя английскому за 3 недели, 2 недели и совсем не приличное время. Релевантных ответов здесь существенно больше, чем посторонних. Кажется, после небольшой тренировки я научился составлять правильные поисковые запросы.









## **Что искать?**





Сами разработчики задумывали приложение, как адекватный поиск нужных приложений и просто мобильный поиск. То есть такой поиск информации, который использует мобильные приложения в качестве источника контента, оформленного в удобном для смартфонов виде. Идея благородная и уже приносит первые плоды. Так, мне показалось удобным искать обучающие программы, рецепты, заглядывать во внутренний контент понравившихся приложений до установки, а также искать конкретные фильмы, при условии, что я хочу посмотреть их в высоком качестве (и готов заплатить за это ivi или stream-у).









## **Индексация новых приложений – как попасть  в osmino**





Коллектив разработчиков osmino apps добавляют в поисковую систему все новые и новые приложения. В списке проиндексированных сейчас находятся более полутора миллионов единиц контента из приложений, среди которых ivi, Википедия, Чемпионат.ру и другие. В список проиндексированных потенциально может попасть любой разработчик – это бесплатно. Кроме того, такое сотрудничество выглядит выгодным для обеих сторон. С одной стороны – конечные разработчики приложений, которые получают трафик из поисковой системы, с другой – авторы сервиса, увеличивающие охват поисковой системы. Ну и с третьей – счастливые пользователи =)





Ниже небольшая выдержка о том, как попасть в суп приложений osmino:





Для индексации контента внутри приложений требуется: Доступ к контенту, подлежащему индексированию, схема URI. (**более подробно можно [прочитать здесь](http://apps.osmino.com/developers.html)**)









## **Большие перспективы**





С точки зрения функционала приложение не имеет ничего лишнего. Созданное для того, чтобы искать информацию в приложениях и о приложениях Google Play, оно неплохо справляется с этой задачей. Немаловажно, что osmino apps может выдать информацию из какого-то конкретного приложения без установки последнего.  Идея приложения мне чрезвычайно понравилась, однако приложение требует ряда доработок. Так, необходимо сократить  долю ответов, приходящуюся на Википедию, Литрес, VideoMix и некоторые другие приложения с огромным массивом текстовой информации. Или же сделать возможность исключать такие приложения выборочно, занеся в отдельный список. Следующий очевидный шаг – разделение приложений по тематическим группам и поиск в рамках какой-то выбранной группы, например «бесплатные игры» ;)





В данный момент приложение доступно для Андроид. Версия iOS – на аппруве.









**Стоимость:** бесплатно









**[Скачать приложение на Андроид](http://goo.gl/seFdJ)**









В заключение, пожелаю будущим пользователям osmino apps потренироваться в поисковых запросах, а разработчикам - успеха в улучшении приложения. Надеюсь, новые версии с расширенным функционалом не заставят себя ждать.





**Спасибо за внимание!**





Источник [4pda.ru](http://4pda.ru/2012/12/04/81169/)
И тут Остапа понесло. :)





Luminus — это красивая логическая видео игра с оригинальной идеей. Для решения головоломок используются разноцветные лучи света: их можно направлять, смешивать и преломлять при помощи разнообразных объектов. Игра использует широко известную модель RGB. От игрока потребуется находчивость и умение, чтобы обойти преграды из стен и черных лучей и устремить свет к заветной цели.





![](http://s.4pda.ru/wp-content/uploads/2012/12/facebook-480x177.jpg)


 <!-- more -->


**Версия: **1.0.2





**Русский интерфейс: **Нет





**Технические требования: **Android 2.2+





**Категория:** головоломка









Минимизируйте число сделанных ходов и получите максимальную награду в 3 звездочки. Открывайте и исследуйте новые объекты, уровни и категории. Сложность уровней идет по нарастающей, от элементарных к действительно заставляющим задуматься.





Особенности:








  * Интересный и увлекательный геймплей



  * Красивые эффекты с лучами(особенно, когда их много)



  * Подходит для изучения RGB модели



  * Высокая детализация для HD дисплеев



  * Социальная интеграция с Twitter и Facebook






Следите за обновлениями, новые уровни и категории не заставят себя ждать. Пишите свои отзывы и комментарии, они помогут улучшить игру.





**Стоимость:** Содержит рекламу





**Обсуждение на 4pda:** [http://4pda.ru/forum/index.php?showtopic=404750](http://4pda.ru/forum/index.php?showtopic=404750)





**Ссылка на Google Play:** ![QR](http://s.4pda.ru/forum/style_images/1/qr_code.gif)[https://play.google.com/store/apps/details?id=org.wolrand.pl](https://play.google.com/store/apps/details?id=org.wolrand.pl)





![](http://s.4pda.ru/wp-content/uploads/2012/12/screen11-480x288.png)
![](http://s.4pda.ru/wp-content/uploads/2012/12/screen21-480x288.png)




![](http://s.4pda.ru/wp-content/uploads/2012/12/screen31-480x288.png)
![](http://s.4pda.ru/wp-content/uploads/2012/12/screen41-480x288.png)





![](http://s.4pda.ru/wp-content/uploads/2012/12/screen51-480x288.png)
![](http://s.4pda.ru/wp-content/uploads/2012/12/screen61-480x288.png)





Источник [4pda.ru](http://4pda.ru/2012/12/05/81230/)
Не сдержался, что бы не написать об этом.





На мобильных платформах вышла первая MOBA-игра - Heroes of Order & Chaos для Android и iOS. Объединяйтесь с друзьями и сразитесь на первой многопользовательской боевой арене (МОВА)! Соберите товарищей, прокачайте героев и сметите базу врагов с лица земли в этой динамичной и затягивающей игре.





![](http://s.4pda.ru/wp-content/uploads/2012/12/unnamed-480x234.jpg)


<!-- more -->

**Русский интерфейс: **да





**Технические требования: **iOS, Android





**Категория:** игры









Невероятно глубокая и затягивающая игра








  * Выберите одного из 30 уникальных героев на свой вкус - от коварных магов до яростных рыцарей



  * Играйте бесплатно за любого из многочисленных героев, меняя их по своему желанию



  * Улучшайте свои вещи и навыки, не теряя прогресс после окончания партии, и втопчите врагов в грязь



  * Битвы в реальном времени: носитесь по карте, заманивайте врагов в ловушки и бейте их из засады






Богатый игровой опыт в одиночку или с друзьями








  * Сражайтесь сами или по сети на картах двух типов (3 на 3 и 5 на 5)



  * Выработайте командную тактику с друзьями, и сметайте вражеские команды с лица земли



  * Покажите всему миру, что ваша команда непобедима - ключом к победе станет сыгранность и стратегия






Релиз игры на iOS состоялся 21 ноября, сегодня же вышла в свет версия для Android. За это время Gameloft значительно увеличил количество серверов и стабильность их работы - теперь каждый игрок в полной мере может без проблем насладится любимым жанром.





*Немного о жанре МОВА: МОВА ([Multiplayer online battle arena](http://en.wikipedia.org/wiki/Multiplayer_online_battle_arena)) - это командная тактическая игра с элементами RPG и RTS, в которой каждый игрок управляет одним выбранным героем. Главная задача каждой команды - уничтожить зеркальную вражескую базу. На данный момент этот жанр известен такими играми как DOTA, Leagues of Legends и является самым популярным жанром на PC.





**Стоимость:** бесплатно





**Ссылка на App Store:** ![QR](http://s.4pda.ru/forum/style_images/1/qr_code.gif)[https://itunes.apple.com/ru/app/id509458284](https://itunes.apple.com/ru/app/id509458284)





![QR](http://s.4pda.ru/forum/style_images/1/qr_code.gif)**Ссылка на Google Play:** ![QR](http://s.4pda.ru/forum/style_images/1/qr_code.gif)[https://play.google.com/store/apps/details?id=com.gameloft.android.ANMP.GloftHOHM](https://play.google.com/store/apps/details?id=com.gameloft.android.ANMP.GloftHOHM)









![](http://s.4pda.ru/wp-content/uploads/2012/12/hoc_960x640_screen_1_ru-480x320.jpg)
![](http://s.4pda.ru/wp-content/uploads/2012/12/hoc_960x640_screen2_ru-480x320.jpg)





![](http://s.4pda.ru/wp-content/uploads/2012/12/hoc_960x640_screen3_ru-480x320.jpg)
![](http://s.4pda.ru/wp-content/uploads/2012/12/hoc_960x640_screen4_ru-480x320.jpg)




Источник [4pda.ru](http://4pda.ru/2012/12/06/81505/)
А вот это круто.





Сегодня пользователи Android OS стали получать обновление программы Поиск Google, но радоваться, в первую очередь, необходимо пользователям версий Android 4.1 Jelly Bean и более поздних, потому что оно содержит огромное количество новых карточек для Google Now.





![](http://s.4pda.ru/wp-content/uploads/2012/12/google-now-480x398.png)

<!-- more -->






Согласно официальному заявлению Google, приложение поиска для Android 4.1+ получит следующие новые функции:





**Карточки**








  * События рядом



  * Предложения, который помогут вам в ваших исследованиях (правда неясно что это значит)



  * Билеты на самолёт (пока только для США)



  * Возможность сканирования окружающего мира камерой (как в [Google Goggles](http://4pda.ru/2012/02/17/55635/))



  * Погода в местах, которые вы вскоре посетите



  * [Примерный учёт физической активности при ходьбе и езде на велосипеде](http://4pda.ru/2012/11/04/77377/)



  * Дни рождения






**Голосовые команды**








  * Сделать запись в Google+



  * Сказать "Что это за песня?" чтобы найти название и исполнителя



  * Сказать "Отсканируй баркод" чтобы получить закодированную информацию






Отрадно, что компания постоянно улучшает свои сервисы. Конечно, в России доступны пока не все функции приложение, но Google Now уже стал полноценным инструментом и незаменимым помощником и информатором в повседневных делах.





Источник[ 4pda.ru](http://4pda.ru/2012/12/06/81472/)
Последняя игра на сегодня.





Готов к решающей битве? Тогда на старт! В игре Звездный Защитник 4 вам предстоит освоить управление супер-звездолетом, оснащенным самым современным оружием. Проиграйте более 100 захватывающих уровней, выполните 8 секретных миссий и спасите человечество, сокрушая все на своем пути.





![](http://s.4pda.ru/wp-content/uploads/2012/12/sd4_android_feature_graphic_1024x5001-480x234.jpg)!


 <!-- more -->

**Версия: **1.83.0





**Русский интерфейс: **Да





**Технические требования: **Android 2.3.3+





**Категория:** Аркадный шутер









В полной версии игры вам будут доступны:
















  * Широкий выбор космических кораблей



  * 8 крупномасштабных миссий



  * Гибкая система бонусов



  * Новое сверхмощное оружие



  * Более 100 захватывающих уровней



  * Красочная графика и увлекательный сеттинг














**Стоимость:** Демо-версия





**Ссылка на Google Play:** ![QR](http://s.4pda.ru/forum/style_images/1/qr_code.gif)[https://play.google.com/store/apps/details?id=awem.libsdl.app.sd4.free](https://play.google.com/store/apps/details?id=awem.libsdl.app.sd4.free)

















![](http://s.4pda.ru/wp-content/uploads/2012/12/sd4_android_screenshots_800x480_01-480x288.png) ![](http://s.4pda.ru/wp-content/uploads/2012/12/sd4_android_screenshots_800x480_05-480x288.png)





![](http://s.4pda.ru/wp-content/uploads/2012/12/sd4_android_screenshots_800x480_04-480x288.png) 
![](http://s.4pda.ru/wp-content/uploads/2012/12/sd4_android_screenshots_800x480_02-480x288.png)




 Источник [4pda.ru](http://4pda.ru/2012/12/07/81691/#more-81691)




И снова расслабуха.





Как же не хочется работать перед Новым годом.





Представляем вашему вниманию нашу новую игру Lamb For The Dragon. Игра создана в лучших традициях Crimsonland и Alien Shooter, но при этом имеет свои уникальные особенности.





Вы - дракон, который очень любит овец, но получить их просто так не удастся. Овец охраняет огромное количество людей, которым они тоже почему-то очень нужны.


<!-- more -->


![](http://s.4pda.ru/wp-content/uploads/2012/12/2012-08-29-08-02-38-480x288.jpg)



**Версия: **1.3





**Русский интерфейс: **Нет





**Технические требования: **iOS 4.3 +; Android 1.5 +





**Категория:** Action





Почувствуйте себя в шкуре Змея Горыныча, бегайте по полю, таскайте овец в свое логово и отбивайтесь от полчищ врагов. Открывайте новые возможности и новых врагов, по мере прохождения уровней.





Всегда помните — одна голова хорошо, а две еще лучше! Соревнуйтесь с игроками на других игровых платформах и докажите, что именно ваша платформа лучшая.





Ключевые особенности:












  * 2 режима: "История" и "Выживание"



  * 3 локации и 27 уровней в режиме "История"



  * Глобальная система рекордов Scoreloop, которая позволяет соревноваться игрокам на разных платформах.










![](http://s.4pda.ru/wp-content/uploads/2012/12/2012-10-12-19-43-26-480x288.jpg)
![](http://s.4pda.ru/wp-content/uploads/2012/12/2012-10-12-08-27-26-480x288.png)





![](http://s.4pda.ru/wp-content/uploads/2012/12/2012-10-12-19-37-30-480x288.jpg)
![](http://s.4pda.ru/wp-content/uploads/2012/12/2012-10-12-08-31-54-480x288.jpg)



Игра реализована по модели free to play, в бесплатной версии доступна одна локация из 9 уровней и режим выживания. При покупке полной версии станут доступными остальные уровни и локации, в процессе прохождения которых вам откроются новые бонусы и возможности.

















**Стоимость:** Демо-версия





**Ссылка на Google Play:** ![QR](http://s.4pda.ru/forum/style_images/1/qr_code.gif)[https://play.google.com/store/apps/details?id=com.pocket.lambforthedragon](https://play.google.com/store/apps/details?id=com.pocket.lambforthedragon)





**Ссылка на Apple Store:** ![QR](http://s.4pda.ru/forum/style_images/1/qr_code.gif)[https://itunes.apple.com/us/app/lamb-for-the-dragon/id539173223](https://itunes.apple.com/us/app/lamb-for-the-dragon/id539173223)





Источник [4pda.ru](http://4pda.ru/2012/12/08/81788/#more-81788)
Прикольно можно расслабиться





Наступают долгожданные новогодние праздники, а вместе с ними - незабываемые радостные эмоции, новые впечатления и... головоломки.





![](http://s.4pda.ru/wp-content/uploads/2012/12/promo4pda-480x234.png)

<!-- more -->

**Версия: **1.1





**Русский интерфейс: **Да





**Технические требования: **android 2.1





**Категория:** головоломка









Праздничную атмосферу создают искрящиеся снежинки. Соедини их с помощью линий, не проходя по одному пути дважды. Рождественские головоломки не закончатся никогда! Более 2000 уникальных уровней и 3 режима игры подарят Вам море позитивных эмоций и ярких впечатлений в новогодние каникулы.





![](http://s.4pda.ru/wp-content/uploads/2012/12/dev1-310x480.png)
![](http://s.4pda.ru/wp-content/uploads/2012/12/dev4-312x480.png)
![](http://s.4pda.ru/wp-content/uploads/2012/12/dev3-312x480.png)




**Стоимость:** Бесплатно





**Ссылка на Google Play:** ![QR](http://s.4pda.ru/forum/style_images/1/qr_code.gif)[https://play.google.com/store/apps/details?id=com.glosculptor.glowpuzzle.xmas2](https://play.google.com/store/apps/details?id=com.glosculptor.glowpuzzle.xmas2)





Источник [4pda.ru](http://4pda.ru/2012/12/09/81604/#more-81604)
Ох, как же я люблю играть в гонки.





Представляю вашему вниманию новую игру Drag Racing 3D. Соревнуйтесь в драг-гонках по ночному городу с другими гонщиками, зарабатывайте деньги, улучшайте купленные автомобили и покупайте более мощные. В гараже доступны различные улучшения для автомобилей, в числе которых новый двигатель, турбонаддув, улучшенная трансмиссия, система прямого впрыска закиси азота (NOS), улучшенные шины и уменьшение веса автомобиля. В игре представлен большой выбор различных автомобилей.





![](http://s.4pda.ru/wp-content/uploads/2012/12/1024-480x234.png)


 <!-- more -->


**Версия: **1.1





**Русский интерфейс: **Да





**Технические требования: **Android 2.0.1+





**Категория:** гонки









Основные особенности игры:








  * Динамичные гонки на 1/4 и 1/2 мили



  * Более 20 настоящих автомобилей: от городского Volvo S40 до спортивного Aston Martin V8 Vantage.



  * Большое количество комбинаций усовершенствований автомобилей



  * Возможность покраски автомобиля и колёсных дисков любым цветом



  * Подробнейшая статистика каждой отдельной гонки и игрового прогресса в целом



  * Режим карьеры позволяет пройти весь путь настоящего гонщика - от новичка до профессионала



  * Режим быстрой гонки помогает подобрать уникального соперника для каждого заезда



  * Система сохранения рекордов позволяет достигать более высоких результатов в каждом заезде



  * Игра полностью переведена на английский и русский языки



  * Размер установочного файла составляет 22,7 мегабайта










**Стоимость:** 2$





**Ссылка на Google Play:** ![QR](http://s.4pda.ru/forum/style_images/1/qr_code.gif)[http://play.google.com/store/apps/details?id=com.mvasiliy.dragracing3d](http://play.google.com/store/apps/details?id=com.mvasiliy.dragracing3d)





![](http://s.4pda.ru/wp-content/uploads/2012/12/screen93-480x288.png)
![](http://s.4pda.ru/wp-content/uploads/2012/12/screen59-480x288.png)





![](http://s.4pda.ru/wp-content/uploads/2012/12/screen50-480x288.png)
![](http://s.4pda.ru/wp-content/uploads/2012/12/screen321-480x288.png)





![](http://s.4pda.ru/wp-content/uploads/2012/12/screen111-480x288.png)
![](http://s.4pda.ru/wp-content/uploads/2012/12/screen23-480x288.png)




Источник [4pda.ru](http://4pda.ru/2012/12/10/81955/)
Прекрасная новость.





Официальный магазин приложений разработчика Android, Google Play, теперь не только магазин приложений. Да, случилось то, чего все долго ждали - Google последовала примеру Apple (которая начала продажи контента в iTunes в начале декабря), и теперь, помимо программ и игр, пользователям из России предлагаются и фильмы с книгами.





![](http://s.4pda.ru/wp-content/uploads/2012/12/google-play-480x358.png)


<!-- more -->






Изменения сразу бросаются в глаза, как при входе в нативный клиент магазина на Android OS, так и на его официальный сайт. Внимание пользователей привлекаются баннеры с предложениями купить самые популярные книги и фильмы. Конечно же, тем, кто захочет покупать новый контент в Google придётся установить два дополнительных приложение - Google Play Фильмы и Google Play Книги. И, если раньше они едва ли могли быть полезными для российских пользователей, с сегодняшнего дня мы, наконец-то, можем использовать их в полном объёме.





![](http://s.4pda.ru/wp-content/uploads/2012/12/screenshot_2012-12-11-14-29-57-270x480.png)
![](http://s.4pda.ru/wp-content/uploads/2012/12/screenshot_2012-12-11-14-27-08-270x480.png) 
![](http://s.4pda.ru/wp-content/uploads/2012/12/screenshot_2012-12-11-14-35-00-270x480.png)



Конечно, цену на контент никак нельзя назвать низкой. Так, самое недорогой вариант просмотра фильма - прокат, обойдётся вам от 49 до 69 рублей, причём, только для стандартного качества. За HD придётся доплатить ещё 20-30 рублей. Сама концепция проката в Google Play означает то, что фильм будет доступен для просмотра только в течение 30 дней после оплаты или в течение 2 суток после того, как вы хотя бы раз открыли файл. После истечения этого срока фильм будет удалён из вашего аккаунта.





![](http://s.4pda.ru/wp-content/uploads/2012/12/play-film-480x443.png)




Если вы желаете купить фильм навсегда, то его цена, особенно в хорошем качестве, будет равняться недорогому билету в кинотеатр. Максимальная стоимость популярных фильмов сейчас составляет 349 рублей.





![](http://s.4pda.ru/wp-content/uploads/2012/12/play-film-2-480x444.png)





Но, если цены на фильмы примерно соответствуют друг другу, то в случае с книгами мы видим огромный разброс цен: от 50 до 350 рублей. Однако, немало и книг бесплатных, прежде всего, русской и зарубежной классики. Купленную литературу можно читать трёмя способами: с Android- и iOS-устройств с помощью официальных приложений, с помощью любых устройств с возможностью выхода в интернет - через веб-интерфейс Google Play, а также после загрузки на поддерживаемые электронные книги (в основном от Sony и Barnes & Noble).





![](http://s.4pda.ru/wp-content/uploads/2012/12/books-480x351.png)



![](http://s.4pda.ru/wp-content/uploads/2012/12/play-books-2-480x313.png)




Сейчас нельзя точно сказать, будут ли эти сервисы пользоваться популярностью среди российских пользователей, особенно при распространении пиратского контента в нашей стране. Но, вне всякого сомнения, найдутся и те, кто захочет покупать лицензионные фильмы и книги, чтобы поддержать их авторов.





Ну, а кроме того, теперь нам остаётся ждать, когда же Google запустит в нашей стране и музыкальный магазин, чтобы мы могли пользоваться услугами компании как любая другая европейская страна.





Источник [4pda.ru](http://4pda.ru/2012/12/11/82113/)
Игровые новинки на нашем блоге.





Сразитесь с вражескими космическими кораблями. Станьте лучшим, примите участие в битве за галактику!





![](http://s.4pda.ru/wp-content/uploads/2012/12/cover2-480x234.jpg)

<!-- more -->


**Версия: **1.0





**Русский интерфейс: **Нет





**Технические требования: **2.1+





**Категория:** Аркады, головоломка









В Brick Battles вы управляете космическим кораблем, который отбрасывает метеорит, чтобы разбить защитную оболочку противника. Но будьте осторожны, метеорит может добраться и до вас! Будьте быстры, умны и станьте лучшим!





Особенности:








  * 9 уникальных планет и 9 врагов.



  * откройте для себя суперспособности: энергетические щиты, лазеры, изменяйте размеры своего корабля и метеорита.



  * откройте режим выживания, после прохождения турнирного режима.



  * наберите больше очков и станьте победителем.






**Стоимость:** 1$





**Ссылка на Google Play:** ![QR](http://s.4pda.ru/forum/style_images/1/qr_code.gif)[https://play.google.com/store/apps/details?id=com.gameshock.brickbattles](https://play.google.com/store/apps/details?id=com.gameshock.brickbattles)









![](http://s.4pda.ru/wp-content/uploads/2012/12/unnamed11-480x287.jpg)
![](http://s.4pda.ru/wp-content/uploads/2012/12/unnamed21-480x287.jpg)




![](http://s.4pda.ru/wp-content/uploads/2012/12/unnamed3-480x287.jpg)



Статья из сайта [4pda.ru](http://4pda.ru/2012/12/11/82116/)
Теперь Google запускает игры.





Компания Google ко множеству своих сервисов добавила еще и игру, получившую название Ingress. Ее разработкой занималось подразделение Google Niantic Labs.





Игра Ingress является представителем жанра MMMMOARG (massively multiplayer map-based mobile online augmented reality game - многопользовательская мобильная онлайн игра дополненной реальности на основе карт). Эта игра позиционируется в качестве глобального проекта, при этом она бесплатна. В игре Ingress рассказывается о том, что группой ученых была обнаружена таинственная энергия, которая, предположительно, оказывает влияние на то, как люди думают. За контроль над этой энергией вступили две группировки: Enlightened (Просвещенные) и Resistance (Сопротивление). Первая группировка намерена при помощи таинственной энергии получить власть, в то время как вторая группа отстаивает человеческие ценности. Игроку предлагается присоединиться к одной из групп и играть при помощи мобильного устройства.





![](http://itc.ua/wp-content/uploads/2012/11/unnamed2.jpg)

<!-- more -->



Ingress предназначена для запуска на смартфонах (планшеты не поддерживаются) на базе ОС Android. В процессе перемещения по реальному миру игроку предстоит находить источники таинственной энергии. Игровой процесс подразумевает возможность объединения с другими игроками, приобретение объектов, изучение технологий, захват территорий. Так как игра носит глобальный характер, то игрок может отслеживать события по всему миру и планировать свои действия с учетом этих данных.









В настоящее время игра Ingress находится в статусе закрытой бета-версии. Для доступа к ней необходимо отправить заявку с указанием своего адреса электронной почты с сайта [ingress.com ](http://www.ingress.com/), дождаться кода с приглашением и установить соответствующее приложение из магазина [Play Store ](https://play.google.com/store/apps/details?id=com.nianticproject.ingress).





Статья из сайта[ itc.ua](http://itc.ua/news/google-zapustila-globalnuyu-mobilnuyu-onlayn-igru-ingress/)
Еще одна полезная статья для владык android устройств.





Многие пользователи Android знают, что с помощью приложения Titanium Backup можно вытащить приложение из устройства в виде apk файла. Сегодня мы рассмотрим способ, с помощью которого можно вытащить apk файл приложения прямо из Google Play Store.





![](http://lifehacker.ru/wp-content/uploads/2012/05/04.png)




Плюсом данного способа является отсутствие необходимости предварительной установки приложения на устройство. К сожалению, работает этот способ только для бесплатных приложений. Итак, что нам понадобится:


 <!-- more -->


## 1. Google Chrome





Создаём на рабочем столе второй ярлык для Google Chrome.





![](http://lifehacker.ru/wp-content/uploads/2012/05/a.png)



Делаем по ярлыку правый клик, выбираем «Свойства». В поле «Объект» дописываем через пробел следующие команды:






	--ignore-certificate-errors
	--allow-running-insecure-content


Получится примерно так:

	...\chrome.exe" --ignore-certificate-errors --allow-running-insecure-content









Нажимаем «Применить» и «ОК».





![](http://lifehacker.ru/wp-content/uploads/2012/05/b.png)



После данной операции нужно перезапустить браузер, закрыв при этом все запущенные экземпляры приложения.





## 2. Имя аккаунта Google и ID устройства





По факту мы собираемся имитировать загрузку приложения на устройство, поэтому необходимо знать имя своего аккаунта, то есть имя вашего почтового ящика Google, а также идентификационный номер вашего Android устройства.





С ящиком всё понятно, а чтобы узнать ID устройства, откройте звонилку на своём смартфоне и наберите *#*#8255#*#*





На появившемся экране необходимо найти строчку «Device ID:»





Идентификационным номером является комбинация букв и цифр, следующая после «android-». К примеру, если в строке вы видите «Device ID: android-1122aa33bb445577», то идентификатором является комбинация «1122aa33bb445577». Запишите эту комбинацию.





Если по каким-то причинам у вас не получилось узнать ваш Device ID указанным выше способом, вы можете просто скачать приложение [Device ID](https://play.google.com/store/apps/details?id=com.redphx.deviceid) в Google Play Store.





## 3. APK Downloader





Скачиваем расширение для браузера под названием APK Downloader ([прямая ссылка на загрузку расширения](http://codekiem.com/apk-downloader/crx/1.2.1.crx)).





В появившемся окне вводим адрес нашего Google аккаунта, то есть адрес почты. Пароль (ага, страшно), а также Device ID. После этого нажимаем «Login».





![](http://lifehacker.ru/wp-content/uploads/2012/05/c.png)



В следующем окне выбираем свою страну и оператора сотовой связи, после чего нажимаем «Save Settings». Далее должно появиться окно с сообщением о успешной активации расширения.





![](http://lifehacker.ru/wp-content/uploads/2012/05/d.png)



## 4. Google Play Store





Теперь заходим на наш любимый [Google Play Store](https://play.google.com/) и выбираем любое бесплатное приложение. В правой части адресной строки браузера появится характерного вида зелёная голова со стрелочкой.





![](http://lifehacker.ru/wp-content/uploads/2012/05/e.png)



Нажимаем на эту иконку, и приложение успешно загружается на компьютер в виде apk файла. По сути, теперь мы умеем создавать standalone дистрибутивы бесплатных приложений.





![](http://lifehacker.ru/wp-content/uploads/2012/05/f.png)



**Убедиться в абсолютной порядочности разработчика расширения APK Downloader не представляется возможным, поэтому вводите данные своего аккаунта на собственный страх и риск. Кроме того, подобные действия в принципе нарушают правила использования Google Play Store.**





Статья из сайта [lifehacker.ru](http://lifehacker.ru/2012/05/30/kak-vytashhit-apk-fajjl-iz-google-play-store/)
Всем привет.





Очень полезная статья, для тех кто активно использует маркет. И хочет что бы все программы устанавливались на телефон.





Зачастую разработчики помечают те или иные приложения в Google Play Store как несовместимые с некоторыми устройствами по причине нестабильной работы приложения на данной модели. Тем не менее, всегда есть шанс того, что на вашем устройстве приложение всё же заработает.





  <!-- more -->



Для владельцев рутованных Android есть простой способ обмануть Play Store, представив своё устройство в качестве другой модели, которая числится для конкретного приложения в списке поддерживаемых. Этот способ избавляет от возни с предварительным выкачиванием apk файла из самого маркета.





Итак, у нас есть рутованный Android. Скачиваем из Play Store любой файловый менеджер, который позволяет получить доступ к системным файлам, а также позволит редактировать их. Мы воспользовались приложением [ES File Explorer](https://play.google.com/store/apps/details?id=com.estrongs.android.pop). После установки приложения заходим в его настройки. Необходимо включить возможность доступа к рут-директории, а также установить возможность записи в файлы, находящиеся в этой директории.





![Как установить несовместимое приложение на Android](http://lifehacker.ru/wp-content/uploads/2012/06/screenshot-1340023180361.png)
![Как установить несовместимое приложение на Android](http://lifehacker.ru/wp-content/uploads/2012/06/screenshot-1340023094634.png)




Теперь идём в папку «system» и находим там файл «build.prop». Перед любыми манипуляциями такого рода лучше конечно забекапиться, а в данном случае хотя бы сделать копию «build.prop» файла куда-нибудь на карту памяти.





![Как установить несовместимое приложение на Android](http://lifehacker.ru/wp-content/uploads/2012/06/screenshot-1340023213651.png)



Открываем файл «build.prop» с помощью встроенного редактора ES проводника как текстовый файл.





![Как установить несовместимое приложение на Android](http://lifehacker.ru/wp-content/uploads/2012/06/screenshot-1340023259603.png)
![Как установить несовместимое приложение на Android](http://lifehacker.ru/wp-content/uploads/2012/06/screenshot-1340023243358.png)




Google Play идентифицирует устройство по данным, записанным в строчках «ro.product.model» и «ro.product.manufacturer». Остаётся лишь изменить значения этих параметров. В данном случае мы подменяем старенький Wildfire на Incredible. После этого нажимаем кнопку «Menu» и сохраняем внесённые изменения.





![Как установить несовместимое приложение на Android](http://lifehacker.ru/wp-content/uploads/2012/06/screenshot-1340023338036.png)
![Как установить несовместимое приложение на Android](http://lifehacker.ru/wp-content/uploads/2012/06/screenshot-1340023633575.png)


Осталось подчистить данные в самом приложении Google Play Store. Для этого заходим в менеджер приложений, находим там Play Store и чистим кэш и данные. После этого необходимо перезагрузить устройство.





![Как установить несовместимое приложение на Android](http://lifehacker.ru/wp-content/uploads/2012/06/screenshot-1340023695040.png)
![Как установить несовместимое приложение на Android](http://lifehacker.ru/wp-content/uploads/2012/06/screenshot-1340023711828.png)




Данный способ не позволит обойти ситуации, когда приложение несовместимо из-за разницы версий операционной системы, либо из-за страны проживания.





Статья из сайта [lifehacker.ru](http://lifehacker.ru/2012/06/19/kak-ustanovit-nesovmestimoe-prilozhenie-na-android/)
Продолжаю собирать игры.





Сам играл и очень советую.





Разминаем мозг, 17 уникальных головоломок.





Игры разума – это новая игра для отдыха и, в то же время, для работы - работы ума. Игра для тех, кто любит решать загадки, задачки, ребусы и головоломки. Для тех, кто в перерывах между работой норовит поупражняться в логике и математике.


<!-- more -->


Игра представляет собой набор лучших головоломок, разной степени сложности  
На данный момент 17 различных типов головоломок и 180 уровней.   
Продуманная последовательность уровней  
Хорошая графика  
Интригующее звуковое сопровождение  
Игра однозначно заинтересует как детей и подростков, так и пользователей более старшего возраста





Как я уже отметил, игра представляет собой набор интереснейших головоломок. Некоторые из них известны каждому из нас с детства – это варианты игры реверси, шахматные задачи, пятнашки. А некоторые являются усовершенствованной комбинацией двух игр, как, например, в случае с морским боем или судоку.





Каждая головоломка имеет несколько уровней. Некоторые уровни отличаются друг от друга лишь степенью сложности. А некоторые – поставленной перед игроком задачей.









![](http://android-helper.com.ua/images/uploads/2012/10/11.jpg)



![](http://android-helper.com.ua/images/uploads/2012/10/2.jpg)





![](http://android-helper.com.ua/images/uploads/2012/10/3.jpg)




![](http://android-helper.com.ua/images/uploads/2012/10/4.jpg)





![](http://android-helper.com.ua/images/uploads/2012/10/5.jpg)




Скачать можно из [PlayMarket](https://play.google.com/store/apps/details?id=com.oxothuk.worldpuzzle)
Продолжаем собирать интересные статьи.





Вы уверены, что сможете дожить до утра в Хеллоуин? Опробуйте свои силы, убивайте монстров и проходите уровни, или же просто убивайте время в дороге.





![Разработчик: Хеллоунские приключения - игра, которая обязана убить ваше рабочее время](http://s.4pda.ru/wp-content/uploads/2012/10/recoment-480x234.png)



<!-- more -->

**Версия: **1.0





**Русский интерфейс: **Нет





**Технические требования: **2.1+





**Поддержка установки на SD:** Нет





**Категория:** Аркады и экшн









Все очень просто. Ваша задача не пропустить злых духов Хеллоуина по ту сторону андроид-девайса. У многих злых духов будут свои особенности, так, например, зеркала  умеют  блокировать урон.





Игра безумно проста, красочна и увлекательна.





**Стоимость:** Бесплатно





**Обсуждение на 4pda:** [http://4pda.ru/forum/index.php?showtopic=390477](http://4pda.ru/forum/index.php?showtopic=390477)





**Ссылка на Google Play:** [http://play.google.com/store/apps/details?id=com.bibizikaman.halloweengame](http://play.google.com/store/apps/details?id=com.bibizikaman.halloweengame)





![](http://s.4pda.ru/wp-content/uploads/2012/10/main2-300x480.png)
![](http://s.4pda.ru/wp-content/uploads/2012/10/46-300x480.png)



![](http://s.4pda.ru/wp-content/uploads/2012/10/27-300x480.png)
![](http://s.4pda.ru/wp-content/uploads/2012/10/37-300x480.png)




![](http://s.4pda.ru/wp-content/uploads/2012/10/114-300x480.png)




Статья из сайта [4pda.ru](http://4pda.ru/2012/10/22/75659/)
Продолжаем собирать интересные статьи.





В честь праздника Хэллоуин (хотя мы его не сильно празднуем, но все же) Gameloft выпустила забавную зомби игру Zombiewood. Зомби захватили Голливуд! Еще вчера на этих роскошных улицах были кинозвезды и прочие знаменитости, а сегодня здесь орудуют орды вернувшихся с того света. Наверное, у кого-то это вызовет ужас, страх, панику... Но некоторые считают это прекрасной возможностью снять потрясающий ужастик!





![](http://s.4pda.ru/wp-content/uploads/2012/10/zombiewood_pack_en-small-480x318.png)

<!-- more -->

**Русский интерфейс:** Да





**Технические требования:** iOS; Android





**Категория:** Комичный зомби-шутер





**Особенности:**








  * Сыграйте в веселящем шутере с двойным стиком



  * Разрывайте на куски орды обезумевших зомби



  * Застрелите, обварите и поджарьте - 20 видов самого невероятного оружия



  * Мультяшный стиль, навеянный Голливудом



  * 11 фильмов и 10 уникальных игровых режимов



  * Переодевайтесь в забавные нелепые прикиды



  * Возглавьте турнирные таблицы



  * Постоянные обновления контента выйдут с новыми фильмами, оружием, прикидами и неудержимым экшеном!






Но и это еще не все – эта игра просто кишит зомбаками! И она бесплатная!





**Стоимость:** Бесплатно





**Ссылка на Apple Store:** [https://itunes.apple.com/ru/app/zombiewood/id467452023?mt=8](https://itunes.apple.com/ru/app/zombiewood/id467452023?mt=8)





**Ссылка на Google Play: **[https://play.google.com/store/apps/details?id=com.gameloft.android.ANMP.GloftZOHM](https://play.google.com/store/apps/details?id=com.gameloft.android.ANMP.GloftZOHM)









![](http://s.4pda.ru/wp-content/uploads/2012/10/zombiewoodhd_screen_960x640_ru_01-480x320.jpg)
![](http://s.4pda.ru/wp-content/uploads/2012/10/zombiewoodhd_screen_960x640_ru_02-480x320.jpg)




![](http://s.4pda.ru/wp-content/uploads/2012/10/zombiewoodhd_screen_960x640_ru_03-480x320.jpg)
![](http://s.4pda.ru/wp-content/uploads/2012/10/zombiewoodhd_screen_960x640_ru_04-480x320.jpg)




![](http://s.4pda.ru/wp-content/uploads/2012/10/zombiewoodhd_screen_960x640_ru_05-480x320.jpg)




Статья из сайта [4pda.ru](http://4pda.ru/2012/10/26/76325/)
Эх химия, химия.





Для школьников и студентов химического факультета.





Periodic Table – это удобная периодическая система химических элементов. В ней вы можете найти информацию о всех известных науке 118 химических элементах. На основном экране вам представлена таблица элементов в привычном для всех виде. Каждый элемент обозначен цветом, который определяет к какой категории относится элемент. При нажатии на элемент вы видите самую часто используемую информацию об элементе.





![](http://s.4pda.ru/wp-content/uploads/2012/10/pt1-480x270.png)

 <!-- more -->


**Версия: **1.5.3





**Русский интерфейс: **Да





**Технические требования: **Android 3.0 и выше





**Поддержка установки на SD:** Да





******Категория:** Образование









Помимо базовой информации об элементе вы можете посмотреть более подробную информацию о его свойствах (физических, химических и т.п.), а также диаграмму электронной оболочки.





![](http://s.4pda.ru/wp-content/uploads/2012/10/pt2-480x270.png)




Программа поддерживает как смартфоны, так и планшеты. Мы протестировали приложение на следующих устройствах:








  1. Смартфоны с разрешением 800x480, 854x480, 1280x720, 1280x800



  2. Планшеты с разрешением: 1280x720, 1280x800






Программа поддерживает русский и английский языки.





Программа постоянно развивается, в ближайшую версию мы планируем добавить поддержку еще большого числа устройств и добавить поиск по элементам. Также в планах добавление изображений для каждого элемента и базовой текстовой информации о каждом элементе.





**Стоимость:** Бесплатно





**Обсуждение на 4pda:** [http://4pda.ru/forum/index.php?showtopic=371331](http://4pda.ru/forum/index.php?showtopic=371331)





**Ссылка на Google Play:** [https://play.google.com/store/apps/details?id=jqsoft.apps.periodictable.hd](https://play.google.com/store/apps/details?id=jqsoft.apps.periodictable.hd)





Статья из сайта [4pda.ru](http://4pda.ru/2012/10/17/74929/)
Пару игр, что бы расслабиться.





Хотите попробовать себя в роли водителя бигфута ? Нет ничего проще! Скачайте игру и наслаждайтесь забавным геймплеем. В игре доступно 5 грузовиков и 52 уровня на четырех ландшафтах: В Лесу, в пустыне, в геометрической абстракции, вгороде. Для лучшего баланса работает акселерометр. По ходу игры надо собирать новые грузовики из запчастей разбросанных по разным уровням. Машина очень устойчива, ее трудно перевернуть. У разных грузовиков - разные параметры. Скорость, вес, количество колес, внешний вид.





![](http://s.4pda.ru/wp-content/uploads/2012/10/intro_new1-480x234.png)


 <!-- more -->


**Версия: **1.0





**Русский интерфейс: **Нет





**Технические требования: **Android 1.6 и выше





**Поддержка установки на SD:** Да





**Категория:** игры









Быть водителем грузовика - не такая простая задача. В этой игре под бодрую музыку Вам предстоит добраться до финиша, преодолевая множество препятствий: это и извержения вулканов, и глубокие овраги, и всевозможные балки и многое-многое другое. Иногда придётся и поломать голову - не всё так просто как кажется на первый взгляд! Ваши союзники: оригинальное мышление, законы физики и, разумеется, Ваш опыт и мастерство!





Всего в игре представлены 4 ландшафта: лес, пустыня, город и геометрическая абстракция. Каждый ландшафт состоит из 13 уровней. В игре Вам доступны и разные виды грузовичков, новый грузовик нужно собрать из запчастей, которые можно найти во время прохождения уровней. Грузовичок состоит из рамы, кабины, кузова и колёс. Собирая бонусы, в дальнейшем, Вы также сможете купить недостающие запчасти.





Управление в игре комбинированное. Есть кнопки вперёд-назад, частично действует акселерометр. Кроме того, грузовичок может прыгать :) Иногда нужно и ускориться - для этого используйте кнопку-молнию. Если нужно начать заного - нажмите кнопку обновления (круговая стрелка). Кнопка с машиной - это гараж. Вы можете выбрать новый грузовик прямо во время прохождения уровня. И не забывайте следить за временем!





Платная версия представлена 4 ландшафтами по 13 уровней в каждом (всего 54 уровня), 4 грузовиками. Бесплатная версия порадует Вас всего 2 грузовиками, 4 ландшафтами по 3 уровня в каждом (всего 12 уровней)





Приятной игры!





**Стоимость:** 1$





**Обсуждение на 4pda:** [http://4pda.ru/forum/index.php?showtopic=382170&st=0](http://4pda.ru/forum/index.php?showtopic=382170&st=0)





**Ссылка на Google Play:** [https://play.google.com/store/apps/details?id=ru.elanser.crazycarfull](https://play.google.com/store/apps/details?id=ru.elanser.crazycarfull)





![](http://s.4pda.ru/wp-content/uploads/2012/10/1_2-480x288.png)
![](http://s.4pda.ru/wp-content/uploads/2012/10/1_3-480x288.png)




![](http://s.4pda.ru/wp-content/uploads/2012/10/c-480x288.png)
![](http://s.4pda.ru/wp-content/uploads/2012/10/c1-480x288.png)




![](http://s.4pda.ru/wp-content/uploads/2012/10/d2-480x288.png)
![](http://s.4pda.ru/wp-content/uploads/2012/10/desert-480x288.png)





![](http://s.4pda.ru/wp-content/uploads/2012/10/g1-480x288.png)




Статья из сайта [4pda.ru](http://4pda.ru/2012/10/16/74835/)





Сам люблю такой жанр.
Продолжаю собирать список из хороших программ.





Renju — спортивная настольная логическая игра. Играют два соперника: один крестиками, его соперник — ноликами. Игра проходит на расчерченной в клетку доске. Игроки делают ходы по очереди. Побеждает тот, кто сможет первым построить непрерывный ряд из пяти своих фишек — по горизонтали, по вертикали или в диагональном направлении.





![](http://s.4pda.ru/wp-content/uploads/2012/10/title2-480x234.png)



 <!-- more -->


**Версия: **1.30





**Русский интерфейс: **Нет





**Технические требования: **Android 2.1+





**Поддержка установки на SD:** Да





**Категория:** головоломки









![](http://s.4pda.ru/wp-content/uploads/2012/10/device-2012-09-25-2148121-288x480.png)
![](http://s.4pda.ru/wp-content/uploads/2012/10/device-2012-10-12-2044241-288x480.png)





**Стоимость:** Бесплатно





**Обсуждение на 4pda:** [http://4pda.ru/forum/index.php?showtopic=381781](http://4pda.ru/forum/index.php?showtopic=381781)





**Ссылка на Google Play:** [http://play.google.com/store/apps/details?id=com.protoss5482.Renju](http://play.google.com/store/apps/details?id=com.protoss5482.Renju)





Статья из сайта [4pda.ru](http://4pda.ru/2012/10/13/74541/)
Продолжаю серию игр для android.





Российский издатель и разработчик игр для массовой аудитории Nevosoft объявляет о выходе игры LandGrabbers для платформы Android. Жанр игры уникален: его можно определить как стратегический симулятор крестовых походов.





![](http://s.4pda.ru/wp-content/uploads/2012/08/icon5121-480x480.png)


 <!-- more -->


**Версия:** 1.0





**Русский интерфейс: **да





**Технические требования:** Android 2.3 и выше. Игра доступна только для телефонов





**Установка на SD поддерживается:** да





**Категория:** Казуальные игры/ стратегия/ симулятор / менеджмент ресурсов









В отличие от традиционных военных стратегий, в LandGrabbers нет элементов насилия, а задорный геймплей и веселый саундтрек надолго вовлекают в увлекательную средневековую битву. Цель при этом остается неизменной: захватить мир, одержав победу над вражескими войсками.





![](http://s.4pda.ru/wp-content/uploads/2012/08/screen-18-480x288.png)



Игрокам необходимо уничтожить вооружённые силы противника, завоевав крепости и окрестные земли. C каждым уровнем испытания усложняется, и пройти их можно, лишь овладев искусством войны. Игровой процесс требует сосредоточенности, решительных наступлений, смелых маневров и умения правильно применять военную тактику.





PC-версия LandGrabbers (“Эвокрафт”) стала лауреатом премии КРИ Awards 2011 в номинации “Лучшая casual-игра”.





![](http://s.4pda.ru/wp-content/uploads/2012/08/screen-26-480x288.png)


**Ключевые особенности:**








  * 27 уровней в 3 различных сеттингах;



  * до трех вражеских армий одновременно;



  * 5 типов построек с уникальными особенностями;



  * 3 уровня сложности, которые могут бросить вызов даже опытным стратегам;



  * великолепная графика и саундтреки создают атмосферу Средневековья;



  * еще больше локаций с обновлениями.






**Ссылка на Google Play:** [https://play.google.com/store/apps/details?id=com.nevosoft.landgrabbers](https://play.google.com/store/apps/details?id=com.nevosoft.landgrabbers&referrer=utm_source%3DReview%26utm_medium%3DReview%26utm_campaign%3DReview)





**Страница игры: **[http://android.nevosoft.com/games/landgrabbers](http://android.nevosoft.com/games/landgrabbers)









Статья взята из сайта [4pda.ru](http://4pda.ru/2012/09/01/70409/)
Продолжаю серию игр для android.





Broken Wire - головоломка в стиле Plumber. В этой простой игре вам нужно соединить два вывода батарейки с помощью отрезков провода.  Но поторопитесь, ведь батарейка разряжается, и когда она полностью разрядится, ток не потечет!





![](http://s.4pda.ru/wp-content/uploads/2012/09/feature_graphics-480x234.png)

<!-- more -->

**Версия:** 1.0





**Русский интерфейс:** нет





**Технические требования:** Android 2.2+





**Необходимы права root:** нет





**Установка на SD поддерживается:** нет





**Категория:** игры, головоломки





Задача игры - собрать путь для тока между выводами батарейки из разбросанных по игровому полю отрезков провода. Для этого всего лишь нужно вращать отрезки с помощью нажатия на них. В каждом уровне можно собрать до трех звездочек в зависимости от того, насколько батарейка успела разрядиться прежде, чем вы собрали пазл.





В игре 900 уровней.





Broken Wire отлично подойдет, чтобы заполнить свободную минутку.









 





![](http://s.4pda.ru/wp-content/uploads/2012/09/screen4_800-288x480.png) 
![](http://s.4pda.ru/wp-content/uploads/2012/09/screen1_800-288x480.png)





**Стоимость программы:** бесплатная с рекламой





**Ссылка на Google Play:** [market://detais?id=tedgifun.brokenwire.game](market://detais?id=tedgifun.brokenwire.game)





**Ссылка на Google Play web:** [https://play.google.com/store/apps/details?id=tedgifun.brokenwire.game](https://play.google.com/store/apps/details?id=tedgifun.brokenwire.game)









Статья взята из сайта [4pda.ru](http://4pda.ru/2012/09/06/70894/)
Продолжаю серию игр для android.





"Быки и Коровы" - классическая игра для тренировки логического мышления, памяти и интуиции. Компьютер загадывает число из четырех цифр, и пользователю дается несколько попыток, чтобы его отгадать. На каждую попытку игрок получает две подсказки от компьютера: сколько цифр угадано в числе, и сколько угадано на правильном месте.





![](http://s.4pda.ru/wp-content/uploads/2012/09/ico512-480x480.png)


 <!-- more -->

**Версия:** 1.0





**Русский интерфейс:** Да.





**Технические требования:** OS Android API 8-16+





**Особенности:** поддержка любых разрешений, ввод цифр с игровой или с софт-клавиатуры, несколько уровней сложности (в платной версии программы)





**Установка на SD:** поддерживается





**Категория:** головоломки





****Игра для проверки и тренировки своих математических способностей и интуиции. После каждой попытки пользователь получает от компьютера косвенные подсказки. Пример: Пусть загаданное число - 1234. Если пользователь введет попытку 3658, то получит такой ответ: (1,0) - одна цифра угадана, и ни одной не угадано на правильно месте. Далее пользователь вводит: 0394, ответ: (2,1) - две цифры угадано и одна из них на своем месте.  
Последовательно комбинируя числа в попытках можно довольно быстро отгадать все число.





![](http://s.4pda.ru/wp-content/uploads/2012/09/device-2012-09-06-222210-288x480.png)
![](http://s.4pda.ru/wp-content/uploads/2012/09/device-2012-09-06-222250-288x480.png)



**Стоимость программы:** доступны платная ($1.25) и бесплатная (с рекламой и ограниченным функционалом)





**Обсуждение на 4PDA: ****[http://4pda.ru/forum/index.php?showtopic=376233](http://4pda.ru/forum/index.php?showtopic=376233)**





**Ссылка на Google Play:**








  * платная версия - [https://play.google.com/store/apps/details?id=com.sevvetapps.guess](https://play.google.com/store/apps/details?id=com.sevvetapps.guess)



  * бесплатная версия - [https://play.google.com/store/apps/details?id=com.sevvetapps.guessf](https://play.google.com/store/apps/details?id=com.sevvetapps.guessf)






Статья взята из сайта [4pda.ru](http://4pda.ru/2012/09/10/71115/)
Продолжаю серию игр для android.





В TegraZone очередное пополнение – аркадная гонка Beach Buggy Blitz (free to play). В новой игре от студии Vector Unit (создатели Riptide GP и Shine Runner) вам предстоит управлять маленькими машинками багги, которые разъезжают по пляжам, пещерам, болотам, храмам и вулканам. Основная задача гонки -  собрать как можно больше золотых монет за отведенное время.





![](http://s.4pda.ru/wp-content/uploads/2012/09/unnamed-480x234.jpg)

 <!-- more -->

В настоящий момент игра доступна только для устройств на базе процессоров Tegra. Версия игры для четырехъядерного процессора Tegra 3 имеет ряд дополнительных визуальных эффектов: брызги на экране, размытие пейзажа при ускорении, динамический свет фар в пещерах, динамические тени машин. Также на устройствах на Tegra 3 доступна улучшенная физика персонажей и объектов.





Дополнительная информация об игре доступна на сайте [TegraZone](http://www.tegrazone.com/). Загрузить игру можно здесь -  [Google Play Store](https://play.google.com/store/apps/details?id=com.vectorunit.yellow).





Сравнительные скриншоты (Tegra 3 versus не Tegra):





**- динамическое освещение**





![](http://s.4pda.ru/wp-content/uploads/2012/09/image001-480x270.jpg)



- **Motion Blur**





![](http://s.4pda.ru/wp-content/uploads/2012/09/image0021-480x270.jpg)





**- брызги на экране**





![](http://s.4pda.ru/wp-content/uploads/2012/09/image003-480x270.jpg)



Статья взята из сайта [4pda.ru](http://4pda.ru/2012/09/12/71378/)
Продолжаю серию игр для android.





Total Defense 3D - новая игра для пользователей Android от наших соотечественников DaSuppa и i-Free Innovations. В игре предлагается возглавить революцию и свергнуть Императора-тирана. Геймплей уникален тем, что включает не только привычный tower defense, но и элементы жанров RPG и стратегии.





Так, в игре присутствуют множество оригинальных находок: вы сможете не только возводить-улучшать башенки, но и добывать ресурсы, развивать технологии, а так же изменять ландшафт поля боя. Игра предлагает окунуться в далекий 2871 год, и у нее это действительно получается, благодаря проработанному сюжету и футуристичному саундтреку, вдохновленными классической серией Command&Conquer.





![](http://s.4pda.ru/wp-content/uploads/2012/09/54.jpg)

<!-- more -->

**Версия:** 1.0





**Русский интерфейс:** да





**Технические требования:** Android OS 2.3+, разрешение 320x480 и выше





**Категория**:





Total Defensed 3D написана на Unity, что обеспечивает детализированную графику и яркие спецэффекты в настоящем 3D. Более того, эпический сюжет в стиле космических саг XX удачно подчеркивает ее особенности и выделяет игру на фоне других игр жанра.





В распоряжении игрока находится база, которую нужно защищать, и 12 видов башен для осуществления этого. После прохождения миссий игрок получает медали, которые может потратить на исследование новых технологий. Вы вольны сами выбирать свою тактику ведения боя.





![](http://s.4pda.ru/wp-content/uploads/2012/09/1_green.jpg)
![](http://s.4pda.ru/wp-content/uploads/2012/09/2_black.jpg)





По полю боя раскиданы многочисленные интерактивные элементы – как ресурсы, так и стратегические объекты. Если добыча первых позволит пополнять запасы базы, и тем самым повышать боевую силу – то вторые открывают целое поля для маневров. Например, можно разрушить мост или завалить проход останками монумента, в результате чего вражеским отрядам придется искать пути обхода, а значит попасть под шквальный обстрел ваших орудий.





![](http://s.4pda.ru/wp-content/uploads/2012/09/3_brown.jpg)
![](http://s.4pda.ru/wp-content/uploads/2012/09/4_red.jpg)




Ну и напоследок – в игре присутствуют три режима сложности и ненавязчивое обучение. Это даст возможность познакомиться с жанром любому новичку. А прохождение кампании на уровне АД – это настоящий вызов даже опытным ветеранам жанра. Даже если вы не фанат такого рода игр, оригинальные находки и действительно хорошее повествование не оставят равнодушным! Игра в Total Defense действительно затягивает – скачайте и убедитесь в этом сами.





**Стоимость приложения:** первая планета доступна бесплатно, разблокировка всех остальных планет обойдется вам всего $1.99 (актуально для новой Android версии)





Ссылки:








  * Google Play: [https://play.google.com/store/apps/details?id=com.ifree.totaldefense3d](https://play.google.com/store/apps/details?id=com.ifree.totaldefense3d)



  * Total Defense 3D также доступна на iOS:



  * iPhone: [http://itunes.apple.com/ru/app/id527536799](http://itunes.apple.com/ru/app/id527536799)



  * iPad: [http://itunes.apple.com/ru/app/id475725703](http://itunes.apple.com/ru/app/id475725703)






Статья взята из сайта [4pda.ru](http://4pda.ru/2012/09/18/71419/)
Продолжаю серию игр для android.





Управляйте Гличем, собирайте батарейки и убегайте с микросхемы. Кажется простым? Это не совсем так - Глич это логическая игра, бросающая вызов уму и реакции. Сможете ли стать самым быстрым?





![](http://s.4pda.ru/wp-content/uploads/2012/09/unnamed9-480x234.jpg)

<!-- more -->

**Версия:** 1.05





**Русский интерфейс:** Да





**Технические требования:** Android 2.3.3, ARM 7





**Необходимы права root?** Нет





**Установка на SD поддерживается?** да, по умолчанию.





**Категория**: Головоломки





Глич - классическая головоломка в стиле старых теплых ламповых игр. Двадцать четыре уровня с возрастающей сложностью. В ближайшее время появится ещё двенадцать. Буду рад любым коментариям/предложениям на форуме и конечно звездочкам на Google Play.





![](http://s.4pda.ru/wp-content/uploads/2012/09/unnamed-13-480x287.jpg) ![](http://s.4pda.ru/wp-content/uploads/2012/09/unnamed-31-480x287.jpg)





![](http://s.4pda.ru/wp-content/uploads/2012/09/unnamed-21-480x287.jpg)





**Стоимость программы: **Бесплатное приложение без ограничений, но с рекламой.  Платное (~1.2$) без рекламы.





**Обсуждение на 4pda: **[http://4pda.ru/forum/index.php?showtopic=376463](http://4pda.ru/forum/index.php?showtopic=376463)





****Ссылка на Google Play: [https://play.google.com/store/apps/details?id=com.vdtech.GlitchTrial](https://play.google.com/store/apps/details?id=com.vdtech.GlitchTrial)









Статья взята из сайта [4pda.ru](http://4pda.ru/2012/09/18/71728/)
Продолжаю серию игр для android.





Любимая всеми игра для тренировки памяти теперь в новом исполнении. Встречайте - Кубуковки!





![](http://s.4pda.ru/wp-content/uploads/2012/09/unnamed7-287x480.jpg)


 <!-- more -->


**Версия:** 1.0.5





**Русский интерфейс:** да





**Технические требования: **Android 2.1 и выше





**Необходимы права root: **нет





**Установка на SD: **нет





**Категория:** Игры, развитие памяти









Никаких сложных рисунков. Подойдет детям и взрослым! 3 уровня сложности! Различные размеры игрового поля и количество букв! Запоминайте расположение букв и открывайте парные, как можно быстрее. Соревнуйтесь с друзьями или превосходите свои результаты.





**Стоимость программы:** бесплатно с рекламой / $0.99 без рекламы





**Ссылка на Google play:**








  * **Бесплатная версия:** [https://play.google.com/store/apps/details?id=com.devfruit.kubukovkifree](https://play.google.com/store/apps/details?id=com.devfruit.kubukovkifree)



  * **Платная версия:** [https://play.google.com/store/apps/details?id=com.devfruit.kubukovkipro](https://play.google.com/store/apps/details?id=com.devfruit.kubukovkipro)










![](http://s.4pda.ru/wp-content/uploads/2012/09/sc20120912-113005.jpeg) ![](http://s.4pda.ru/wp-content/uploads/2012/09/sc20120912-111051.jpeg)





Статья взята из сайта [4pda.ru](http://4pda.ru/2012/09/18/71718/)
Продолжаю серию игр для android.





Владельцы смартфонов и планшетов на платформе Android могут порадоваться — для них и для их детей разрабатывают по-настоящему качественные и красивые приложения, которые до недавнего времени встречались в Google Play достаточно редко. Одно из них — красочная игра-одевалка для девочек «Модельное агентство Superstar».





![Разработчик: ](http://s.4pda.ru/wp-content/uploads/2012/10/device-2012-10-01-0917401-480x300.png)


  <!-- more -->


**Версия: **1.4.0





**Русский интерфейс: **Нет





**Технические требования: **Android 2.3.3 и выше, поддерживаемое разрешение 1280 х 800





**Поддержка установки на SD:** Нет





**Категория: **Дети









Помните игру из детства, когда девочки вырезали из бумаги кукол и наряды для них? Высокие технологии позволяют юным модницам гораздо больше!





![](http://s.4pda.ru/wp-content/uploads/2012/10/device-2012-10-01-0920311-480x300.png)



Вашей дочке наверняка понравится играть с пятью очаровательными моделями: Алисой, Анной, Марией, Сашей и Викторией, гардеробу которых позавидует любая модница. Подбирая моделям наряды и аксессуары, ваша малышка будет не просто играть, она будет учиться правильно сочетать вещи и одеваться со вкусом, а это, согласитесь, для девчонок очень важно.





![](http://s.4pda.ru/wp-content/uploads/2012/10/device-2012-10-01-0919321-480x300.png)


Интерфейс приложения выполнен в стиле модельного подиума, на котором стоят стройняшки-модели. Всем моделям можно изменять цвет волос и губ в соответствии с требованиями юного кутюрье. Все по-настоящему!





![](http://s.4pda.ru/wp-content/uploads/2012/10/device-2012-10-01-0933591-480x300.png)

В приложении маленьких дизайнеров ждет более 30 самых модных нарядов: шорты, юбки, майки, пиджаки, костюмы и, конечно, мечта каждой девочки — великолепное свадебное платье! Можно одеть модель в готовый наряд, подготовленный разработчиками или подобрать совершенно оригинальный комплект — к услугам юного дизайнера более 150 предметов одежды и стильных аксессуаров. Скучно точно не будет! Кроме того, когда идеальный образ найден, можно устроить для супермодели настоящую фотосессию. Самые удачные ансамбли можно сохранить, дополнить своими рисунками и отправить подружкам по почте. У «Модельного агентства Superstar» есть все шансы стать первой ступенькой в карьере вашего маленького модного дизайнера!





**Стоимость:** $1,99





**Обсуждение на 4pda:** [http://4pda.ru/forum/index.php?showtopic=383793](http://4pda.ru/forum/index.php?showtopic=383793)





**Ссылка на Google Play:** [https://play.google.com/store/apps/details?id=ru.phonematics.superstar](https://play.google.com/store/apps/details?id=ru.phonematics.superstar)





**Сылка на Samsung Apps:** [http://www.samsungapps.com/topApps/topAppsDetail.as?productId=G00005588299](http://www.samsungapps.com/topApps/topAppsDetail.as?productId=G00005588299)





Статья взята из сайта [4pda.ru](http://4pda.ru/2012/10/03/73543/)
Продолжаю серию игр для android.





Вы играете за новоиспеченного призрака, которому предстоит пройти всевозможные лабиринты, для достижения конечной цели. В игре есть возможность создавать свои уровни и делиться ими с друзьями.





![](http://s.4pda.ru/wp-content/uploads/2012/10/unnamed3-287x480.jpg)

<!-- more -->

**Версия: **1.0





**Русский интерфейс: **Нет





**Технические требования: **Android 1.5+





**Поддержка установки на SD:** Нет





**Категория:** аркады и экшн









**Стоимость:** Бесплатно





**Ссылка на Google Play:** [https://play.google.com/store/apps/details?id=ru.GhostAdventure](https://play.google.com/store/apps/details?id=ru.GhostAdventure)













Статья взята из сайта [4pda.ru](http://4pda.ru/2012/10/11/74336/)
Продолжаю серию игр для android.





Каждый человек, посещает туалет. Но поход в уборную ещё никогда не был так увлекателен! Но не думайте, что это будет очень просто. Придется значительно постараться, чтобы не стать свиньей и не описать все вокруг.





![Разработчик: Мой первый проект под adnroid](http://s.4pda.ru/wp-content/uploads/2012/10/recommend3-480x234.jpg)


<!-- more -->


**Версия:** 1.0





**Русский интерфейс:** Нет





**Технические требования:** android 2.0.1 +





**Поддержка установки на SD:** Да





**Категория:** Аркады и экшн









Наконец-то закончил свой первый проект под android! В игре необходимо писать в туалет как можно точнее, при этом на уровнях происходят различные мешающие факторы, такие как закрывание крышки, поломка туалета, выключение света. К тому же, камера игрока трясётся с силой, увеличивающейся прямо пропорционально долготе попадания в туалет без промаха. Игру решил сделать в двух версиях: бесплатная демка с рекламой и 1 уровнем и полная версия, включающая в себя 25 уровней и 5 различных локаций, естественно она без рекламы. С внутри-игровыми покупками, пока что не разобрался, так что они отсутствуют. Зато есть "накопительный" момент - если убивать золотых мух, летающих на уровнях, то открываются различные вспомогательные бонусы.





Игру не делал на русском языке, так как все знают, что в России не так много людей, готовых платить за игры, хотя и цену установил минимальную в 1$.





**Стоимость:** 1$





**Ссылка на Google Play:** [https://play.google.com/store/apps/details?id=com.SmileApps.WCfull](https://play.google.com/store/apps/details?id=com.SmileApps.WCfull)





![](http://s.4pda.ru/wp-content/uploads/2012/10/unnamed4-287x480.jpg)
![](http://s.4pda.ru/wp-content/uploads/2012/10/scrin4-288x480.jpg)





Статья взята из сайта [4pda.ru](http://4pda.ru/2012/10/11/74342/)
Начинаю собирать игры для android.





Если у кого есть и хотите поделится пишите, буду рад добавить на блог.





Игра написана специально для тех, кто скучает по старым-добрым временам и провёл не один час за этой простой, но вместе с тем затягивающей игрой. Игра визуально максимально приближена к оригиналу.





Цель игры состоит в том, чтобы как можно быстрее найти все мины на минном поле, не вскрыв ни одну из них. Игрок открывает ячейки, стараясь не открыть ячейку с миной. Открыв ячейку с миной, он проигрывает. Если под открытой ячейкой мины нет, то в ней появляется число, показывающее, сколько ячеек, соседствующих с только что открытой, «заминировано»; используя эти числа, игрок пытается рассчитать расположение мин, однако иногда даже в середине и в конце игры некоторые ячейки всё же приходится открывать наугад.


<!-- more -->


![](http://s.4pda.ru/wp-content/uploads/2012/10/unnamed2.jpg)




**Версия: **1.4





**Русский интерфейс: **Да





**Технические требования: **Android 2.0.1+





**Поддержка установки на SD:** Да





**Категория: **Головоломки





Открыв все «незаминированные» ячейки, игрок выигрывает.








  * Игрок имеет возможность открыть любую ячейку простым нажатием на неё. Если ячейка содержит мину, вы проиграли.



  * Если мины нет, в ячейке появится цифра, которая указывает, сколько мин находится в восьми смежных с ней ячейках.



  * Чтобы пометить ячейку, в которой по вашему мнению находится мина, нажмите на неё длинным нажатием.



  * Игровое поле состоит из счетчика мин, секундомера и минного поля.






Размер игровых ячеек меняется кнопками громкости, либо при помощи специальных пунктов в меню.





**__****Стоимость:** Содержит рекламу****





**Ссылка на Google Play:** [https://play.google.com/store/apps/details?id=biz.toway.games.minesweeper](https://play.google.com/store/apps/details?id=biz.toway.games.minesweeper)













![](http://s.4pda.ru/wp-content/uploads/2012/10/qr-code.gif)



Статья взята из сайта [4pda.ru](http://4pda.ru/2012/10/10/74177/)








</li>&ndash;&gt;-->
    <!--&lt;!&ndash;&ndash;&gt;-->
    <!--&lt;!&ndash;<li>ИнтервьюВсем привет.





Продолжаем тему интервью.





И сегодня у меня в гостях, человек который поменял мишление и стиль жизни очень многих людей.


<!-- more -->


[Артем Мельник](http://artemmelnik.ru/) - являеться експертом №1 в области личной еффективности.





Вы спросите как же Артем попал ко мне в программу.





И вот что я вам скажу.





Однажды прочитав книгу "[Как работать по 4 часа в неделю и при этом не торчать в офисе "от звонка до звонка", жить где угодно и богатеть](http://www.bookzone.com.ua/Netshop/catalogue/catalogue_31123.html?part=11)" (**Тимоти Феррис**), я задался целью работать и отдыхать как Новые богатые.





И вот я начал копать просторы интернета и нашел сайт [Секреты новых богатых](http://nrsecrets.ru/) (автором и ведущим которого является [Артем Мельник](http://artemmelnik.ru/)).





Я пересмотрел все его видео, также нашел еще один его сайт по [личной еффективности](http://artemmelnik.ru/).





Но все это было только в одну сторону. И вот я написал Артему письмо.





В котором рассказал о себе и пригласил его себе в Винницу.





И к моему большому удивлению Артем принял мое приглашение. Но я подумал, что такие люди как он, никогда не приежают к своим зрителям. Но не тут то было. Артем через несколько дней написал, что будет в Украине и заедет ко мне.





Я долго думал, как же можно воспользоваться такой возможностью. И записал с ним видео интервью.





Смотрим!



{% youtube 6fHN1rISy7g %}





Жду ваши комментарии! А также если у вас есть вопросы к Артему. Я могу собирать их и записать еще одно видео.
Друзья всем привет.





Вот и пришел тот день, когда мы с большим удовольствием хотим вам представить, наше первое интервью, с директором IT компании.





Сегодня у меня в гостях замечательный человек и мой хороший друг **Андрей Ремовский**.


<!-- more -->


То что он являеться директором по развитию социальных игр в компании **Win Interactive**. Не мешает ему быть активным учасником не только разработок но и спортивных созтизаний.





Я очень надеюсь, что большая часть зрителей, увидет куда и как можно применить свои знания и навыки программирования под android.





Приятного вам просмотра.





Жду много, много лайков и комментариев.


{% youtube rTPENnY0Y2E %}





Привет друзья.





Вот и заканчивается 2012 год.





За этот год мы с вами очень много всего пережили:





Стартовал блог

<!-- more -->



Добавили больше 200 статей и видео





Записали вебинар





Стартовали рубрику интервью





Пережили конец света





Надеюсь, что 2013 год у всех вас будет более продуктивный чем 2012. Со своей стороны обещаю помощь и развитие.





А сейчас прошу к просмотру поздравления:

{% youtube KtKsjysq6SE %}


Друзья всем привет.





Сегодня хотел бы вам представить, замечательного человека - Артема Мельника.





[Артем Мельник](http://artemmelnik.ru/) - автор и ведущий программы ["Секреты Новых богатых"](http://nrsecrets.ru/).





Артем создал 2 сайта на которых он показывает людям, что можно жить не только ради работы.


<!-- more -->


Но и как перейти от работы к своему бизнесу.





Надеюсь вам понравиться. 





Лайки в социальные сети приветствуются!  :lol:


{% youtube 83PvPWGexZs %}






Пишем ваши отзывы и замечания!
Всем привет.





Сегодня я представляю вам старт новой рубрики.





Прошу к просмотру нового ролика.


{% youtube IayY3tl66RA %}


Если вам понравилось, расскажите друзьям!




</li>&ndash;&gt;-->
    <!--&lt;!&ndash;&ndash;&gt;-->
    <!--&lt;!&ndash;<li>КоучингДрузья всем привет.





Смотрю, что целый месяц мы ничего не писали для вас. Прошу меня извинить!





Этот месяц был полностью посвящен коуч группе. Что это такое возможно спросите вы?

<!-- more -->


Месяц назад был проведен вебинар, по заработку на android программах. Из этого вебинара подали заявки на участие 9 человек. Все они сейчас проходят обучение и буду в скором времени возвращать свои инвестиции.




{% youtube 0xGKIHkRF8Y %}




Что было сделано за этот месяц:








  1. Мы начали с самого начала



  2. Поработали с визуальным оформлением



  3. Выложили приложение на маркет [см. список](https://play.google.com/store/apps/developer?id=Android%20Studio%20Development%20Group&hl=ru)






А вот, то что нам написали наши учасники:





Григорий (Винница)





> 


> 
> _Месяц прошел быстро, но насыщено. Было очень интересно, прояснил для себя многие не совсем понятные моменты и самое главное удалось опубликовать свое первое приложение на маркете. Это очень мотивирует продолжать дальше. Не сомневаюсь что дальше будет еще интересней._
> 
> 







Александр





> 


> 
> _Да, первый месяц пролетел быстро ) Для себя в этом месяце открыл новые грани Андроида, узнал интересные нюансы. Продолжаем в том же духе. Дальше будет интересней )_
> 
> 







Василий





> 


> 
> _Ну что же, вот и прошёл месяц обучения. Для себя узнал много нового, и даже некоторые моменты, вроде бы ранее понятные, стали ещё более понятными, но уже на новом уровне. Спасибо преподавателю! Я записался на 2-й месяц обучения, и надеюсь что в таком ключе будем работать и дальше. По материалу 1-го месяца вопросов особо не было, но глядя на программу второго месяца понимаю, что вопросы обязательно появятся :)_
> 
> 


</li>&ndash;&gt;-->
    <!--&lt;!&ndash;&ndash;&gt;-->
<!--</ul>-->
  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - Andrii Stakhov -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a><div>
      <!--LiveInternet counter-->
      <script type="text/javascript">
          document.write("<a href='http://www.liveinternet.ru/click' "+
                         "target=_blank><img src='//counter.yadro.ru/hit?t26.6;r"+
                         escape(document.referrer)+((typeof(screen)=="undefined")?"":
                         ";s"+screen.width+"*"+screen.height+"*"+(screen.colorDepth?
                          screen.colorDepth:screen.pixelDepth))+";u"+escape(document.URL)+
                         ";"+Math.random()+
                         "' alt='' title='LiveInternet: number of visitors for today is"+
                         " shown' "+
                         "border='0' width='88' height='15'><\/a>");
      </script>
      <!--/LiveInternet-->
  </div></span>

</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'androidhelper';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>



<div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) {return;}
  js = d.createElement(s); js.id = id; js.async = true;
  js.src = "//connect.facebook.net/en_US/all.js#appId=212934732101925&xfbml=1";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>



  <script type="text/javascript">
    (function() {
      var script = document.createElement('script'); script.type = 'text/javascript'; script.async = true;
      script.src = 'https://apis.google.com/js/plusone.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(script, s);
    })();
  </script>



  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
